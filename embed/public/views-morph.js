;(function(f) {
  if (typeof exports === 'object' && typeof module !== 'undefined') {
    module.exports = f()
  } else if (typeof define === 'function' && define.amd) {
    define([], f)
  } else {
    var g
    if (typeof window !== 'undefined') {
      g = window
    } else if (typeof global !== 'undefined') {
      g = global
    } else if (typeof self !== 'undefined') {
      g = self
    } else {
      g = this
    }
    g.views = f()
  }
})(function() {
  var define, module, exports
  return (function e(t, n, r) {
    function s(o, u) {
      if (!n[o]) {
        if (!t[o]) {
          var a = typeof require == 'function' && require
          if (!u && a) return a(o, !0)
          if (i) return i(o, !0)
          var f = new Error("Cannot find module '" + o + "'")
          throw ((f.code = 'MODULE_NOT_FOUND'), f)
        }
        var l = (n[o] = { exports: {} })
        t[o][0].call(
          l.exports,
          function(e) {
            var n = t[o][1][e]
            return s(n ? n : e)
          },
          l,
          l.exports,
          e,
          t,
          n,
          r
        )
      }
      return n[o].exports
    }
    var i = typeof require == 'function' && require
    for (var o = 0; o < r.length; o++) s(r[o])
    return s
  })(
    {
      1: [
        function(require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', { value: true })

          function _interopDefault(ex) {
            return ex && typeof ex === 'object' && 'default' in ex
              ? ex['default']
              : ex
          }

          var path = require('path')
          var buble = _interopDefault(require('buble'))
          var synesthesia = require('synesthesia')
          var cssProperties = _interopDefault(require('css-properties'))
          var toCamelCase = _interopDefault(require('to-camel-case'))
          var babelCore = require('babel-core')
          var toSlugCase = _interopDefault(require('to-slug-case'))
          var glam = _interopDefault(require('glam/babel'))
          var toPascalCase = _interopDefault(require('to-pascal-case'))
          var getColor = _interopDefault(require('color'))
          var prettier = _interopDefault(require('prettier'))

          const BASIC = /^(CaptureEmail|CaptureFile|CaptureInput|CaptureNumber|CapturePhone|CaptureSecure|CaptureText|G|Horizontal|Image|Input|List|Select|Style|Svg|SvgDefs|SvgFeMerge|SvgFilter|Text|Vertical)$/i
          const BLOCK = /^([A-Z][a-zA-Z0-9]*)(\s+[a-z\s]*([A-Z][a-zA-Z0-9]*))?$/
          const BOOL = /^(false|true)$/i
          const CAPTURE = /^(CaptureEmail|CaptureFile|CaptureInput|CaptureNumber|CapturePhone|CaptureSecure|CaptureText)$/i
          const CODE_EXPLICIT = /^{.+}$/
          const CODE_IMPLICIT = /(props|item)\./
          const DATA = /^.+\.data$/
          const EMPTY_LIST = /^is empty list$/i
          const EMPTY_TEXT = /^is empty text$/i
          const FLOAT = /^[0-9]+\.[0-9]+$/
          const FONTABLE = /^(CaptureEmail|CaptureInput|CaptureNumber|CapturePhone|CaptureSecure|CaptureText|Input|Text)$/
          const GROUP = /^(G|Horizontal|List|Svg|SvgDefs|SvgFeMerge|SvgFilter|Vertical)$/i
          const LIST = /^List$/
          const INT = /^[0-9]+$/
          const ITEM = /^item[A-Z]*$/
          const MARGIN = /^margin/
          const PADDING = /^padding/
          const PROP = /^([a-z][a-zA-Z0-9]*)\s+(.+)$/
          const PROP_STYLE_STEMS = /^([a-z][A-Z0-9]*?)(Active|ActiveHover|Hover|Placeholder|Disabled|Print)?$/i
          const SECTION = /^([a-z][a-zA-Z0-9]*)$/
          const STYLE = new RegExp(
            `^(${cssProperties.map(toCamelCase).join('|')}|heightBlocked)$`
          )
          const TERNARY = /\?\s*['"]?\s*(.+)?\s*['"]?\s*:\s*['"]?\s*(.+)\s*['"]?\s*/
          const TODO = /TODO\s*(@([a-z]+))?\s*(.+)/i
          const TOGGLE = new RegExp(`^toggle (props|item).(.+)$`)
          const TRUE = /^true$/i

          const is = (thing, line) => thing.test(line)
          const isBasic = line => is(BASIC, line)
          const isBlock = line => is(BLOCK, line)
          const isBool = line => is(BOOL, line)
          const isCapture = line => is(CAPTURE, line)
          const isData = line => is(DATA, line)
          const isCode = line =>
            isCodeOneWord(line) ||
            is(CODE_EXPLICIT, line) ||
            is(CODE_IMPLICIT, line)
          const isCodeOneWord = line =>
            line === 'props' || line === 'item' || line === 'i'
          // TODO
          const isCodeInvalid = line => {
            return getCodeData(line).find(
              l =>
                /\. /.test(l) || // props. x
                / \./.test(l) || // props .
                / \[/.test(l) || // props[
                /\]/.test(l) // props]
            )
          }

          const isColor = line => is(synesthesia.all, line)
          const isEmptyList = line => is(EMPTY_LIST, line)
          const isEmptyText = line => is(EMPTY_TEXT, line)
          const isEnd = line => line === ''
          const isFloat = line => is(FLOAT, line)
          const isFontable = line => is(FONTABLE, line)
          const isGroup = line => is(GROUP, line)
          const isList = line => is(LIST, line)
          const isInt = line => is(INT, line)
          const isItem = line => is(ITEM, line)
          const isMargin = line => is(MARGIN, line)
          const isPadding = line => is(PADDING, line)
          const isProp = line => is(PROP, line)

          const isSection = line => is(SECTION, line)
          const isStyle = line => is(STYLE, line)
          const isTodo = line => is(TODO, line)
          const isToggle = line => is(TOGGLE, line)
          const isTrue = line => is(TRUE, line)

          const get = (regex, line) => line.match(regex)

          const getBlock = line => {
            const match = get(BLOCK, line)
            if (match[3]) {
              return {
                block: match[3],
                is: match[1],
              }
            } else {
              return {
                block: match[1],
                is: null,
              }
            }
          }
          const getCodeData = line => {
            if (isCodeOneWord(line)) return [line]

            return line
              .replace(/^{/, '')
              .replace(/}$/, '')
              .split(' ')
              .filter(l => isCodeOneWord(l) || /[.[]/.test(l))
          }

          const getColor$1 = line => get(synesthesia.all, line)
          const getFontInfo = (fontFamily, fontWeight) => {
            const fonts = []

            const families = []
            const familyTernary = fontFamily.match(TERNARY)
            if (familyTernary) {
              families.push(
                getMainFont(familyTernary[1]),
                getMainFont(familyTernary[2])
              )
            } else {
              families.push(getMainFont(fontFamily))
            }

            const weights = []

            if (typeof fontWeight === 'string') {
              const weightTernary = fontWeight.match(TERNARY)
              if (weightTernary) {
                weights.push(weightTernary[1], weightTernary[2])
              } else {
                weights.push(fontWeight)
              }
            } else if (typeof fontWeight === 'number') {
              weights.push(`${fontWeight}`)
            } else if (typeof fontWeight === 'undefined') {
              // default to 400
              weights.push('400')
            }

            families.forEach(family => {
              if (weights.length) {
                weights.forEach(weight => {
                  fonts.push({
                    family,
                    weight,
                  })
                })
              } else {
                fonts.push({
                  family,
                })
              }
            })

            return fonts
          }
          const getMainFont = line => line.split(',')[0].replace(/['"]/g, '')
          const getProp = line => get(PROP, line).slice(1)
          const getSection = line => get(SECTION, line)[1]
          const getTodo = line => get(TODO, line).slice(1)
          const getToggle = line => get(TOGGLE, line)[2]
          const getValue$1 = value => {
            if (isFloat(value)) {
              return parseFloat(value, 10)
            } else if (isInt(value)) {
              return parseInt(value, 10)
            } else if (isEmptyText(value)) {
              return ''
            } else if (isBool(value)) {
              return isTrue(value)
            } else {
              return value
            }
          }

          const stemStylesFromProp = raw => {
            const [prop, tag] = get(PROP_STYLE_STEMS, raw).slice(1)

            return tag && !isStyle(prop)
              ? [raw]
              : [prop, typeof tag === 'string' ? toCamelCase(tag) : undefined]
          }

          const warn = (message, block) => {
            if (!Array.isArray(block.warnings)) {
              block.warnings = []
            }
            block.warnings.push(message)
          }

          var getLoc = (line, scolumn, ecolumn) => ({
            start: {
              line,
              column: scolumn,
            },
            end: {
              line,
              column: ecolumn,
            },
          })

          var getMeta = (value, line, startLine) => {
            const hasCode = isCode(value)
            const hasColor = isColor(value)

            if (!(hasCode || hasColor)) return null

            const ret = {
              type: 'ArrayExpression',
              elements: [],
              loc: getLoc(startLine, 0, line.length - 1),
            }

            const add = tag => value => {
              const column = line.indexOf(value)
              ret.elements.push({
                type: 'Literal',
                loc: getLoc(startLine, column, column + value.length - 1),
                tag,
                value,
              })
            }

            if (hasCode) {
              getCodeData(value).forEach(add('code'))
            }
            if (hasColor) {
              getColor$1(value).forEach(add('color'))
            }

            return ret
          }

          var getTags = (prop, value) => {
            const tags = {}

            if (isCode(value))
              tags.code = isCodeInvalid(value) ? 'invalid' : true
            if (isData(value)) tags.data = true
            if (isMargin(prop)) tags.margin = true
            if (isPadding(prop)) tags.padding = true
            if (isStyle(prop)) tags.style = true
            if (isToggle(value)) tags.toggle = getToggle(value)

            return tags
          }

          var parse = text => {
            const fonts = {}
            const lines = text.split('\n')
            const stack = []
            const todos = []
            const views = []
            let lastCapture

            const lookForFonts = block => {
              if (
                block.properties &&
                (isFontable(block.name.value) || !block.isBasic)
              ) {
                let fontFamily
                let fontWeight

                block.properties.list.forEach(p => {
                  if (p.key.value === 'fontFamily') {
                    fontFamily = p.value.value
                  } else if (p.key.value === 'fontWeight') {
                    fontWeight = p.value.value
                  }
                })

                if (fontFamily) {
                  const info = getFontInfo(fontFamily, fontWeight)

                  info.forEach(font => {
                    if (!fonts[font.family]) fonts[font.family] = []
                    if (!fonts[font.family].includes(font.weight)) {
                      fonts[font.family].push(font.weight)
                    }
                  })
                }
              }
            }

            const end = (block, maybeEndLine) => {
              let endLine = maybeEndLine
              while (lines[endLine] === '' && endLine > 0) {
                endLine--
              }

              const prevLine = lines[endLine - 1]

              block.loc.end = {
                line: endLine,
                column:
                  (typeof prevLine === 'string' ? prevLine : lines[endLine])
                    .length - 1,
              }
              // TODO review this
              // if we're past our line, use the previous line's end
              if (block.loc.end.column < 0) {
                block.loc.end = {
                  line: endLine - 1,
                  column: lines[endLine - 2].length - 1,
                }
              }

              // TODO define end location of blocks inside this
              // block.blocks.forEach(innerBlock => {
              //   innerBlock.loc.end = // ...
              // })
              // end this block's properties if any
              if (block.properties) {
                const last =
                  block.properties.list[block.properties.list.length - 1]
                block.properties.loc.end = last.loc.end

                // look for fonts
                lookForFonts(block)
              }

              if (block.blocks) {
                block.blocks.list.forEach(lookForFonts)
              }

              if (stack.length > 0) {
                // // if there are more blocks, put this block as part of the last block on the stack's block
                // const nextLast = stack[stack.length - 1]
                // if (nextLast !== block && nextLast.blocks) {
                //   nextLast.blocks.list.push(block)
                // }
                return false
              } else {
                // if we're the last block on the stack, then this is the view!
                views.push(block)
                return true
              }
            }

            const parseBlock = (l, i, line, lineIndex) => {
              const { block: name, is: is$$1 } = getBlock(line)
              let shouldPushToStack = false

              const block = {
                type: 'Block',
                name: {
                  type: 'Literal',
                  value: name,
                  loc: getLoc(lineIndex, l.indexOf(line), l.length - 1),
                },
                isBasic: isBasic(name),
                loc: getLoc(lineIndex, l.indexOf(line)),
                parents: stack
                  .filter(b => b.type === 'Block')
                  .map(b => b.is || b.name.value),
              }
              if (is$$1) {
                block.is = is$$1

                if (isCapture(name)) {
                  if (lastCapture) {
                    lastCapture.captureNext = is$$1
                  }
                  lastCapture = block
                }
              }

              const last = stack[stack.length - 1]
              if (last) {
                if (last.blocks) {
                  if (isList(last.name.value) && last.blocks.list.length > 0) {
                    // the list already has a block
                    let topLevelIsGroup = false
                    if (stack.length - 2 >= 0) {
                      topLevelIsGroup = isGroup(
                        stack[stack.length - 2].name.value
                      )
                    } else if (views.length > 0) {
                      topLevelIsGroup = !!views[0].blocks
                    }

                    if (topLevelIsGroup) {
                      // tell how we can fix that
                      warn(
                        lines[i - 1] === ''
                          ? `put 1 empty line before`
                          : `put 2 empty lines before`,
                        block
                      )
                    } else {
                      warn(`add Vertical at the top`, block)
                    }
                    // shouldPushToStack = true
                  }

                  last.blocks.list.push(block)
                } else {
                  // the block is inside a block that isn't a group
                  end(stack.pop(), lineIndex - 1)
                  const topLevelIsGroup = !!views[0].blocks

                  if (topLevelIsGroup) {
                    // tell how we can fix that
                    warn(
                      lines[i - 1] === ''
                        ? `put 1 empty line before`
                        : `put 2 empty lines before`,
                      block
                    )
                  } else {
                    warn(`add Vertical at the top`, block)
                  }
                  shouldPushToStack = true
                }
              } else if (views.length > 0) {
                // the block is outside the top level block
                const topLevelIsGroup = !!views[0].blocks
                let newLinesBeforePreviousBlock = 1
                while (isEnd(lines[i - newLinesBeforePreviousBlock])) {
                  newLinesBeforePreviousBlock++
                }

                const help = []
                if (!topLevelIsGroup) {
                  help.push(`add Vertical at the top`)
                }
                if (newLinesBeforePreviousBlock > 2) {
                  const linesToRemove = newLinesBeforePreviousBlock - 2
                  help.push(
                    `remove ${linesToRemove} empty line${linesToRemove > 1
                      ? 's'
                      : ''} before`
                  )
                }
                warn(help.join(', '), block)
              }

              if (isGroup(name)) {
                block.blocks = {
                  type: 'Blocks',
                  list: [],
                  loc: getLoc(lineIndex + 1, 0),
                }
                shouldPushToStack = true
              }

              if (shouldPushToStack || stack.length === 0) {
                stack.push(block)
              }
            }

            const parseProps = (i, block) => {
              let endOfBlockIndex = i
              while (
                endOfBlockIndex < lines.length - 1 &&
                !isBlock(lines[endOfBlockIndex])
              ) {
                endOfBlockIndex++
              }

              const properties = []
              const nested = []

              for (let j = i; j <= endOfBlockIndex; j++) {
                const l = lines[j]
                const line = l.trim()
                const lineIndex = j + 1

                if (isSection(line)) {
                  const prop = getSection(line)

                  if (isItem(prop) && nested.length > 0) {
                    const item = {
                      type: 'ArrayItem',
                      value: {
                        type: 'ObjectExpression',
                        properties: [],
                        loc: getLoc(lineIndex + 1, 0),
                      },
                    }

                    const last = nested[nested.length - 1]
                    if (last.value.type === 'ObjectExpression') {
                      last.value = {
                        type: 'ArrayExpression',
                        elements: [],
                        item: prop,
                        loc: last.value.loc,
                      }
                    }

                    last.value.elements.push(item)
                  } else {
                    nested.push({
                      type: 'Property',
                      loc: getLoc(lineIndex, l.indexOf(prop), l.length - 1),
                      key: {
                        type: 'Literal',
                        value: prop,
                        loc: getLoc(
                          lineIndex,
                          l.indexOf(prop),
                          l.indexOf(prop) + prop.length - 1
                        ),
                      },
                      value: {
                        type: 'ObjectExpression',
                        properties: [],
                        loc: getLoc(lineIndex + 1, 0),
                      },
                    })
                  }
                } else if (isProp(line)) {
                  const [propRaw, value] = getProp(line)
                  const [prop, stemmedTag] = stemStylesFromProp(propRaw)
                  const tags = getTags(prop, value)
                  if (stemmedTag) {
                    tags[stemmedTag] = true
                  }

                  let last = properties
                  if (nested[nested.length - 1]) {
                    const lastValue = nested[nested.length - 1].value

                    if (lastValue.type === 'ObjectExpression') {
                      last = lastValue.properties
                    } else if (lastValue.type === 'ArrayExpression') {
                      const lastElement =
                        lastValue.elements[lastValue.elements.length - 1]
                      if (
                        lastElement &&
                        lastElement.type === 'ArrayItem' &&
                        !isItem(prop)
                      ) {
                        last = lastElement.value.properties
                      } else {
                        last = lastValue.elements
                      }
                    }
                  }

                  if (isItem(prop)) {
                    // TODO FIXME cast last to array
                    last.push({
                      type: 'ArrayItem',
                      value: {
                        type: 'Literal',
                        value: getValue$1(value),
                        loc: getLoc(
                          lineIndex,
                          l.indexOf(value),
                          l.indexOf(value) + value.length - 1
                        ),
                      },
                    })
                  } else {
                    const propValue = isEmptyList(value)
                      ? {
                          type: 'ArrayExpression',
                          elements: [],
                        }
                      : {
                          type: 'Literal',
                          value: getValue$1(value),
                        }

                    propValue.loc = getLoc(
                      lineIndex,
                      l.indexOf(value),
                      l.indexOf(value) + value.length - 1
                    )

                    last.push({
                      type: 'Property',
                      loc: getLoc(lineIndex, l.indexOf(propRaw), l.length - 1),
                      key: {
                        type: 'Literal',
                        // TODO should we use propRaw as value here?
                        value: prop,
                        loc: getLoc(
                          lineIndex,
                          l.indexOf(propRaw),
                          l.indexOf(propRaw) + propRaw.length - 1
                        ),
                      },
                      tags,
                      meta: getMeta(value, l, lineIndex),
                      value: propValue,
                    })
                  }
                } else if (isEnd(line)) {
                  const prevLine = lines[j - 1]

                  // TODO close item
                  if (isEnd(prevLine)) {
                    if (nested.length > 0) {
                      const props = nested.pop()

                      let last = properties
                      if (nested.length > 0) {
                        last = nested[nested.length - 1].value.properties
                      }
                      // TODO add warning
                      if (last) {
                        last.push(props)
                      }
                    }
                  }
                }
              }

              const loc = getLoc(i + 1, 0, lines[endOfBlockIndex].length - 1)
              loc.end.line = endOfBlockIndex

              while (nested.length > 0) {
                const props = nested.pop()

                let last = properties
                if (nested.length > 0) {
                  last = nested[nested.length - 1].value.properties
                }
                if (last) {
                  last.push(props)
                }
              }

              if (properties.length > 0) {
                block.properties = {
                  type: 'Properties',
                  list: properties,
                  loc,
                }
              }
            }

            lines.forEach((l, i) => {
              const line = l.trim()
              const lineIndex = i + 1

              if (isBlock(line)) {
                parseBlock(l, i, line, lineIndex)
              } else if (isProp(line) || isSection(line)) {
                let block = stack[stack.length - 1] || views[views.length - 1]
                // TODO add warning
                if (!block) return
                if (block.blocks && block.blocks.list.length > 0) {
                  block = block.blocks.list[block.blocks.list.length - 1]
                }

                if (!block.properties) {
                  parseProps(i, block)
                }
              } else if (isTodo(line)) {
                // eslint-disable-next-line
                const [_, to, message] = getTodo(line)

                const todo = {
                  type: 'Todo',
                  loc: getLoc(lineIndex, l.indexOf('#') + 1, l.length - 1),
                  to,
                  message: message.trim(),
                }

                todos.push(todo)
              } else if (isEnd(line) && stack.length > 0) {
                const prevLine = lines[i - 1]
                if (isEnd(prevLine)) {
                  end(stack.pop(), lineIndex)
                }
              }
            })

            if (stack.length > 0) {
              while (!end(stack.pop(), lines.length)) {}
            }

            return {
              fonts,
              todos,
              views,
            }
          }

          // source https://github.com/Rich-Harris/estree-walker
          // with added nodeKeys to be able to define the order in which groups of properties will be called
          function walk(ast, { enter, leave, nodeKeys }) {
            childKeys = Object.assign({}, nodeKeys)
            visit(ast, null, enter, leave)
          }

          const context = {
            skip: () => (context.shouldSkip = true),
            shouldSkip: false,
          }

          let childKeys = {}

          const toString = Object.prototype.toString

          function isArray(thing) {
            return toString.call(thing) === '[object Array]'
          }

          function visit(node, parent, enter, leave, prop, index) {
            if (!node) return

            if (enter) {
              context.shouldSkip = false
              enter.call(context, node, parent, prop, index)
              if (context.shouldSkip) return
            }

            const keys =
              childKeys[node.type] ||
              (childKeys[node.type] = Object.keys(node).filter(
                key => typeof node[key] === 'object'
              ))

            for (let i = 0; i < keys.length; i += 1) {
              const key = keys[i]
              const value = node[key]

              if (isArray(value)) {
                for (let j = 0; j < value.length; j += 1) {
                  // allow you to walk up the tree
                  node.parent = parent
                  visit(value[j], node, enter, leave, key, j)
                }
              } else if (value && value.type) {
                // allow you to walk up the tree
                node.parent = parent
                visit(value, node, enter, leave, key, null)
              }
            }

            if (leave) {
              leave(node, parent, prop, index)
            }
          }

          var morph$1 = (code, state, visitors) => {
            const parsed = parse(code)

            walk(parsed.views[0], {
              enter(node, parent) {
                const visitor = visitors[node.type]
                if (visitor && visitor.enter)
                  visitor.enter.call(this, node, parent, state)
              },
              leave(node, parent) {
                const visitor = visitors[node.type]
                if (visitor && visitor.leave)
                  visitor.leave.call(this, node, parent, state)
              },
              nodeKeys: {
                Block: ['properties', 'blocks'],
              },
            })

            if (visitors.Fonts) visitors.Fonts(parsed.fonts, state)
            if (visitors.Todos) visitors.Todos(parsed.todos, state)
          }

          var data = ({ view }) => {
            const state = {}

            const visitors = {
              Property,
            }

            morph$1(view, state, visitors)

            return `export default ${JSON.stringify(state.default || state)}`
          }

          const Property = {
            enter(node, parent, state) {
              state[node.key.value] = getValue(node)

              if (
                node.value.type === 'ArrayExpression' ||
                node.value.type === 'ObjectExpression'
              )
                this.skip()
            },
          }

          // TODO relations
          // eg
          // Data
          // name Dario
          // addresses
          // from addresses.data
          const getValue = property => {
            switch (property.value.type) {
              case 'Literal':
                return property.value.value

              case 'ArrayExpression':
                return property.value.elements.map(getValue)

              case 'ObjectExpression':
                let value = {}

                property.value.properties.forEach(pr => {
                  value[pr.key.value] = getValue(pr)
                })

                return value

              default:
                return null
            }
          }

          var wrap = s => `{${s}}`

          const getObjectAsString = obj =>
            wrap(
              Object.keys(obj)
                .map(k => {
                  const v = typeof obj[k] === 'object' && hasKeys(obj[k])
                    ? getObjectAsString(obj[k])
                    : obj[k]
                  return `${JSON.stringify(k)}: ${v}`
                })
                .join(',')
            )

          const getProp$1 = (node, key) => {
            const finder = typeof key === 'string'
              ? p => p.key.value === key
              : p => key.test(p.key.value)

            return node.properties && node.properties.list.find(finder)
          }

          const styleStems = [
            'active',
            'hover',
            'activeHover',
            'placeholder',
            'disabled',
            'print',
          ]
          const getStyleType = node =>
            styleStems.find(tag => isTag(node, tag)) || 'base'

          const hasKeys = obj => Object.keys(obj).length > 0
          const hasKeysInChildren = obj =>
            Object.keys(obj).some(k => hasKeys(obj[k]))

          const hasProp = (node, key, match) => {
            const prop = getProp$1(node, key)
            if (!prop) return false
            return typeof match === 'function' ? match(prop.value.value) : true
          }

          const isCode$1 = node =>
            typeof node === 'string'
              ? /props|item/.test(node)
              : isTag(node, 'code')
          const isData$1 = node => isTag(node, 'data')
          const isStyle$1 = node => isTag(node, 'style')
          const isToggle$1 = node => isTag(node, 'toggle')

          const isTag = (node, tag) => node.tags[tag]

          var safe = value =>
            typeof value === 'string' && !/props|item/.test(value)
              ? JSON.stringify(value)
              : wrap(value)

          const enter = (node, parent, state) => {
            if (node.goTo) {
              const goTo = getProp$1(node, 'goTo')
              state.render.push(
                ` target='_blank' href=${safe(goTo.value.value, goTo)}`
              )
            }
          }

          const enter$1 = (node, parent, state) => {
            if (node.teleport) {
              let to = getProp$1(node, 'teleportTo').value.value

              if (to.startsWith('/') || to === '..') {
                to = safe(to)
              } else {
                to = isCode$1(to) ? `\${${to}}` : to
                to = `{\`\${props.match.url === '/' ? '' : props.match.url}/${to}\`}`
                state.withRouter = true
              }

              state.render.push(` to=${to}`)
            }
          }

          // https://raw.githubusercontent.com/threepointone/glam/master/src/hash.js
          // murmurhash2 via https://gist.github.com/raycmorgan/588423

          var hash = (arr, prefix = 'h') => `h${hash$1(arr)}`
          function hash$1(arr) {
            let str = (Array.isArray(arr)
              ? arr
              : Object.keys(arr).map(
                  k => `${k}:${JSON.stringify(arr[k])}`
                )).join(',')
            return murmur2(str, str.length).toString(36)
          }

          function murmur2(str, seed) {
            let m = 0x5bd1e995
            let r = 24
            let h = seed ^ str.length
            let length = str.length
            let currentIndex = 0

            while (length >= 4) {
              let k = UInt32(str, currentIndex)

              k = Umul32(k, m)
              k ^= k >>> r
              k = Umul32(k, m)

              h = Umul32(h, m)
              h ^= k

              currentIndex += 4
              length -= 4
            }

            switch (length) {
              case 3:
                h ^= UInt16(str, currentIndex)
                h ^= str.charCodeAt(currentIndex + 2) << 16
                h = Umul32(h, m)
                break

              case 2:
                h ^= UInt16(str, currentIndex)
                h = Umul32(h, m)
                break

              case 1:
                h ^= str.charCodeAt(currentIndex)
                h = Umul32(h, m)
                break
            }

            h ^= h >>> 13
            h = Umul32(h, m)
            h ^= h >>> 15

            return h >>> 0
          }

          function UInt32(str, pos) {
            return (
              str.charCodeAt(pos++) +
              (str.charCodeAt(pos++) << 8) +
              (str.charCodeAt(pos++) << 16) +
              (str.charCodeAt(pos) << 24)
            )
          }

          function UInt16(str, pos) {
            return str.charCodeAt(pos++) + (str.charCodeAt(pos++) << 8)
          }

          function Umul32(n, m) {
            n = n | 0
            m = m | 0
            let nlo = n & 0xffff
            let nhi = n >>> 16
            let res = (nlo * m + (((nhi * m) & 0xffff) << 16)) | 0
            return res
          }

          const leave = (node, parent, state) => {
            if (hasKeysInChildren(node.style.static)) {
              const id = hash(node.style.static)
              state.styles[id] = node.style.static
              parent.styleId = id
              const isActive = getProp$1(parent, 'isActive')

              let className = [
                `styles.${id}`,
                isActive && `${isActive.value.value} && 'active'`,
              ].filter(Boolean)

              if (className.length > 0) {
                className = className.map(k => `\${${k}}`).join(' ')
                className = `\`${className}\``
              }

              state.render.push(` className=${wrap(className)}`)
            }
            // TODO needs to be different, it should also be a classname here too
            if (hasKeysInChildren(node.style.dynamic)) {
              const dynamic = getObjectAsString(node.style.dynamic.base)
              state.render.push(` style={${dynamic}}`)
            }
          }

          var getBlockName = node => {
            switch (node.name.value) {
              case 'CaptureEmail':
              case 'CaptureFile':
              case 'CaptureInput':
              case 'CaptureNumber':
              case 'CapturePhone':
              case 'CaptureSecure':
              case 'CaptureText':
                return 'input'

              case 'Horizontal':
              case 'Vertical':
                return getGroupBlockName(node)

              case 'Image':
                return 'img'

              case 'Text':
              case 'List':
                return 'div'

              case 'Proxy':
                return getProxyBlockName(node)
              // TODO SvgText should be just Text but the import should be determined from the parent
              // being Svg

              case 'SvgText':
                return 'text'

              case 'Svg':
              case 'Circle':
              case 'Ellipse':
              case 'G':
              case 'LinearGradient':
              case 'RadialGradient':
              case 'Line':
              case 'Path':
              case 'Polygon':
              case 'Polyline':
              case 'Rect':
              case 'Symbol':
              case 'Use':
              case 'Defs':
              case 'Stop':
                return node.name.value.toLowerCase()

              default:
                return node.name.value
            }
          }

          const getGroupBlockName = node => {
            let name = 'div'

            if (hasProp(node, 'teleportTo')) {
              name = 'Link'
              node.teleport = true
            } else if (hasProp(node, 'goTo')) {
              name = 'a'
              node.goTo = true
            } else if (hasProp(node, 'onClick')) {
              name = 'button'
            } else if (
              hasProp(node, 'overflowY', v => v === 'auto' || v === 'scroll')
            ) {
              name = 'div'
            }

            return name
          }

          const getProxyBlockName = node => {
            const from = getProp$1(node, 'from')
            return from && from.value.value
          }

          const interpolateCode = s =>
            /props|item/.test(s) ? '${' + s + '}' : s

          var safe$1 = s =>
            '`' + s.split(' ').map(interpolateCode).join(' ') + '`'

          var getStyleForProperty = (node, parent, code) => {
            const key = node.key.value
            const value = node.value.value

            switch (key) {
              case 'backgroundImage':
                return {
                  backgroundImage: code
                    ? `\`url(\${${value}})\``
                    : `url("${value}")`,
                  backgroundSize: 'cover',
                }

              case 'zIndex':
                return {
                  zIndex: code ? value : parseInt(value, 10),
                }

              default:
                return {
                  [key]: code && !/(.+)\?(.+):(.+)/.test(value)
                    ? safe$1(value)
                    : value,
                }
            }
          }

          /**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule CSSProperty
 */

          // https://raw.githubusercontent.com/facebook/react/3b96650e39ddda5ba49245713ef16dbc52d25e9e/src/renderers/dom/shared/CSSProperty.js

          /**
 * CSS properties which accept numbers but are not in units of "px".
 */
          var isUnitlessNumber = {
            animationIterationCount: true,
            borderImageOutset: true,
            borderImageSlice: true,
            borderImageWidth: true,
            boxFlex: true,
            boxFlexGroup: true,
            boxOrdinalGroup: true,
            columnCount: true,
            flex: true,
            flexGrow: true,
            flexPositive: true,
            flexShrink: true,
            flexNegative: true,
            flexOrder: true,
            gridRow: true,
            gridRowEnd: true,
            gridRowSpan: true,
            gridRowStart: true,
            gridColumn: true,
            gridColumnEnd: true,
            gridColumnSpan: true,
            gridColumnStart: true,
            fontWeight: true,
            lineClamp: true,
            lineHeight: true,
            opacity: true,
            order: true,
            orphans: true,
            tabSize: true,
            widows: true,
            zIndex: true,
            zoom: true,

            // SVG-related properties
            fillOpacity: true,
            floodOpacity: true,
            stopOpacity: true,
            strokeDasharray: true,
            strokeDashoffset: true,
            strokeMiterlimit: true,
            strokeOpacity: true,
            strokeWidth: true,
          }

          /**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */
          function prefixKey(prefix, key) {
            return prefix + key.charAt(0).toUpperCase() + key.substring(1)
          }

          /**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */
          const prefixes = ['Webkit', 'ms', 'Moz', 'O']

          // Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
          // infinite loop, because it iterates over the newly added props too.
          Object.keys(isUnitlessNumber).forEach(function(prop) {
            prefixes.forEach(function(prefix) {
              isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop]
            })
          })

          var getStyles = ({ file, inlineStyles, styles }, name) => {
            if (!hasKeys(styles)) return ''

            const obj = Object.keys(styles)
              .filter(k => hasKeysInChildren(styles[k]))
              .map(
                k => `${JSON.stringify(k)}: css\`${toNestedCss(styles[k])}\``
              )
              .join(',')

            const code = transformGlam(
              `const styles = {${obj}}`,
              inlineStyles,
              file.raw
            )
            const maybeImport = inlineStyles
              ? ''
              : `import '${file.relative}.css'\n`
            return `${maybeImport}${code}`
          }

          const getValue$2 = (key, value) =>
            typeof value === 'number' &&
              !(isUnitlessNumber.hasOwnProperty(key) && isUnitlessNumber[key])
              ? `${value}px`
              : `${value}`

          const toCss = obj =>
            Object.keys(obj)
              .map(k => `${toSlugCase(k)}: ${getValue$2(k, obj[k])};`)
              .join('\n')

          const toNestedCss = ({
            base,
            hover,
            active,
            activeHover,
            disabled,
            placeholder,
            print,
          }) => {
            const baseCss = toCss(base)
            const hoverCss = toCss(hover)
            const activeCss = toCss(active)
            const activeHoverCss = toCss(activeHover)
            const disabledCss = toCss(disabled)
            const placeholderCss = toCss(placeholder)
            const printCss = toCss(print)

            const ret = [
              baseCss,
              hoverCss && `&:hover {${hoverCss}}`,
              activeCss && `&.active {${activeCss}}`,
              activeHoverCss && `&.active:hover {${activeHoverCss}}`,
              disabledCss && `&:disabled {${disabledCss}}`,
              placeholderCss && `&::placeholder {${placeholderCss}}`,
              printCss && `@media print {${printCss}}`,
            ]
              .filter(Boolean)
              .join('\n')

            return ret
          }

          const transformGlam = (code, inline, filename) =>
            babelCore.transform(code, {
              babelrc: false,
              filename,
              plugins: [[glam, { inline }]],
            }).code

          var getValueForProperty = (node, parent) => {
            const key = node.key.value
            const value = node.value.value

            switch (node.value.type) {
              case 'Literal':
                return {
                  [key]: typeof value === 'string' && !isCode$1(node)
                    ? JSON.stringify(value)
                    : wrap(value),
                }
              // TODO lists
              case 'ArrayExpression':
              // TODO support object nesting
              case 'ObjectExpression':
              default:
                return false
            }
          }

          const blacklist = ['backgroundSize', 'teleportTo', 'goTo', 'isActive']
          var isValidPropertyForBlock = (node, parent) =>
            !blacklist.includes(node.key.value)

          var makeToggle = (fn, prop) =>
            `${fn} = () => this.setState({ ${prop}: !this.state.${prop} })`

          var _extends =
            Object.assign ||
            function(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i]

                for (var key in source) {
                  if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key]
                  }
                }
              }

              return target
            }

          var objectWithoutProperties = function(obj, keys) {
            var target = {}

            for (var i in obj) {
              if (keys.indexOf(i) >= 0) continue
              if (!Object.prototype.hasOwnProperty.call(obj, i)) continue
              target[i] = obj[i]
            }

            return target
          }

          var makeVisitors = ({
            getBlockName,
            getStyleForProperty,
            getValueForProperty,
            isValidPropertyForBlock,
            PropertiesStyleLeave,
          }) => {
            const BlockDefaultProps = {
              enter(node, parent, state) {
                if (parent || node.name.value === 'List') return

                const from = getProp$1(node, 'from')
                if (from && isData$1(from)) {
                  state.use(from.value.value)
                  state.defaultProps = toCamelCase(from.value.value)
                }
              },
            }

            const BlockName = {
              enter(node, parent, state) {
                const name = getBlockName(node, state)
                if (name === null) return this.skip()

                node.name.finalValue = name
                state.use(name)

                state.render.push(`<${name}`)
              },
              leave(node, parent, state) {
                if (
                  !parent ||
                  node.explicitChildren ||
                  (node.blocks && node.blocks.list.length > 0)
                ) {
                  if (!parent) {
                    if (
                      !node.blocks ||
                      (node.blocks && node.blocks.list.length === 0)
                    ) {
                      state.render.push('>')
                    }
                    state.render.push(`{props.children}`)
                  }
                  state.render.push(`</${node.name.finalValue}>`)
                } else {
                  state.render.push('/>')
                }
              },
            }

            const BlockWhen = {
              enter(node, parent, state) {
                // when lets you show/hide blocks depending on props
                const when = getProp$1(node, 'when')
                if (when) {
                  node.when = true

                  if (parent) state.render.push('{')
                  state.render.push(`${when.value.value} ? `)
                }
              },
              leave(node, parent, state) {
                if (node.when) {
                  state.render.push(` : null`)
                  if (parent) state.render.push('}')
                }
              },
            }

            const BlockExplicitChildren = {
              leave(node, parent, state) {
                if (node.explicitChildren) {
                  state.render.push('>')
                  state.render.push(node.explicitChildren)
                }
              },
            }

            const BlocksList = {
              enter(node, parent, state) {
                if (parent.name.value === 'List') {
                  let from = getProp$1(parent, 'from')
                  if (!from) return

                  if (isData$1(from)) {
                    state.use(from.value.value)
                    from = toCamelCase(from.value.value)
                  } else {
                    from = from.value.value
                  }

                  state.render.push(
                    `{Array.isArray(${from}) && ${from}.map((item, i) => `
                  )

                  node.list.forEach(n => (n.isInList = true))
                }
              },
              leave(node, parent, state) {
                if (parent.name.value === 'List') {
                  state.render.push(')}')
                }
              },
            }

            const BlockRoute = {
              enter(node, parent, state) {
                const at = getProp$1(node, 'at')
                if (at) {
                  let [path$$1, isExact = false] = at.value.value.split(' ')
                  state.use('Route')

                  if (path$$1 === '/') state.use('Router')

                  if (!path$$1.startsWith('/')) {
                    path$$1 = `\`\${props.match.url}/${path$$1}\``
                  }

                  node.isRoute = true
                  state.render.push(
                    `<Route path=${safe(path$$1)} ${isExact
                      ? 'exact'
                      : ''} render={routeProps => `
                  )
                }
              },
              leave(node, parent, state) {
                if (node.isRoute) {
                  state.render.push('} />')
                }
              },
            }

            const PropertiesListKey = {
              leave(node, parent, state) {
                if (parent.isInList && !node.hasKey) {
                  state.render.push(' key={i}')
                }
              },
            }

            const PropertiesRoute = {
              leave(node, parent, state) {
                if (parent.isRoute) {
                  state.render.push(' {...routeProps}')
                }
              },
            }

            const PropertiesStyle = {
              enter(node, parent, state) {
                node.style = {
                  dynamic: {
                    base: {},
                    active: {},
                    hover: {},
                    activeHover: {},
                    disabled: {},
                    placeholder: {},
                    print: {},
                  },
                  static: {
                    base: {},
                    active: {},
                    hover: {},
                    activeHover: {},
                    disabled: {},
                    placeholder: {},
                    print: {},
                  },
                }

                const name = parent.name.value
                if (name === 'Vertical' || name === 'List') {
                  node.style.static.base.flexDirection = 'column'
                } else if (name === 'Horizontal') {
                  node.style.static.base.flexDirection = 'row'
                }
              },
              leave: PropertiesStyleLeave,
            }

            // const PropertyData = {
            //   enter(node, parent, state) {
            //     if (isData(node)) {
            //       state.render.push(``)
            //       return true
            //     }
            //   }
            // }

            const PropertyList = {
              enter(node, parent, state) {
                // block is inside List
                if (parent.isInList === 'List' && node.key.value === 'key') {
                  parent.hasKey = true
                }
              },
            }

            const PropertyRest = {
              enter(node, parent, state) {
                if (
                  !parent.skip &&
                  !(
                    node.key.value === 'from' &&
                    parent.parent.name.value === 'List'
                  )
                ) {
                  if (isToggle$1(node)) {
                    const propToToggle = node.tags.toggle
                    const functionName = `toggle${toPascalCase(propToToggle)}`
                    state.remap[propToToggle] = {
                      body: makeToggle(functionName, propToToggle),
                      fn: functionName,
                    }
                    state.render.push(
                      ` ${node.key.value}={props.${functionName}}`
                    )
                    return
                  }

                  if (state.views[node.value.value]) {
                    state.render.push(
                      ` ${node.key.value}=${wrap(node.value.value)}`
                    )
                    state.use(node.value.value)
                    return
                  }

                  const value = getValueForProperty(node, parent)

                  if (value) {
                    Object.keys(value).forEach(k =>
                      state.render.push(` ${k}=${value[k]}`)
                    )
                  }
                }
              },
            }

            const PropertyStyle = {
              enter(node, parent, state) {
                if (isStyle$1(node) && parent.parent.isBasic) {
                  const code = isCode$1(node)
                  const _getStyleForProperty = getStyleForProperty(
                    node,
                    parent,
                    code
                  ),
                    { _isProp } = _getStyleForProperty,
                    styleForProperty = objectWithoutProperties(
                      _getStyleForProperty,
                      ['_isProp']
                    )

                  if (_isProp) {
                    Object.keys(styleForProperty).forEach(k =>
                      state.render.push(
                        ` ${k}=${safe(styleForProperty[k], node)}`
                      )
                    )
                  } else {
                    const target = code
                      ? parent.style.dynamic
                      : parent.style.static
                    Object.assign(target[getStyleType(node)], styleForProperty)
                  }

                  return true
                }
              },
            }

            const PropertyText = {
              enter(node, parent, state) {
                if (
                  node.key.value === 'text' &&
                  parent.parent.name.value === 'Text'
                ) {
                  parent.parent.explicitChildren = isCode$1(node)
                    ? wrap(node.value.value)
                    : node.value.value

                  return true
                }
              },
            }

            return {
              BlockDefaultProps,
              BlockExplicitChildren,
              BlockName,
              BlockRoute,
              BlockWhen,

              Block: {
                // TODO Image
                // TODO Capture*
                // TODO List without wrapper?
                enter(node, parent, state) {
                  BlockWhen.enter.call(this, node, parent, state)
                  BlockRoute.enter.call(this, node, parent, state)
                  BlockName.enter.call(this, node, parent, state)
                  BlockDefaultProps.enter.call(this, node, parent, state)
                },
                leave(node, parent, state) {
                  BlockExplicitChildren.leave.call(this, node, parent, state)
                  BlockName.leave.call(this, node, parent, state)
                  BlockRoute.leave.call(this, node, parent, state)
                  BlockWhen.leave.call(this, node, parent, state)
                },
              },

              Blocks: {
                enter(node, parent, state) {
                  if (node.list.length > 0) state.render.push('>')
                  BlocksList.enter.call(this, node, parent, state)
                },
                leave(node, parent, state) {
                  BlocksList.leave.call(this, node, parent, state)
                },
              },

              Properties: {
                enter(node, parent, state) {
                  PropertiesStyle.enter.call(this, node, parent, state)
                },
                leave(node, parent, state) {
                  PropertiesStyle.leave.call(this, node, parent, state)
                  PropertiesListKey.leave.call(this, node, parent, state)
                  PropertiesRoute.leave.call(this, node, parent, state)
                },
              },

              Property: {
                enter(node, parent, state) {
                  if (
                    node.key.value === 'at' ||
                    node.key.value === 'when' ||
                    isData$1(node)
                  )
                    return
                  if (!isValidPropertyForBlock(node, parent)) return

                  // if (PropertyData.enter.call(this, node, parent, state)) return
                  if (PropertyStyle.enter.call(this, node, parent, state))
                    return
                  if (PropertyText.enter.call(this, node, parent, state)) return
                  PropertyList.enter.call(this, node, parent, state)
                  PropertyRest.enter.call(this, node, parent, state)
                },
              },

              Fonts(list, state) {
                state.fonts = list
              },

              Todos(list, state) {
                state.todos = list
              },
            }
          }

          var maybeUsesRouter = state => {
            if (state.uses.includes('Router')) {
              state.render = ['<Router>', ...state.render, '</Router>']
            }
          }

          // TODO don't import glam if styles aren't inlined and there are no dynamic
          // styles
          var maybeUsesStyleSheet = state => {
            if (hasKeys(state.styles)) {
              state.uses.push('glam')
            }
          }

          var reactNative = [
            'CaptureEmail',
            'CaptureFile',
            'CaptureInput',
            'CaptureNumber',
            'CapturePhone',
            'CaptureSecure',
            'CaptureText',
            'Horizontal',
            'Vertical',
            'Image',
            'Text',
            'List',
            'Proxy',
            'SvgText',
            'Svg',
            'Circle',
            'Ellipse',
            'G',
            'LinearGradient',
            'RadialGradient',
            'Line',
            'Path',
            'Polygon',
            'Polyline',
            'Rect',
            'Symbol',
            'Use',
            'Defs',
            'Stop',
            'Router',
            'Route',
            'Link',
          ]

          var getBody = ({ state, name }) => {
            const render = state.render.join('')
            return state.captures.length > 0
              ? `class ${name} extends React.Component {
  constructor(props) {
    super(props)
    this.state = {}
  }

  render() {
    const { props, state } = this
    return (${render})
  }
}`
              : `const ${name} = (props) => (${render})`
          }

          var getDefaultProps = ({ state, name }) =>
            state.defaultProps
              ? `${name}.defaultProps = ${state.defaultProps}`
              : ''

          var SVG = [
            'Svg',
            'Circle',
            'Ellipse',
            'G',
            'LinearGradient',
            'RadialGradient',
            'Line',
            'Path',
            'Polygon',
            'Polyline',
            'Rect',
            'Symbol',
            'SvgText',
            'Use',
            'Defs',
            'Stop',
          ]

          const NATIVE = [
            'Image',
            'KeyboardAvoidingView',
            'ScrollView',
            'StyleSheet',
            'Text',
            'TextInput',
            'TouchableHighlight',
            'View',
          ]

          var getDependencies = (uses, getImport) => {
            const usesNative = []
            const usesSvg = []

            const useNative = d => {
              if (!usesNative.includes(d)) {
                usesNative.push(d)
              }
            }
            const useSvg = d => {
              if (!usesSvg.includes(d)) {
                usesSvg.push(d)
              }
            }

            const dependencies = []
            uses.sort().forEach(d => {
              if (NATIVE.includes(d)) {
                useNative(d)
              } else if (SVG.includes(d)) {
                useSvg(d === 'SvgText' ? 'Text as SvgText' : d)
              } else if (/^[A-Z]/.test(d) || /\.data$/.test(d)) {
                dependencies.push(getImport(d))
              } else if (d === 'glam') {
                dependencies.push(`import css from 'glam'`)
              }
            })

            if (usesSvg.length > 0) {
              const svg = usesSvg.filter(m => m !== 'Svg').join(', ')
              dependencies.push(
                `import Svg, { ${svg} } from 'react-native-svg'`
              )
            }

            if (usesNative.length > 0) {
              dependencies.push(
                `import { ${usesNative.join(', ')} } from 'react-native'`
              )
            }

            return dependencies.join('\n')
          }

          var getFonts = fonts => `// fonts ${JSON.stringify(fonts)}`

          var getRemap = ({ state, name }) => {
            if (Object.keys(state.remap).length === 0) return false
            const remap = {
              name: `Remap${name}`,
            }

            const localState = []
            const fns = []
            const methods = Object.keys(state.remap).map(prop => {
              localState.push(`${prop}: props.${prop},`)
              const { body, fn } = state.remap[prop]
              fns.push(`${fn}={this.${fn}}`)
              return body
            })

            remap.component = `class ${remap.name} extends React.Component {
constructor(props) {
super(props)
this.state = ${wrap(localState.join('\n'))}
}
${methods.join('\n')}

render() {
  return <${name} {...this.props} {...this.state} ${fns.join(' ')} />
}
}`

            return remap
          }

          var getTests = ({ state, name }) => {
            if (!state.tests) return false

            const tests = {
              name: `Tests${name}`,
            }

            // TODO track choices in sessionStorage
            tests.component = `
  const g = typeof window === 'undefined' ? global : window

  class ${tests.name} extends React.Component {
  constructor(props) {
    super(props)

    const { _main, ...rest } = makeTests(this.display)
    this.state = {
      ...rest[_main],
      _on: true,
    }

    const tests = {
      active: _main,
      on: this.on,
      off: this.off,
    }

    Object.keys(rest).forEach(test => {
      tests[test] = () => this.display(rest[test], test)
    })

    if (typeof g.tests === 'undefined') {
      const validTests = k => !(k === 'off' || k === 'on')
      g.tests = {
        off: () => Object.keys(g.tests).filter(validTests).forEach(t => g.tests[t].off()),
        on: () => Object.keys(g.tests).filter(validTests).forEach(t => g.tests[t].on()),
      }
    }

    if (typeof g.tests.${name} === 'undefined') {
      g.tests.${name} = tests
    } else if (Array.isArray(g.tests.${name})) {
      g.tests.${name}.push(tests)
    } else {
      g.tests.${name} = [
        g.tests.${name},
        tests
      ]
      g.tests.${name}.off = () => g.tests.${name}.forEach(t => t.off())
      g.tests.${name}.on = () => g.tests.${name}.forEach(t => t.on())
    }

    this.test = tests

    console.info('${name} tests ', g.tests)
  }

  componentWillUnmount() {
    if (Array.isArray(g.tests.${name})) {
      g.tests.${name} = g.tests.${name}.filter(t => t === this.tests)
      if (g.tests.${name}.length === 0) {
        delete g.tests.${name}
      }
    } else {
      delete g.tests.${name}
    }
  }

  display = (next, name) => {
    this.setState(next, () => {
      g.tests.${name}.active = name
    })
  }

  off = () => this.setState({ _on: false })
  on = () => this.setState({ _on: true })

  render() {
    const { _on, ...state } = this.state
    return _on ? <${name} {...this.props} {...state} /> : <${name} {...this.props} />
  }
}`

            return tests
          }

          var toComponent = ({ getImport, getStyles, name, state }) => {
            const remap = getRemap({ state, name })
            let xport = remap ? remap.name : name

            const tests = getTests({ state, name: xport })
            if (tests) xport = tests.name
            // TODO remove withRouter when
            // https://github.com/ReactTraining/react-router/issues/4571 is merged and
            // relative links are supported
            if (state.withRouter) xport = `withRouter(${xport})`

            const dependencies = [
              `import React from 'react'`,
              state.withRouter && `import { withRouter } from 'react-router'`,
              tests && `import makeTests from './${name}.view.tests.js'`,
              getDependencies(state.uses, getImport),
            ]
              .filter(Boolean)
              .join('\n')

            // TODO Emojis should be wrapped in <span>, have role="img", and have an accessible description
            // with aria-label or aria-labelledby  jsx-a11y/accessible-emoji
            return `/* eslint-disable jsx-a11y/accessible-emoji */
${dependencies}

${getStyles(state, name)}

${tests ? tests.component : ''}
${remap ? remap.component : ''}

${getBody({ state, name })}
${getDefaultProps({ state, name })}
export default ${xport}
${getFonts(state.fonts)}`
          }

          const imports = {
            Link: "import { Link } from 'react-router-dom'",
            Route: "import { Route } from 'react-router-dom'",
            Router:
              "import { BrowserRouter as Router } from 'react-router-dom'",
          }

          var reactDom = ({
            getImport,
            inlineStyles = true,
            file,
            name,
            tests = false,
            view,
            views = {},
          }) => {
            const finalName = reactNative.includes(name) ? `${name}1` : name
            if (name !== finalName) {
              console.warn(`// "${name}" is a Views reserved name.
      We've renamed it to "${finalName}", so your view should work but this isn't ideal.
      To fix this, change its file name to something else.`)
            }

            const state = {
              captures: [],
              defaultProps: false,
              file,
              fonts: [],
              inlineStyles,
              remap: {},
              render: [],
              styles: {},
              todos: [],
              uses: [],
              tests,
              use(block) {
                if (
                  state.uses.includes(block) ||
                  /props/.test(block) ||
                  block === finalName
                )
                  return

                state.uses.push(block)
              },
              views,
              withRouter: false,
            }

            if (name !== finalName) {
              console.warn(
                `// ${name} is a Views reserved name. To fix this, change its file name to something else.`
              )
            }

            const _makeVisitors = makeVisitors({
              getBlockName,
              getStyleForProperty,
              getValueForProperty,
              isValidPropertyForBlock,
              PropertiesStyleLeave: leave,
            }),
              {
                BlockDefaultProps,
                BlockExplicitChildren,
                BlockName,
                BlockRoute,
                BlockWhen,
              } = _makeVisitors,
              visitors = objectWithoutProperties(_makeVisitors, [
                'BlockDefaultProps',
                'BlockExplicitChildren',
                'BlockName',
                'BlockRoute',
                'BlockWhen',
              ])

            visitors.Block = {
              // TODO Capture*
              // TODO List without wrapper?
              enter(node, parent, state) {
                ;[
                  BlockWhen.enter,
                  BlockRoute.enter,
                  BlockName.enter,
                  enter$1,
                  enter,
                  BlockDefaultProps.enter,
                ].forEach(fn => fn.call(this, node, parent, state))
              },
              leave(node, parent, state) {
                ;[
                  BlockExplicitChildren.leave,
                  BlockName.leave,
                  BlockRoute.leave,
                  BlockWhen.leave,
                ].forEach(fn => fn.call(this, node, parent, state))
              },
            }

            morph$1(view, state, visitors)

            maybeUsesStyleSheet(state)
            maybeUsesRouter(state)

            const finalGetImport = name => imports[name] || getImport(name)

            return toComponent({
              getImport: finalGetImport,
              getStyles,
              name: finalName,
              state,
            })
          }

          const enter$2 = (node, parent, state) => {
            if (node.backgroundImage) {
              const source = wrap(
                getObjectAsString({ uri: node.backgroundImage })
              )
              state.render.push(` resizeMode="cover" source=${source}`)
            }
          }

          const enter$3 = (node, parent, state) => {
            if (/Capture/.test(node.name.value)) {
              if (node.properties && !hasProp(node, 'ref')) {
                node.properties.skip = true

                const { captureNext } = node
                let onSubmit = getProp$1(node, 'onSubmit') || null
                if (onSubmit) onSubmit = onSubmit.value.value

                if (captureNext) {
                  state.render.push(` blurOnSubmit={false}`)
                  state.render.push(
                    ` onSubmitEditing={this.$capture${captureNext}? () => this.$capture${captureNext}.focus() : ${onSubmit}}`
                  )
                  state.render(
                    ` returnKeyType = {this.$capture${captureNext}? 'next' : 'go'}`
                  )
                } else {
                  if (onSubmit) {
                    state.render.push(` onSubmitEditing={${onSubmit}}`)
                    state.render.push(` returnKeyType="go"`)
                  } else {
                    state.render.push(` returnKeyType="done"`)
                  }
                }
                state.render.push(
                  ` onChangeText = {${node.is} => this.setState({ ${node.is} })}`
                )
                state.render.push(` ref={$e => this.$capture${node.is} = $e}`)
                state.render.push(` value={state.${node.is}}`)
              }
            }
          }

          var getBlockName$1 = (node, state) => {
            switch (node.name.value) {
              case 'CaptureEmail':
              // case 'CaptureFile':
              case 'CaptureInput':
              case 'CaptureNumber':
              case 'CapturePhone':
              case 'CaptureSecure':
              case 'CaptureText':
                return 'TextInput'

              case 'Horizontal':
              case 'Vertical':
                return getGroupBlockName$1(node, state)

              case 'List':
                return getListBlockName(node)

              case 'Proxy':
                return getProxyBlockName$1(node)
              // TODO SvgText should be just Text but the import should be determined from the parent
              // being Svg

              default:
                return node.name.value
            }
          }

          const getGroupBlockName$1 = (node, state) => {
            let name = 'View'

            if (hasProp(node, 'teleportTo')) {
              node.teleport = true
            } else if (hasProp(node, 'goTo')) {
              node.goTo = true
            } else if (hasProp(node, 'onClick')) {
              const propNode = getProp$1(node, 'onClick')

              if (isToggle$1(propNode)) {
                const propToToggle = propNode.tags.toggle
                const functionName = `toggle${toPascalCase(propToToggle)}`
                state.remap[propToToggle] = {
                  body: makeToggle(functionName, propToToggle),
                  fn: functionName,
                }

                node.action = `props.${functionName}`
                return
              } else {
                node.action = propNode.value.value
              }
            }

            if (hasProp(node, 'backgroundImage')) {
              const propNode = getProp$1(node, 'backgroundImage')
              node.backgroundImage = isCode$1(propNode)
                ? propNode.value.value
                : JSON.stringify(propNode.value.value)

              name = 'Image'
            } else if (
              hasProp(node, 'overflowY', v => v === 'auto' || v === 'scroll')
            ) {
              name = 'ScrollView'
            }

            return name
          }

          const getListBlockName = node =>
            hasProp(node, /^overflow/, v => v === 'auto' || v === 'scroll')
              ? 'ScrollView'
              : 'View'

          const getProxyBlockName$1 = node => {
            const from = getProp$1(node, 'from')
            return from && from.value.value
          }

          const enter$4 = (node, parent, state) => {
            const name = getBlockName$1(node, state)

            if (
              name === 'Text' &&
              parent &&
              parent.parent &&
              (parent.parent.backgroundImage ||
                parent.parent.ensureBackgroundColor)
            ) {
              node.ensureBackgroundColor = true
            }

            if (node.action) {
              state.use('TouchableHighlight')
              state.render.push(`<TouchableHighlight
          activeOpacity={0.7}
          onPress=${wrap(node.action)}
          underlayColor='transparent'>`)
              node.wrapEnd = '</TouchableHighlight>'
            } else if (node.teleport) {
              state.use('Link')
              let to = getProp$1(node, 'teleportTo').value.value

              if (to.startsWith('/') || to === '..') {
                to = safe(to)
              } else {
                to = isCode$1(to) ? `\${${to}}` : to
                to = `{\`\${props.match.url === '/' ? '' : props.match.url}/${to}\`}`
                state.withRouter = true
              }

              state.render.push(`<Link
          activeOpacity={0.7}
          to=${to}
          underlayColor='transparent'>`)
              node.wrapEnd = '</Link>'
            } else if (node.goTo) {
              // const goTo = getProp(node, 'goTo')
              // TODO https://facebook.github.io/react-native/docs/linking.html
            }
          }

          const leave$1 = (node, parent, state) => {
            if (node.wrapEnd) {
              state.render.push(node.wrapEnd)
            }
          }

          const leave$2 = (node, parent, state) => {
            let style = null

            if (
              parent.ensureBackgroundColor &&
              (!('backgroundColor' in node.style.static.base) ||
                !('backgroundColor' in node.style.dynamic.base))
            ) {
              node.style.static.base.backgroundColor = 'transparent'
            }

            if (hasKeys(node.style.static.base)) {
              const id = hash(node.style.static.base)
              state.styles[id] = node.style.static.base
              parent.styleId = id
              style = `styles.${id}`
            }
            if (hasKeys(node.style.dynamic.base)) {
              const dynamic = getObjectAsString(node.style.dynamic.base)
              style = style ? `[${style},${dynamic}]` : dynamic
            }

            if (style) {
              state.render.push(` style={${style}}`)
            }
          }

          var getStyleForProperty$1 = (node, parent, code) => {
            const key = node.key.value
            const value = node.value.value

            switch (key) {
              case 'border':
              case 'borderBottom':
              case 'borderLeft':
              case 'borderRight':
              case 'borderTop':
                return getBorder(value, key.replace('border', ''))

              case 'boxShadow':
                return getShadow(value)

              case 'fontFamily':
                return {
                  fontFamily: getFontFamily(node, parent),
                }

              case 'zIndex':
                return {
                  zIndex: code ? value : parseInt(value, 10),
                }

              case 'color':
                if (
                  /Capture/.test(parent.parent.name.value) &&
                  isTag(node, 'placeholder')
                ) {
                  return {
                    _isProp: true,
                    placeholderTextColor: value,
                  }
                }

              default:
                return {
                  [key]: value,
                }
            }
          }

          const getFontFamily = (node, parent) => {
            const fontWeight = parent.list.find(
              n => n.key.value === 'fontWeight'
            )
            // const key = node.key.value
            const fontFamily = node.value.value.split(',')[0].replace(/\s/g, '')

            return fontWeight
              ? `${fontFamily}-${fontWeight.value.value}`
              : fontFamily
          }

          // support
          // /* offset-x | offset-y | color */
          // box-shadow: 60px -16px teal;
          // /* offset-x | offset-y | blur-radius | color */
          // box-shadow: 10px 5px 5px black;
          // /* offset-x | offset-y | blur-radius | spread-radius | color */
          // box-shadow: 2px 2px 2px 1px rgba(0, 0, 0, 0.2);
          //
          // https://developer.mozilla.org/en/docs/Web/CSS/box-shadow?v=example
          // prop mapping https://github.com/necolas/react-native-web/issues/44#issuecomment-269031472
          const getShadow = value => {
            const [offsetX, offsetY, ...parts] = value.split(' ')

            const ret = {
              // Android
              elevation: 1,
              // iOS,
              shadowOffset: {
                height: parseInt(offsetX, 10),
                width: parseInt(offsetY, 10),
              },
            }

            let color
            if (parts.length === 1) {
              color = parts[0]
            } else if (parts.length === 2) {
              color = parts[1]
              ret.shadowRadius = parseInt(parts[0], 10)
            }

            if (color) {
              // TODO what if the color is a prop? do we calculate this on the fly, how?
              if (/props/.test(color)) {
                ret.shadowColor = color
                ret.shadowOpacity = 1
              } else {
                color = getColor(color)
                ret.shadowColor = color.string()
                ret.shadowOpacity = color.valpha
              }
            }

            return ret
          }

          const getBorder = (value, specific = '') => {
            const [borderWidth, borderStyle, borderColor] = value.split(' ')

            return {
              [`border${specific}Color`]: borderColor,
              /*[`border${specific}Style`]:*/ borderStyle,
              [`border${specific}Width`]: parseInt(borderWidth, 10),
            }
          }

          var getStyles$1 = ({ styles }) =>
            hasKeys(styles)
              ? `const styles = StyleSheet.create(${JSON.stringify(styles)})`
              : ''

          var getValueForProperty$1 = (node, parent) => {
            const key = node.key.value
            const value = node.value.value

            switch (node.value.type) {
              case 'Literal':
                return {
                  [key]: safe(value, node),
                }
              // TODO lists
              case 'ArrayExpression':
              // TODO support object nesting
              case 'ObjectExpression':
              default:
                return false
            }
          }

          const blacklist$1 = [
            'backgroundImage',
            'backgroundSize',
            'cursor',
            'overflow',
            'overflowX',
            'overflowY',
            'fontWeight',
            'onClick',
            'pageBreakInside',
            'teleportTo',
            // TODO convert to upper case...
            'textTransform',
            'goTo',
          ]

          // TODO whitelist instead

          // TODO FIXME pass props to non basic blocks
          var isValidPropertyForBlock$1 = (node, parent) =>
            !blacklist$1.includes(node.key.value)
          // !node.isBasic || (node.isBasic &&

          var maybeUsesTextInput = state => {
            if (state.uses.includes('TextInput')) {
              state.uses.push('KeyboardAvoidingView')
              state.render = [
                `<KeyboardAvoidingView behavior='position'>`,
                ...state.render,
                `</KeyboardAvoidingView>`,
              ]
            }
          }

          var maybeUsesRouter$1 = state => {
            if (state.uses.includes('Router')) {
              state.render = ['<Router>', ...state.render, '</Router>']
            }
          }

          var maybeUsesStyleSheet$1 = state => {
            if (Object.keys(state.styles).length > 0) {
              state.uses.push('StyleSheet')
            }
          }

          const imports$1 = {
            Link: "import { Link } from 'react-router-native'",
            Route: "import { Route } from 'react-router-native'",
            Router:
              "import { NativeRouter as Router } from 'react-router-native'",
          }

          var reactNative$1 = ({
            getImport,
            name,
            tests = false,
            view,
            views = {},
          }) => {
            const finalName = reactNative.includes(name) ? `${name}1` : name
            if (name !== finalName) {
              console.warn(`// "${name}" is a Views reserved name.
      We've renamed it to "${finalName}", so your view should work but this isn't ideal.
      To fix this, change its file name to something else.`)
            }

            const state = {
              captures: [],
              defaultProps: false,
              fonts: [],
              remap: {},
              render: [],
              styles: {},
              tests,
              todos: [],
              uses: [],
              use(block) {
                if (
                  state.uses.includes(block) ||
                  /props/.test(block) ||
                  block === finalName
                )
                  return

                state.uses.push(block)
              },
              views,
              withRouter: false,
            }

            const _makeVisitors = makeVisitors({
              getBlockName: getBlockName$1,
              getStyleForProperty: getStyleForProperty$1,
              getValueForProperty: getValueForProperty$1,
              isValidPropertyForBlock: isValidPropertyForBlock$1,
              PropertiesStyleLeave: leave$2,
            }),
              {
                BlockDefaultProps,
                BlockExplicitChildren,
                BlockName,
                BlockRoute,
                BlockWhen,
              } = _makeVisitors,
              visitors = objectWithoutProperties(_makeVisitors, [
                'BlockDefaultProps',
                'BlockExplicitChildren',
                'BlockName',
                'BlockRoute',
                'BlockWhen',
              ])

            visitors.Block = {
              // TODO Capture*
              // TODO FlatList
              enter(node, parent, state) {
                ;[
                  BlockWhen.enter,
                  BlockRoute.enter,
                  enter$4,
                  BlockName.enter,
                  enter$3,
                  enter$2,
                  BlockDefaultProps.enter,
                ].forEach(fn => fn.call(this, node, parent, state))
              },
              leave(node, parent, state) {
                ;[
                  BlockExplicitChildren.leave,
                  BlockName.leave,
                  leave$1,
                  BlockRoute.leave,
                  BlockWhen.leave,
                ].forEach(fn => fn.call(this, node, parent, state))
              },
            }

            morph$1(view, state, visitors)

            maybeUsesTextInput(state)
            maybeUsesRouter$1(state)
            maybeUsesStyleSheet$1(state)

            const finalGetImport = name => imports$1[name] || getImport(name)

            return toComponent({
              getImport: finalGetImport,
              getStyles: getStyles$1,
              name: finalName,
              state,
            })
          }

          var tests = ({ view }) => {
            // because the walker mutates the AST, we need to get a new one each time
            // get the names first
            const names = parse(view).views.map((view, index) => {
              let name

              walk(view, {
                enter(node, parent) {
                  if (node.type === 'Block') {
                    name = node.is || `Test${index}`
                  }
                },
              })

              return name
            })

            // then the tests
            const tests = parse(view).views.map((view, index) => {
              const test = {}
              let name

              walk(view, {
                enter(node, parent) {
                  if (node.type === 'Block') {
                    name = node.is || `Test${index}`
                  } else if (node.type === 'Property') {
                    test[node.key.value] = getValue$3(node, names)

                    if (
                      node.value.type === 'ArrayExpression' ||
                      node.value.type === 'ObjectExpression'
                    )
                      this.skip()
                  }
                },
              })

              return {
                name,
                test,
              }
            })

            const body = tests
              .map(({ name, test }, index) => {
                // every test after the first one inherits the first one
                const data = index > 0
                  ? _extends({}, tests[0].test, test)
                  : test

                return `const ${name} = ${JSON.stringify(data)}`
              })
              .join('\n')

            return `export default display => {
    ${body.replace(/"?<<DISPLAY>>"?/g, '')}
    return { _main: '${names[0]}', ${names.join(',')} }
  }`
          }

          // TODO embed data
          // Test
          // name Dario
          // addresses
          // from addresses.data
          const getValue$3 = (property, tests) => {
            switch (property.value.type) {
              case 'Literal':
                const v = property.value.value
                return tests.includes(v)
                  ? `<<DISPLAY>>() => display(${v}, '${v}')<<DISPLAY>>`
                  : v

              case 'ArrayExpression':
                return property.value.elements.map(v => getValue$3(v, tests))

              case 'ObjectExpression':
                let value = {}

                property.value.properties.forEach(pr => {
                  value[pr.key.value] = getValue$3(pr, tests)
                })

                return value

              default:
                return null
            }
          }

          var doMorph = {
            data,
            'react-dom': reactDom,
            'react-native': reactNative$1,
            tests,
          }

          const data$1 = (name, warning) =>
            `const ${toCamelCase(
              name
            )} = () => { console.warn("${warning}"); return {} }`

          const reactDom$2 = (name, warning) =>
            `const ${name} = () => { console.warn("${warning}"); return <div>${name} </div> }`

          const reactNative$3 = (name, warning) =>
            `const ${name} = () => { console.warn("${warning}"); return <Text>${name} </Text> }`

          var doGetViewNotFound = {
            data: data$1,
            'react-dom': reactDom$2,
            'react-native': reactNative$3,
          }

          var restrictedNames = {
            data: [],
            'react-dom': reactNative,
            'react-native': reactNative,
            tests: [],
          }

          const DEFAULT_IMPORT = name =>
            /\.data$/.test(name)
              ? `import ${toCamelCase(name)} from './${name}.js'`
              : `import ${name} from './${name}.view.js'`

          const morph = (
            code,
            {
              as,
              compile,
              file = {},
              getImport = DEFAULT_IMPORT,
              inlineStyles,
              name,
              pretty = false,
              tests,
              views = {},
            }
          ) => {
            let morphed = doMorph[as]({
              file,
              getImport,
              inlineStyles,
              name,
              view: code,
              tests,
              views,
            })

            if (compile) {
              morphed = buble.transform(morphed, {
                objectAssign: 'Object.assign',
                transforms: {
                  modules: false,
                },
              }).code
            }

            return pretty
              ? prettier.format(morphed, {
                  singleQuote: true,
                  trailingComma: 'es5',
                })
              : morphed
          }

          const getViewNotFound = (as, name, warning) =>
            doGetViewNotFound[as](name, warning)

          const sanitize = input =>
            path
              .basename(input)
              .replace(path.extname(input), '')
              .replace(/[^a-zA-Z_$0-9]+/g, '_')
              .replace(/^_/, '')
              .replace(/_$/, '')
              .replace(/^(\d)/, '_$1')

          const pathToName = path$$1 =>
            toPascalCase(sanitize(path.basename(path$$1).replace('.view', '')))

          const isViewNameRestricted = (view, as) =>
            restrictedNames[as].includes(view)

          exports.morph = morph
          exports.getViewNotFound = getViewNotFound
          exports.pathToName = pathToName
          exports.isViewNameRestricted = isViewNameRestricted
        },
        {
          'babel-core': 5,
          buble: 119,
          color: 129,
          'css-properties': 240,
          'glam/babel': 259,
          path: 505,
          prettier: 'prettier',
          synesthesia: 555,
          'to-camel-case': 557,
          'to-pascal-case': 560,
          'to-slug-case': 561,
        },
      ],
      2: [
        function(require, module, exports) {
          'use strict'
          module.exports = function() {
            return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g
          }
        },
        {},
      ],
      3: [
        function(require, module, exports) {
          'use strict'
          function assembleStyles() {
            var styles = {
              modifiers: {
                reset: [0, 0],
                bold: [1, 22], // 21 isn't widely supported and 22 does the same thing
                dim: [2, 22],
                italic: [3, 23],
                underline: [4, 24],
                inverse: [7, 27],
                hidden: [8, 28],
                strikethrough: [9, 29],
              },
              colors: {
                black: [30, 39],
                red: [31, 39],
                green: [32, 39],
                yellow: [33, 39],
                blue: [34, 39],
                magenta: [35, 39],
                cyan: [36, 39],
                white: [37, 39],
                gray: [90, 39],
              },
              bgColors: {
                bgBlack: [40, 49],
                bgRed: [41, 49],
                bgGreen: [42, 49],
                bgYellow: [43, 49],
                bgBlue: [44, 49],
                bgMagenta: [45, 49],
                bgCyan: [46, 49],
                bgWhite: [47, 49],
              },
            }

            // fix humans
            styles.colors.grey = styles.colors.gray

            Object.keys(styles).forEach(function(groupName) {
              var group = styles[groupName]

              Object.keys(group).forEach(function(styleName) {
                var style = group[styleName]

                styles[styleName] = group[styleName] = {
                  open: '\u001b[' + style[0] + 'm',
                  close: '\u001b[' + style[1] + 'm',
                }
              })

              Object.defineProperty(styles, groupName, {
                value: group,
                enumerable: false,
              })
            })

            return styles
          }

          Object.defineProperty(module, 'exports', {
            enumerable: true,
            get: assembleStyles,
          })
        },
        {},
      ],
      4: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true

          exports.default = function(rawLines, lineNumber, colNumber) {
            var opts = arguments.length > 3 && arguments[3] !== undefined
              ? arguments[3]
              : {}

            colNumber = Math.max(colNumber, 0)

            var highlighted =
              (opts.highlightCode && _chalk2.default.supportsColor) ||
              opts.forceColor
            var chalk = _chalk2.default
            if (opts.forceColor) {
              chalk = new _chalk2.default.constructor({ enabled: true })
            }
            var maybeHighlight = function maybeHighlight(chalkFn, string) {
              return highlighted ? chalkFn(string) : string
            }
            var defs = getDefs(chalk)
            if (highlighted) rawLines = highlight(defs, rawLines)

            var linesAbove = opts.linesAbove || 2
            var linesBelow = opts.linesBelow || 3

            var lines = rawLines.split(NEWLINE)
            var start = Math.max(lineNumber - (linesAbove + 1), 0)
            var end = Math.min(lines.length, lineNumber + linesBelow)

            if (!lineNumber && !colNumber) {
              start = 0
              end = lines.length
            }

            var numberMaxWidth = String(end).length

            var frame = lines
              .slice(start, end)
              .map(function(line, index) {
                var number = start + 1 + index
                var paddedNumber = (' ' + number).slice(-numberMaxWidth)
                var gutter = ' ' + paddedNumber + ' | '
                if (number === lineNumber) {
                  var markerLine = ''
                  if (colNumber) {
                    var markerSpacing = line
                      .slice(0, colNumber - 1)
                      .replace(/[^\t]/g, ' ')
                    markerLine = [
                      '\n ',
                      maybeHighlight(defs.gutter, gutter.replace(/\d/g, ' ')),
                      markerSpacing,
                      maybeHighlight(defs.marker, '^'),
                    ].join('')
                  }
                  return [
                    maybeHighlight(defs.marker, '>'),
                    maybeHighlight(defs.gutter, gutter),
                    line,
                    markerLine,
                  ].join('')
                } else {
                  return ' ' + maybeHighlight(defs.gutter, gutter) + line
                }
              })
              .join('\n')

            if (highlighted) {
              return chalk.reset(frame)
            } else {
              return frame
            }
          }

          var _jsTokens = require('js-tokens')

          var _jsTokens2 = _interopRequireDefault(_jsTokens)

          var _esutils = require('esutils')

          var _esutils2 = _interopRequireDefault(_esutils)

          var _chalk = require('chalk')

          var _chalk2 = _interopRequireDefault(_chalk)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          function getDefs(chalk) {
            return {
              keyword: chalk.cyan,
              capitalized: chalk.yellow,
              jsx_tag: chalk.yellow,
              punctuator: chalk.yellow,

              number: chalk.magenta,
              string: chalk.green,
              regex: chalk.magenta,
              comment: chalk.grey,
              invalid: chalk.white.bgRed.bold,
              gutter: chalk.grey,
              marker: chalk.red.bold,
            }
          }

          var NEWLINE = /\r\n|[\n\r\u2028\u2029]/

          var JSX_TAG = /^[a-z][\w-]*$/i

          var BRACKET = /^[()\[\]{}]$/

          function getTokenType(match) {
            var _match$slice = match.slice(-2),
              offset = _match$slice[0],
              text = _match$slice[1]

            var token = (0, _jsTokens.matchToToken)(match)

            if (token.type === 'name') {
              if (_esutils2.default.keyword.isReservedWordES6(token.value)) {
                return 'keyword'
              }

              if (
                JSX_TAG.test(token.value) &&
                (text[offset - 1] === '<' || text.substr(offset - 2, 2) == '</')
              ) {
                return 'jsx_tag'
              }

              if (token.value[0] !== token.value[0].toLowerCase()) {
                return 'capitalized'
              }
            }

            if (token.type === 'punctuator' && BRACKET.test(token.value)) {
              return 'bracket'
            }

            return token.type
          }

          function highlight(defs, text) {
            return text.replace(_jsTokens2.default, function() {
              for (
                var _len = arguments.length, args = Array(_len), _key = 0;
                _key < _len;
                _key++
              ) {
                args[_key] = arguments[_key]
              }

              var type = getTokenType(args)
              var colorize = defs[type]
              if (colorize) {
                return args[0]
                  .split(NEWLINE)
                  .map(function(str) {
                    return colorize(str)
                  })
                  .join('\n')
              } else {
                return args[0]
              }
            })
          }

          module.exports = exports['default']
        },
        { chalk: 122, esutils: 251, 'js-tokens': 288 },
      ],
      5: [
        function(require, module, exports) {
          module.exports = require('./lib/api/node.js')
        },
        { './lib/api/node.js': 6 },
      ],
      6: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true
          exports.transformFromAst = exports.transform = exports.analyse = exports.Pipeline = exports.OptionManager = exports.traverse = exports.types = exports.messages = exports.util = exports.version = exports.resolvePreset = exports.resolvePlugin = exports.template = exports.buildExternalHelpers = exports.options = exports.File = undefined

          var _file = require('../transformation/file')

          Object.defineProperty(exports, 'File', {
            enumerable: true,
            get: function get() {
              return _interopRequireDefault(_file).default
            },
          })

          var _config = require('../transformation/file/options/config')

          Object.defineProperty(exports, 'options', {
            enumerable: true,
            get: function get() {
              return _interopRequireDefault(_config).default
            },
          })

          var _buildExternalHelpers = require('../tools/build-external-helpers')

          Object.defineProperty(exports, 'buildExternalHelpers', {
            enumerable: true,
            get: function get() {
              return _interopRequireDefault(_buildExternalHelpers).default
            },
          })

          var _babelTemplate = require('babel-template')

          Object.defineProperty(exports, 'template', {
            enumerable: true,
            get: function get() {
              return _interopRequireDefault(_babelTemplate).default
            },
          })

          var _resolvePlugin = require('../helpers/resolve-plugin')

          Object.defineProperty(exports, 'resolvePlugin', {
            enumerable: true,
            get: function get() {
              return _interopRequireDefault(_resolvePlugin).default
            },
          })

          var _resolvePreset = require('../helpers/resolve-preset')

          Object.defineProperty(exports, 'resolvePreset', {
            enumerable: true,
            get: function get() {
              return _interopRequireDefault(_resolvePreset).default
            },
          })

          var _package = require('../../package')

          Object.defineProperty(exports, 'version', {
            enumerable: true,
            get: function get() {
              return _package.version
            },
          })
          exports.Plugin = Plugin
          exports.transformFile = transformFile
          exports.transformFileSync = transformFileSync

          var _fs = require('fs')

          var _fs2 = _interopRequireDefault(_fs)

          var _util = require('../util')

          var util = _interopRequireWildcard(_util)

          var _babelMessages = require('babel-messages')

          var messages = _interopRequireWildcard(_babelMessages)

          var _babelTypes = require('babel-types')

          var t = _interopRequireWildcard(_babelTypes)

          var _babelTraverse = require('babel-traverse')

          var _babelTraverse2 = _interopRequireDefault(_babelTraverse)

          var _optionManager = require('../transformation/file/options/option-manager')

          var _optionManager2 = _interopRequireDefault(_optionManager)

          var _pipeline = require('../transformation/pipeline')

          var _pipeline2 = _interopRequireDefault(_pipeline)

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj
            } else {
              var newObj = {}
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key]
                }
              }
              newObj.default = obj
              return newObj
            }
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          exports.util = util
          exports.messages = messages
          exports.types = t
          exports.traverse = _babelTraverse2.default
          exports.OptionManager = _optionManager2.default
          function Plugin(alias) {
            throw new Error(
              'The (' + alias + ') Babel 5 plugin is being run with Babel 6.'
            )
          }

          exports.Pipeline = _pipeline2.default

          var pipeline = new _pipeline2.default()
          var analyse = (exports.analyse = pipeline.analyse.bind(pipeline))
          var transform = (exports.transform = pipeline.transform.bind(
            pipeline
          ))
          var transformFromAst = (exports.transformFromAst = pipeline.transformFromAst.bind(
            pipeline
          ))

          function transformFile(filename, opts, callback) {
            if (typeof opts === 'function') {
              callback = opts
              opts = {}
            }

            opts.filename = filename

            _fs2.default.readFile(filename, function(err, code) {
              var result = void 0

              if (!err) {
                try {
                  result = transform(code, opts)
                } catch (_err) {
                  err = _err
                }
              }

              if (err) {
                callback(err)
              } else {
                callback(null, result)
              }
            })
          }

          function transformFileSync(filename) {
            var opts = arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : {}

            opts.filename = filename
            return transform(_fs2.default.readFileSync(filename, 'utf8'), opts)
          }
        },
        {
          '../../package': 32,
          '../helpers/resolve-plugin': 12,
          '../helpers/resolve-preset': 13,
          '../tools/build-external-helpers': 16,
          '../transformation/file': 17,
          '../transformation/file/options/config': 21,
          '../transformation/file/options/option-manager': 23,
          '../transformation/pipeline': 28,
          '../util': 31,
          'babel-messages': 53,
          'babel-template': 73,
          'babel-traverse': 77,
          'babel-types': 110,
          fs: 118,
        },
      ],
      7: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true
          exports.default = getPossiblePluginNames
          function getPossiblePluginNames(pluginName) {
            return ['babel-plugin-' + pluginName, pluginName]
          }
          module.exports = exports['default']
        },
        {},
      ],
      8: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true
          exports.default = getPossiblePresetNames
          function getPossiblePresetNames(presetName) {
            var possibleNames = ['babel-preset-' + presetName, presetName]

            var matches = presetName.match(/^(@[^/]+)\/(.+)$/)
            if (matches) {
              var orgName = matches[1],
                presetPath = matches[2]

              possibleNames.push(orgName + '/babel-preset-' + presetPath)
            }

            return possibleNames
          }
          module.exports = exports['default']
        },
        {},
      ],
      9: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true

          var _getIterator2 = require('babel-runtime/core-js/get-iterator')

          var _getIterator3 = _interopRequireDefault(_getIterator2)

          exports.default = function(dest, src) {
            if (!dest || !src) return

            return (0, _mergeWith2.default)(dest, src, function(a, b) {
              if (b && Array.isArray(a)) {
                var newArray = b.slice(0)

                for (
                  var _iterator = a,
                    _isArray = Array.isArray(_iterator),
                    _i = 0,
                    _iterator = _isArray
                      ? _iterator
                      : (0, _getIterator3.default)(_iterator);
                  ;

                ) {
                  var _ref

                  if (_isArray) {
                    if (_i >= _iterator.length) break
                    _ref = _iterator[_i++]
                  } else {
                    _i = _iterator.next()
                    if (_i.done) break
                    _ref = _i.value
                  }

                  var item = _ref

                  if (newArray.indexOf(item) < 0) {
                    newArray.push(item)
                  }
                }

                return newArray
              }
            })
          }

          var _mergeWith = require('lodash/mergeWith')

          var _mergeWith2 = _interopRequireDefault(_mergeWith)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          module.exports = exports['default']
        },
        { 'babel-runtime/core-js/get-iterator': 54, 'lodash/mergeWith': 486 },
      ],
      10: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true

          exports.default = function(ast, comments, tokens) {
            if (ast) {
              if (ast.type === 'Program') {
                return t.file(ast, comments || [], tokens || [])
              } else if (ast.type === 'File') {
                return ast
              }
            }

            throw new Error('Not a valid ast?')
          }

          var _babelTypes = require('babel-types')

          var t = _interopRequireWildcard(_babelTypes)

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj
            } else {
              var newObj = {}
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key]
                }
              }
              newObj.default = obj
              return newObj
            }
          }

          module.exports = exports['default']
        },
        { 'babel-types': 110 },
      ],
      11: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true
          exports.default = resolveFromPossibleNames

          var _resolve = require('./resolve')

          var _resolve2 = _interopRequireDefault(_resolve)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          function resolveFromPossibleNames(possibleNames, dirname) {
            return possibleNames.reduce(function(accum, curr) {
              return accum || (0, _resolve2.default)(curr, dirname)
            }, null)
          }
          module.exports = exports['default']
        },
        { './resolve': 14 },
      ],
      12: [
        function(require, module, exports) {
          ;(function(process) {
            'use strict'
            exports.__esModule = true
            exports.default = resolvePlugin

            var _resolveFromPossibleNames = require('./resolve-from-possible-names')

            var _resolveFromPossibleNames2 = _interopRequireDefault(
              _resolveFromPossibleNames
            )

            var _getPossiblePluginNames = require('./get-possible-plugin-names')

            var _getPossiblePluginNames2 = _interopRequireDefault(
              _getPossiblePluginNames
            )

            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj }
            }

            function resolvePlugin(pluginName) {
              var dirname = arguments.length > 1 && arguments[1] !== undefined
                ? arguments[1]
                : process.cwd()

              return (0, _resolveFromPossibleNames2.default)(
                (0, _getPossiblePluginNames2.default)(pluginName),
                dirname
              )
            }
            module.exports = exports['default']
          }.call(this, require('_process')))
        },
        {
          './get-possible-plugin-names': 7,
          './resolve-from-possible-names': 11,
          _process: 507,
        },
      ],
      13: [
        function(require, module, exports) {
          ;(function(process) {
            'use strict'
            exports.__esModule = true
            exports.default = resolvePreset

            var _resolveFromPossibleNames = require('./resolve-from-possible-names')

            var _resolveFromPossibleNames2 = _interopRequireDefault(
              _resolveFromPossibleNames
            )

            var _getPossiblePresetNames = require('./get-possible-preset-names')

            var _getPossiblePresetNames2 = _interopRequireDefault(
              _getPossiblePresetNames
            )

            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj }
            }

            function resolvePreset(presetName) {
              var dirname = arguments.length > 1 && arguments[1] !== undefined
                ? arguments[1]
                : process.cwd()

              return (0, _resolveFromPossibleNames2.default)(
                (0, _getPossiblePresetNames2.default)(presetName),
                dirname
              )
            }
            module.exports = exports['default']
          }.call(this, require('_process')))
        },
        {
          './get-possible-preset-names': 8,
          './resolve-from-possible-names': 11,
          _process: 507,
        },
      ],
      14: [
        function(require, module, exports) {
          ;(function(process) {
            'use strict'
            exports.__esModule = true

            var _typeof2 = require('babel-runtime/helpers/typeof')

            var _typeof3 = _interopRequireDefault(_typeof2)

            exports.default = function(loc) {
              var relative = arguments.length > 1 && arguments[1] !== undefined
                ? arguments[1]
                : process.cwd()

              if (
                (typeof _module2.default === 'undefined'
                  ? 'undefined'
                  : (0, _typeof3.default)(_module2.default)) === 'object'
              )
                return null

              var relativeMod = relativeModules[relative]

              if (!relativeMod) {
                relativeMod = new _module2.default()

                var filename = _path2.default.join(relative, '.babelrc')
                relativeMod.id = filename
                relativeMod.filename = filename

                relativeMod.paths = _module2.default._nodeModulePaths(relative)
                relativeModules[relative] = relativeMod
              }

              try {
                return _module2.default._resolveFilename(loc, relativeMod)
              } catch (err) {
                return null
              }
            }

            var _module = require('module')

            var _module2 = _interopRequireDefault(_module)

            var _path = require('path')

            var _path2 = _interopRequireDefault(_path)

            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj }
            }

            var relativeModules = {}

            module.exports = exports['default']
          }.call(this, require('_process')))
        },
        {
          _process: 507,
          'babel-runtime/helpers/typeof': 72,
          module: 118,
          path: 505,
        },
      ],
      15: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true

          var _map = require('babel-runtime/core-js/map')

          var _map2 = _interopRequireDefault(_map)

          var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck')

          var _classCallCheck3 = _interopRequireDefault(_classCallCheck2)

          var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn')

          var _possibleConstructorReturn3 = _interopRequireDefault(
            _possibleConstructorReturn2
          )

          var _inherits2 = require('babel-runtime/helpers/inherits')

          var _inherits3 = _interopRequireDefault(_inherits2)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          var Store = (function(_Map) {
            ;(0, _inherits3.default)(Store, _Map)

            function Store() {
              ;(0, _classCallCheck3.default)(this, Store)

              var _this = (0, _possibleConstructorReturn3.default)(
                this,
                _Map.call(this)
              )

              _this.dynamicData = {}
              return _this
            }

            Store.prototype.setDynamic = function setDynamic(key, fn) {
              this.dynamicData[key] = fn
            }

            Store.prototype.get = function get(key) {
              if (this.has(key)) {
                return _Map.prototype.get.call(this, key)
              } else {
                if (
                  Object.prototype.hasOwnProperty.call(this.dynamicData, key)
                ) {
                  var val = this.dynamicData[key]()
                  this.set(key, val)
                  return val
                }
              }
            }

            return Store
          })(_map2.default)

          exports.default = Store
          module.exports = exports['default']
        },
        {
          'babel-runtime/core-js/map': 56,
          'babel-runtime/helpers/classCallCheck': 68,
          'babel-runtime/helpers/inherits': 69,
          'babel-runtime/helpers/possibleConstructorReturn': 71,
        },
      ],
      16: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true

          exports.default = function(whitelist) {
            var outputType = arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : 'global'

            var namespace = t.identifier('babelHelpers')

            var builder = function builder(body) {
              return buildHelpers(body, namespace, whitelist)
            }

            var tree = void 0

            var build = {
              global: buildGlobal,
              umd: buildUmd,
              var: buildVar,
            }[outputType]

            if (build) {
              tree = build(namespace, builder)
            } else {
              throw new Error(messages.get('unsupportedOutputType', outputType))
            }

            return (0, _babelGenerator2.default)(tree).code
          }

          var _babelHelpers = require('babel-helpers')

          var helpers = _interopRequireWildcard(_babelHelpers)

          var _babelGenerator = require('babel-generator')

          var _babelGenerator2 = _interopRequireDefault(_babelGenerator)

          var _babelMessages = require('babel-messages')

          var messages = _interopRequireWildcard(_babelMessages)

          var _babelTemplate = require('babel-template')

          var _babelTemplate2 = _interopRequireDefault(_babelTemplate)

          var _babelTypes = require('babel-types')

          var t = _interopRequireWildcard(_babelTypes)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj
            } else {
              var newObj = {}
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key]
                }
              }
              newObj.default = obj
              return newObj
            }
          }

          var buildUmdWrapper = (0, _babelTemplate2.default)(
            '\n  (function (root, factory) {\n    if (typeof define === "function" && define.amd) {\n      define(AMD_ARGUMENTS, factory);\n    } else if (typeof exports === "object") {\n      factory(COMMON_ARGUMENTS);\n    } else {\n      factory(BROWSER_ARGUMENTS);\n    }\n  })(UMD_ROOT, function (FACTORY_PARAMETERS) {\n    FACTORY_BODY\n  });\n'
          )

          function buildGlobal(namespace, builder) {
            var body = []
            var container = t.functionExpression(
              null,
              [t.identifier('global')],
              t.blockStatement(body)
            )
            var tree = t.program([
              t.expressionStatement(
                t.callExpression(container, [helpers.get('selfGlobal')])
              ),
            ])

            body.push(
              t.variableDeclaration('var', [
                t.variableDeclarator(
                  namespace,
                  t.assignmentExpression(
                    '=',
                    t.memberExpression(t.identifier('global'), namespace),
                    t.objectExpression([])
                  )
                ),
              ])
            )

            builder(body)

            return tree
          }

          function buildUmd(namespace, builder) {
            var body = []
            body.push(
              t.variableDeclaration('var', [
                t.variableDeclarator(namespace, t.identifier('global')),
              ])
            )

            builder(body)

            return t.program([
              buildUmdWrapper({
                FACTORY_PARAMETERS: t.identifier('global'),
                BROWSER_ARGUMENTS: t.assignmentExpression(
                  '=',
                  t.memberExpression(t.identifier('root'), namespace),
                  t.objectExpression([])
                ),
                COMMON_ARGUMENTS: t.identifier('exports'),
                AMD_ARGUMENTS: t.arrayExpression([t.stringLiteral('exports')]),
                FACTORY_BODY: body,
                UMD_ROOT: t.identifier('this'),
              }),
            ])
          }

          function buildVar(namespace, builder) {
            var body = []
            body.push(
              t.variableDeclaration('var', [
                t.variableDeclarator(namespace, t.objectExpression([])),
              ])
            )
            builder(body)
            body.push(t.expressionStatement(namespace))
            return t.program(body)
          }

          function buildHelpers(body, namespace, whitelist) {
            helpers.list.forEach(function(name) {
              if (whitelist && whitelist.indexOf(name) < 0) return

              var key = t.identifier(name)
              body.push(
                t.expressionStatement(
                  t.assignmentExpression(
                    '=',
                    t.memberExpression(namespace, key),
                    helpers.get(name)
                  )
                )
              )
            })
          }
          module.exports = exports['default']
        },
        {
          'babel-generator': 44,
          'babel-helpers': 52,
          'babel-messages': 53,
          'babel-template': 73,
          'babel-types': 110,
        },
      ],
      17: [
        function(require, module, exports) {
          ;(function(process) {
            'use strict'
            exports.__esModule = true
            exports.File = undefined

            var _getIterator2 = require('babel-runtime/core-js/get-iterator')

            var _getIterator3 = _interopRequireDefault(_getIterator2)

            var _create = require('babel-runtime/core-js/object/create')

            var _create2 = _interopRequireDefault(_create)

            var _assign = require('babel-runtime/core-js/object/assign')

            var _assign2 = _interopRequireDefault(_assign)

            var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck')

            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2)

            var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn')

            var _possibleConstructorReturn3 = _interopRequireDefault(
              _possibleConstructorReturn2
            )

            var _inherits2 = require('babel-runtime/helpers/inherits')

            var _inherits3 = _interopRequireDefault(_inherits2)

            var _babelHelpers = require('babel-helpers')

            var _babelHelpers2 = _interopRequireDefault(_babelHelpers)

            var _metadata = require('./metadata')

            var metadataVisitor = _interopRequireWildcard(_metadata)

            var _convertSourceMap = require('convert-source-map')

            var _convertSourceMap2 = _interopRequireDefault(_convertSourceMap)

            var _optionManager = require('./options/option-manager')

            var _optionManager2 = _interopRequireDefault(_optionManager)

            var _pluginPass = require('../plugin-pass')

            var _pluginPass2 = _interopRequireDefault(_pluginPass)

            var _babelTraverse = require('babel-traverse')

            var _babelTraverse2 = _interopRequireDefault(_babelTraverse)

            var _sourceMap = require('source-map')

            var _sourceMap2 = _interopRequireDefault(_sourceMap)

            var _babelGenerator = require('babel-generator')

            var _babelGenerator2 = _interopRequireDefault(_babelGenerator)

            var _babelCodeFrame = require('babel-code-frame')

            var _babelCodeFrame2 = _interopRequireDefault(_babelCodeFrame)

            var _defaults = require('lodash/defaults')

            var _defaults2 = _interopRequireDefault(_defaults)

            var _logger = require('./logger')

            var _logger2 = _interopRequireDefault(_logger)

            var _store = require('../../store')

            var _store2 = _interopRequireDefault(_store)

            var _babylon = require('babylon')

            var _util = require('../../util')

            var util = _interopRequireWildcard(_util)

            var _path = require('path')

            var _path2 = _interopRequireDefault(_path)

            var _babelTypes = require('babel-types')

            var t = _interopRequireWildcard(_babelTypes)

            var _resolve = require('../../helpers/resolve')

            var _resolve2 = _interopRequireDefault(_resolve)

            var _blockHoist = require('../internal-plugins/block-hoist')

            var _blockHoist2 = _interopRequireDefault(_blockHoist)

            var _shadowFunctions = require('../internal-plugins/shadow-functions')

            var _shadowFunctions2 = _interopRequireDefault(_shadowFunctions)

            function _interopRequireWildcard(obj) {
              if (obj && obj.__esModule) {
                return obj
              } else {
                var newObj = {}
                if (obj != null) {
                  for (var key in obj) {
                    if (Object.prototype.hasOwnProperty.call(obj, key))
                      newObj[key] = obj[key]
                  }
                }
                newObj.default = obj
                return newObj
              }
            }

            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj }
            }

            var shebangRegex = /^#!.*/

            var INTERNAL_PLUGINS = [
              [_blockHoist2.default],
              [_shadowFunctions2.default],
            ]

            var errorVisitor = {
              enter: function enter(path, state) {
                var loc = path.node.loc
                if (loc) {
                  state.loc = loc
                  path.stop()
                }
              },
            }

            var File = (function(_Store) {
              ;(0, _inherits3.default)(File, _Store)

              function File() {
                var opts = arguments.length > 0 && arguments[0] !== undefined
                  ? arguments[0]
                  : {}
                var pipeline = arguments[1]
                ;(0, _classCallCheck3.default)(this, File)

                var _this = (0, _possibleConstructorReturn3.default)(
                  this,
                  _Store.call(this)
                )

                _this.pipeline = pipeline

                _this.log = new _logger2.default(
                  _this,
                  opts.filename || 'unknown'
                )
                _this.opts = _this.initOptions(opts)

                _this.parserOpts = {
                  sourceType: _this.opts.sourceType,
                  sourceFileName: _this.opts.filename,
                  plugins: [],
                }

                _this.pluginVisitors = []
                _this.pluginPasses = []

                _this.buildPluginsForOptions(_this.opts)

                if (_this.opts.passPerPreset) {
                  _this.perPresetOpts = []
                  _this.opts.presets.forEach(function(presetOpts) {
                    var perPresetOpts = (0, _assign2.default)(
                      (0, _create2.default)(_this.opts),
                      presetOpts
                    )
                    _this.perPresetOpts.push(perPresetOpts)
                    _this.buildPluginsForOptions(perPresetOpts)
                  })
                }

                _this.metadata = {
                  usedHelpers: [],
                  marked: [],
                  modules: {
                    imports: [],
                    exports: {
                      exported: [],
                      specifiers: [],
                    },
                  },
                }

                _this.dynamicImportTypes = {}
                _this.dynamicImportIds = {}
                _this.dynamicImports = []
                _this.declarations = {}
                _this.usedHelpers = {}

                _this.path = null
                _this.ast = {}

                _this.code = ''
                _this.shebang = ''

                _this.hub = new _babelTraverse.Hub(_this)
                return _this
              }

              File.prototype.getMetadata = function getMetadata() {
                var has = false
                for (
                  var _iterator = this.ast.program.body,
                    _isArray = Array.isArray(_iterator),
                    _i = 0,
                    _iterator = _isArray
                      ? _iterator
                      : (0, _getIterator3.default)(_iterator);
                  ;

                ) {
                  var _ref

                  if (_isArray) {
                    if (_i >= _iterator.length) break
                    _ref = _iterator[_i++]
                  } else {
                    _i = _iterator.next()
                    if (_i.done) break
                    _ref = _i.value
                  }

                  var node = _ref

                  if (t.isModuleDeclaration(node)) {
                    has = true
                    break
                  }
                }
                if (has) {
                  this.path.traverse(metadataVisitor, this)
                }
              }

              File.prototype.initOptions = function initOptions(opts) {
                opts = new _optionManager2.default(
                  this.log,
                  this.pipeline
                ).init(opts)

                if (opts.inputSourceMap) {
                  opts.sourceMaps = true
                }

                if (opts.moduleId) {
                  opts.moduleIds = true
                }

                opts.basename = _path2.default.basename(
                  opts.filename,
                  _path2.default.extname(opts.filename)
                )

                opts.ignore = util.arrayify(opts.ignore, util.regexify)

                if (opts.only)
                  opts.only = util.arrayify(opts.only, util.regexify)
                ;(0, _defaults2.default)(opts, {
                  moduleRoot: opts.sourceRoot,
                })
                ;(0, _defaults2.default)(opts, {
                  sourceRoot: opts.moduleRoot,
                })
                ;(0, _defaults2.default)(opts, {
                  filenameRelative: opts.filename,
                })

                var basenameRelative = _path2.default.basename(
                  opts.filenameRelative
                )
                ;(0, _defaults2.default)(opts, {
                  sourceFileName: basenameRelative,
                  sourceMapTarget: basenameRelative,
                })

                return opts
              }

              File.prototype.buildPluginsForOptions = function buildPluginsForOptions(
                opts
              ) {
                if (!Array.isArray(opts.plugins)) {
                  return
                }

                var plugins = opts.plugins.concat(INTERNAL_PLUGINS)
                var currentPluginVisitors = []
                var currentPluginPasses = []

                for (
                  var _iterator2 = plugins,
                    _isArray2 = Array.isArray(_iterator2),
                    _i2 = 0,
                    _iterator2 = _isArray2
                      ? _iterator2
                      : (0, _getIterator3.default)(_iterator2);
                  ;

                ) {
                  var _ref2

                  if (_isArray2) {
                    if (_i2 >= _iterator2.length) break
                    _ref2 = _iterator2[_i2++]
                  } else {
                    _i2 = _iterator2.next()
                    if (_i2.done) break
                    _ref2 = _i2.value
                  }

                  var ref = _ref2
                  var plugin = ref[0],
                    pluginOpts = ref[1]

                  currentPluginVisitors.push(plugin.visitor)
                  currentPluginPasses.push(
                    new _pluginPass2.default(this, plugin, pluginOpts)
                  )

                  if (plugin.manipulateOptions) {
                    plugin.manipulateOptions(opts, this.parserOpts, this)
                  }
                }

                this.pluginVisitors.push(currentPluginVisitors)
                this.pluginPasses.push(currentPluginPasses)
              }

              File.prototype.getModuleName = function getModuleName() {
                var opts = this.opts
                if (!opts.moduleIds) {
                  return null
                }

                if (opts.moduleId != null && !opts.getModuleId) {
                  return opts.moduleId
                }

                var filenameRelative = opts.filenameRelative
                var moduleName = ''

                if (opts.moduleRoot != null) {
                  moduleName = opts.moduleRoot + '/'
                }

                if (!opts.filenameRelative) {
                  return moduleName + opts.filename.replace(/^\//, '')
                }

                if (opts.sourceRoot != null) {
                  var sourceRootRegEx = new RegExp('^' + opts.sourceRoot + '/?')
                  filenameRelative = filenameRelative.replace(
                    sourceRootRegEx,
                    ''
                  )
                }

                filenameRelative = filenameRelative.replace(/\.(\w*?)$/, '')

                moduleName += filenameRelative

                moduleName = moduleName.replace(/\\/g, '/')

                if (opts.getModuleId) {
                  return opts.getModuleId(moduleName) || moduleName
                } else {
                  return moduleName
                }
              }

              File.prototype.resolveModuleSource = function resolveModuleSource(
                source
              ) {
                var resolveModuleSource = this.opts.resolveModuleSource
                if (resolveModuleSource)
                  source = resolveModuleSource(source, this.opts.filename)
                return source
              }

              File.prototype.addImport = function addImport(source, imported) {
                var name = arguments.length > 2 && arguments[2] !== undefined
                  ? arguments[2]
                  : imported

                var alias = source + ':' + imported
                var id = this.dynamicImportIds[alias]

                if (!id) {
                  source = this.resolveModuleSource(source)
                  id = this.dynamicImportIds[
                    alias
                  ] = this.scope.generateUidIdentifier(name)

                  var specifiers = []

                  if (imported === '*') {
                    specifiers.push(t.importNamespaceSpecifier(id))
                  } else if (imported === 'default') {
                    specifiers.push(t.importDefaultSpecifier(id))
                  } else {
                    specifiers.push(
                      t.importSpecifier(id, t.identifier(imported))
                    )
                  }

                  var declar = t.importDeclaration(
                    specifiers,
                    t.stringLiteral(source)
                  )
                  declar._blockHoist = 3

                  this.path.unshiftContainer('body', declar)
                }

                return id
              }

              File.prototype.addHelper = function addHelper(name) {
                var declar = this.declarations[name]
                if (declar) return declar

                if (!this.usedHelpers[name]) {
                  this.metadata.usedHelpers.push(name)
                  this.usedHelpers[name] = true
                }

                var generator = this.get('helperGenerator')
                var runtime = this.get('helpersNamespace')
                if (generator) {
                  var res = generator(name)
                  if (res) return res
                } else if (runtime) {
                  return t.memberExpression(runtime, t.identifier(name))
                }

                var ref = (0, _babelHelpers2.default)(name)
                var uid = (this.declarations[
                  name
                ] = this.scope.generateUidIdentifier(name))

                if (t.isFunctionExpression(ref) && !ref.id) {
                  ref.body._compact = true
                  ref._generated = true
                  ref.id = uid
                  ref.type = 'FunctionDeclaration'
                  this.path.unshiftContainer('body', ref)
                } else {
                  ref._compact = true
                  this.scope.push({
                    id: uid,
                    init: ref,
                    unique: true,
                  })
                }

                return uid
              }

              File.prototype.addTemplateObject = function addTemplateObject(
                helperName,
                strings,
                raw
              ) {
                var stringIds = raw.elements.map(function(string) {
                  return string.value
                })
                var name =
                  helperName +
                  '_' +
                  raw.elements.length +
                  '_' +
                  stringIds.join(',')

                var declar = this.declarations[name]
                if (declar) return declar

                var uid = (this.declarations[
                  name
                ] = this.scope.generateUidIdentifier('templateObject'))

                var helperId = this.addHelper(helperName)
                var init = t.callExpression(helperId, [strings, raw])
                init._compact = true
                this.scope.push({
                  id: uid,
                  init: init,
                  _blockHoist: 1.9,
                })
                return uid
              }

              File.prototype.buildCodeFrameError = function buildCodeFrameError(
                node,
                msg
              ) {
                var Error = arguments.length > 2 && arguments[2] !== undefined
                  ? arguments[2]
                  : SyntaxError

                var loc = node && (node.loc || node._loc)

                var err = new Error(msg)

                if (loc) {
                  err.loc = loc.start
                } else {
                  ;(0, _babelTraverse2.default)(
                    node,
                    errorVisitor,
                    this.scope,
                    err
                  )

                  err.message +=
                    ' (This is an error on an internal node. Probably an internal error'

                  if (err.loc) {
                    err.message += '. Location has been estimated.'
                  }

                  err.message += ')'
                }

                return err
              }

              File.prototype.mergeSourceMap = function mergeSourceMap(map) {
                var inputMap = this.opts.inputSourceMap

                if (inputMap) {
                  var inputMapConsumer = new _sourceMap2.default
                    .SourceMapConsumer(inputMap)
                  var outputMapConsumer = new _sourceMap2.default
                    .SourceMapConsumer(map)

                  var mergedGenerator = new _sourceMap2.default
                    .SourceMapGenerator({
                    file: inputMapConsumer.file,
                    sourceRoot: inputMapConsumer.sourceRoot,
                  })

                  var source = outputMapConsumer.sources[0]

                  inputMapConsumer.eachMapping(function(mapping) {
                    var generatedPosition = outputMapConsumer.generatedPositionFor(
                      {
                        line: mapping.generatedLine,
                        column: mapping.generatedColumn,
                        source: source,
                      }
                    )
                    if (generatedPosition.column != null) {
                      mergedGenerator.addMapping({
                        source: mapping.source,

                        original: mapping.source == null
                          ? null
                          : {
                              line: mapping.originalLine,
                              column: mapping.originalColumn,
                            },

                        generated: generatedPosition,
                      })
                    }
                  })

                  var mergedMap = mergedGenerator.toJSON()
                  inputMap.mappings = mergedMap.mappings
                  return inputMap
                } else {
                  return map
                }
              }

              File.prototype.parse = function parse(code) {
                var parseCode = _babylon.parse
                var parserOpts = this.opts.parserOpts

                if (parserOpts) {
                  parserOpts = (0, _assign2.default)(
                    {},
                    this.parserOpts,
                    parserOpts
                  )

                  if (parserOpts.parser) {
                    if (typeof parserOpts.parser === 'string') {
                      var dirname =
                        _path2.default.dirname(this.opts.filename) ||
                        process.cwd()
                      var parser = (0, _resolve2.default)(
                        parserOpts.parser,
                        dirname
                      )
                      if (parser) {
                        parseCode = require(parser).parse
                      } else {
                        throw new Error(
                          "Couldn't find parser " +
                            parserOpts.parser +
                            ' with "parse" method ' +
                            ('relative to directory ' + dirname)
                        )
                      }
                    } else {
                      parseCode = parserOpts.parser
                    }

                    parserOpts.parser = {
                      parse: function parse(source) {
                        return (0, _babylon.parse)(source, parserOpts)
                      },
                    }
                  }
                }

                this.log.debug('Parse start')
                var ast = parseCode(code, parserOpts || this.parserOpts)
                this.log.debug('Parse stop')
                return ast
              }

              File.prototype._addAst = function _addAst(ast) {
                this.path = _babelTraverse.NodePath
                  .get({
                    hub: this.hub,
                    parentPath: null,
                    parent: ast,
                    container: ast,
                    key: 'program',
                  })
                  .setContext()
                this.scope = this.path.scope
                this.ast = ast
                this.getMetadata()
              }

              File.prototype.addAst = function addAst(ast) {
                this.log.debug('Start set AST')
                this._addAst(ast)
                this.log.debug('End set AST')
              }

              File.prototype.transform = function transform() {
                for (var i = 0; i < this.pluginPasses.length; i++) {
                  var pluginPasses = this.pluginPasses[i]
                  this.call('pre', pluginPasses)
                  this.log.debug('Start transform traverse')

                  var visitor = _babelTraverse2.default.visitors.merge(
                    this.pluginVisitors[i],
                    pluginPasses,
                    this.opts.wrapPluginVisitorMethod
                  )
                  ;(0, _babelTraverse2.default)(this.ast, visitor, this.scope)

                  this.log.debug('End transform traverse')
                  this.call('post', pluginPasses)
                }

                return this.generate()
              }

              File.prototype.wrap = function wrap(code, callback) {
                code = code + ''

                try {
                  if (this.shouldIgnore()) {
                    return this.makeResult({ code: code, ignored: true })
                  } else {
                    return callback()
                  }
                } catch (err) {
                  if (err._babel) {
                    throw err
                  } else {
                    err._babel = true
                  }

                  var message = (err.message =
                    this.opts.filename + ': ' + err.message)

                  var loc = err.loc
                  if (loc) {
                    err.codeFrame = (0, _babelCodeFrame2.default)(
                      code,
                      loc.line,
                      loc.column + 1,
                      this.opts
                    )
                    message += '\n' + err.codeFrame
                  }

                  if (process.browser) {
                    err.message = message
                  }

                  if (err.stack) {
                    var newStack = err.stack.replace(err.message, message)
                    err.stack = newStack
                  }

                  throw err
                }
              }

              File.prototype.addCode = function addCode(code) {
                code = (code || '') + ''
                code = this.parseInputSourceMap(code)
                this.code = code
              }

              File.prototype.parseCode = function parseCode() {
                this.parseShebang()
                var ast = this.parse(this.code)
                this.addAst(ast)
              }

              File.prototype.shouldIgnore = function shouldIgnore() {
                var opts = this.opts
                return util.shouldIgnore(opts.filename, opts.ignore, opts.only)
              }

              File.prototype.call = function call(key, pluginPasses) {
                for (
                  var _iterator3 = pluginPasses,
                    _isArray3 = Array.isArray(_iterator3),
                    _i3 = 0,
                    _iterator3 = _isArray3
                      ? _iterator3
                      : (0, _getIterator3.default)(_iterator3);
                  ;

                ) {
                  var _ref3

                  if (_isArray3) {
                    if (_i3 >= _iterator3.length) break
                    _ref3 = _iterator3[_i3++]
                  } else {
                    _i3 = _iterator3.next()
                    if (_i3.done) break
                    _ref3 = _i3.value
                  }

                  var pass = _ref3

                  var plugin = pass.plugin
                  var fn = plugin[key]
                  if (fn) fn.call(pass, this)
                }
              }

              File.prototype.parseInputSourceMap = function parseInputSourceMap(
                code
              ) {
                var opts = this.opts

                if (opts.inputSourceMap !== false) {
                  var inputMap = _convertSourceMap2.default.fromSource(code)
                  if (inputMap) {
                    opts.inputSourceMap = inputMap.toObject()
                    code = _convertSourceMap2.default.removeComments(code)
                  }
                }

                return code
              }

              File.prototype.parseShebang = function parseShebang() {
                var shebangMatch = shebangRegex.exec(this.code)
                if (shebangMatch) {
                  this.shebang = shebangMatch[0]
                  this.code = this.code.replace(shebangRegex, '')
                }
              }

              File.prototype.makeResult = function makeResult(_ref4) {
                var code = _ref4.code,
                  map = _ref4.map,
                  ast = _ref4.ast,
                  ignored = _ref4.ignored

                var result = {
                  metadata: null,
                  options: this.opts,
                  ignored: !!ignored,
                  code: null,
                  ast: null,
                  map: map || null,
                }

                if (this.opts.code) {
                  result.code = code
                }

                if (this.opts.ast) {
                  result.ast = ast
                }

                if (this.opts.metadata) {
                  result.metadata = this.metadata
                }

                return result
              }

              File.prototype.generate = function generate() {
                var opts = this.opts
                var ast = this.ast

                var result = { ast: ast }
                if (!opts.code) return this.makeResult(result)

                var gen = _babelGenerator2.default
                if (opts.generatorOpts.generator) {
                  gen = opts.generatorOpts.generator

                  if (typeof gen === 'string') {
                    var dirname =
                      _path2.default.dirname(this.opts.filename) ||
                      process.cwd()
                    var generator = (0, _resolve2.default)(gen, dirname)
                    if (generator) {
                      gen = require(generator).print
                    } else {
                      throw new Error(
                        "Couldn't find generator " +
                          gen +
                          ' with "print" method relative ' +
                          ('to directory ' + dirname)
                      )
                    }
                  }
                }

                this.log.debug('Generation start')

                var _result = gen(
                  ast,
                  opts.generatorOpts
                    ? (0, _assign2.default)(opts, opts.generatorOpts)
                    : opts,
                  this.code
                )
                result.code = _result.code
                result.map = _result.map

                this.log.debug('Generation end')

                if (this.shebang) {
                  result.code = this.shebang + '\n' + result.code
                }

                if (result.map) {
                  result.map = this.mergeSourceMap(result.map)
                }

                if (
                  opts.sourceMaps === 'inline' ||
                  opts.sourceMaps === 'both'
                ) {
                  result.code +=
                    '\n' +
                    _convertSourceMap2.default
                      .fromObject(result.map)
                      .toComment()
                }

                if (opts.sourceMaps === 'inline') {
                  result.map = null
                }

                return this.makeResult(result)
              }

              return File
            })(_store2.default)

            exports.default = File
            exports.File = File
          }.call(this, require('_process')))
        },
        {
          '../../helpers/resolve': 14,
          '../../store': 15,
          '../../util': 31,
          '../internal-plugins/block-hoist': 26,
          '../internal-plugins/shadow-functions': 27,
          '../plugin-pass': 29,
          './logger': 18,
          './metadata': 19,
          './options/option-manager': 23,
          _process: 507,
          'babel-code-frame': 4,
          'babel-generator': 44,
          'babel-helpers': 52,
          'babel-runtime/core-js/get-iterator': 54,
          'babel-runtime/core-js/object/assign': 58,
          'babel-runtime/core-js/object/create': 59,
          'babel-runtime/helpers/classCallCheck': 68,
          'babel-runtime/helpers/inherits': 69,
          'babel-runtime/helpers/possibleConstructorReturn': 71,
          'babel-traverse': 77,
          'babel-types': 110,
          babylon: 114,
          'convert-source-map': 132,
          'lodash/defaults': 455,
          path: 505,
          'source-map': 526,
        },
      ],
      18: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true

          var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck')

          var _classCallCheck3 = _interopRequireDefault(_classCallCheck2)

          var _node = require('debug/node')

          var _node2 = _interopRequireDefault(_node)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          var verboseDebug = (0, _node2.default)('babel:verbose')
          var generalDebug = (0, _node2.default)('babel')

          var seenDeprecatedMessages = []

          var Logger = (function() {
            function Logger(file, filename) {
              ;(0, _classCallCheck3.default)(this, Logger)

              this.filename = filename
              this.file = file
            }

            Logger.prototype._buildMessage = function _buildMessage(msg) {
              var parts = '[BABEL] ' + this.filename
              if (msg) parts += ': ' + msg
              return parts
            }

            Logger.prototype.warn = function warn(msg) {
              console.warn(this._buildMessage(msg))
            }

            Logger.prototype.error = function error(msg) {
              var Constructor = arguments.length > 1 &&
                arguments[1] !== undefined
                ? arguments[1]
                : Error

              throw new Constructor(this._buildMessage(msg))
            }

            Logger.prototype.deprecate = function deprecate(msg) {
              if (this.file.opts && this.file.opts.suppressDeprecationMessages)
                return

              msg = this._buildMessage(msg)

              if (seenDeprecatedMessages.indexOf(msg) >= 0) return

              seenDeprecatedMessages.push(msg)

              console.error(msg)
            }

            Logger.prototype.verbose = function verbose(msg) {
              if (verboseDebug.enabled) verboseDebug(this._buildMessage(msg))
            }

            Logger.prototype.debug = function debug(msg) {
              if (generalDebug.enabled) generalDebug(this._buildMessage(msg))
            }

            Logger.prototype.deopt = function deopt(node, msg) {
              this.debug(msg)
            }

            return Logger
          })()

          exports.default = Logger
          module.exports = exports['default']
        },
        { 'babel-runtime/helpers/classCallCheck': 68, 'debug/node': 242 },
      ],
      19: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true
          exports.ImportDeclaration = exports.ModuleDeclaration = undefined

          var _getIterator2 = require('babel-runtime/core-js/get-iterator')

          var _getIterator3 = _interopRequireDefault(_getIterator2)

          exports.ExportDeclaration = ExportDeclaration
          exports.Scope = Scope

          var _babelTypes = require('babel-types')

          var t = _interopRequireWildcard(_babelTypes)

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj
            } else {
              var newObj = {}
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key]
                }
              }
              newObj.default = obj
              return newObj
            }
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          var ModuleDeclaration = (exports.ModuleDeclaration = {
            enter: function enter(path, file) {
              var node = path.node

              if (node.source) {
                node.source.value = file.resolveModuleSource(node.source.value)
              }
            },
          })

          var ImportDeclaration = (exports.ImportDeclaration = {
            exit: function exit(path, file) {
              var node = path.node

              var specifiers = []
              var imported = []
              file.metadata.modules.imports.push({
                source: node.source.value,
                imported: imported,
                specifiers: specifiers,
              })

              for (
                var _iterator = path.get('specifiers'),
                  _isArray = Array.isArray(_iterator),
                  _i = 0,
                  _iterator = _isArray
                    ? _iterator
                    : (0, _getIterator3.default)(_iterator);
                ;

              ) {
                var _ref

                if (_isArray) {
                  if (_i >= _iterator.length) break
                  _ref = _iterator[_i++]
                } else {
                  _i = _iterator.next()
                  if (_i.done) break
                  _ref = _i.value
                }

                var specifier = _ref

                var local = specifier.node.local.name

                if (specifier.isImportDefaultSpecifier()) {
                  imported.push('default')
                  specifiers.push({
                    kind: 'named',
                    imported: 'default',
                    local: local,
                  })
                }

                if (specifier.isImportSpecifier()) {
                  var importedName = specifier.node.imported.name
                  imported.push(importedName)
                  specifiers.push({
                    kind: 'named',
                    imported: importedName,
                    local: local,
                  })
                }

                if (specifier.isImportNamespaceSpecifier()) {
                  imported.push('*')
                  specifiers.push({
                    kind: 'namespace',
                    local: local,
                  })
                }
              }
            },
          })

          function ExportDeclaration(path, file) {
            var node = path.node

            var source = node.source ? node.source.value : null
            var exports = file.metadata.modules.exports

            var declar = path.get('declaration')
            if (declar.isStatement()) {
              var bindings = declar.getBindingIdentifiers()

              for (var name in bindings) {
                exports.exported.push(name)
                exports.specifiers.push({
                  kind: 'local',
                  local: name,
                  exported: path.isExportDefaultDeclaration()
                    ? 'default'
                    : name,
                })
              }
            }

            if (path.isExportNamedDeclaration() && node.specifiers) {
              for (
                var _iterator2 = node.specifiers,
                  _isArray2 = Array.isArray(_iterator2),
                  _i2 = 0,
                  _iterator2 = _isArray2
                    ? _iterator2
                    : (0, _getIterator3.default)(_iterator2);
                ;

              ) {
                var _ref2

                if (_isArray2) {
                  if (_i2 >= _iterator2.length) break
                  _ref2 = _iterator2[_i2++]
                } else {
                  _i2 = _iterator2.next()
                  if (_i2.done) break
                  _ref2 = _i2.value
                }

                var specifier = _ref2

                var exported = specifier.exported.name
                exports.exported.push(exported)

                if (t.isExportDefaultSpecifier(specifier)) {
                  exports.specifiers.push({
                    kind: 'external',
                    local: exported,
                    exported: exported,
                    source: source,
                  })
                }

                if (t.isExportNamespaceSpecifier(specifier)) {
                  exports.specifiers.push({
                    kind: 'external-namespace',
                    exported: exported,
                    source: source,
                  })
                }

                var local = specifier.local
                if (!local) continue

                if (source) {
                  exports.specifiers.push({
                    kind: 'external',
                    local: local.name,
                    exported: exported,
                    source: source,
                  })
                }

                if (!source) {
                  exports.specifiers.push({
                    kind: 'local',
                    local: local.name,
                    exported: exported,
                  })
                }
              }
            }

            if (path.isExportAllDeclaration()) {
              exports.specifiers.push({
                kind: 'external-all',
                source: source,
              })
            }
          }

          function Scope(path) {
            path.skip()
          }
        },
        { 'babel-runtime/core-js/get-iterator': 54, 'babel-types': 110 },
      ],
      20: [
        function(require, module, exports) {
          ;(function(process) {
            'use strict'
            exports.__esModule = true

            var _assign = require('babel-runtime/core-js/object/assign')

            var _assign2 = _interopRequireDefault(_assign)

            var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck')

            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2)

            exports.default = buildConfigChain

            var _resolve = require('../../../helpers/resolve')

            var _resolve2 = _interopRequireDefault(_resolve)

            var _json = require('json5')

            var _json2 = _interopRequireDefault(_json)

            var _pathIsAbsolute = require('path-is-absolute')

            var _pathIsAbsolute2 = _interopRequireDefault(_pathIsAbsolute)

            var _path = require('path')

            var _path2 = _interopRequireDefault(_path)

            var _fs = require('fs')

            var _fs2 = _interopRequireDefault(_fs)

            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj }
            }

            var existsCache = {}
            var jsonCache = {}

            var BABELIGNORE_FILENAME = '.babelignore'
            var BABELRC_FILENAME = '.babelrc'
            var PACKAGE_FILENAME = 'package.json'

            function exists(filename) {
              var cached = existsCache[filename]
              if (cached == null) {
                return (existsCache[filename] = _fs2.default.existsSync(
                  filename
                ))
              } else {
                return cached
              }
            }

            function buildConfigChain() {
              var opts = arguments.length > 0 && arguments[0] !== undefined
                ? arguments[0]
                : {}
              var log = arguments[1]

              var filename = opts.filename
              var builder = new ConfigChainBuilder(log)

              if (opts.babelrc !== false) {
                builder.findConfigs(filename)
              }

              builder.mergeConfig({
                options: opts,
                alias: 'base',
                dirname: filename && _path2.default.dirname(filename),
              })

              return builder.configs
            }

            var ConfigChainBuilder = (function() {
              function ConfigChainBuilder(log) {
                ;(0, _classCallCheck3.default)(this, ConfigChainBuilder)

                this.resolvedConfigs = []
                this.configs = []
                this.log = log
              }

              ConfigChainBuilder.prototype.findConfigs = function findConfigs(
                loc
              ) {
                if (!loc) return

                if (!(0, _pathIsAbsolute2.default)(loc)) {
                  loc = _path2.default.join(process.cwd(), loc)
                }

                var foundConfig = false
                var foundIgnore = false

                while (loc !== (loc = _path2.default.dirname(loc))) {
                  if (!foundConfig) {
                    var configLoc = _path2.default.join(loc, BABELRC_FILENAME)
                    if (exists(configLoc)) {
                      this.addConfig(configLoc)
                      foundConfig = true
                    }

                    var pkgLoc = _path2.default.join(loc, PACKAGE_FILENAME)
                    if (!foundConfig && exists(pkgLoc)) {
                      foundConfig = this.addConfig(pkgLoc, 'babel', JSON)
                    }
                  }

                  if (!foundIgnore) {
                    var ignoreLoc = _path2.default.join(
                      loc,
                      BABELIGNORE_FILENAME
                    )
                    if (exists(ignoreLoc)) {
                      this.addIgnoreConfig(ignoreLoc)
                      foundIgnore = true
                    }
                  }

                  if (foundIgnore && foundConfig) return
                }
              }

              ConfigChainBuilder.prototype.addIgnoreConfig = function addIgnoreConfig(
                loc
              ) {
                var file = _fs2.default.readFileSync(loc, 'utf8')
                var lines = file.split('\n')

                lines = lines
                  .map(function(line) {
                    return line.replace(/#(.*?)$/, '').trim()
                  })
                  .filter(function(line) {
                    return !!line
                  })

                if (lines.length) {
                  this.mergeConfig({
                    options: { ignore: lines },
                    alias: loc,
                    dirname: _path2.default.dirname(loc),
                  })
                }
              }

              ConfigChainBuilder.prototype.addConfig = function addConfig(
                loc,
                key
              ) {
                var json = arguments.length > 2 && arguments[2] !== undefined
                  ? arguments[2]
                  : _json2.default

                if (this.resolvedConfigs.indexOf(loc) >= 0) {
                  return false
                }

                this.resolvedConfigs.push(loc)

                var content = _fs2.default.readFileSync(loc, 'utf8')
                var options = void 0

                try {
                  options = jsonCache[content] =
                    jsonCache[content] || json.parse(content)
                  if (key) options = options[key]
                } catch (err) {
                  err.message =
                    loc + ': Error while parsing JSON - ' + err.message
                  throw err
                }

                this.mergeConfig({
                  options: options,
                  alias: loc,
                  dirname: _path2.default.dirname(loc),
                })

                return !!options
              }

              ConfigChainBuilder.prototype.mergeConfig = function mergeConfig(
                _ref
              ) {
                var options = _ref.options,
                  alias = _ref.alias,
                  loc = _ref.loc,
                  dirname = _ref.dirname

                if (!options) {
                  return false
                }

                options = (0, _assign2.default)({}, options)

                dirname = dirname || process.cwd()
                loc = loc || alias

                if (options.extends) {
                  var extendsLoc = (0, _resolve2.default)(
                    options.extends,
                    dirname
                  )
                  if (extendsLoc) {
                    this.addConfig(extendsLoc)
                  } else {
                    if (this.log)
                      this.log.error(
                        "Couldn't resolve extends clause of " +
                          options.extends +
                          ' in ' +
                          alias
                      )
                  }
                  delete options.extends
                }

                this.configs.push({
                  options: options,
                  alias: alias,
                  loc: loc,
                  dirname: dirname,
                })

                var envOpts = void 0
                var envKey =
                  process.env.BABEL_ENV || process.env.NODE_ENV || 'development'
                if (options.env) {
                  envOpts = options.env[envKey]
                  delete options.env
                }

                this.mergeConfig({
                  options: envOpts,
                  alias: alias + '.env.' + envKey,
                  dirname: dirname,
                })
              }

              return ConfigChainBuilder
            })()

            module.exports = exports['default']
          }.call(this, require('_process')))
        },
        {
          '../../../helpers/resolve': 14,
          _process: 507,
          'babel-runtime/core-js/object/assign': 58,
          'babel-runtime/helpers/classCallCheck': 68,
          fs: 118,
          json5: 290,
          path: 505,
          'path-is-absolute': 506,
        },
      ],
      21: [
        function(require, module, exports) {
          'use strict'
          module.exports = {
            filename: {
              type: 'filename',
              description:
                'filename to use when reading from stdin - this will be used in source-maps, errors etc',
              default: 'unknown',
              shorthand: 'f',
            },

            filenameRelative: {
              hidden: true,
              type: 'string',
            },

            inputSourceMap: {
              hidden: true,
            },

            env: {
              hidden: true,
              default: {},
            },

            mode: {
              description: '',
              hidden: true,
            },

            retainLines: {
              type: 'boolean',
              default: false,
              description:
                'retain line numbers - will result in really ugly code',
            },

            highlightCode: {
              description:
                'enable/disable ANSI syntax highlighting of code frames (on by default)',
              type: 'boolean',
              default: true,
            },

            suppressDeprecationMessages: {
              type: 'boolean',
              default: false,
              hidden: true,
            },

            presets: {
              type: 'list',
              description: '',
              default: [],
            },

            plugins: {
              type: 'list',
              default: [],
              description: '',
            },

            ignore: {
              type: 'list',
              description: 'list of glob paths to **not** compile',
              default: [],
            },

            only: {
              type: 'list',
              description: 'list of glob paths to **only** compile',
            },

            code: {
              hidden: true,
              default: true,
              type: 'boolean',
            },

            metadata: {
              hidden: true,
              default: true,
              type: 'boolean',
            },

            ast: {
              hidden: true,
              default: true,
              type: 'boolean',
            },

            extends: {
              type: 'string',
              hidden: true,
            },

            comments: {
              type: 'boolean',
              default: true,
              description:
                'write comments to generated output (true by default)',
            },

            shouldPrintComment: {
              hidden: true,
              description:
                'optional callback to control whether a comment should be inserted, when this is used the comments option is ignored',
            },

            wrapPluginVisitorMethod: {
              hidden: true,
              description: 'optional callback to wrap all visitor methods',
            },

            compact: {
              type: 'booleanString',
              default: 'auto',
              description:
                'do not include superfluous whitespace characters and line terminators [true|false|auto]',
            },

            minified: {
              type: 'boolean',
              default: false,
              description: 'save as much bytes when printing [true|false]',
            },

            sourceMap: {
              alias: 'sourceMaps',
              hidden: true,
            },

            sourceMaps: {
              type: 'booleanString',
              description: '[true|false|inline]',
              default: false,
              shorthand: 's',
            },

            sourceMapTarget: {
              type: 'string',
              description: 'set `file` on returned source map',
            },

            sourceFileName: {
              type: 'string',
              description: 'set `sources[0]` on returned source map',
            },

            sourceRoot: {
              type: 'filename',
              description: 'the root from which all sources are relative',
            },

            babelrc: {
              description:
                'Whether or not to look up .babelrc and .babelignore files',
              type: 'boolean',
              default: true,
            },

            sourceType: {
              description: '',
              default: 'module',
            },

            auxiliaryCommentBefore: {
              type: 'string',
              description: 'print a comment before any injected non-user code',
            },

            auxiliaryCommentAfter: {
              type: 'string',
              description: 'print a comment after any injected non-user code',
            },

            resolveModuleSource: {
              hidden: true,
            },

            getModuleId: {
              hidden: true,
            },

            moduleRoot: {
              type: 'filename',
              description:
                'optional prefix for the AMD module formatter that will be prepend to the filename on module definitions',
            },

            moduleIds: {
              type: 'boolean',
              default: false,
              shorthand: 'M',
              description: 'insert an explicit id for modules',
            },

            moduleId: {
              description: 'specify a custom name for module ids',
              type: 'string',
            },

            passPerPreset: {
              description:
                'Whether to spawn a traversal pass per a preset. By default all presets are merged.',
              type: 'boolean',
              default: false,
              hidden: true,
            },

            parserOpts: {
              description:
                'Options to pass into the parser, or to change parsers (parserOpts.parser)',
              default: false,
            },

            generatorOpts: {
              description:
                'Options to pass into the generator, or to change generators (generatorOpts.generator)',
              default: false,
            },
          }
        },
        {},
      ],
      22: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true
          exports.config = undefined
          exports.normaliseOptions = normaliseOptions

          var _parsers = require('./parsers')

          var parsers = _interopRequireWildcard(_parsers)

          var _config = require('./config')

          var _config2 = _interopRequireDefault(_config)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj
            } else {
              var newObj = {}
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key]
                }
              }
              newObj.default = obj
              return newObj
            }
          }

          exports.config = _config2.default
          function normaliseOptions() {
            var options = arguments.length > 0 && arguments[0] !== undefined
              ? arguments[0]
              : {}

            for (var key in options) {
              var val = options[key]
              if (val == null) continue

              var opt = _config2.default[key]
              if (opt && opt.alias) opt = _config2.default[opt.alias]
              if (!opt) continue

              var parser = parsers[opt.type]
              if (parser) val = parser(val)

              options[key] = val
            }

            return options
          }
        },
        { './config': 21, './parsers': 24 },
      ],
      23: [
        function(require, module, exports) {
          ;(function(process) {
            'use strict'
            exports.__esModule = true

            var _objectWithoutProperties2 = require('babel-runtime/helpers/objectWithoutProperties')

            var _objectWithoutProperties3 = _interopRequireDefault(
              _objectWithoutProperties2
            )

            var _stringify = require('babel-runtime/core-js/json/stringify')

            var _stringify2 = _interopRequireDefault(_stringify)

            var _assign = require('babel-runtime/core-js/object/assign')

            var _assign2 = _interopRequireDefault(_assign)

            var _getIterator2 = require('babel-runtime/core-js/get-iterator')

            var _getIterator3 = _interopRequireDefault(_getIterator2)

            var _typeof2 = require('babel-runtime/helpers/typeof')

            var _typeof3 = _interopRequireDefault(_typeof2)

            var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck')

            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2)

            var _node = require('../../../api/node')

            var context = _interopRequireWildcard(_node)

            var _plugin2 = require('../../plugin')

            var _plugin3 = _interopRequireDefault(_plugin2)

            var _babelMessages = require('babel-messages')

            var messages = _interopRequireWildcard(_babelMessages)

            var _index = require('./index')

            var _resolvePlugin = require('../../../helpers/resolve-plugin')

            var _resolvePlugin2 = _interopRequireDefault(_resolvePlugin)

            var _resolvePreset = require('../../../helpers/resolve-preset')

            var _resolvePreset2 = _interopRequireDefault(_resolvePreset)

            var _cloneDeepWith = require('lodash/cloneDeepWith')

            var _cloneDeepWith2 = _interopRequireDefault(_cloneDeepWith)

            var _clone = require('lodash/clone')

            var _clone2 = _interopRequireDefault(_clone)

            var _merge = require('../../../helpers/merge')

            var _merge2 = _interopRequireDefault(_merge)

            var _config2 = require('./config')

            var _config3 = _interopRequireDefault(_config2)

            var _removed = require('./removed')

            var _removed2 = _interopRequireDefault(_removed)

            var _buildConfigChain = require('./build-config-chain')

            var _buildConfigChain2 = _interopRequireDefault(_buildConfigChain)

            var _path = require('path')

            var _path2 = _interopRequireDefault(_path)

            function _interopRequireWildcard(obj) {
              if (obj && obj.__esModule) {
                return obj
              } else {
                var newObj = {}
                if (obj != null) {
                  for (var key in obj) {
                    if (Object.prototype.hasOwnProperty.call(obj, key))
                      newObj[key] = obj[key]
                  }
                }
                newObj.default = obj
                return newObj
              }
            }

            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj }
            }

            var OptionManager = (function() {
              function OptionManager(log) {
                ;(0, _classCallCheck3.default)(this, OptionManager)

                this.resolvedConfigs = []
                this.options = OptionManager.createBareOptions()
                this.log = log
              }

              OptionManager.memoisePluginContainer = function memoisePluginContainer(
                fn,
                loc,
                i,
                alias
              ) {
                for (
                  var _iterator = OptionManager.memoisedPlugins,
                    _isArray = Array.isArray(_iterator),
                    _i = 0,
                    _iterator = _isArray
                      ? _iterator
                      : (0, _getIterator3.default)(_iterator);
                  ;

                ) {
                  var _ref

                  if (_isArray) {
                    if (_i >= _iterator.length) break
                    _ref = _iterator[_i++]
                  } else {
                    _i = _iterator.next()
                    if (_i.done) break
                    _ref = _i.value
                  }

                  var cache = _ref

                  if (cache.container === fn) return cache.plugin
                }

                var obj = void 0

                if (typeof fn === 'function') {
                  obj = fn(context)
                } else {
                  obj = fn
                }

                if (
                  (typeof obj === 'undefined'
                    ? 'undefined'
                    : (0, _typeof3.default)(obj)) === 'object'
                ) {
                  var _plugin = new _plugin3.default(obj, alias)
                  OptionManager.memoisedPlugins.push({
                    container: fn,
                    plugin: _plugin,
                  })
                  return _plugin
                } else {
                  throw new TypeError(
                    messages.get(
                      'pluginNotObject',
                      loc,
                      i,
                      typeof obj === 'undefined'
                        ? 'undefined'
                        : (0, _typeof3.default)(obj)
                    ) +
                      loc +
                      i
                  )
                }
              }

              OptionManager.createBareOptions = function createBareOptions() {
                var opts = {}

                for (var _key in _config3.default) {
                  var opt = _config3.default[_key]
                  opts[_key] = (0, _clone2.default)(opt.default)
                }

                return opts
              }

              OptionManager.normalisePlugin = function normalisePlugin(
                plugin,
                loc,
                i,
                alias
              ) {
                plugin = plugin.__esModule ? plugin.default : plugin

                if (!(plugin instanceof _plugin3.default)) {
                  if (
                    typeof plugin === 'function' ||
                    (typeof plugin === 'undefined'
                      ? 'undefined'
                      : (0, _typeof3.default)(plugin)) === 'object'
                  ) {
                    plugin = OptionManager.memoisePluginContainer(
                      plugin,
                      loc,
                      i,
                      alias
                    )
                  } else {
                    throw new TypeError(
                      messages.get(
                        'pluginNotFunction',
                        loc,
                        i,
                        typeof plugin === 'undefined'
                          ? 'undefined'
                          : (0, _typeof3.default)(plugin)
                      )
                    )
                  }
                }

                plugin.init(loc, i)

                return plugin
              }

              OptionManager.normalisePlugins = function normalisePlugins(
                loc,
                dirname,
                plugins
              ) {
                return plugins.map(function(val, i) {
                  var plugin = void 0,
                    options = void 0

                  if (!val) {
                    throw new TypeError('Falsy value found in plugins')
                  }

                  if (Array.isArray(val)) {
                    plugin = val[0]
                    options = val[1]
                  } else {
                    plugin = val
                  }

                  var alias = typeof plugin === 'string'
                    ? plugin
                    : loc + '$' + i

                  if (typeof plugin === 'string') {
                    var pluginLoc = (0, _resolvePlugin2.default)(
                      plugin,
                      dirname
                    )
                    if (pluginLoc) {
                      plugin = require(pluginLoc)
                    } else {
                      throw new ReferenceError(
                        messages.get('pluginUnknown', plugin, loc, i, dirname)
                      )
                    }
                  }

                  plugin = OptionManager.normalisePlugin(plugin, loc, i, alias)

                  return [plugin, options]
                })
              }

              OptionManager.prototype.mergeOptions = function mergeOptions(
                _ref2
              ) {
                var _this = this

                var rawOpts = _ref2.options,
                  extendingOpts = _ref2.extending,
                  alias = _ref2.alias,
                  loc = _ref2.loc,
                  dirname = _ref2.dirname

                alias = alias || 'foreign'
                if (!rawOpts) return

                if (
                  (typeof rawOpts === 'undefined'
                    ? 'undefined'
                    : (0, _typeof3.default)(rawOpts)) !== 'object' ||
                  Array.isArray(rawOpts)
                ) {
                  this.log.error('Invalid options type for ' + alias, TypeError)
                }

                var opts = (0, _cloneDeepWith2.default)(rawOpts, function(val) {
                  if (val instanceof _plugin3.default) {
                    return val
                  }
                })

                dirname = dirname || process.cwd()
                loc = loc || alias

                for (var _key2 in opts) {
                  var option = _config3.default[_key2]

                  if (!option && this.log) {
                    if (_removed2.default[_key2]) {
                      this.log.error(
                        'Using removed Babel 5 option: ' +
                          alias +
                          '.' +
                          _key2 +
                          ' - ' +
                          _removed2.default[_key2].message,
                        ReferenceError
                      )
                    } else {
                      var unknownOptErr =
                        'Unknown option: ' +
                        alias +
                        '.' +
                        _key2 +
                        '. Check out http://babeljs.io/docs/usage/options/ for more information about options.'
                      var presetConfigErr =
                        "A common cause of this error is the presence of a configuration options object without the corresponding preset name. Example:\n\nInvalid:\n  `{ presets: [{option: value}] }`\nValid:\n  `{ presets: [['presetName', {option: value}]] }`\n\nFor more detailed information on preset configuration, please see http://babeljs.io/docs/plugins/#pluginpresets-options."

                      this.log.error(
                        unknownOptErr + '\n\n' + presetConfigErr,
                        ReferenceError
                      )
                    }
                  }
                }

                ;(0, _index.normaliseOptions)(opts)

                if (opts.plugins) {
                  opts.plugins = OptionManager.normalisePlugins(
                    loc,
                    dirname,
                    opts.plugins
                  )
                }

                if (opts.presets) {
                  if (opts.passPerPreset) {
                    opts.presets = this.resolvePresets(
                      opts.presets,
                      dirname,
                      function(preset, presetLoc) {
                        _this.mergeOptions({
                          options: preset,
                          extending: preset,
                          alias: presetLoc,
                          loc: presetLoc,
                          dirname: dirname,
                        })
                      }
                    )
                  } else {
                    this.mergePresets(opts.presets, dirname)
                    delete opts.presets
                  }
                }

                if (rawOpts === extendingOpts) {
                  ;(0, _assign2.default)(extendingOpts, opts)
                } else {
                  ;(0, _merge2.default)(extendingOpts || this.options, opts)
                }
              }

              OptionManager.prototype.mergePresets = function mergePresets(
                presets,
                dirname
              ) {
                var _this2 = this

                this.resolvePresets(presets, dirname, function(
                  presetOpts,
                  presetLoc
                ) {
                  _this2.mergeOptions({
                    options: presetOpts,
                    alias: presetLoc,
                    loc: presetLoc,
                    dirname: _path2.default.dirname(presetLoc || ''),
                  })
                })
              }

              OptionManager.prototype.resolvePresets = function resolvePresets(
                presets,
                dirname,
                onResolve
              ) {
                return presets.map(function(val) {
                  var options = void 0
                  if (Array.isArray(val)) {
                    if (val.length > 2) {
                      throw new Error(
                        'Unexpected extra options ' +
                          (0, _stringify2.default)(val.slice(2)) +
                          ' passed to preset.'
                      )
                    }

                    var _val = val
                    val = _val[0]
                    options = _val[1]
                  }

                  var presetLoc = void 0
                  try {
                    if (typeof val === 'string') {
                      presetLoc = (0, _resolvePreset2.default)(val, dirname)

                      if (!presetLoc) {
                        throw new Error(
                          "Couldn't find preset " +
                            (0, _stringify2.default)(val) +
                            ' relative to directory ' +
                            (0, _stringify2.default)(dirname)
                        )
                      }

                      val = require(presetLoc)
                    }

                    if (
                      (typeof val === 'undefined'
                        ? 'undefined'
                        : (0, _typeof3.default)(val)) === 'object' &&
                      val.__esModule
                    ) {
                      if (val.default) {
                        val = val.default
                      } else {
                        var _val2 = val,
                          __esModule = _val2.__esModule,
                          rest = (0, _objectWithoutProperties3.default)(_val2, [
                            '__esModule',
                          ])

                        val = rest
                      }
                    }

                    if (
                      (typeof val === 'undefined'
                        ? 'undefined'
                        : (0, _typeof3.default)(val)) === 'object' &&
                      val.buildPreset
                    )
                      val = val.buildPreset

                    if (typeof val !== 'function' && options !== undefined) {
                      throw new Error(
                        'Options ' +
                          (0, _stringify2.default)(options) +
                          ' passed to ' +
                          (presetLoc || 'a preset') +
                          ' which does not accept options.'
                      )
                    }

                    if (typeof val === 'function')
                      val = val(context, options, { dirname: dirname })

                    if (
                      (typeof val === 'undefined'
                        ? 'undefined'
                        : (0, _typeof3.default)(val)) !== 'object'
                    ) {
                      throw new Error('Unsupported preset format: ' + val + '.')
                    }

                    onResolve && onResolve(val, presetLoc)
                  } catch (e) {
                    if (presetLoc) {
                      e.message +=
                        ' (While processing preset: ' +
                        (0, _stringify2.default)(presetLoc) +
                        ')'
                    }
                    throw e
                  }
                  return val
                })
              }

              OptionManager.prototype.normaliseOptions = function normaliseOptions() {
                var opts = this.options

                for (var _key3 in _config3.default) {
                  var option = _config3.default[_key3]
                  var val = opts[_key3]

                  if (!val && option.optional) continue

                  if (option.alias) {
                    opts[option.alias] = opts[option.alias] || val
                  } else {
                    opts[_key3] = val
                  }
                }
              }

              OptionManager.prototype.init = function init() {
                var opts = arguments.length > 0 && arguments[0] !== undefined
                  ? arguments[0]
                  : {}

                for (
                  var _iterator2 = (0, _buildConfigChain2.default)(
                    opts,
                    this.log
                  ),
                    _isArray2 = Array.isArray(_iterator2),
                    _i2 = 0,
                    _iterator2 = _isArray2
                      ? _iterator2
                      : (0, _getIterator3.default)(_iterator2);
                  ;

                ) {
                  var _ref3

                  if (_isArray2) {
                    if (_i2 >= _iterator2.length) break
                    _ref3 = _iterator2[_i2++]
                  } else {
                    _i2 = _iterator2.next()
                    if (_i2.done) break
                    _ref3 = _i2.value
                  }

                  var _config = _ref3

                  this.mergeOptions(_config)
                }

                this.normaliseOptions(opts)

                return this.options
              }

              return OptionManager
            })()

            exports.default = OptionManager

            OptionManager.memoisedPlugins = []
            module.exports = exports['default']
          }.call(this, require('_process')))
        },
        {
          '../../../api/node': 6,
          '../../../helpers/merge': 9,
          '../../../helpers/resolve-plugin': 12,
          '../../../helpers/resolve-preset': 13,
          '../../plugin': 30,
          './build-config-chain': 20,
          './config': 21,
          './index': 22,
          './removed': 25,
          _process: 507,
          'babel-messages': 53,
          'babel-runtime/core-js/get-iterator': 54,
          'babel-runtime/core-js/json/stringify': 55,
          'babel-runtime/core-js/object/assign': 58,
          'babel-runtime/helpers/classCallCheck': 68,
          'babel-runtime/helpers/objectWithoutProperties': 70,
          'babel-runtime/helpers/typeof': 72,
          'lodash/clone': 451,
          'lodash/cloneDeepWith': 453,
          path: 505,
        },
      ],
      24: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true
          exports.filename = undefined
          exports.boolean = boolean
          exports.booleanString = booleanString
          exports.list = list

          var _slash = require('slash')

          var _slash2 = _interopRequireDefault(_slash)

          var _util = require('../../../util')

          var util = _interopRequireWildcard(_util)

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj
            } else {
              var newObj = {}
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key]
                }
              }
              newObj.default = obj
              return newObj
            }
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          var filename = (exports.filename = _slash2.default)

          function boolean(val) {
            return !!val
          }

          function booleanString(val) {
            return util.booleanify(val)
          }

          function list(val) {
            return util.list(val)
          }
        },
        { '../../../util': 31, slash: 515 },
      ],
      25: [
        function(require, module, exports) {
          'use strict'
          module.exports = {
            auxiliaryComment: {
              message:
                'Use `auxiliaryCommentBefore` or `auxiliaryCommentAfter`',
            },
            blacklist: {
              message:
                'Put the specific transforms you want in the `plugins` option',
            },
            breakConfig: {
              message: 'This is not a necessary option in Babel 6',
            },
            experimental: {
              message:
                'Put the specific transforms you want in the `plugins` option',
            },
            externalHelpers: {
              message:
                'Use the `external-helpers` plugin instead. Check out http://babeljs.io/docs/plugins/external-helpers/',
            },
            extra: {
              message: '',
            },
            jsxPragma: {
              message:
                'use the `pragma` option in the `react-jsx` plugin . Check out http://babeljs.io/docs/plugins/transform-react-jsx/',
            },

            loose: {
              message:
                'Specify the `loose` option for the relevant plugin you are using or use a preset that sets the option.',
            },
            metadataUsedHelpers: {
              message: 'Not required anymore as this is enabled by default',
            },
            modules: {
              message:
                'Use the corresponding module transform plugin in the `plugins` option. Check out http://babeljs.io/docs/plugins/#modules',
            },
            nonStandard: {
              message:
                'Use the `react-jsx` and `flow-strip-types` plugins to support JSX and Flow. Also check out the react preset http://babeljs.io/docs/plugins/preset-react/',
            },
            optional: {
              message:
                'Put the specific transforms you want in the `plugins` option',
            },
            sourceMapName: {
              message: 'Use the `sourceMapTarget` option',
            },
            stage: {
              message:
                'Check out the corresponding stage-x presets http://babeljs.io/docs/plugins/#presets',
            },
            whitelist: {
              message:
                'Put the specific transforms you want in the `plugins` option',
            },
          }
        },
        {},
      ],
      26: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true

          var _plugin = require('../plugin')

          var _plugin2 = _interopRequireDefault(_plugin)

          var _sortBy = require('lodash/sortBy')

          var _sortBy2 = _interopRequireDefault(_sortBy)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          exports.default = new _plugin2.default({
            name: 'internal.blockHoist',

            visitor: {
              Block: {
                exit: function exit(_ref) {
                  var node = _ref.node

                  var hasChange = false
                  for (var i = 0; i < node.body.length; i++) {
                    var bodyNode = node.body[i]
                    if (bodyNode && bodyNode._blockHoist != null) {
                      hasChange = true
                      break
                    }
                  }
                  if (!hasChange) return

                  node.body = (0, _sortBy2.default)(node.body, function(
                    bodyNode
                  ) {
                    var priority = bodyNode && bodyNode._blockHoist
                    if (priority == null) priority = 1
                    if (priority === true) priority = 2

                    return -1 * priority
                  })
                },
              },
            },
          })
          module.exports = exports['default']
        },
        { '../plugin': 30, 'lodash/sortBy': 490 },
      ],
      27: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true

          var _symbol = require('babel-runtime/core-js/symbol')

          var _symbol2 = _interopRequireDefault(_symbol)

          var _plugin = require('../plugin')

          var _plugin2 = _interopRequireDefault(_plugin)

          var _babelTypes = require('babel-types')

          var t = _interopRequireWildcard(_babelTypes)

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj
            } else {
              var newObj = {}
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key]
                }
              }
              newObj.default = obj
              return newObj
            }
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          var SUPER_THIS_BOUND = (0, _symbol2.default)('super this bound')

          var superVisitor = {
            CallExpression: function CallExpression(path) {
              if (!path.get('callee').isSuper()) return

              var node = path.node

              if (node[SUPER_THIS_BOUND]) return
              node[SUPER_THIS_BOUND] = true

              path.replaceWith(t.assignmentExpression('=', this.id, node))
            },
          }

          exports.default = new _plugin2.default({
            name: 'internal.shadowFunctions',

            visitor: {
              ThisExpression: function ThisExpression(path) {
                remap(path, 'this')
              },
              ReferencedIdentifier: function ReferencedIdentifier(path) {
                if (path.node.name === 'arguments') {
                  remap(path, 'arguments')
                }
              },
            },
          })

          function shouldShadow(path, shadowPath) {
            if (path.is('_forceShadow')) {
              return true
            } else {
              return shadowPath
            }
          }

          function remap(path, key) {
            var shadowPath = path.inShadow(key)
            if (!shouldShadow(path, shadowPath)) return

            var shadowFunction = path.node._shadowedFunctionLiteral

            var currentFunction = void 0
            var passedShadowFunction = false

            var fnPath = path.find(function(innerPath) {
              if (
                innerPath.parentPath &&
                innerPath.parentPath.isClassProperty() &&
                innerPath.key === 'value'
              ) {
                return true
              }
              if (path === innerPath) return false
              if (innerPath.isProgram() || innerPath.isFunction()) {
                currentFunction = currentFunction || innerPath
              }

              if (innerPath.isProgram()) {
                passedShadowFunction = true

                return true
              } else if (
                innerPath.isFunction() &&
                !innerPath.isArrowFunctionExpression()
              ) {
                if (shadowFunction) {
                  if (
                    innerPath === shadowFunction ||
                    innerPath.node === shadowFunction.node
                  )
                    return true
                } else {
                  if (!innerPath.is('shadow')) return true
                }

                passedShadowFunction = true
                return false
              }

              return false
            })

            if (
              shadowFunction &&
              fnPath.isProgram() &&
              !shadowFunction.isProgram()
            ) {
              fnPath = path.findParent(function(p) {
                return p.isProgram() || p.isFunction()
              })
            }

            if (fnPath === currentFunction) return

            if (!passedShadowFunction) return

            var cached = fnPath.getData(key)
            if (cached) return path.replaceWith(cached)

            var id = path.scope.generateUidIdentifier(key)

            fnPath.setData(key, id)

            var classPath = fnPath.findParent(function(p) {
              return p.isClass()
            })
            var hasSuperClass = !!(
              classPath &&
              classPath.node &&
              classPath.node.superClass
            )

            if (
              key === 'this' &&
              fnPath.isMethod({ kind: 'constructor' }) &&
              hasSuperClass
            ) {
              fnPath.scope.push({ id: id })

              fnPath.traverse(superVisitor, { id: id })
            } else {
              var init = key === 'this' ? t.thisExpression() : t.identifier(key)

              if (shadowFunction) init._shadowedFunctionLiteral = shadowFunction

              fnPath.scope.push({ id: id, init: init })
            }

            return path.replaceWith(id)
          }
          module.exports = exports['default']
        },
        {
          '../plugin': 30,
          'babel-runtime/core-js/symbol': 63,
          'babel-types': 110,
        },
      ],
      28: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true

          var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck')

          var _classCallCheck3 = _interopRequireDefault(_classCallCheck2)

          var _normalizeAst = require('../helpers/normalize-ast')

          var _normalizeAst2 = _interopRequireDefault(_normalizeAst)

          var _plugin = require('./plugin')

          var _plugin2 = _interopRequireDefault(_plugin)

          var _file = require('./file')

          var _file2 = _interopRequireDefault(_file)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          var Pipeline = (function() {
            function Pipeline() {
              ;(0, _classCallCheck3.default)(this, Pipeline)
            }

            Pipeline.prototype.lint = function lint(code) {
              var opts = arguments.length > 1 && arguments[1] !== undefined
                ? arguments[1]
                : {}

              opts.code = false
              opts.mode = 'lint'
              return this.transform(code, opts)
            }

            Pipeline.prototype.pretransform = function pretransform(
              code,
              opts
            ) {
              var file = new _file2.default(opts, this)
              return file.wrap(code, function() {
                file.addCode(code)
                file.parseCode(code)
                return file
              })
            }

            Pipeline.prototype.transform = function transform(code, opts) {
              var file = new _file2.default(opts, this)
              return file.wrap(code, function() {
                file.addCode(code)
                file.parseCode(code)
                return file.transform()
              })
            }

            Pipeline.prototype.analyse = function analyse(code) {
              var opts = arguments.length > 1 && arguments[1] !== undefined
                ? arguments[1]
                : {}
              var visitor = arguments[2]

              opts.code = false
              if (visitor) {
                opts.plugins = opts.plugins || []
                opts.plugins.push(new _plugin2.default({ visitor: visitor }))
              }
              return this.transform(code, opts).metadata
            }

            Pipeline.prototype.transformFromAst = function transformFromAst(
              ast,
              code,
              opts
            ) {
              ast = (0, _normalizeAst2.default)(ast)

              var file = new _file2.default(opts, this)
              return file.wrap(code, function() {
                file.addCode(code)
                file.addAst(ast)
                return file.transform()
              })
            }

            return Pipeline
          })()

          exports.default = Pipeline
          module.exports = exports['default']
        },
        {
          '../helpers/normalize-ast': 10,
          './file': 17,
          './plugin': 30,
          'babel-runtime/helpers/classCallCheck': 68,
        },
      ],
      29: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true

          var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck')

          var _classCallCheck3 = _interopRequireDefault(_classCallCheck2)

          var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn')

          var _possibleConstructorReturn3 = _interopRequireDefault(
            _possibleConstructorReturn2
          )

          var _inherits2 = require('babel-runtime/helpers/inherits')

          var _inherits3 = _interopRequireDefault(_inherits2)

          var _store = require('../store')

          var _store2 = _interopRequireDefault(_store)

          var _file5 = require('./file')

          var _file6 = _interopRequireDefault(_file5)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          var PluginPass = (function(_Store) {
            ;(0, _inherits3.default)(PluginPass, _Store)

            function PluginPass(file, plugin) {
              var options = arguments.length > 2 && arguments[2] !== undefined
                ? arguments[2]
                : {}
              ;(0, _classCallCheck3.default)(this, PluginPass)

              var _this = (0, _possibleConstructorReturn3.default)(
                this,
                _Store.call(this)
              )

              _this.plugin = plugin
              _this.key = plugin.key
              _this.file = file
              _this.opts = options
              return _this
            }

            PluginPass.prototype.addHelper = function addHelper() {
              var _file

              return (_file = this.file).addHelper.apply(_file, arguments)
            }

            PluginPass.prototype.addImport = function addImport() {
              var _file2

              return (_file2 = this.file).addImport.apply(_file2, arguments)
            }

            PluginPass.prototype.getModuleName = function getModuleName() {
              var _file3

              return (_file3 = this.file).getModuleName.apply(_file3, arguments)
            }

            PluginPass.prototype.buildCodeFrameError = function buildCodeFrameError() {
              var _file4

              return (_file4 = this.file).buildCodeFrameError.apply(
                _file4,
                arguments
              )
            }

            return PluginPass
          })(_store2.default)

          exports.default = PluginPass
          module.exports = exports['default']
        },
        {
          '../store': 15,
          './file': 17,
          'babel-runtime/helpers/classCallCheck': 68,
          'babel-runtime/helpers/inherits': 69,
          'babel-runtime/helpers/possibleConstructorReturn': 71,
        },
      ],
      30: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true

          var _getIterator2 = require('babel-runtime/core-js/get-iterator')

          var _getIterator3 = _interopRequireDefault(_getIterator2)

          var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck')

          var _classCallCheck3 = _interopRequireDefault(_classCallCheck2)

          var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn')

          var _possibleConstructorReturn3 = _interopRequireDefault(
            _possibleConstructorReturn2
          )

          var _inherits2 = require('babel-runtime/helpers/inherits')

          var _inherits3 = _interopRequireDefault(_inherits2)

          var _optionManager = require('./file/options/option-manager')

          var _optionManager2 = _interopRequireDefault(_optionManager)

          var _babelMessages = require('babel-messages')

          var messages = _interopRequireWildcard(_babelMessages)

          var _store = require('../store')

          var _store2 = _interopRequireDefault(_store)

          var _babelTraverse = require('babel-traverse')

          var _babelTraverse2 = _interopRequireDefault(_babelTraverse)

          var _assign = require('lodash/assign')

          var _assign2 = _interopRequireDefault(_assign)

          var _clone = require('lodash/clone')

          var _clone2 = _interopRequireDefault(_clone)

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj
            } else {
              var newObj = {}
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key]
                }
              }
              newObj.default = obj
              return newObj
            }
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          var GLOBAL_VISITOR_PROPS = ['enter', 'exit']

          var Plugin = (function(_Store) {
            ;(0, _inherits3.default)(Plugin, _Store)

            function Plugin(plugin, key) {
              ;(0, _classCallCheck3.default)(this, Plugin)

              var _this = (0, _possibleConstructorReturn3.default)(
                this,
                _Store.call(this)
              )

              _this.initialized = false
              _this.raw = (0, _assign2.default)({}, plugin)
              _this.key = _this.take('name') || key

              _this.manipulateOptions = _this.take('manipulateOptions')
              _this.post = _this.take('post')
              _this.pre = _this.take('pre')
              _this.visitor = _this.normaliseVisitor(
                (0, _clone2.default)(_this.take('visitor')) || {}
              )
              return _this
            }

            Plugin.prototype.take = function take(key) {
              var val = this.raw[key]
              delete this.raw[key]
              return val
            }

            Plugin.prototype.chain = function chain(target, key) {
              if (!target[key]) return this[key]
              if (!this[key]) return target[key]

              var fns = [target[key], this[key]]

              return function() {
                var val = void 0

                for (
                  var _len = arguments.length, args = Array(_len), _key = 0;
                  _key < _len;
                  _key++
                ) {
                  args[_key] = arguments[_key]
                }

                for (
                  var _iterator = fns,
                    _isArray = Array.isArray(_iterator),
                    _i = 0,
                    _iterator = _isArray
                      ? _iterator
                      : (0, _getIterator3.default)(_iterator);
                  ;

                ) {
                  var _ref

                  if (_isArray) {
                    if (_i >= _iterator.length) break
                    _ref = _iterator[_i++]
                  } else {
                    _i = _iterator.next()
                    if (_i.done) break
                    _ref = _i.value
                  }

                  var fn = _ref

                  if (fn) {
                    var ret = fn.apply(this, args)
                    if (ret != null) val = ret
                  }
                }
                return val
              }
            }

            Plugin.prototype.maybeInherit = function maybeInherit(loc) {
              var inherits = this.take('inherits')
              if (!inherits) return

              inherits = _optionManager2.default.normalisePlugin(
                inherits,
                loc,
                'inherits'
              )

              this.manipulateOptions = this.chain(inherits, 'manipulateOptions')
              this.post = this.chain(inherits, 'post')
              this.pre = this.chain(inherits, 'pre')
              this.visitor = _babelTraverse2.default.visitors.merge([
                inherits.visitor,
                this.visitor,
              ])
            }

            Plugin.prototype.init = function init(loc, i) {
              if (this.initialized) return
              this.initialized = true

              this.maybeInherit(loc)

              for (var key in this.raw) {
                throw new Error(
                  messages.get('pluginInvalidProperty', loc, i, key)
                )
              }
            }

            Plugin.prototype.normaliseVisitor = function normaliseVisitor(
              visitor
            ) {
              for (
                var _iterator2 = GLOBAL_VISITOR_PROPS,
                  _isArray2 = Array.isArray(_iterator2),
                  _i2 = 0,
                  _iterator2 = _isArray2
                    ? _iterator2
                    : (0, _getIterator3.default)(_iterator2);
                ;

              ) {
                var _ref2

                if (_isArray2) {
                  if (_i2 >= _iterator2.length) break
                  _ref2 = _iterator2[_i2++]
                } else {
                  _i2 = _iterator2.next()
                  if (_i2.done) break
                  _ref2 = _i2.value
                }

                var key = _ref2

                if (visitor[key]) {
                  throw new Error(
                    "Plugins aren't allowed to specify catch-all enter/exit handlers. " +
                      'Please target individual nodes.'
                  )
                }
              }

              _babelTraverse2.default.explode(visitor)
              return visitor
            }

            return Plugin
          })(_store2.default)

          exports.default = Plugin
          module.exports = exports['default']
        },
        {
          '../store': 15,
          './file/options/option-manager': 23,
          'babel-messages': 53,
          'babel-runtime/core-js/get-iterator': 54,
          'babel-runtime/helpers/classCallCheck': 68,
          'babel-runtime/helpers/inherits': 69,
          'babel-runtime/helpers/possibleConstructorReturn': 71,
          'babel-traverse': 77,
          'lodash/assign': 449,
          'lodash/clone': 451,
        },
      ],
      31: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true
          exports.inspect = exports.inherits = undefined

          var _getIterator2 = require('babel-runtime/core-js/get-iterator')

          var _getIterator3 = _interopRequireDefault(_getIterator2)

          var _util = require('util')

          Object.defineProperty(exports, 'inherits', {
            enumerable: true,
            get: function get() {
              return _util.inherits
            },
          })
          Object.defineProperty(exports, 'inspect', {
            enumerable: true,
            get: function get() {
              return _util.inspect
            },
          })
          exports.canCompile = canCompile
          exports.list = list
          exports.regexify = regexify
          exports.arrayify = arrayify
          exports.booleanify = booleanify
          exports.shouldIgnore = shouldIgnore

          var _escapeRegExp = require('lodash/escapeRegExp')

          var _escapeRegExp2 = _interopRequireDefault(_escapeRegExp)

          var _startsWith = require('lodash/startsWith')

          var _startsWith2 = _interopRequireDefault(_startsWith)

          var _minimatch = require('minimatch')

          var _minimatch2 = _interopRequireDefault(_minimatch)

          var _includes = require('lodash/includes')

          var _includes2 = _interopRequireDefault(_includes)

          var _isRegExp = require('lodash/isRegExp')

          var _isRegExp2 = _interopRequireDefault(_isRegExp)

          var _path = require('path')

          var _path2 = _interopRequireDefault(_path)

          var _slash = require('slash')

          var _slash2 = _interopRequireDefault(_slash)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          function canCompile(filename, altExts) {
            var exts = altExts || canCompile.EXTENSIONS
            var ext = _path2.default.extname(filename)
            return (0, _includes2.default)(exts, ext)
          }

          canCompile.EXTENSIONS = ['.js', '.jsx', '.es6', '.es']

          function list(val) {
            if (!val) {
              return []
            } else if (Array.isArray(val)) {
              return val
            } else if (typeof val === 'string') {
              return val.split(',')
            } else {
              return [val]
            }
          }

          function regexify(val) {
            if (!val) {
              return new RegExp(/.^/)
            }

            if (Array.isArray(val)) {
              val = new RegExp(val.map(_escapeRegExp2.default).join('|'), 'i')
            }

            if (typeof val === 'string') {
              val = (0, _slash2.default)(val)

              if (
                (0, _startsWith2.default)(val, './') ||
                (0, _startsWith2.default)(val, '*/')
              )
                val = val.slice(2)
              if ((0, _startsWith2.default)(val, '**/')) val = val.slice(3)

              var regex = _minimatch2.default.makeRe(val, { nocase: true })
              return new RegExp(regex.source.slice(1, -1), 'i')
            }

            if ((0, _isRegExp2.default)(val)) {
              return val
            }

            throw new TypeError('illegal type for regexify')
          }

          function arrayify(val, mapFn) {
            if (!val) return []
            if (typeof val === 'boolean') return arrayify([val], mapFn)
            if (typeof val === 'string') return arrayify(list(val), mapFn)

            if (Array.isArray(val)) {
              if (mapFn) val = val.map(mapFn)
              return val
            }

            return [val]
          }

          function booleanify(val) {
            if (val === 'true' || val == 1) {
              return true
            }

            if (val === 'false' || val == 0 || !val) {
              return false
            }

            return val
          }

          function shouldIgnore(filename) {
            var ignore = arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : []
            var only = arguments[2]

            filename = filename.replace(/\\/g, '/')

            if (only) {
              for (
                var _iterator = only,
                  _isArray = Array.isArray(_iterator),
                  _i = 0,
                  _iterator = _isArray
                    ? _iterator
                    : (0, _getIterator3.default)(_iterator);
                ;

              ) {
                var _ref

                if (_isArray) {
                  if (_i >= _iterator.length) break
                  _ref = _iterator[_i++]
                } else {
                  _i = _iterator.next()
                  if (_i.done) break
                  _ref = _i.value
                }

                var pattern = _ref

                if (_shouldIgnore(pattern, filename)) return false
              }
              return true
            } else if (ignore.length) {
              for (
                var _iterator2 = ignore,
                  _isArray2 = Array.isArray(_iterator2),
                  _i2 = 0,
                  _iterator2 = _isArray2
                    ? _iterator2
                    : (0, _getIterator3.default)(_iterator2);
                ;

              ) {
                var _ref2

                if (_isArray2) {
                  if (_i2 >= _iterator2.length) break
                  _ref2 = _iterator2[_i2++]
                } else {
                  _i2 = _iterator2.next()
                  if (_i2.done) break
                  _ref2 = _i2.value
                }

                var _pattern = _ref2

                if (_shouldIgnore(_pattern, filename)) return true
              }
            }

            return false
          }

          function _shouldIgnore(pattern, filename) {
            if (typeof pattern === 'function') {
              return pattern(filename)
            } else {
              return pattern.test(filename)
            }
          }
        },
        {
          'babel-runtime/core-js/get-iterator': 54,
          'lodash/escapeRegExp': 457,
          'lodash/includes': 466,
          'lodash/isRegExp': 478,
          'lodash/startsWith': 491,
          minimatch: 502,
          path: 505,
          slash: 515,
          util: 568,
        },
      ],
      32: [
        function(require, module, exports) {
          module.exports = {
            name: 'babel-core',
            version: '6.24.1',
            description: 'Babel compiler core.',
            author: 'Sebastian McKenzie <sebmck@gmail.com>',
            homepage: 'https://babeljs.io/',
            license: 'MIT',
            repository:
              'https://github.com/babel/babel/tree/master/packages/babel-core',
            keywords: [
              '6to5',
              'babel',
              'classes',
              'const',
              'es6',
              'harmony',
              'let',
              'modules',
              'transpile',
              'transpiler',
              'var',
              'babel-core',
              'compiler',
            ],
            scripts: {
              bench: 'make bench',
              test: 'make test',
            },
            dependencies: {
              'babel-code-frame': '^6.22.0',
              'babel-generator': '^6.24.1',
              'babel-helpers': '^6.24.1',
              'babel-messages': '^6.23.0',
              'babel-template': '^6.24.1',
              'babel-runtime': '^6.22.0',
              'babel-register': '^6.24.1',
              'babel-traverse': '^6.24.1',
              'babel-types': '^6.24.1',
              babylon: '^6.11.0',
              'convert-source-map': '^1.1.0',
              debug: '^2.1.1',
              json5: '^0.5.0',
              lodash: '^4.2.0',
              minimatch: '^3.0.2',
              'path-is-absolute': '^1.0.0',
              private: '^0.1.6',
              slash: '^1.0.0',
              'source-map': '^0.5.0',
            },
            devDependencies: {
              'babel-helper-fixtures': '^6.22.0',
              'babel-helper-transform-fixture-test-runner': '^6.24.1',
              'babel-polyfill': '^6.23.0',
            },
          }
        },
        {},
      ],
      33: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true

          var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck')

          var _classCallCheck3 = _interopRequireDefault(_classCallCheck2)

          var _trimRight = require('trim-right')

          var _trimRight2 = _interopRequireDefault(_trimRight)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          var SPACES_RE = /^[ \t]+$/

          var Buffer = (function() {
            function Buffer(map) {
              ;(0, _classCallCheck3.default)(this, Buffer)
              this._map = null
              this._buf = []
              this._last = ''
              this._queue = []
              this._position = {
                line: 1,
                column: 0,
              }
              this._sourcePosition = {
                identifierName: null,
                line: null,
                column: null,
                filename: null,
              }

              this._map = map
            }

            Buffer.prototype.get = function get() {
              this._flush()

              var map = this._map
              var result = {
                code: (0, _trimRight2.default)(this._buf.join('')),
                map: null,
                rawMappings: map && map.getRawMappings(),
              }

              if (map) {
                Object.defineProperty(result, 'map', {
                  configurable: true,
                  enumerable: true,
                  get: function get() {
                    return (this.map = map.get())
                  },
                  set: function set(value) {
                    Object.defineProperty(this, 'map', {
                      value: value,
                      writable: true,
                    })
                  },
                })
              }

              return result
            }

            Buffer.prototype.append = function append(str) {
              this._flush()
              var _sourcePosition = this._sourcePosition,
                line = _sourcePosition.line,
                column = _sourcePosition.column,
                filename = _sourcePosition.filename,
                identifierName = _sourcePosition.identifierName

              this._append(str, line, column, identifierName, filename)
            }

            Buffer.prototype.queue = function queue(str) {
              if (str === '\n')
                while (
                  this._queue.length > 0 &&
                  SPACES_RE.test(this._queue[0][0])
                ) {
                  this._queue.shift()
                }
              var _sourcePosition2 = this._sourcePosition,
                line = _sourcePosition2.line,
                column = _sourcePosition2.column,
                filename = _sourcePosition2.filename,
                identifierName = _sourcePosition2.identifierName

              this._queue.unshift([str, line, column, identifierName, filename])
            }

            Buffer.prototype._flush = function _flush() {
              var item = void 0
              while ((item = this._queue.pop())) {
                this._append.apply(this, item)
              }
            }

            Buffer.prototype._append = function _append(
              str,
              line,
              column,
              identifierName,
              filename
            ) {
              if (this._map && str[0] !== '\n') {
                this._map.mark(
                  this._position.line,
                  this._position.column,
                  line,
                  column,
                  identifierName,
                  filename
                )
              }

              this._buf.push(str)
              this._last = str[str.length - 1]

              for (var i = 0; i < str.length; i++) {
                if (str[i] === '\n') {
                  this._position.line++
                  this._position.column = 0
                } else {
                  this._position.column++
                }
              }
            }

            Buffer.prototype.removeTrailingNewline = function removeTrailingNewline() {
              if (this._queue.length > 0 && this._queue[0][0] === '\n')
                this._queue.shift()
            }

            Buffer.prototype.removeLastSemicolon = function removeLastSemicolon() {
              if (this._queue.length > 0 && this._queue[0][0] === ';')
                this._queue.shift()
            }

            Buffer.prototype.endsWith = function endsWith(suffix) {
              if (suffix.length === 1) {
                var last = void 0
                if (this._queue.length > 0) {
                  var str = this._queue[0][0]
                  last = str[str.length - 1]
                } else {
                  last = this._last
                }

                return last === suffix
              }

              var end =
                this._last +
                this._queue.reduce(function(acc, item) {
                  return item[0] + acc
                }, '')
              if (suffix.length <= end.length) {
                return end.slice(-suffix.length) === suffix
              }

              return false
            }

            Buffer.prototype.hasContent = function hasContent() {
              return this._queue.length > 0 || !!this._last
            }

            Buffer.prototype.source = function source(prop, loc) {
              if (prop && !loc) return

              var pos = loc ? loc[prop] : null

              this._sourcePosition.identifierName =
                (loc && loc.identifierName) || null
              this._sourcePosition.line = pos ? pos.line : null
              this._sourcePosition.column = pos ? pos.column : null
              this._sourcePosition.filename = (loc && loc.filename) || null
            }

            Buffer.prototype.withSource = function withSource(prop, loc, cb) {
              if (!this._map) return cb()

              var originalLine = this._sourcePosition.line
              var originalColumn = this._sourcePosition.column
              var originalFilename = this._sourcePosition.filename
              var originalIdentifierName = this._sourcePosition.identifierName

              this.source(prop, loc)

              cb()

              this._sourcePosition.line = originalLine
              this._sourcePosition.column = originalColumn
              this._sourcePosition.filename = originalFilename
              this._sourcePosition.identifierName = originalIdentifierName
            }

            Buffer.prototype.getCurrentColumn = function getCurrentColumn() {
              var extra = this._queue.reduce(function(acc, item) {
                return item[0] + acc
              }, '')
              var lastIndex = extra.lastIndexOf('\n')

              return lastIndex === -1
                ? this._position.column + extra.length
                : extra.length - 1 - lastIndex
            }

            Buffer.prototype.getCurrentLine = function getCurrentLine() {
              var extra = this._queue.reduce(function(acc, item) {
                return item[0] + acc
              }, '')

              var count = 0
              for (var i = 0; i < extra.length; i++) {
                if (extra[i] === '\n') count++
              }

              return this._position.line + count
            }

            return Buffer
          })()

          exports.default = Buffer
          module.exports = exports['default']
        },
        { 'babel-runtime/helpers/classCallCheck': 68, 'trim-right': 564 },
      ],
      34: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true
          exports.File = File
          exports.Program = Program
          exports.BlockStatement = BlockStatement
          exports.Noop = Noop
          exports.Directive = Directive

          var _types = require('./types')

          Object.defineProperty(exports, 'DirectiveLiteral', {
            enumerable: true,
            get: function get() {
              return _types.StringLiteral
            },
          })
          function File(node) {
            this.print(node.program, node)
          }

          function Program(node) {
            this.printInnerComments(node, false)

            this.printSequence(node.directives, node)
            if (node.directives && node.directives.length) this.newline()

            this.printSequence(node.body, node)
          }

          function BlockStatement(node) {
            this.token('{')
            this.printInnerComments(node)

            var hasDirectives = node.directives && node.directives.length

            if (node.body.length || hasDirectives) {
              this.newline()

              this.printSequence(node.directives, node, { indent: true })
              if (hasDirectives) this.newline()

              this.printSequence(node.body, node, { indent: true })
              this.removeTrailingNewline()

              this.source('end', node.loc)

              if (!this.endsWith('\n')) this.newline()

              this.rightBrace()
            } else {
              this.source('end', node.loc)
              this.token('}')
            }
          }

          function Noop() {}

          function Directive(node) {
            this.print(node.value, node)
            this.semicolon()
          }
        },
        { './types': 43 },
      ],
      35: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true
          exports.ClassDeclaration = ClassDeclaration
          exports.ClassBody = ClassBody
          exports.ClassProperty = ClassProperty
          exports.ClassMethod = ClassMethod
          function ClassDeclaration(node) {
            this.printJoin(node.decorators, node)
            this.word('class')

            if (node.id) {
              this.space()
              this.print(node.id, node)
            }

            this.print(node.typeParameters, node)

            if (node.superClass) {
              this.space()
              this.word('extends')
              this.space()
              this.print(node.superClass, node)
              this.print(node.superTypeParameters, node)
            }

            if (node.implements) {
              this.space()
              this.word('implements')
              this.space()
              this.printList(node.implements, node)
            }

            this.space()
            this.print(node.body, node)
          }

          exports.ClassExpression = ClassDeclaration
          function ClassBody(node) {
            this.token('{')
            this.printInnerComments(node)
            if (node.body.length === 0) {
              this.token('}')
            } else {
              this.newline()

              this.indent()
              this.printSequence(node.body, node)
              this.dedent()

              if (!this.endsWith('\n')) this.newline()

              this.rightBrace()
            }
          }

          function ClassProperty(node) {
            this.printJoin(node.decorators, node)

            if (node.static) {
              this.word('static')
              this.space()
            }
            if (node.computed) {
              this.token('[')
              this.print(node.key, node)
              this.token(']')
            } else {
              this._variance(node)
              this.print(node.key, node)
            }
            this.print(node.typeAnnotation, node)
            if (node.value) {
              this.space()
              this.token('=')
              this.space()
              this.print(node.value, node)
            }
            this.semicolon()
          }

          function ClassMethod(node) {
            this.printJoin(node.decorators, node)

            if (node.static) {
              this.word('static')
              this.space()
            }

            if (node.kind === 'constructorCall') {
              this.word('call')
              this.space()
            }

            this._method(node)
          }
        },
        {},
      ],
      36: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true
          exports.LogicalExpression = exports.BinaryExpression = exports.AwaitExpression = exports.YieldExpression = undefined
          exports.UnaryExpression = UnaryExpression
          exports.DoExpression = DoExpression
          exports.ParenthesizedExpression = ParenthesizedExpression
          exports.UpdateExpression = UpdateExpression
          exports.ConditionalExpression = ConditionalExpression
          exports.NewExpression = NewExpression
          exports.SequenceExpression = SequenceExpression
          exports.ThisExpression = ThisExpression
          exports.Super = Super
          exports.Decorator = Decorator
          exports.CallExpression = CallExpression
          exports.Import = Import
          exports.EmptyStatement = EmptyStatement
          exports.ExpressionStatement = ExpressionStatement
          exports.AssignmentPattern = AssignmentPattern
          exports.AssignmentExpression = AssignmentExpression
          exports.BindExpression = BindExpression
          exports.MemberExpression = MemberExpression
          exports.MetaProperty = MetaProperty

          var _babelTypes = require('babel-types')

          var t = _interopRequireWildcard(_babelTypes)

          var _node = require('../node')

          var n = _interopRequireWildcard(_node)

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj
            } else {
              var newObj = {}
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key]
                }
              }
              newObj.default = obj
              return newObj
            }
          }

          function UnaryExpression(node) {
            if (
              node.operator === 'void' ||
              node.operator === 'delete' ||
              node.operator === 'typeof'
            ) {
              this.word(node.operator)
              this.space()
            } else {
              this.token(node.operator)
            }

            this.print(node.argument, node)
          }

          function DoExpression(node) {
            this.word('do')
            this.space()
            this.print(node.body, node)
          }

          function ParenthesizedExpression(node) {
            this.token('(')
            this.print(node.expression, node)
            this.token(')')
          }

          function UpdateExpression(node) {
            if (node.prefix) {
              this.token(node.operator)
              this.print(node.argument, node)
            } else {
              this.print(node.argument, node)
              this.token(node.operator)
            }
          }

          function ConditionalExpression(node) {
            this.print(node.test, node)
            this.space()
            this.token('?')
            this.space()
            this.print(node.consequent, node)
            this.space()
            this.token(':')
            this.space()
            this.print(node.alternate, node)
          }

          function NewExpression(node, parent) {
            this.word('new')
            this.space()
            this.print(node.callee, node)
            if (
              node.arguments.length === 0 &&
              this.format.minified &&
              !t.isCallExpression(parent, { callee: node }) &&
              !t.isMemberExpression(parent) &&
              !t.isNewExpression(parent)
            )
              return

            this.token('(')
            this.printList(node.arguments, node)
            this.token(')')
          }

          function SequenceExpression(node) {
            this.printList(node.expressions, node)
          }

          function ThisExpression() {
            this.word('this')
          }

          function Super() {
            this.word('super')
          }

          function Decorator(node) {
            this.token('@')
            this.print(node.expression, node)
            this.newline()
          }

          function commaSeparatorNewline() {
            this.token(',')
            this.newline()

            if (!this.endsWith('\n')) this.space()
          }

          function CallExpression(node) {
            this.print(node.callee, node)

            this.token('(')

            var isPrettyCall = node._prettyCall

            var separator = void 0
            if (isPrettyCall) {
              separator = commaSeparatorNewline
              this.newline()
              this.indent()
            }

            this.printList(node.arguments, node, { separator: separator })

            if (isPrettyCall) {
              this.newline()
              this.dedent()
            }

            this.token(')')
          }

          function Import() {
            this.word('import')
          }

          function buildYieldAwait(keyword) {
            return function(node) {
              this.word(keyword)

              if (node.delegate) {
                this.token('*')
              }

              if (node.argument) {
                this.space()
                var terminatorState = this.startTerminatorless()
                this.print(node.argument, node)
                this.endTerminatorless(terminatorState)
              }
            }
          }

          var YieldExpression = (exports.YieldExpression = buildYieldAwait(
            'yield'
          ))
          var AwaitExpression = (exports.AwaitExpression = buildYieldAwait(
            'await'
          ))

          function EmptyStatement() {
            this.semicolon(true)
          }

          function ExpressionStatement(node) {
            this.print(node.expression, node)
            this.semicolon()
          }

          function AssignmentPattern(node) {
            this.print(node.left, node)
            if (node.left.optional) this.token('?')
            this.print(node.left.typeAnnotation, node)
            this.space()
            this.token('=')
            this.space()
            this.print(node.right, node)
          }

          function AssignmentExpression(node, parent) {
            var parens =
              this.inForStatementInitCounter &&
              node.operator === 'in' &&
              !n.needsParens(node, parent)

            if (parens) {
              this.token('(')
            }

            this.print(node.left, node)

            this.space()
            if (node.operator === 'in' || node.operator === 'instanceof') {
              this.word(node.operator)
            } else {
              this.token(node.operator)
            }
            this.space()

            this.print(node.right, node)

            if (parens) {
              this.token(')')
            }
          }

          function BindExpression(node) {
            this.print(node.object, node)
            this.token('::')
            this.print(node.callee, node)
          }

          exports.BinaryExpression = AssignmentExpression
          exports.LogicalExpression = AssignmentExpression
          function MemberExpression(node) {
            this.print(node.object, node)

            if (!node.computed && t.isMemberExpression(node.property)) {
              throw new TypeError(
                'Got a MemberExpression for MemberExpression property'
              )
            }

            var computed = node.computed
            if (
              t.isLiteral(node.property) &&
              typeof node.property.value === 'number'
            ) {
              computed = true
            }

            if (computed) {
              this.token('[')
              this.print(node.property, node)
              this.token(']')
            } else {
              this.token('.')
              this.print(node.property, node)
            }
          }

          function MetaProperty(node) {
            this.print(node.meta, node)
            this.token('.')
            this.print(node.property, node)
          }
        },
        { '../node': 45, 'babel-types': 110 },
      ],
      37: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true
          exports.AnyTypeAnnotation = AnyTypeAnnotation
          exports.ArrayTypeAnnotation = ArrayTypeAnnotation
          exports.BooleanTypeAnnotation = BooleanTypeAnnotation
          exports.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation
          exports.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation
          exports.DeclareClass = DeclareClass
          exports.DeclareFunction = DeclareFunction
          exports.DeclareInterface = DeclareInterface
          exports.DeclareModule = DeclareModule
          exports.DeclareModuleExports = DeclareModuleExports
          exports.DeclareTypeAlias = DeclareTypeAlias
          exports.DeclareVariable = DeclareVariable
          exports.ExistentialTypeParam = ExistentialTypeParam
          exports.FunctionTypeAnnotation = FunctionTypeAnnotation
          exports.FunctionTypeParam = FunctionTypeParam
          exports.InterfaceExtends = InterfaceExtends
          exports._interfaceish = _interfaceish
          exports._variance = _variance
          exports.InterfaceDeclaration = InterfaceDeclaration
          exports.IntersectionTypeAnnotation = IntersectionTypeAnnotation
          exports.MixedTypeAnnotation = MixedTypeAnnotation
          exports.EmptyTypeAnnotation = EmptyTypeAnnotation
          exports.NullableTypeAnnotation = NullableTypeAnnotation

          var _types = require('./types')

          Object.defineProperty(exports, 'NumericLiteralTypeAnnotation', {
            enumerable: true,
            get: function get() {
              return _types.NumericLiteral
            },
          })
          Object.defineProperty(exports, 'StringLiteralTypeAnnotation', {
            enumerable: true,
            get: function get() {
              return _types.StringLiteral
            },
          })
          exports.NumberTypeAnnotation = NumberTypeAnnotation
          exports.StringTypeAnnotation = StringTypeAnnotation
          exports.ThisTypeAnnotation = ThisTypeAnnotation
          exports.TupleTypeAnnotation = TupleTypeAnnotation
          exports.TypeofTypeAnnotation = TypeofTypeAnnotation
          exports.TypeAlias = TypeAlias
          exports.TypeAnnotation = TypeAnnotation
          exports.TypeParameter = TypeParameter
          exports.TypeParameterInstantiation = TypeParameterInstantiation
          exports.ObjectTypeAnnotation = ObjectTypeAnnotation
          exports.ObjectTypeCallProperty = ObjectTypeCallProperty
          exports.ObjectTypeIndexer = ObjectTypeIndexer
          exports.ObjectTypeProperty = ObjectTypeProperty
          exports.QualifiedTypeIdentifier = QualifiedTypeIdentifier
          exports.UnionTypeAnnotation = UnionTypeAnnotation
          exports.TypeCastExpression = TypeCastExpression
          exports.VoidTypeAnnotation = VoidTypeAnnotation
          function AnyTypeAnnotation() {
            this.word('any')
          }

          function ArrayTypeAnnotation(node) {
            this.print(node.elementType, node)
            this.token('[')
            this.token(']')
          }

          function BooleanTypeAnnotation() {
            this.word('boolean')
          }

          function BooleanLiteralTypeAnnotation(node) {
            this.word(node.value ? 'true' : 'false')
          }

          function NullLiteralTypeAnnotation() {
            this.word('null')
          }

          function DeclareClass(node) {
            this.word('declare')
            this.space()
            this.word('class')
            this.space()
            this._interfaceish(node)
          }

          function DeclareFunction(node) {
            this.word('declare')
            this.space()
            this.word('function')
            this.space()
            this.print(node.id, node)
            this.print(node.id.typeAnnotation.typeAnnotation, node)
            this.semicolon()
          }

          function DeclareInterface(node) {
            this.word('declare')
            this.space()
            this.InterfaceDeclaration(node)
          }

          function DeclareModule(node) {
            this.word('declare')
            this.space()
            this.word('module')
            this.space()
            this.print(node.id, node)
            this.space()
            this.print(node.body, node)
          }

          function DeclareModuleExports(node) {
            this.word('declare')
            this.space()
            this.word('module')
            this.token('.')
            this.word('exports')
            this.print(node.typeAnnotation, node)
          }

          function DeclareTypeAlias(node) {
            this.word('declare')
            this.space()
            this.TypeAlias(node)
          }

          function DeclareVariable(node) {
            this.word('declare')
            this.space()
            this.word('var')
            this.space()
            this.print(node.id, node)
            this.print(node.id.typeAnnotation, node)
            this.semicolon()
          }

          function ExistentialTypeParam() {
            this.token('*')
          }

          function FunctionTypeAnnotation(node, parent) {
            this.print(node.typeParameters, node)
            this.token('(')
            this.printList(node.params, node)

            if (node.rest) {
              if (node.params.length) {
                this.token(',')
                this.space()
              }
              this.token('...')
              this.print(node.rest, node)
            }

            this.token(')')

            if (
              parent.type === 'ObjectTypeCallProperty' ||
              parent.type === 'DeclareFunction'
            ) {
              this.token(':')
            } else {
              this.space()
              this.token('=>')
            }

            this.space()
            this.print(node.returnType, node)
          }

          function FunctionTypeParam(node) {
            this.print(node.name, node)
            if (node.optional) this.token('?')
            this.token(':')
            this.space()
            this.print(node.typeAnnotation, node)
          }

          function InterfaceExtends(node) {
            this.print(node.id, node)
            this.print(node.typeParameters, node)
          }

          exports.ClassImplements = InterfaceExtends
          exports.GenericTypeAnnotation = InterfaceExtends
          function _interfaceish(node) {
            this.print(node.id, node)
            this.print(node.typeParameters, node)
            if (node.extends.length) {
              this.space()
              this.word('extends')
              this.space()
              this.printList(node.extends, node)
            }
            if (node.mixins && node.mixins.length) {
              this.space()
              this.word('mixins')
              this.space()
              this.printList(node.mixins, node)
            }
            this.space()
            this.print(node.body, node)
          }

          function _variance(node) {
            if (node.variance === 'plus') {
              this.token('+')
            } else if (node.variance === 'minus') {
              this.token('-')
            }
          }

          function InterfaceDeclaration(node) {
            this.word('interface')
            this.space()
            this._interfaceish(node)
          }

          function andSeparator() {
            this.space()
            this.token('&')
            this.space()
          }

          function IntersectionTypeAnnotation(node) {
            this.printJoin(node.types, node, { separator: andSeparator })
          }

          function MixedTypeAnnotation() {
            this.word('mixed')
          }

          function EmptyTypeAnnotation() {
            this.word('empty')
          }

          function NullableTypeAnnotation(node) {
            this.token('?')
            this.print(node.typeAnnotation, node)
          }

          function NumberTypeAnnotation() {
            this.word('number')
          }

          function StringTypeAnnotation() {
            this.word('string')
          }

          function ThisTypeAnnotation() {
            this.word('this')
          }

          function TupleTypeAnnotation(node) {
            this.token('[')
            this.printList(node.types, node)
            this.token(']')
          }

          function TypeofTypeAnnotation(node) {
            this.word('typeof')
            this.space()
            this.print(node.argument, node)
          }

          function TypeAlias(node) {
            this.word('type')
            this.space()
            this.print(node.id, node)
            this.print(node.typeParameters, node)
            this.space()
            this.token('=')
            this.space()
            this.print(node.right, node)
            this.semicolon()
          }

          function TypeAnnotation(node) {
            this.token(':')
            this.space()
            if (node.optional) this.token('?')
            this.print(node.typeAnnotation, node)
          }

          function TypeParameter(node) {
            this._variance(node)

            this.word(node.name)

            if (node.bound) {
              this.print(node.bound, node)
            }

            if (node.default) {
              this.space()
              this.token('=')
              this.space()
              this.print(node.default, node)
            }
          }

          function TypeParameterInstantiation(node) {
            this.token('<')
            this.printList(node.params, node, {})
            this.token('>')
          }

          exports.TypeParameterDeclaration = TypeParameterInstantiation
          function ObjectTypeAnnotation(node) {
            var _this = this

            if (node.exact) {
              this.token('{|')
            } else {
              this.token('{')
            }

            var props = node.properties.concat(
              node.callProperties,
              node.indexers
            )

            if (props.length) {
              this.space()

              this.printJoin(props, node, {
                addNewlines: function addNewlines(leading) {
                  if (leading && !props[0]) return 1
                },

                indent: true,
                statement: true,
                iterator: function iterator() {
                  if (props.length !== 1) {
                    if (_this.format.flowCommaSeparator) {
                      _this.token(',')
                    } else {
                      _this.semicolon()
                    }
                    _this.space()
                  }
                },
              })

              this.space()
            }

            if (node.exact) {
              this.token('|}')
            } else {
              this.token('}')
            }
          }

          function ObjectTypeCallProperty(node) {
            if (node.static) {
              this.word('static')
              this.space()
            }
            this.print(node.value, node)
          }

          function ObjectTypeIndexer(node) {
            if (node.static) {
              this.word('static')
              this.space()
            }
            this._variance(node)
            this.token('[')
            this.print(node.id, node)
            this.token(':')
            this.space()
            this.print(node.key, node)
            this.token(']')
            this.token(':')
            this.space()
            this.print(node.value, node)
          }

          function ObjectTypeProperty(node) {
            if (node.static) {
              this.word('static')
              this.space()
            }
            this._variance(node)
            this.print(node.key, node)
            if (node.optional) this.token('?')
            this.token(':')
            this.space()
            this.print(node.value, node)
          }

          function QualifiedTypeIdentifier(node) {
            this.print(node.qualification, node)
            this.token('.')
            this.print(node.id, node)
          }

          function orSeparator() {
            this.space()
            this.token('|')
            this.space()
          }

          function UnionTypeAnnotation(node) {
            this.printJoin(node.types, node, { separator: orSeparator })
          }

          function TypeCastExpression(node) {
            this.token('(')
            this.print(node.expression, node)
            this.print(node.typeAnnotation, node)
            this.token(')')
          }

          function VoidTypeAnnotation() {
            this.word('void')
          }
        },
        { './types': 43 },
      ],
      38: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true

          var _getIterator2 = require('babel-runtime/core-js/get-iterator')

          var _getIterator3 = _interopRequireDefault(_getIterator2)

          exports.JSXAttribute = JSXAttribute
          exports.JSXIdentifier = JSXIdentifier
          exports.JSXNamespacedName = JSXNamespacedName
          exports.JSXMemberExpression = JSXMemberExpression
          exports.JSXSpreadAttribute = JSXSpreadAttribute
          exports.JSXExpressionContainer = JSXExpressionContainer
          exports.JSXSpreadChild = JSXSpreadChild
          exports.JSXText = JSXText
          exports.JSXElement = JSXElement
          exports.JSXOpeningElement = JSXOpeningElement
          exports.JSXClosingElement = JSXClosingElement
          exports.JSXEmptyExpression = JSXEmptyExpression

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          function JSXAttribute(node) {
            this.print(node.name, node)
            if (node.value) {
              this.token('=')
              this.print(node.value, node)
            }
          }

          function JSXIdentifier(node) {
            this.word(node.name)
          }

          function JSXNamespacedName(node) {
            this.print(node.namespace, node)
            this.token(':')
            this.print(node.name, node)
          }

          function JSXMemberExpression(node) {
            this.print(node.object, node)
            this.token('.')
            this.print(node.property, node)
          }

          function JSXSpreadAttribute(node) {
            this.token('{')
            this.token('...')
            this.print(node.argument, node)
            this.token('}')
          }

          function JSXExpressionContainer(node) {
            this.token('{')
            this.print(node.expression, node)
            this.token('}')
          }

          function JSXSpreadChild(node) {
            this.token('{')
            this.token('...')
            this.print(node.expression, node)
            this.token('}')
          }

          function JSXText(node) {
            this.token(node.value)
          }

          function JSXElement(node) {
            var open = node.openingElement
            this.print(open, node)
            if (open.selfClosing) return

            this.indent()
            for (
              var _iterator = node.children,
                _isArray = Array.isArray(_iterator),
                _i = 0,
                _iterator = _isArray
                  ? _iterator
                  : (0, _getIterator3.default)(_iterator);
              ;

            ) {
              var _ref

              if (_isArray) {
                if (_i >= _iterator.length) break
                _ref = _iterator[_i++]
              } else {
                _i = _iterator.next()
                if (_i.done) break
                _ref = _i.value
              }

              var child = _ref

              this.print(child, node)
            }
            this.dedent()

            this.print(node.closingElement, node)
          }

          function spaceSeparator() {
            this.space()
          }

          function JSXOpeningElement(node) {
            this.token('<')
            this.print(node.name, node)
            if (node.attributes.length > 0) {
              this.space()
              this.printJoin(node.attributes, node, {
                separator: spaceSeparator,
              })
            }
            if (node.selfClosing) {
              this.space()
              this.token('/>')
            } else {
              this.token('>')
            }
          }

          function JSXClosingElement(node) {
            this.token('</')
            this.print(node.name, node)
            this.token('>')
          }

          function JSXEmptyExpression() {}
        },
        { 'babel-runtime/core-js/get-iterator': 54 },
      ],
      39: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true
          exports.FunctionDeclaration = undefined
          exports._params = _params
          exports._method = _method
          exports.FunctionExpression = FunctionExpression
          exports.ArrowFunctionExpression = ArrowFunctionExpression

          var _babelTypes = require('babel-types')

          var t = _interopRequireWildcard(_babelTypes)

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj
            } else {
              var newObj = {}
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key]
                }
              }
              newObj.default = obj
              return newObj
            }
          }

          function _params(node) {
            var _this = this

            this.print(node.typeParameters, node)
            this.token('(')
            this.printList(node.params, node, {
              iterator: function iterator(node) {
                if (node.optional) _this.token('?')
                _this.print(node.typeAnnotation, node)
              },
            })
            this.token(')')

            if (node.returnType) {
              this.print(node.returnType, node)
            }
          }

          function _method(node) {
            var kind = node.kind
            var key = node.key

            if (kind === 'method' || kind === 'init') {
              if (node.generator) {
                this.token('*')
              }
            }

            if (kind === 'get' || kind === 'set') {
              this.word(kind)
              this.space()
            }

            if (node.async) {
              this.word('async')
              this.space()
            }

            if (node.computed) {
              this.token('[')
              this.print(key, node)
              this.token(']')
            } else {
              this.print(key, node)
            }

            this._params(node)
            this.space()
            this.print(node.body, node)
          }

          function FunctionExpression(node) {
            if (node.async) {
              this.word('async')
              this.space()
            }
            this.word('function')
            if (node.generator) this.token('*')

            if (node.id) {
              this.space()
              this.print(node.id, node)
            } else {
              this.space()
            }

            this._params(node)
            this.space()
            this.print(node.body, node)
          }

          exports.FunctionDeclaration = FunctionExpression
          function ArrowFunctionExpression(node) {
            if (node.async) {
              this.word('async')
              this.space()
            }

            var firstParam = node.params[0]

            if (
              node.params.length === 1 &&
              t.isIdentifier(firstParam) &&
              !hasTypes(node, firstParam)
            ) {
              this.print(firstParam, node)
            } else {
              this._params(node)
            }

            this.space()
            this.token('=>')
            this.space()

            this.print(node.body, node)
          }

          function hasTypes(node, param) {
            return (
              node.typeParameters ||
              node.returnType ||
              param.typeAnnotation ||
              param.optional ||
              param.trailingComments
            )
          }
        },
        { 'babel-types': 110 },
      ],
      40: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true
          exports.ImportSpecifier = ImportSpecifier
          exports.ImportDefaultSpecifier = ImportDefaultSpecifier
          exports.ExportDefaultSpecifier = ExportDefaultSpecifier
          exports.ExportSpecifier = ExportSpecifier
          exports.ExportNamespaceSpecifier = ExportNamespaceSpecifier
          exports.ExportAllDeclaration = ExportAllDeclaration
          exports.ExportNamedDeclaration = ExportNamedDeclaration
          exports.ExportDefaultDeclaration = ExportDefaultDeclaration
          exports.ImportDeclaration = ImportDeclaration
          exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier

          var _babelTypes = require('babel-types')

          var t = _interopRequireWildcard(_babelTypes)

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj
            } else {
              var newObj = {}
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key]
                }
              }
              newObj.default = obj
              return newObj
            }
          }

          function ImportSpecifier(node) {
            if (node.importKind === 'type' || node.importKind === 'typeof') {
              this.word(node.importKind)
              this.space()
            }

            this.print(node.imported, node)
            if (node.local && node.local.name !== node.imported.name) {
              this.space()
              this.word('as')
              this.space()
              this.print(node.local, node)
            }
          }

          function ImportDefaultSpecifier(node) {
            this.print(node.local, node)
          }

          function ExportDefaultSpecifier(node) {
            this.print(node.exported, node)
          }

          function ExportSpecifier(node) {
            this.print(node.local, node)
            if (node.exported && node.local.name !== node.exported.name) {
              this.space()
              this.word('as')
              this.space()
              this.print(node.exported, node)
            }
          }

          function ExportNamespaceSpecifier(node) {
            this.token('*')
            this.space()
            this.word('as')
            this.space()
            this.print(node.exported, node)
          }

          function ExportAllDeclaration(node) {
            this.word('export')
            this.space()
            this.token('*')
            this.space()
            this.word('from')
            this.space()
            this.print(node.source, node)
            this.semicolon()
          }

          function ExportNamedDeclaration() {
            this.word('export')
            this.space()
            ExportDeclaration.apply(this, arguments)
          }

          function ExportDefaultDeclaration() {
            this.word('export')
            this.space()
            this.word('default')
            this.space()
            ExportDeclaration.apply(this, arguments)
          }

          function ExportDeclaration(node) {
            if (node.declaration) {
              var declar = node.declaration
              this.print(declar, node)
              if (!t.isStatement(declar)) this.semicolon()
            } else {
              if (node.exportKind === 'type') {
                this.word('type')
                this.space()
              }

              var specifiers = node.specifiers.slice(0)

              var hasSpecial = false
              while (true) {
                var first = specifiers[0]
                if (
                  t.isExportDefaultSpecifier(first) ||
                  t.isExportNamespaceSpecifier(first)
                ) {
                  hasSpecial = true
                  this.print(specifiers.shift(), node)
                  if (specifiers.length) {
                    this.token(',')
                    this.space()
                  }
                } else {
                  break
                }
              }

              if (specifiers.length || (!specifiers.length && !hasSpecial)) {
                this.token('{')
                if (specifiers.length) {
                  this.space()
                  this.printList(specifiers, node)
                  this.space()
                }
                this.token('}')
              }

              if (node.source) {
                this.space()
                this.word('from')
                this.space()
                this.print(node.source, node)
              }

              this.semicolon()
            }
          }

          function ImportDeclaration(node) {
            this.word('import')
            this.space()

            if (node.importKind === 'type' || node.importKind === 'typeof') {
              this.word(node.importKind)
              this.space()
            }

            var specifiers = node.specifiers.slice(0)
            if (specifiers && specifiers.length) {
              while (true) {
                var first = specifiers[0]
                if (
                  t.isImportDefaultSpecifier(first) ||
                  t.isImportNamespaceSpecifier(first)
                ) {
                  this.print(specifiers.shift(), node)
                  if (specifiers.length) {
                    this.token(',')
                    this.space()
                  }
                } else {
                  break
                }
              }

              if (specifiers.length) {
                this.token('{')
                this.space()
                this.printList(specifiers, node)
                this.space()
                this.token('}')
              }

              this.space()
              this.word('from')
              this.space()
            }

            this.print(node.source, node)
            this.semicolon()
          }

          function ImportNamespaceSpecifier(node) {
            this.token('*')
            this.space()
            this.word('as')
            this.space()
            this.print(node.local, node)
          }
        },
        { 'babel-types': 110 },
      ],
      41: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true
          exports.ThrowStatement = exports.BreakStatement = exports.ReturnStatement = exports.ContinueStatement = exports.ForAwaitStatement = exports.ForOfStatement = exports.ForInStatement = undefined

          var _getIterator2 = require('babel-runtime/core-js/get-iterator')

          var _getIterator3 = _interopRequireDefault(_getIterator2)

          exports.WithStatement = WithStatement
          exports.IfStatement = IfStatement
          exports.ForStatement = ForStatement
          exports.WhileStatement = WhileStatement
          exports.DoWhileStatement = DoWhileStatement
          exports.LabeledStatement = LabeledStatement
          exports.TryStatement = TryStatement
          exports.CatchClause = CatchClause
          exports.SwitchStatement = SwitchStatement
          exports.SwitchCase = SwitchCase
          exports.DebuggerStatement = DebuggerStatement
          exports.VariableDeclaration = VariableDeclaration
          exports.VariableDeclarator = VariableDeclarator

          var _babelTypes = require('babel-types')

          var t = _interopRequireWildcard(_babelTypes)

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj
            } else {
              var newObj = {}
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key]
                }
              }
              newObj.default = obj
              return newObj
            }
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          function WithStatement(node) {
            this.word('with')
            this.space()
            this.token('(')
            this.print(node.object, node)
            this.token(')')
            this.printBlock(node)
          }

          function IfStatement(node) {
            this.word('if')
            this.space()
            this.token('(')
            this.print(node.test, node)
            this.token(')')
            this.space()

            var needsBlock =
              node.alternate &&
              t.isIfStatement(getLastStatement(node.consequent))
            if (needsBlock) {
              this.token('{')
              this.newline()
              this.indent()
            }

            this.printAndIndentOnComments(node.consequent, node)

            if (needsBlock) {
              this.dedent()
              this.newline()
              this.token('}')
            }

            if (node.alternate) {
              if (this.endsWith('}')) this.space()
              this.word('else')
              this.space()
              this.printAndIndentOnComments(node.alternate, node)
            }
          }

          function getLastStatement(statement) {
            if (!t.isStatement(statement.body)) return statement
            return getLastStatement(statement.body)
          }

          function ForStatement(node) {
            this.word('for')
            this.space()
            this.token('(')

            this.inForStatementInitCounter++
            this.print(node.init, node)
            this.inForStatementInitCounter--
            this.token(';')

            if (node.test) {
              this.space()
              this.print(node.test, node)
            }
            this.token(';')

            if (node.update) {
              this.space()
              this.print(node.update, node)
            }

            this.token(')')
            this.printBlock(node)
          }

          function WhileStatement(node) {
            this.word('while')
            this.space()
            this.token('(')
            this.print(node.test, node)
            this.token(')')
            this.printBlock(node)
          }

          var buildForXStatement = function buildForXStatement(op) {
            return function(node) {
              this.word('for')
              this.space()
              if (op === 'await') {
                this.word('await')
                this.space()
              }
              this.token('(')

              this.print(node.left, node)
              this.space()
              this.word(op === 'await' ? 'of' : op)
              this.space()
              this.print(node.right, node)
              this.token(')')
              this.printBlock(node)
            }
          }

          var ForInStatement = (exports.ForInStatement = buildForXStatement(
            'in'
          ))
          var ForOfStatement = (exports.ForOfStatement = buildForXStatement(
            'of'
          ))
          var ForAwaitStatement = (exports.ForAwaitStatement = buildForXStatement(
            'await'
          ))

          function DoWhileStatement(node) {
            this.word('do')
            this.space()
            this.print(node.body, node)
            this.space()
            this.word('while')
            this.space()
            this.token('(')
            this.print(node.test, node)
            this.token(')')
            this.semicolon()
          }

          function buildLabelStatement(prefix) {
            var key = arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : 'label'

            return function(node) {
              this.word(prefix)

              var label = node[key]
              if (label) {
                this.space()

                var terminatorState = this.startTerminatorless()
                this.print(label, node)
                this.endTerminatorless(terminatorState)
              }

              this.semicolon()
            }
          }

          var ContinueStatement = (exports.ContinueStatement = buildLabelStatement(
            'continue'
          ))
          var ReturnStatement = (exports.ReturnStatement = buildLabelStatement(
            'return',
            'argument'
          ))
          var BreakStatement = (exports.BreakStatement = buildLabelStatement(
            'break'
          ))
          var ThrowStatement = (exports.ThrowStatement = buildLabelStatement(
            'throw',
            'argument'
          ))

          function LabeledStatement(node) {
            this.print(node.label, node)
            this.token(':')
            this.space()
            this.print(node.body, node)
          }

          function TryStatement(node) {
            this.word('try')
            this.space()
            this.print(node.block, node)
            this.space()

            if (node.handlers) {
              this.print(node.handlers[0], node)
            } else {
              this.print(node.handler, node)
            }

            if (node.finalizer) {
              this.space()
              this.word('finally')
              this.space()
              this.print(node.finalizer, node)
            }
          }

          function CatchClause(node) {
            this.word('catch')
            this.space()
            this.token('(')
            this.print(node.param, node)
            this.token(')')
            this.space()
            this.print(node.body, node)
          }

          function SwitchStatement(node) {
            this.word('switch')
            this.space()
            this.token('(')
            this.print(node.discriminant, node)
            this.token(')')
            this.space()
            this.token('{')

            this.printSequence(node.cases, node, {
              indent: true,
              addNewlines: function addNewlines(leading, cas) {
                if (!leading && node.cases[node.cases.length - 1] === cas)
                  return -1
              },
            })

            this.token('}')
          }

          function SwitchCase(node) {
            if (node.test) {
              this.word('case')
              this.space()
              this.print(node.test, node)
              this.token(':')
            } else {
              this.word('default')
              this.token(':')
            }

            if (node.consequent.length) {
              this.newline()
              this.printSequence(node.consequent, node, { indent: true })
            }
          }

          function DebuggerStatement() {
            this.word('debugger')
            this.semicolon()
          }

          function variableDeclarationIdent() {
            this.token(',')
            this.newline()
            if (this.endsWith('\n'))
              for (var i = 0; i < 4; i++) {
                this.space(true)
              }
          }

          function constDeclarationIdent() {
            this.token(',')
            this.newline()
            if (this.endsWith('\n'))
              for (var i = 0; i < 6; i++) {
                this.space(true)
              }
          }

          function VariableDeclaration(node, parent) {
            this.word(node.kind)
            this.space()

            var hasInits = false

            if (!t.isFor(parent)) {
              for (
                var _iterator = node.declarations,
                  _isArray = Array.isArray(_iterator),
                  _i = 0,
                  _iterator = _isArray
                    ? _iterator
                    : (0, _getIterator3.default)(_iterator);
                ;

              ) {
                var _ref

                if (_isArray) {
                  if (_i >= _iterator.length) break
                  _ref = _iterator[_i++]
                } else {
                  _i = _iterator.next()
                  if (_i.done) break
                  _ref = _i.value
                }

                var declar = _ref

                if (declar.init) {
                  hasInits = true
                }
              }
            }

            var separator = void 0
            if (hasInits) {
              separator = node.kind === 'const'
                ? constDeclarationIdent
                : variableDeclarationIdent
            }

            this.printList(node.declarations, node, { separator: separator })

            if (t.isFor(parent)) {
              if (parent.left === node || parent.init === node) return
            }

            this.semicolon()
          }

          function VariableDeclarator(node) {
            this.print(node.id, node)
            this.print(node.id.typeAnnotation, node)
            if (node.init) {
              this.space()
              this.token('=')
              this.space()
              this.print(node.init, node)
            }
          }
        },
        { 'babel-runtime/core-js/get-iterator': 54, 'babel-types': 110 },
      ],
      42: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true
          exports.TaggedTemplateExpression = TaggedTemplateExpression
          exports.TemplateElement = TemplateElement
          exports.TemplateLiteral = TemplateLiteral
          function TaggedTemplateExpression(node) {
            this.print(node.tag, node)
            this.print(node.quasi, node)
          }

          function TemplateElement(node, parent) {
            var isFirst = parent.quasis[0] === node
            var isLast = parent.quasis[parent.quasis.length - 1] === node

            var value =
              (isFirst ? '`' : '}') + node.value.raw + (isLast ? '`' : '${')

            this.token(value)
          }

          function TemplateLiteral(node) {
            var quasis = node.quasis

            for (var i = 0; i < quasis.length; i++) {
              this.print(quasis[i], node)

              if (i + 1 < quasis.length) {
                this.print(node.expressions[i], node)
              }
            }
          }
        },
        {},
      ],
      43: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true
          exports.ArrayPattern = exports.ObjectPattern = exports.RestProperty = exports.SpreadProperty = exports.SpreadElement = undefined
          exports.Identifier = Identifier
          exports.RestElement = RestElement
          exports.ObjectExpression = ObjectExpression
          exports.ObjectMethod = ObjectMethod
          exports.ObjectProperty = ObjectProperty
          exports.ArrayExpression = ArrayExpression
          exports.RegExpLiteral = RegExpLiteral
          exports.BooleanLiteral = BooleanLiteral
          exports.NullLiteral = NullLiteral
          exports.NumericLiteral = NumericLiteral
          exports.StringLiteral = StringLiteral

          var _babelTypes = require('babel-types')

          var t = _interopRequireWildcard(_babelTypes)

          var _jsesc = require('jsesc')

          var _jsesc2 = _interopRequireDefault(_jsesc)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj
            } else {
              var newObj = {}
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key]
                }
              }
              newObj.default = obj
              return newObj
            }
          }

          function Identifier(node) {
            if (node.variance) {
              if (node.variance === 'plus') {
                this.token('+')
              } else if (node.variance === 'minus') {
                this.token('-')
              }
            }

            this.word(node.name)
          }

          function RestElement(node) {
            this.token('...')
            this.print(node.argument, node)
          }

          exports.SpreadElement = RestElement
          exports.SpreadProperty = RestElement
          exports.RestProperty = RestElement
          function ObjectExpression(node) {
            var props = node.properties

            this.token('{')
            this.printInnerComments(node)

            if (props.length) {
              this.space()
              this.printList(props, node, { indent: true, statement: true })
              this.space()
            }

            this.token('}')
          }

          exports.ObjectPattern = ObjectExpression
          function ObjectMethod(node) {
            this.printJoin(node.decorators, node)
            this._method(node)
          }

          function ObjectProperty(node) {
            this.printJoin(node.decorators, node)

            if (node.computed) {
              this.token('[')
              this.print(node.key, node)
              this.token(']')
            } else {
              if (
                t.isAssignmentPattern(node.value) &&
                t.isIdentifier(node.key) &&
                node.key.name === node.value.left.name
              ) {
                this.print(node.value, node)
                return
              }

              this.print(node.key, node)

              if (
                node.shorthand &&
                t.isIdentifier(node.key) &&
                t.isIdentifier(node.value) &&
                node.key.name === node.value.name
              ) {
                return
              }
            }

            this.token(':')
            this.space()
            this.print(node.value, node)
          }

          function ArrayExpression(node) {
            var elems = node.elements
            var len = elems.length

            this.token('[')
            this.printInnerComments(node)

            for (var i = 0; i < elems.length; i++) {
              var elem = elems[i]
              if (elem) {
                if (i > 0) this.space()
                this.print(elem, node)
                if (i < len - 1) this.token(',')
              } else {
                this.token(',')
              }
            }

            this.token(']')
          }

          exports.ArrayPattern = ArrayExpression
          function RegExpLiteral(node) {
            this.word('/' + node.pattern + '/' + node.flags)
          }

          function BooleanLiteral(node) {
            this.word(node.value ? 'true' : 'false')
          }

          function NullLiteral() {
            this.word('null')
          }

          function NumericLiteral(node) {
            var raw = this.getPossibleRaw(node)
            var value = node.value + ''
            if (raw == null) {
              this.number(value)
            } else if (this.format.minified) {
              this.number(raw.length < value.length ? raw : value)
            } else {
              this.number(raw)
            }
          }

          function StringLiteral(node, parent) {
            var raw = this.getPossibleRaw(node)
            if (!this.format.minified && raw != null) {
              this.token(raw)
              return
            }

            var opts = {
              quotes: t.isJSX(parent) ? 'double' : this.format.quotes,
              wrap: true,
            }
            if (this.format.jsonCompatibleStrings) {
              opts.json = true
            }
            var val = (0, _jsesc2.default)(node.value, opts)

            return this.token(val)
          }
        },
        { 'babel-types': 110, jsesc: 289 },
      ],
      44: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true
          exports.CodeGenerator = undefined

          var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck')

          var _classCallCheck3 = _interopRequireDefault(_classCallCheck2)

          var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn')

          var _possibleConstructorReturn3 = _interopRequireDefault(
            _possibleConstructorReturn2
          )

          var _inherits2 = require('babel-runtime/helpers/inherits')

          var _inherits3 = _interopRequireDefault(_inherits2)

          exports.default = function(ast, opts, code) {
            var gen = new Generator(ast, opts, code)
            return gen.generate()
          }

          var _detectIndent = require('detect-indent')

          var _detectIndent2 = _interopRequireDefault(_detectIndent)

          var _sourceMap = require('./source-map')

          var _sourceMap2 = _interopRequireDefault(_sourceMap)

          var _babelMessages = require('babel-messages')

          var messages = _interopRequireWildcard(_babelMessages)

          var _printer = require('./printer')

          var _printer2 = _interopRequireDefault(_printer)

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj
            } else {
              var newObj = {}
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key]
                }
              }
              newObj.default = obj
              return newObj
            }
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          var Generator = (function(_Printer) {
            ;(0, _inherits3.default)(Generator, _Printer)

            function Generator(ast) {
              var opts = arguments.length > 1 && arguments[1] !== undefined
                ? arguments[1]
                : {}
              var code = arguments[2]
              ;(0, _classCallCheck3.default)(this, Generator)

              var tokens = ast.tokens || []
              var format = normalizeOptions(code, opts, tokens)
              var map = opts.sourceMaps
                ? new _sourceMap2.default(opts, code)
                : null

              var _this = (0, _possibleConstructorReturn3.default)(
                this,
                _Printer.call(this, format, map, tokens)
              )

              _this.ast = ast
              return _this
            }

            Generator.prototype.generate = function generate() {
              return _Printer.prototype.generate.call(this, this.ast)
            }

            return Generator
          })(_printer2.default)

          function normalizeOptions(code, opts, tokens) {
            var style = '  '
            if (code && typeof code === 'string') {
              var indent = (0, _detectIndent2.default)(code).indent
              if (indent && indent !== ' ') style = indent
            }

            var format = {
              auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
              auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
              shouldPrintComment: opts.shouldPrintComment,
              retainLines: opts.retainLines,
              retainFunctionParens: opts.retainFunctionParens,
              comments: opts.comments == null || opts.comments,
              compact: opts.compact,
              minified: opts.minified,
              concise: opts.concise,
              quotes: opts.quotes || findCommonStringDelimiter(code, tokens),
              jsonCompatibleStrings: opts.jsonCompatibleStrings,
              indent: {
                adjustMultilineComment: true,
                style: style,
                base: 0,
              },
              flowCommaSeparator: opts.flowCommaSeparator,
            }

            if (format.minified) {
              format.compact = true

              format.shouldPrintComment =
                format.shouldPrintComment ||
                function() {
                  return format.comments
                }
            } else {
              format.shouldPrintComment =
                format.shouldPrintComment ||
                function(value) {
                  return (
                    format.comments ||
                    value.indexOf('@license') >= 0 ||
                    value.indexOf('@preserve') >= 0
                  )
                }
            }

            if (format.compact === 'auto') {
              format.compact = code.length > 500000

              if (format.compact) {
                console.error(
                  '[BABEL] ' +
                    messages.get('codeGeneratorDeopt', opts.filename, '500KB')
                )
              }
            }

            if (format.compact) {
              format.indent.adjustMultilineComment = false
            }

            return format
          }

          function findCommonStringDelimiter(code, tokens) {
            var DEFAULT_STRING_DELIMITER = 'double'
            if (!code) {
              return DEFAULT_STRING_DELIMITER
            }

            var occurrences = {
              single: 0,
              double: 0,
            }

            var checked = 0

            for (var i = 0; i < tokens.length; i++) {
              var token = tokens[i]
              if (token.type.label !== 'string') continue

              var raw = code.slice(token.start, token.end)
              if (raw[0] === "'") {
                occurrences.single++
              } else {
                occurrences.double++
              }

              checked++
              if (checked >= 3) break
            }
            if (occurrences.single > occurrences.double) {
              return 'single'
            } else {
              return 'double'
            }
          }

          var CodeGenerator = (exports.CodeGenerator = (function() {
            function CodeGenerator(ast, opts, code) {
              ;(0, _classCallCheck3.default)(this, CodeGenerator)

              this._generator = new Generator(ast, opts, code)
            }

            CodeGenerator.prototype.generate = function generate() {
              return this._generator.generate()
            }

            return CodeGenerator
          })())
        },
        {
          './printer': 48,
          './source-map': 49,
          'babel-messages': 53,
          'babel-runtime/helpers/classCallCheck': 68,
          'babel-runtime/helpers/inherits': 69,
          'babel-runtime/helpers/possibleConstructorReturn': 71,
          'detect-indent': 246,
        },
      ],
      45: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true

          var _getIterator2 = require('babel-runtime/core-js/get-iterator')

          var _getIterator3 = _interopRequireDefault(_getIterator2)

          var _keys = require('babel-runtime/core-js/object/keys')

          var _keys2 = _interopRequireDefault(_keys)

          exports.needsWhitespace = needsWhitespace
          exports.needsWhitespaceBefore = needsWhitespaceBefore
          exports.needsWhitespaceAfter = needsWhitespaceAfter
          exports.needsParens = needsParens

          var _whitespace = require('./whitespace')

          var _whitespace2 = _interopRequireDefault(_whitespace)

          var _parentheses = require('./parentheses')

          var parens = _interopRequireWildcard(_parentheses)

          var _babelTypes = require('babel-types')

          var t = _interopRequireWildcard(_babelTypes)

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj
            } else {
              var newObj = {}
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key]
                }
              }
              newObj.default = obj
              return newObj
            }
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          function expandAliases(obj) {
            var newObj = {}

            function add(type, func) {
              var fn = newObj[type]
              newObj[type] = fn
                ? function(node, parent, stack) {
                    var result = fn(node, parent, stack)

                    return result == null ? func(node, parent, stack) : result
                  }
                : func
            }

            for (
              var _iterator = (0, _keys2.default)(obj),
                _isArray = Array.isArray(_iterator),
                _i = 0,
                _iterator = _isArray
                  ? _iterator
                  : (0, _getIterator3.default)(_iterator);
              ;

            ) {
              var _ref

              if (_isArray) {
                if (_i >= _iterator.length) break
                _ref = _iterator[_i++]
              } else {
                _i = _iterator.next()
                if (_i.done) break
                _ref = _i.value
              }

              var type = _ref

              var aliases = t.FLIPPED_ALIAS_KEYS[type]
              if (aliases) {
                for (
                  var _iterator2 = aliases,
                    _isArray2 = Array.isArray(_iterator2),
                    _i2 = 0,
                    _iterator2 = _isArray2
                      ? _iterator2
                      : (0, _getIterator3.default)(_iterator2);
                  ;

                ) {
                  var _ref2

                  if (_isArray2) {
                    if (_i2 >= _iterator2.length) break
                    _ref2 = _iterator2[_i2++]
                  } else {
                    _i2 = _iterator2.next()
                    if (_i2.done) break
                    _ref2 = _i2.value
                  }

                  var alias = _ref2

                  add(alias, obj[type])
                }
              } else {
                add(type, obj[type])
              }
            }

            return newObj
          }

          var expandedParens = expandAliases(parens)
          var expandedWhitespaceNodes = expandAliases(
            _whitespace2.default.nodes
          )
          var expandedWhitespaceList = expandAliases(_whitespace2.default.list)

          function find(obj, node, parent, printStack) {
            var fn = obj[node.type]
            return fn ? fn(node, parent, printStack) : null
          }

          function isOrHasCallExpression(node) {
            if (t.isCallExpression(node)) {
              return true
            }

            if (t.isMemberExpression(node)) {
              return (
                isOrHasCallExpression(node.object) ||
                (!node.computed && isOrHasCallExpression(node.property))
              )
            } else {
              return false
            }
          }

          function needsWhitespace(node, parent, type) {
            if (!node) return 0

            if (t.isExpressionStatement(node)) {
              node = node.expression
            }

            var linesInfo = find(expandedWhitespaceNodes, node, parent)

            if (!linesInfo) {
              var items = find(expandedWhitespaceList, node, parent)
              if (items) {
                for (var i = 0; i < items.length; i++) {
                  linesInfo = needsWhitespace(items[i], node, type)
                  if (linesInfo) break
                }
              }
            }

            return (linesInfo && linesInfo[type]) || 0
          }

          function needsWhitespaceBefore(node, parent) {
            return needsWhitespace(node, parent, 'before')
          }

          function needsWhitespaceAfter(node, parent) {
            return needsWhitespace(node, parent, 'after')
          }

          function needsParens(node, parent, printStack) {
            if (!parent) return false

            if (t.isNewExpression(parent) && parent.callee === node) {
              if (isOrHasCallExpression(node)) return true
            }

            return find(expandedParens, node, parent, printStack)
          }
        },
        {
          './parentheses': 46,
          './whitespace': 47,
          'babel-runtime/core-js/get-iterator': 54,
          'babel-runtime/core-js/object/keys': 61,
          'babel-types': 110,
        },
      ],
      46: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true
          exports.AwaitExpression = exports.FunctionTypeAnnotation = undefined
          exports.NullableTypeAnnotation = NullableTypeAnnotation
          exports.UpdateExpression = UpdateExpression
          exports.ObjectExpression = ObjectExpression
          exports.DoExpression = DoExpression
          exports.Binary = Binary
          exports.BinaryExpression = BinaryExpression
          exports.SequenceExpression = SequenceExpression
          exports.YieldExpression = YieldExpression
          exports.ClassExpression = ClassExpression
          exports.UnaryLike = UnaryLike
          exports.FunctionExpression = FunctionExpression
          exports.ArrowFunctionExpression = ArrowFunctionExpression
          exports.ConditionalExpression = ConditionalExpression
          exports.AssignmentExpression = AssignmentExpression

          var _babelTypes = require('babel-types')

          var t = _interopRequireWildcard(_babelTypes)

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj
            } else {
              var newObj = {}
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key]
                }
              }
              newObj.default = obj
              return newObj
            }
          }

          var PRECEDENCE = {
            '||': 0,
            '&&': 1,
            '|': 2,
            '^': 3,
            '&': 4,
            '==': 5,
            '===': 5,
            '!=': 5,
            '!==': 5,
            '<': 6,
            '>': 6,
            '<=': 6,
            '>=': 6,
            in: 6,
            instanceof: 6,
            '>>': 7,
            '<<': 7,
            '>>>': 7,
            '+': 8,
            '-': 8,
            '*': 9,
            '/': 9,
            '%': 9,
            '**': 10,
          }

          function NullableTypeAnnotation(node, parent) {
            return t.isArrayTypeAnnotation(parent)
          }

          exports.FunctionTypeAnnotation = NullableTypeAnnotation
          function UpdateExpression(node, parent) {
            return t.isMemberExpression(parent) && parent.object === node
          }

          function ObjectExpression(node, parent, printStack) {
            return isFirstInStatement(printStack, { considerArrow: true })
          }

          function DoExpression(node, parent, printStack) {
            return isFirstInStatement(printStack)
          }

          function Binary(node, parent) {
            if (
              ((t.isCallExpression(parent) || t.isNewExpression(parent)) &&
                parent.callee === node) ||
              t.isUnaryLike(parent) ||
              (t.isMemberExpression(parent) && parent.object === node) ||
              t.isAwaitExpression(parent)
            ) {
              return true
            }

            if (t.isBinary(parent)) {
              var parentOp = parent.operator
              var parentPos = PRECEDENCE[parentOp]

              var nodeOp = node.operator
              var nodePos = PRECEDENCE[nodeOp]

              if (
                (parentPos === nodePos &&
                  parent.right === node &&
                  !t.isLogicalExpression(parent)) ||
                parentPos > nodePos
              ) {
                return true
              }
            }

            return false
          }

          function BinaryExpression(node, parent) {
            return (
              node.operator === 'in' &&
              (t.isVariableDeclarator(parent) || t.isFor(parent))
            )
          }

          function SequenceExpression(node, parent) {
            if (
              t.isForStatement(parent) ||
              t.isThrowStatement(parent) ||
              t.isReturnStatement(parent) ||
              (t.isIfStatement(parent) && parent.test === node) ||
              (t.isWhileStatement(parent) && parent.test === node) ||
              (t.isForInStatement(parent) && parent.right === node) ||
              (t.isSwitchStatement(parent) && parent.discriminant === node) ||
              (t.isExpressionStatement(parent) && parent.expression === node)
            ) {
              return false
            }

            return true
          }

          function YieldExpression(node, parent) {
            return (
              t.isBinary(parent) ||
              t.isUnaryLike(parent) ||
              t.isCallExpression(parent) ||
              t.isMemberExpression(parent) ||
              t.isNewExpression(parent) ||
              (t.isConditionalExpression(parent) && node === parent.test)
            )
          }

          exports.AwaitExpression = YieldExpression
          function ClassExpression(node, parent, printStack) {
            return isFirstInStatement(printStack, {
              considerDefaultExports: true,
            })
          }

          function UnaryLike(node, parent) {
            return (
              t.isMemberExpression(parent, { object: node }) ||
              t.isCallExpression(parent, { callee: node }) ||
              t.isNewExpression(parent, { callee: node })
            )
          }

          function FunctionExpression(node, parent, printStack) {
            return isFirstInStatement(printStack, {
              considerDefaultExports: true,
            })
          }

          function ArrowFunctionExpression(node, parent) {
            if (
              t.isExportDeclaration(parent) ||
              t.isBinaryExpression(parent) ||
              t.isLogicalExpression(parent) ||
              t.isUnaryExpression(parent) ||
              t.isTaggedTemplateExpression(parent)
            ) {
              return true
            }

            return UnaryLike(node, parent)
          }

          function ConditionalExpression(node, parent) {
            if (
              t.isUnaryLike(parent) ||
              t.isBinary(parent) ||
              t.isConditionalExpression(parent, { test: node }) ||
              t.isAwaitExpression(parent)
            ) {
              return true
            }

            return UnaryLike(node, parent)
          }

          function AssignmentExpression(node) {
            if (t.isObjectPattern(node.left)) {
              return true
            } else {
              return ConditionalExpression.apply(undefined, arguments)
            }
          }

          function isFirstInStatement(printStack) {
            var _ref = arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : {},
              _ref$considerArrow = _ref.considerArrow,
              considerArrow = _ref$considerArrow === undefined
                ? false
                : _ref$considerArrow,
              _ref$considerDefaultE = _ref.considerDefaultExports,
              considerDefaultExports = _ref$considerDefaultE === undefined
                ? false
                : _ref$considerDefaultE

            var i = printStack.length - 1
            var node = printStack[i]
            i--
            var parent = printStack[i]
            while (i > 0) {
              if (
                t.isExpressionStatement(parent, { expression: node }) ||
                t.isTaggedTemplateExpression(parent) ||
                (considerDefaultExports &&
                  t.isExportDefaultDeclaration(parent, {
                    declaration: node,
                  })) ||
                (considerArrow &&
                  t.isArrowFunctionExpression(parent, { body: node }))
              ) {
                return true
              }

              if (
                t.isCallExpression(parent, { callee: node }) ||
                (t.isSequenceExpression(parent) &&
                  parent.expressions[0] === node) ||
                t.isMemberExpression(parent, { object: node }) ||
                t.isConditional(parent, { test: node }) ||
                t.isBinary(parent, { left: node }) ||
                t.isAssignmentExpression(parent, { left: node })
              ) {
                node = parent
                i--
                parent = printStack[i]
              } else {
                return false
              }
            }

            return false
          }
        },
        { 'babel-types': 110 },
      ],
      47: [
        function(require, module, exports) {
          'use strict'
          var _map = require('lodash/map')

          var _map2 = _interopRequireDefault(_map)

          var _babelTypes = require('babel-types')

          var t = _interopRequireWildcard(_babelTypes)

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj
            } else {
              var newObj = {}
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key]
                }
              }
              newObj.default = obj
              return newObj
            }
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          function crawl(node) {
            var state = arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : {}

            if (t.isMemberExpression(node)) {
              crawl(node.object, state)
              if (node.computed) crawl(node.property, state)
            } else if (t.isBinary(node) || t.isAssignmentExpression(node)) {
              crawl(node.left, state)
              crawl(node.right, state)
            } else if (t.isCallExpression(node)) {
              state.hasCall = true
              crawl(node.callee, state)
            } else if (t.isFunction(node)) {
              state.hasFunction = true
            } else if (t.isIdentifier(node)) {
              state.hasHelper = state.hasHelper || isHelper(node.callee)
            }

            return state
          }

          function isHelper(node) {
            if (t.isMemberExpression(node)) {
              return isHelper(node.object) || isHelper(node.property)
            } else if (t.isIdentifier(node)) {
              return node.name === 'require' || node.name[0] === '_'
            } else if (t.isCallExpression(node)) {
              return isHelper(node.callee)
            } else if (t.isBinary(node) || t.isAssignmentExpression(node)) {
              return (
                (t.isIdentifier(node.left) && isHelper(node.left)) ||
                isHelper(node.right)
              )
            } else {
              return false
            }
          }

          function isType(node) {
            return (
              t.isLiteral(node) ||
              t.isObjectExpression(node) ||
              t.isArrayExpression(node) ||
              t.isIdentifier(node) ||
              t.isMemberExpression(node)
            )
          }

          exports.nodes = {
            AssignmentExpression: function AssignmentExpression(node) {
              var state = crawl(node.right)
              if ((state.hasCall && state.hasHelper) || state.hasFunction) {
                return {
                  before: state.hasFunction,
                  after: true,
                }
              }
            },
            SwitchCase: function SwitchCase(node, parent) {
              return {
                before: node.consequent.length || parent.cases[0] === node,
              }
            },
            LogicalExpression: function LogicalExpression(node) {
              if (t.isFunction(node.left) || t.isFunction(node.right)) {
                return {
                  after: true,
                }
              }
            },
            Literal: function Literal(node) {
              if (node.value === 'use strict') {
                return {
                  after: true,
                }
              }
            },
            CallExpression: function CallExpression(node) {
              if (t.isFunction(node.callee) || isHelper(node)) {
                return {
                  before: true,
                  after: true,
                }
              }
            },
            VariableDeclaration: function VariableDeclaration(node) {
              for (var i = 0; i < node.declarations.length; i++) {
                var declar = node.declarations[i]

                var enabled = isHelper(declar.id) && !isType(declar.init)
                if (!enabled) {
                  var state = crawl(declar.init)
                  enabled =
                    (isHelper(declar.init) && state.hasCall) ||
                    state.hasFunction
                }

                if (enabled) {
                  return {
                    before: true,
                    after: true,
                  }
                }
              }
            },
            IfStatement: function IfStatement(node) {
              if (t.isBlockStatement(node.consequent)) {
                return {
                  before: true,
                  after: true,
                }
              }
            },
          }

          exports.nodes.ObjectProperty = exports.nodes.ObjectTypeProperty = exports.nodes.ObjectMethod = exports.nodes.SpreadProperty = function(
            node,
            parent
          ) {
            if (parent.properties[0] === node) {
              return {
                before: true,
              }
            }
          }

          exports.list = {
            VariableDeclaration: function VariableDeclaration(node) {
              return (0, _map2.default)(node.declarations, 'init')
            },
            ArrayExpression: function ArrayExpression(node) {
              return node.elements
            },
            ObjectExpression: function ObjectExpression(node) {
              return node.properties
            },
          }
          ;[
            ['Function', true],
            ['Class', true],
            ['Loop', true],
            ['LabeledStatement', true],
            ['SwitchStatement', true],
            ['TryStatement', true],
          ].forEach(function(_ref) {
            var type = _ref[0],
              amounts = _ref[1]

            if (typeof amounts === 'boolean') {
              amounts = { after: amounts, before: amounts }
            }
            ;[type]
              .concat(t.FLIPPED_ALIAS_KEYS[type] || [])
              .forEach(function(type) {
                exports.nodes[type] = function() {
                  return amounts
                }
              })
          })
        },
        { 'babel-types': 110, 'lodash/map': 484 },
      ],
      48: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true

          var _assign = require('babel-runtime/core-js/object/assign')

          var _assign2 = _interopRequireDefault(_assign)

          var _getIterator2 = require('babel-runtime/core-js/get-iterator')

          var _getIterator3 = _interopRequireDefault(_getIterator2)

          var _stringify = require('babel-runtime/core-js/json/stringify')

          var _stringify2 = _interopRequireDefault(_stringify)

          var _weakSet = require('babel-runtime/core-js/weak-set')

          var _weakSet2 = _interopRequireDefault(_weakSet)

          var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck')

          var _classCallCheck3 = _interopRequireDefault(_classCallCheck2)

          var _find = require('lodash/find')

          var _find2 = _interopRequireDefault(_find)

          var _findLast = require('lodash/findLast')

          var _findLast2 = _interopRequireDefault(_findLast)

          var _isInteger = require('lodash/isInteger')

          var _isInteger2 = _interopRequireDefault(_isInteger)

          var _repeat = require('lodash/repeat')

          var _repeat2 = _interopRequireDefault(_repeat)

          var _buffer = require('./buffer')

          var _buffer2 = _interopRequireDefault(_buffer)

          var _node = require('./node')

          var n = _interopRequireWildcard(_node)

          var _whitespace = require('./whitespace')

          var _whitespace2 = _interopRequireDefault(_whitespace)

          var _babelTypes = require('babel-types')

          var t = _interopRequireWildcard(_babelTypes)

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj
            } else {
              var newObj = {}
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key]
                }
              }
              newObj.default = obj
              return newObj
            }
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          var SCIENTIFIC_NOTATION = /e/i
          var ZERO_DECIMAL_INTEGER = /\.0+$/
          var NON_DECIMAL_LITERAL = /^0[box]/

          var Printer = (function() {
            function Printer(format, map, tokens) {
              ;(0, _classCallCheck3.default)(this, Printer)
              this.inForStatementInitCounter = 0
              this._printStack = []
              this._indent = 0
              this._insideAux = false
              this._printedCommentStarts = {}
              this._parenPushNewlineState = null
              this._printAuxAfterOnNextUserNode = false
              this._printedComments = new _weakSet2.default()
              this._endsWithInteger = false
              this._endsWithWord = false

              this.format = format || {}
              this._buf = new _buffer2.default(map)
              this._whitespace = tokens.length > 0
                ? new _whitespace2.default(tokens)
                : null
            }

            Printer.prototype.generate = function generate(ast) {
              this.print(ast)
              this._maybeAddAuxComment()

              return this._buf.get()
            }

            Printer.prototype.indent = function indent() {
              if (this.format.compact || this.format.concise) return

              this._indent++
            }

            Printer.prototype.dedent = function dedent() {
              if (this.format.compact || this.format.concise) return

              this._indent--
            }

            Printer.prototype.semicolon = function semicolon() {
              var force = arguments.length > 0 && arguments[0] !== undefined
                ? arguments[0]
                : false

              this._maybeAddAuxComment()
              this._append(';', !force)
            }

            Printer.prototype.rightBrace = function rightBrace() {
              if (this.format.minified) {
                this._buf.removeLastSemicolon()
              }
              this.token('}')
            }

            Printer.prototype.space = function space() {
              var force = arguments.length > 0 && arguments[0] !== undefined
                ? arguments[0]
                : false

              if (this.format.compact) return

              if (
                (this._buf.hasContent() &&
                  !this.endsWith(' ') &&
                  !this.endsWith('\n')) ||
                force
              ) {
                this._space()
              }
            }

            Printer.prototype.word = function word(str) {
              if (this._endsWithWord) this._space()

              this._maybeAddAuxComment()
              this._append(str)

              this._endsWithWord = true
            }

            Printer.prototype.number = function number(str) {
              this.word(str)

              this._endsWithInteger =
                (0, _isInteger2.default)(+str) &&
                !NON_DECIMAL_LITERAL.test(str) &&
                !SCIENTIFIC_NOTATION.test(str) &&
                !ZERO_DECIMAL_INTEGER.test(str) &&
                str[str.length - 1] !== '.'
            }

            Printer.prototype.token = function token(str) {
              if (
                (str === '--' && this.endsWith('!')) ||
                (str[0] === '+' && this.endsWith('+')) ||
                (str[0] === '-' && this.endsWith('-')) ||
                (str[0] === '.' && this._endsWithInteger)
              ) {
                this._space()
              }

              this._maybeAddAuxComment()
              this._append(str)
            }

            Printer.prototype.newline = function newline(i) {
              if (this.format.retainLines || this.format.compact) return

              if (this.format.concise) {
                this.space()
                return
              }

              if (this.endsWith('\n\n')) return

              if (typeof i !== 'number') i = 1

              i = Math.min(2, i)
              if (this.endsWith('{\n') || this.endsWith(':\n')) i--
              if (i <= 0) return

              for (var j = 0; j < i; j++) {
                this._newline()
              }
            }

            Printer.prototype.endsWith = function endsWith(str) {
              return this._buf.endsWith(str)
            }

            Printer.prototype.removeTrailingNewline = function removeTrailingNewline() {
              this._buf.removeTrailingNewline()
            }

            Printer.prototype.source = function source(prop, loc) {
              this._catchUp(prop, loc)

              this._buf.source(prop, loc)
            }

            Printer.prototype.withSource = function withSource(prop, loc, cb) {
              this._catchUp(prop, loc)

              this._buf.withSource(prop, loc, cb)
            }

            Printer.prototype._space = function _space() {
              this._append(' ', true)
            }

            Printer.prototype._newline = function _newline() {
              this._append('\n', true)
            }

            Printer.prototype._append = function _append(str) {
              var queue = arguments.length > 1 && arguments[1] !== undefined
                ? arguments[1]
                : false

              this._maybeAddParen(str)
              this._maybeIndent(str)

              if (queue) this._buf.queue(str)
              else this._buf.append(str)

              this._endsWithWord = false
              this._endsWithInteger = false
            }

            Printer.prototype._maybeIndent = function _maybeIndent(str) {
              if (this._indent && this.endsWith('\n') && str[0] !== '\n') {
                this._buf.queue(this._getIndent())
              }
            }

            Printer.prototype._maybeAddParen = function _maybeAddParen(str) {
              var parenPushNewlineState = this._parenPushNewlineState
              if (!parenPushNewlineState) return
              this._parenPushNewlineState = null

              var i = void 0
              for (i = 0; i < str.length && str[i] === ' '; i++) {
                continue
              }
              if (i === str.length) return

              var cha = str[i]
              if (cha === '\n' || cha === '/') {
                this.token('(')
                this.indent()
                parenPushNewlineState.printed = true
              }
            }

            Printer.prototype._catchUp = function _catchUp(prop, loc) {
              if (!this.format.retainLines) return

              var pos = loc ? loc[prop] : null
              if (pos && pos.line !== null) {
                var count = pos.line - this._buf.getCurrentLine()

                for (var i = 0; i < count; i++) {
                  this._newline()
                }
              }
            }

            Printer.prototype._getIndent = function _getIndent() {
              return (0, _repeat2.default)(
                this.format.indent.style,
                this._indent
              )
            }

            Printer.prototype.startTerminatorless = function startTerminatorless() {
              return (this._parenPushNewlineState = {
                printed: false,
              })
            }

            Printer.prototype.endTerminatorless = function endTerminatorless(
              state
            ) {
              if (state.printed) {
                this.dedent()
                this.newline()
                this.token(')')
              }
            }

            Printer.prototype.print = function print(node, parent) {
              var _this = this

              if (!node) return

              var oldConcise = this.format.concise
              if (node._compact) {
                this.format.concise = true
              }

              var printMethod = this[node.type]
              if (!printMethod) {
                throw new ReferenceError(
                  'unknown node of type ' +
                    (0, _stringify2.default)(node.type) +
                    ' with constructor ' +
                    (0, _stringify2.default)(node && node.constructor.name)
                )
              }

              this._printStack.push(node)

              var oldInAux = this._insideAux
              this._insideAux = !node.loc
              this._maybeAddAuxComment(this._insideAux && !oldInAux)

              var needsParens = n.needsParens(node, parent, this._printStack)
              if (
                this.format.retainFunctionParens &&
                node.type === 'FunctionExpression' &&
                node.extra &&
                node.extra.parenthesized
              ) {
                needsParens = true
              }
              if (needsParens) this.token('(')

              this._printLeadingComments(node, parent)

              var loc = t.isProgram(node) || t.isFile(node) ? null : node.loc
              this.withSource('start', loc, function() {
                _this[node.type](node, parent)
              })

              this._printTrailingComments(node, parent)

              if (needsParens) this.token(')')

              this._printStack.pop()

              this.format.concise = oldConcise
              this._insideAux = oldInAux
            }

            Printer.prototype._maybeAddAuxComment = function _maybeAddAuxComment(
              enteredPositionlessNode
            ) {
              if (enteredPositionlessNode) this._printAuxBeforeComment()
              if (!this._insideAux) this._printAuxAfterComment()
            }

            Printer.prototype._printAuxBeforeComment = function _printAuxBeforeComment() {
              if (this._printAuxAfterOnNextUserNode) return
              this._printAuxAfterOnNextUserNode = true

              var comment = this.format.auxiliaryCommentBefore
              if (comment) {
                this._printComment({
                  type: 'CommentBlock',
                  value: comment,
                })
              }
            }

            Printer.prototype._printAuxAfterComment = function _printAuxAfterComment() {
              if (!this._printAuxAfterOnNextUserNode) return
              this._printAuxAfterOnNextUserNode = false

              var comment = this.format.auxiliaryCommentAfter
              if (comment) {
                this._printComment({
                  type: 'CommentBlock',
                  value: comment,
                })
              }
            }

            Printer.prototype.getPossibleRaw = function getPossibleRaw(node) {
              var extra = node.extra
              if (
                extra &&
                extra.raw != null &&
                extra.rawValue != null &&
                node.value === extra.rawValue
              ) {
                return extra.raw
              }
            }

            Printer.prototype.printJoin = function printJoin(nodes, parent) {
              var opts = arguments.length > 2 && arguments[2] !== undefined
                ? arguments[2]
                : {}

              if (!nodes || !nodes.length) return

              if (opts.indent) this.indent()

              var newlineOpts = {
                addNewlines: opts.addNewlines,
              }

              for (var i = 0; i < nodes.length; i++) {
                var node = nodes[i]
                if (!node) continue

                if (opts.statement)
                  this._printNewline(true, node, parent, newlineOpts)

                this.print(node, parent)

                if (opts.iterator) {
                  opts.iterator(node, i)
                }

                if (opts.separator && i < nodes.length - 1) {
                  opts.separator.call(this)
                }

                if (opts.statement)
                  this._printNewline(false, node, parent, newlineOpts)
              }

              if (opts.indent) this.dedent()
            }

            Printer.prototype.printAndIndentOnComments = function printAndIndentOnComments(
              node,
              parent
            ) {
              var indent = !!node.leadingComments
              if (indent) this.indent()
              this.print(node, parent)
              if (indent) this.dedent()
            }

            Printer.prototype.printBlock = function printBlock(parent) {
              var node = parent.body

              if (!t.isEmptyStatement(node)) {
                this.space()
              }

              this.print(node, parent)
            }

            Printer.prototype._printTrailingComments = function _printTrailingComments(
              node,
              parent
            ) {
              this._printComments(this._getComments(false, node, parent))
            }

            Printer.prototype._printLeadingComments = function _printLeadingComments(
              node,
              parent
            ) {
              this._printComments(this._getComments(true, node, parent))
            }

            Printer.prototype.printInnerComments = function printInnerComments(
              node
            ) {
              var indent = arguments.length > 1 && arguments[1] !== undefined
                ? arguments[1]
                : true

              if (!node.innerComments) return
              if (indent) this.indent()
              this._printComments(node.innerComments)
              if (indent) this.dedent()
            }

            Printer.prototype.printSequence = function printSequence(
              nodes,
              parent
            ) {
              var opts = arguments.length > 2 && arguments[2] !== undefined
                ? arguments[2]
                : {}

              opts.statement = true
              return this.printJoin(nodes, parent, opts)
            }

            Printer.prototype.printList = function printList(items, parent) {
              var opts = arguments.length > 2 && arguments[2] !== undefined
                ? arguments[2]
                : {}

              if (opts.separator == null) {
                opts.separator = commaSeparator
              }

              return this.printJoin(items, parent, opts)
            }

            Printer.prototype._printNewline = function _printNewline(
              leading,
              node,
              parent,
              opts
            ) {
              var _this2 = this

              if (this.format.retainLines || this.format.compact) return

              if (this.format.concise) {
                this.space()
                return
              }

              var lines = 0

              if (
                node.start != null &&
                !node._ignoreUserWhitespace &&
                this._whitespace
              ) {
                if (leading) {
                  var _comments = node.leadingComments
                  var _comment =
                    _comments &&
                    (0, _find2.default)(_comments, function(comment) {
                      return (
                        !!comment.loc &&
                        _this2.format.shouldPrintComment(comment.value)
                      )
                    })

                  lines = this._whitespace.getNewlinesBefore(_comment || node)
                } else {
                  var _comments2 = node.trailingComments
                  var _comment2 =
                    _comments2 &&
                    (0, _findLast2.default)(_comments2, function(comment) {
                      return (
                        !!comment.loc &&
                        _this2.format.shouldPrintComment(comment.value)
                      )
                    })

                  lines = this._whitespace.getNewlinesAfter(_comment2 || node)
                }
              } else {
                if (!leading) lines++
                if (opts.addNewlines)
                  lines += opts.addNewlines(leading, node) || 0

                var needs = n.needsWhitespaceAfter
                if (leading) needs = n.needsWhitespaceBefore
                if (needs(node, parent)) lines++

                if (!this._buf.hasContent()) lines = 0
              }

              this.newline(lines)
            }

            Printer.prototype._getComments = function _getComments(
              leading,
              node
            ) {
              return (
                (node &&
                  (leading ? node.leadingComments : node.trailingComments)) ||
                []
              )
            }

            Printer.prototype._printComment = function _printComment(comment) {
              var _this3 = this

              if (!this.format.shouldPrintComment(comment.value)) return

              if (comment.ignore) return

              if (this._printedComments.has(comment)) return
              this._printedComments.add(comment)

              if (comment.start != null) {
                if (this._printedCommentStarts[comment.start]) return
                this._printedCommentStarts[comment.start] = true
              }

              this.newline(
                this._whitespace
                  ? this._whitespace.getNewlinesBefore(comment)
                  : 0
              )

              if (!this.endsWith('[') && !this.endsWith('{')) this.space()

              var val = comment.type === 'CommentLine'
                ? '//' + comment.value + '\n'
                : '/*' + comment.value + '*/'

              if (
                comment.type === 'CommentBlock' &&
                this.format.indent.adjustMultilineComment
              ) {
                var offset = comment.loc && comment.loc.start.column
                if (offset) {
                  var newlineRegex = new RegExp('\\n\\s{1,' + offset + '}', 'g')
                  val = val.replace(newlineRegex, '\n')
                }

                var indentSize = Math.max(
                  this._getIndent().length,
                  this._buf.getCurrentColumn()
                )
                val = val.replace(
                  /\n(?!$)/g,
                  '\n' + (0, _repeat2.default)(' ', indentSize)
                )
              }

              this.withSource('start', comment.loc, function() {
                _this3._append(val)
              })

              this.newline(
                (this._whitespace
                  ? this._whitespace.getNewlinesAfter(comment)
                  : 0) + (comment.type === 'CommentLine' ? -1 : 0)
              )
            }

            Printer.prototype._printComments = function _printComments(
              comments
            ) {
              if (!comments || !comments.length) return

              for (
                var _iterator = comments,
                  _isArray = Array.isArray(_iterator),
                  _i = 0,
                  _iterator = _isArray
                    ? _iterator
                    : (0, _getIterator3.default)(_iterator);
                ;

              ) {
                var _ref

                if (_isArray) {
                  if (_i >= _iterator.length) break
                  _ref = _iterator[_i++]
                } else {
                  _i = _iterator.next()
                  if (_i.done) break
                  _ref = _i.value
                }

                var _comment3 = _ref

                this._printComment(_comment3)
              }
            }

            return Printer
          })()

          exports.default = Printer

          function commaSeparator() {
            this.token(',')
            this.space()
          }

          var _arr = [
            require('./generators/template-literals'),
            require('./generators/expressions'),
            require('./generators/statements'),
            require('./generators/classes'),
            require('./generators/methods'),
            require('./generators/modules'),
            require('./generators/types'),
            require('./generators/flow'),
            require('./generators/base'),
            require('./generators/jsx'),
          ]
          for (var _i2 = 0; _i2 < _arr.length; _i2++) {
            var generator = _arr[_i2]
            ;(0, _assign2.default)(Printer.prototype, generator)
          }
          module.exports = exports['default']
        },
        {
          './buffer': 33,
          './generators/base': 34,
          './generators/classes': 35,
          './generators/expressions': 36,
          './generators/flow': 37,
          './generators/jsx': 38,
          './generators/methods': 39,
          './generators/modules': 40,
          './generators/statements': 41,
          './generators/template-literals': 42,
          './generators/types': 43,
          './node': 45,
          './whitespace': 50,
          'babel-runtime/core-js/get-iterator': 54,
          'babel-runtime/core-js/json/stringify': 55,
          'babel-runtime/core-js/object/assign': 58,
          'babel-runtime/core-js/weak-set': 67,
          'babel-runtime/helpers/classCallCheck': 68,
          'babel-types': 110,
          'lodash/find': 458,
          'lodash/findLast': 460,
          'lodash/isInteger': 473,
          'lodash/repeat': 489,
        },
      ],
      49: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true

          var _keys = require('babel-runtime/core-js/object/keys')

          var _keys2 = _interopRequireDefault(_keys)

          var _typeof2 = require('babel-runtime/helpers/typeof')

          var _typeof3 = _interopRequireDefault(_typeof2)

          var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck')

          var _classCallCheck3 = _interopRequireDefault(_classCallCheck2)

          var _sourceMap = require('source-map')

          var _sourceMap2 = _interopRequireDefault(_sourceMap)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          var SourceMap = (function() {
            function SourceMap(opts, code) {
              ;(0, _classCallCheck3.default)(this, SourceMap)

              this._cachedMap = null
              this._code = code
              this._opts = opts
              this._rawMappings = []
            }

            SourceMap.prototype.get = function get() {
              if (!this._cachedMap) {
                var map = (this._cachedMap = new _sourceMap2.default
                  .SourceMapGenerator({
                  file: this._opts.sourceMapTarget,
                  sourceRoot: this._opts.sourceRoot,
                }))

                var code = this._code
                if (typeof code === 'string') {
                  map.setSourceContent(this._opts.sourceFileName, code)
                } else if (
                  (typeof code === 'undefined'
                    ? 'undefined'
                    : (0, _typeof3.default)(code)) === 'object'
                ) {
                  ;(0, _keys2.default)(code).forEach(function(sourceFileName) {
                    map.setSourceContent(sourceFileName, code[sourceFileName])
                  })
                }

                this._rawMappings.forEach(map.addMapping, map)
              }

              return this._cachedMap.toJSON()
            }

            SourceMap.prototype.getRawMappings = function getRawMappings() {
              return this._rawMappings.slice()
            }

            SourceMap.prototype.mark = function mark(
              generatedLine,
              generatedColumn,
              line,
              column,
              identifierName,
              filename
            ) {
              if (this._lastGenLine !== generatedLine && line === null) return

              if (
                this._lastGenLine === generatedLine &&
                this._lastSourceLine === line &&
                this._lastSourceColumn === column
              ) {
                return
              }

              this._cachedMap = null
              this._lastGenLine = generatedLine
              this._lastSourceLine = line
              this._lastSourceColumn = column

              this._rawMappings.push({
                name: identifierName || undefined,
                generated: {
                  line: generatedLine,
                  column: generatedColumn,
                },
                source: line == null
                  ? undefined
                  : filename || this._opts.sourceFileName,
                original: line == null
                  ? undefined
                  : {
                      line: line,
                      column: column,
                    },
              })
            }

            return SourceMap
          })()

          exports.default = SourceMap
          module.exports = exports['default']
        },
        {
          'babel-runtime/core-js/object/keys': 61,
          'babel-runtime/helpers/classCallCheck': 68,
          'babel-runtime/helpers/typeof': 72,
          'source-map': 526,
        },
      ],
      50: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true

          var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck')

          var _classCallCheck3 = _interopRequireDefault(_classCallCheck2)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          var Whitespace = (function() {
            function Whitespace(tokens) {
              ;(0, _classCallCheck3.default)(this, Whitespace)

              this.tokens = tokens
              this.used = {}
            }

            Whitespace.prototype.getNewlinesBefore = function getNewlinesBefore(
              node
            ) {
              var startToken = void 0
              var endToken = void 0
              var tokens = this.tokens

              var index = this._findToken(
                function(token) {
                  return token.start - node.start
                },
                0,
                tokens.length
              )
              if (index >= 0) {
                while (index && node.start === tokens[index - 1].start) {
                  --index
                }
                startToken = tokens[index - 1]
                endToken = tokens[index]
              }

              return this._getNewlinesBetween(startToken, endToken)
            }

            Whitespace.prototype.getNewlinesAfter = function getNewlinesAfter(
              node
            ) {
              var startToken = void 0
              var endToken = void 0
              var tokens = this.tokens

              var index = this._findToken(
                function(token) {
                  return token.end - node.end
                },
                0,
                tokens.length
              )
              if (index >= 0) {
                while (index && node.end === tokens[index - 1].end) {
                  --index
                }
                startToken = tokens[index]
                endToken = tokens[index + 1]
                if (endToken.type.label === ',') endToken = tokens[index + 2]
              }

              if (endToken && endToken.type.label === 'eof') {
                return 1
              } else {
                return this._getNewlinesBetween(startToken, endToken)
              }
            }

            Whitespace.prototype._getNewlinesBetween = function _getNewlinesBetween(
              startToken,
              endToken
            ) {
              if (!endToken || !endToken.loc) return 0

              var start = startToken ? startToken.loc.end.line : 1
              var end = endToken.loc.start.line
              var lines = 0

              for (var line = start; line < end; line++) {
                if (typeof this.used[line] === 'undefined') {
                  this.used[line] = true
                  lines++
                }
              }

              return lines
            }

            Whitespace.prototype._findToken = function _findToken(
              test,
              start,
              end
            ) {
              if (start >= end) return -1
              var middle = (start + end) >>> 1
              var match = test(this.tokens[middle])
              if (match < 0) {
                return this._findToken(test, middle + 1, end)
              } else if (match > 0) {
                return this._findToken(test, start, middle)
              } else if (match === 0) {
                return middle
              }
              return -1
            }

            return Whitespace
          })()

          exports.default = Whitespace
          module.exports = exports['default']
        },
        { 'babel-runtime/helpers/classCallCheck': 68 },
      ],
      51: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true

          var _babelTemplate = require('babel-template')

          var _babelTemplate2 = _interopRequireDefault(_babelTemplate)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          var helpers = {}
          exports.default = helpers

          helpers.typeof = (0, _babelTemplate2.default)(
            '\n  (typeof Symbol === "function" && typeof Symbol.iterator === "symbol")\n    ? function (obj) { return typeof obj; }\n    : function (obj) {\n        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype\n          ? "symbol"\n          : typeof obj;\n      };\n'
          )

          helpers.jsx = (0, _babelTemplate2.default)(
            '\n  (function () {\n    var REACT_ELEMENT_TYPE = (typeof Symbol === "function" && Symbol.for && Symbol.for("react.element")) || 0xeac7;\n\n    return function createRawReactElement (type, props, key, children) {\n      var defaultProps = type && type.defaultProps;\n      var childrenLength = arguments.length - 3;\n\n      if (!props && childrenLength !== 0) {\n        // If we\'re going to assign props.children, we create a new object now\n        // to avoid mutating defaultProps.\n        props = {};\n      }\n      if (props && defaultProps) {\n        for (var propName in defaultProps) {\n          if (props[propName] === void 0) {\n            props[propName] = defaultProps[propName];\n          }\n        }\n      } else if (!props) {\n        props = defaultProps || {};\n      }\n\n      if (childrenLength === 1) {\n        props.children = children;\n      } else if (childrenLength > 1) {\n        var childArray = Array(childrenLength);\n        for (var i = 0; i < childrenLength; i++) {\n          childArray[i] = arguments[i + 3];\n        }\n        props.children = childArray;\n      }\n\n      return {\n        $$typeof: REACT_ELEMENT_TYPE,\n        type: type,\n        key: key === undefined ? null : \'\' + key,\n        ref: null,\n        props: props,\n        _owner: null,\n      };\n    };\n\n  })()\n'
          )

          helpers.asyncIterator = (0, _babelTemplate2.default)(
            '\n  (function (iterable) {\n    if (typeof Symbol === "function") {\n      if (Symbol.asyncIterator) {\n        var method = iterable[Symbol.asyncIterator];\n        if (method != null) return method.call(iterable);\n      }\n      if (Symbol.iterator) {\n        return iterable[Symbol.iterator]();\n      }\n    }\n    throw new TypeError("Object is not async iterable");\n  })\n'
          )

          helpers.asyncGenerator = (0, _babelTemplate2.default)(
            '\n  (function () {\n    function AwaitValue(value) {\n      this.value = value;\n    }\n\n    function AsyncGenerator(gen) {\n      var front, back;\n\n      function send(key, arg) {\n        return new Promise(function (resolve, reject) {\n          var request = {\n            key: key,\n            arg: arg,\n            resolve: resolve,\n            reject: reject,\n            next: null\n          };\n\n          if (back) {\n            back = back.next = request;\n          } else {\n            front = back = request;\n            resume(key, arg);\n          }\n        });\n      }\n\n      function resume(key, arg) {\n        try {\n          var result = gen[key](arg)\n          var value = result.value;\n          if (value instanceof AwaitValue) {\n            Promise.resolve(value.value).then(\n              function (arg) { resume("next", arg); },\n              function (arg) { resume("throw", arg); });\n          } else {\n            settle(result.done ? "return" : "normal", result.value);\n          }\n        } catch (err) {\n          settle("throw", err);\n        }\n      }\n\n      function settle(type, value) {\n        switch (type) {\n          case "return":\n            front.resolve({ value: value, done: true });\n            break;\n          case "throw":\n            front.reject(value);\n            break;\n          default:\n            front.resolve({ value: value, done: false });\n            break;\n        }\n\n        front = front.next;\n        if (front) {\n          resume(front.key, front.arg);\n        } else {\n          back = null;\n        }\n      }\n\n      this._invoke = send;\n\n      // Hide "return" method if generator return is not supported\n      if (typeof gen.return !== "function") {\n        this.return = undefined;\n      }\n    }\n\n    if (typeof Symbol === "function" && Symbol.asyncIterator) {\n      AsyncGenerator.prototype[Symbol.asyncIterator] = function () { return this; };\n    }\n\n    AsyncGenerator.prototype.next = function (arg) { return this._invoke("next", arg); };\n    AsyncGenerator.prototype.throw = function (arg) { return this._invoke("throw", arg); };\n    AsyncGenerator.prototype.return = function (arg) { return this._invoke("return", arg); };\n\n    return {\n      wrap: function (fn) {\n        return function () {\n          return new AsyncGenerator(fn.apply(this, arguments));\n        };\n      },\n      await: function (value) {\n        return new AwaitValue(value);\n      }\n    };\n\n  })()\n'
          )

          helpers.asyncGeneratorDelegate = (0, _babelTemplate2.default)(
            '\n  (function (inner, awaitWrap) {\n    var iter = {}, waiting = false;\n\n    function pump(key, value) {\n      waiting = true;\n      value = new Promise(function (resolve) { resolve(inner[key](value)); });\n      return { done: false, value: awaitWrap(value) };\n    };\n\n    if (typeof Symbol === "function" && Symbol.iterator) {\n      iter[Symbol.iterator] = function () { return this; };\n    }\n\n    iter.next = function (value) {\n      if (waiting) {\n        waiting = false;\n        return value;\n      }\n      return pump("next", value);\n    };\n\n    if (typeof inner.throw === "function") {\n      iter.throw = function (value) {\n        if (waiting) {\n          waiting = false;\n          throw value;\n        }\n        return pump("throw", value);\n      };\n    }\n\n    if (typeof inner.return === "function") {\n      iter.return = function (value) {\n        return pump("return", value);\n      };\n    }\n\n    return iter;\n  })\n'
          )

          helpers.asyncToGenerator = (0, _babelTemplate2.default)(
            '\n  (function (fn) {\n    return function () {\n      var gen = fn.apply(this, arguments);\n      return new Promise(function (resolve, reject) {\n        function step(key, arg) {\n          try {\n            var info = gen[key](arg);\n            var value = info.value;\n          } catch (error) {\n            reject(error);\n            return;\n          }\n\n          if (info.done) {\n            resolve(value);\n          } else {\n            return Promise.resolve(value).then(function (value) {\n              step("next", value);\n            }, function (err) {\n              step("throw", err);\n            });\n          }\n        }\n\n        return step("next");\n      });\n    };\n  })\n'
          )

          helpers.classCallCheck = (0, _babelTemplate2.default)(
            '\n  (function (instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError("Cannot call a class as a function");\n    }\n  });\n'
          )

          helpers.createClass = (0, _babelTemplate2.default)(
            '\n  (function() {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i ++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if ("value" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    return function (Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) defineProperties(Constructor, staticProps);\n      return Constructor;\n    };\n  })()\n'
          )

          helpers.defineEnumerableProperties = (0, _babelTemplate2.default)(
            '\n  (function (obj, descs) {\n    for (var key in descs) {\n      var desc = descs[key];\n      desc.configurable = desc.enumerable = true;\n      if ("value" in desc) desc.writable = true;\n      Object.defineProperty(obj, key, desc);\n    }\n    return obj;\n  })\n'
          )

          helpers.defaults = (0, _babelTemplate2.default)(
            '\n  (function (obj, defaults) {\n    var keys = Object.getOwnPropertyNames(defaults);\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var value = Object.getOwnPropertyDescriptor(defaults, key);\n      if (value && value.configurable && obj[key] === undefined) {\n        Object.defineProperty(obj, key, value);\n      }\n    }\n    return obj;\n  })\n'
          )

          helpers.defineProperty = (0, _babelTemplate2.default)(
            '\n  (function (obj, key, value) {\n    // Shortcircuit the slow defineProperty path when possible.\n    // We are trying to avoid issues where setters defined on the\n    // prototype cause side effects under the fast path of simple\n    // assignment. By checking for existence of the property with\n    // the in operator, we can optimize most of this overhead away.\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n    return obj;\n  });\n'
          )

          helpers.extends = (0, _babelTemplate2.default)(
            '\n  Object.assign || (function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  })\n'
          )

          helpers.get = (0, _babelTemplate2.default)(
            '\n  (function get(object, property, receiver) {\n    if (object === null) object = Function.prototype;\n\n    var desc = Object.getOwnPropertyDescriptor(object, property);\n\n    if (desc === undefined) {\n      var parent = Object.getPrototypeOf(object);\n\n      if (parent === null) {\n        return undefined;\n      } else {\n        return get(parent, property, receiver);\n      }\n    } else if ("value" in desc) {\n      return desc.value;\n    } else {\n      var getter = desc.get;\n\n      if (getter === undefined) {\n        return undefined;\n      }\n\n      return getter.call(receiver);\n    }\n  });\n'
          )

          helpers.inherits = (0, _babelTemplate2.default)(
            '\n  (function (subClass, superClass) {\n    if (typeof superClass !== "function" && superClass !== null) {\n      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n  })\n'
          )

          helpers.instanceof = (0, _babelTemplate2.default)(
            '\n  (function (left, right) {\n    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {\n      return right[Symbol.hasInstance](left);\n    } else {\n      return left instanceof right;\n    }\n  });\n'
          )

          helpers.interopRequireDefault = (0, _babelTemplate2.default)(
            '\n  (function (obj) {\n    return obj && obj.__esModule ? obj : { default: obj };\n  })\n'
          )

          helpers.interopRequireWildcard = (0, _babelTemplate2.default)(
            '\n  (function (obj) {\n    if (obj && obj.__esModule) {\n      return obj;\n    } else {\n      var newObj = {};\n      if (obj != null) {\n        for (var key in obj) {\n          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n        }\n      }\n      newObj.default = obj;\n      return newObj;\n    }\n  })\n'
          )

          helpers.newArrowCheck = (0, _babelTemplate2.default)(
            '\n  (function (innerThis, boundThis) {\n    if (innerThis !== boundThis) {\n      throw new TypeError("Cannot instantiate an arrow function");\n    }\n  });\n'
          )

          helpers.objectDestructuringEmpty = (0, _babelTemplate2.default)(
            '\n  (function (obj) {\n    if (obj == null) throw new TypeError("Cannot destructure undefined");\n  });\n'
          )

          helpers.objectWithoutProperties = (0, _babelTemplate2.default)(
            '\n  (function (obj, keys) {\n    var target = {};\n    for (var i in obj) {\n      if (keys.indexOf(i) >= 0) continue;\n      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n      target[i] = obj[i];\n    }\n    return target;\n  })\n'
          )

          helpers.possibleConstructorReturn = (0, _babelTemplate2.default)(
            '\n  (function (self, call) {\n    if (!self) {\n      throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called");\n    }\n    return call && (typeof call === "object" || typeof call === "function") ? call : self;\n  });\n'
          )

          helpers.selfGlobal = (0, _babelTemplate2.default)(
            '\n  typeof global === "undefined" ? self : global\n'
          )

          helpers.set = (0, _babelTemplate2.default)(
            '\n  (function set(object, property, value, receiver) {\n    var desc = Object.getOwnPropertyDescriptor(object, property);\n\n    if (desc === undefined) {\n      var parent = Object.getPrototypeOf(object);\n\n      if (parent !== null) {\n        set(parent, property, value, receiver);\n      }\n    } else if ("value" in desc && desc.writable) {\n      desc.value = value;\n    } else {\n      var setter = desc.set;\n\n      if (setter !== undefined) {\n        setter.call(receiver, value);\n      }\n    }\n\n    return value;\n  });\n'
          )

          helpers.slicedToArray = (0, _babelTemplate2.default)(
            '\n  (function () {\n    // Broken out into a separate function to avoid deoptimizations due to the try/catch for the\n    // array iterator case.\n    function sliceIterator(arr, i) {\n      // this is an expanded form of `for...of` that properly supports abrupt completions of\n      // iterators etc. variable names have been minimised to reduce the size of this massive\n      // helper. sometimes spec compliancy is annoying :(\n      //\n      // _n = _iteratorNormalCompletion\n      // _d = _didIteratorError\n      // _e = _iteratorError\n      // _i = _iterator\n      // _s = _step\n\n      var _arr = [];\n      var _n = true;\n      var _d = false;\n      var _e = undefined;\n      try {\n        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n          _arr.push(_s.value);\n          if (i && _arr.length === i) break;\n        }\n      } catch (err) {\n        _d = true;\n        _e = err;\n      } finally {\n        try {\n          if (!_n && _i["return"]) _i["return"]();\n        } finally {\n          if (_d) throw _e;\n        }\n      }\n      return _arr;\n    }\n\n    return function (arr, i) {\n      if (Array.isArray(arr)) {\n        return arr;\n      } else if (Symbol.iterator in Object(arr)) {\n        return sliceIterator(arr, i);\n      } else {\n        throw new TypeError("Invalid attempt to destructure non-iterable instance");\n      }\n    };\n  })();\n'
          )

          helpers.slicedToArrayLoose = (0, _babelTemplate2.default)(
            '\n  (function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      var _arr = [];\n      for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {\n        _arr.push(_step.value);\n        if (i && _arr.length === i) break;\n      }\n      return _arr;\n    } else {\n      throw new TypeError("Invalid attempt to destructure non-iterable instance");\n    }\n  });\n'
          )

          helpers.taggedTemplateLiteral = (0, _babelTemplate2.default)(
            '\n  (function (strings, raw) {\n    return Object.freeze(Object.defineProperties(strings, {\n        raw: { value: Object.freeze(raw) }\n    }));\n  });\n'
          )

          helpers.taggedTemplateLiteralLoose = (0, _babelTemplate2.default)(
            '\n  (function (strings, raw) {\n    strings.raw = raw;\n    return strings;\n  });\n'
          )

          helpers.temporalRef = (0, _babelTemplate2.default)(
            '\n  (function (val, name, undef) {\n    if (val === undef) {\n      throw new ReferenceError(name + " is not defined - temporal dead zone");\n    } else {\n      return val;\n    }\n  })\n'
          )

          helpers.temporalUndefined = (0, _babelTemplate2.default)('\n  ({})\n')

          helpers.toArray = (0, _babelTemplate2.default)(
            '\n  (function (arr) {\n    return Array.isArray(arr) ? arr : Array.from(arr);\n  });\n'
          )

          helpers.toConsumableArray = (0, _babelTemplate2.default)(
            '\n  (function (arr) {\n    if (Array.isArray(arr)) {\n      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n      return arr2;\n    } else {\n      return Array.from(arr);\n    }\n  });\n'
          )
          module.exports = exports['default']
        },
        { 'babel-template': 73 },
      ],
      52: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true
          exports.list = undefined

          var _keys = require('babel-runtime/core-js/object/keys')

          var _keys2 = _interopRequireDefault(_keys)

          exports.get = get

          var _helpers = require('./helpers')

          var _helpers2 = _interopRequireDefault(_helpers)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          function get(name) {
            var fn = _helpers2.default[name]
            if (!fn) throw new ReferenceError('Unknown helper ' + name)

            return fn().expression
          }

          var list = (exports.list = (0, _keys2.default)(_helpers2.default)
            .map(function(name) {
              return name.replace(/^_/, '')
            })
            .filter(function(name) {
              return name !== '__esModule'
            }))

          exports.default = get
        },
        { './helpers': 51, 'babel-runtime/core-js/object/keys': 61 },
      ],
      53: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true
          exports.MESSAGES = undefined

          var _stringify = require('babel-runtime/core-js/json/stringify')

          var _stringify2 = _interopRequireDefault(_stringify)

          exports.get = get
          exports.parseArgs = parseArgs

          var _util = require('util')

          var util = _interopRequireWildcard(_util)

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj
            } else {
              var newObj = {}
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key]
                }
              }
              newObj.default = obj
              return newObj
            }
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          var MESSAGES = (exports.MESSAGES = {
            tailCallReassignmentDeopt:
              "Function reference has been reassigned, so it will probably be dereferenced, therefore we can't optimise this with confidence",
            classesIllegalBareSuper: 'Illegal use of bare super',
            classesIllegalSuperCall:
              'Direct super call is illegal in non-constructor, use super.$1() instead',
            scopeDuplicateDeclaration: 'Duplicate declaration $1',
            settersNoRest: "Setters aren't allowed to have a rest",
            noAssignmentsInForHead: 'No assignments allowed in for-in/of head',
            expectedMemberExpressionOrIdentifier:
              'Expected type MemberExpression or Identifier',
            invalidParentForThisNode:
              "We don't know how to handle this node within the current parent - please open an issue",
            readOnly: '$1 is read-only',
            unknownForHead: 'Unknown node type $1 in ForStatement',
            didYouMean: 'Did you mean $1?',
            codeGeneratorDeopt:
              'Note: The code generator has deoptimised the styling of $1 as it exceeds the max of $2.',
            missingTemplatesDirectory:
              'no templates directory - this is most likely the result of a broken `npm publish`. Please report to https://github.com/babel/babel/issues',
            unsupportedOutputType: 'Unsupported output type $1',
            illegalMethodName: 'Illegal method name $1',
            lostTrackNodePath:
              "We lost track of this node's position, likely because the AST was directly manipulated",

            modulesIllegalExportName: 'Illegal export $1',
            modulesDuplicateDeclarations:
              'Duplicate module declarations with the same source but in different scopes',

            undeclaredVariable: 'Reference to undeclared variable $1',
            undeclaredVariableType:
              'Referencing a type alias outside of a type annotation',
            undeclaredVariableSuggestion:
              'Reference to undeclared variable $1 - did you mean $2?',

            traverseNeedsParent:
              'You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a $1 node without passing scope and parentPath.',
            traverseVerifyRootFunction:
              "You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?",
            traverseVerifyVisitorProperty:
              'You passed `traverse()` a visitor object with the property $1 that has the invalid property $2',
            traverseVerifyNodeType:
              "You gave us a visitor for the node type $1 but it's not a valid type",

            pluginNotObject:
              'Plugin $2 specified in $1 was expected to return an object when invoked but returned $3',
            pluginNotFunction:
              'Plugin $2 specified in $1 was expected to return a function but returned $3',
            pluginUnknown:
              'Unknown plugin $1 specified in $2 at $3, attempted to resolve relative to $4',
            pluginInvalidProperty:
              'Plugin $2 specified in $1 provided an invalid property of $3',
          })

          function get(key) {
            for (
              var _len = arguments.length,
                args = Array(_len > 1 ? _len - 1 : 0),
                _key = 1;
              _key < _len;
              _key++
            ) {
              args[_key - 1] = arguments[_key]
            }

            var msg = MESSAGES[key]
            if (!msg)
              throw new ReferenceError(
                'Unknown message ' + (0, _stringify2.default)(key)
              )

            args = parseArgs(args)

            return msg.replace(/\$(\d+)/g, function(str, i) {
              return args[i - 1]
            })
          }

          function parseArgs(args) {
            return args.map(function(val) {
              if (val != null && val.inspect) {
                return val.inspect()
              } else {
                try {
                  return (0, _stringify2.default)(val) || val + ''
                } catch (e) {
                  return util.inspect(val)
                }
              }
            })
          }
        },
        { 'babel-runtime/core-js/json/stringify': 55, util: 568 },
      ],
      54: [
        function(require, module, exports) {
          module.exports = {
            default: require('core-js/library/fn/get-iterator'),
            __esModule: true,
          }
        },
        { 'core-js/library/fn/get-iterator': 133 },
      ],
      55: [
        function(require, module, exports) {
          module.exports = {
            default: require('core-js/library/fn/json/stringify'),
            __esModule: true,
          }
        },
        { 'core-js/library/fn/json/stringify': 134 },
      ],
      56: [
        function(require, module, exports) {
          module.exports = {
            default: require('core-js/library/fn/map'),
            __esModule: true,
          }
        },
        { 'core-js/library/fn/map': 135 },
      ],
      57: [
        function(require, module, exports) {
          module.exports = {
            default: require('core-js/library/fn/number/max-safe-integer'),
            __esModule: true,
          }
        },
        { 'core-js/library/fn/number/max-safe-integer': 136 },
      ],
      58: [
        function(require, module, exports) {
          module.exports = {
            default: require('core-js/library/fn/object/assign'),
            __esModule: true,
          }
        },
        { 'core-js/library/fn/object/assign': 137 },
      ],
      59: [
        function(require, module, exports) {
          module.exports = {
            default: require('core-js/library/fn/object/create'),
            __esModule: true,
          }
        },
        { 'core-js/library/fn/object/create': 138 },
      ],
      60: [
        function(require, module, exports) {
          module.exports = {
            default: require('core-js/library/fn/object/get-own-property-symbols'),
            __esModule: true,
          }
        },
        { 'core-js/library/fn/object/get-own-property-symbols': 139 },
      ],
      61: [
        function(require, module, exports) {
          module.exports = {
            default: require('core-js/library/fn/object/keys'),
            __esModule: true,
          }
        },
        { 'core-js/library/fn/object/keys': 140 },
      ],
      62: [
        function(require, module, exports) {
          module.exports = {
            default: require('core-js/library/fn/object/set-prototype-of'),
            __esModule: true,
          }
        },
        { 'core-js/library/fn/object/set-prototype-of': 141 },
      ],
      63: [
        function(require, module, exports) {
          module.exports = {
            default: require('core-js/library/fn/symbol'),
            __esModule: true,
          }
        },
        { 'core-js/library/fn/symbol': 143 },
      ],
      64: [
        function(require, module, exports) {
          module.exports = {
            default: require('core-js/library/fn/symbol/for'),
            __esModule: true,
          }
        },
        { 'core-js/library/fn/symbol/for': 142 },
      ],
      65: [
        function(require, module, exports) {
          module.exports = {
            default: require('core-js/library/fn/symbol/iterator'),
            __esModule: true,
          }
        },
        { 'core-js/library/fn/symbol/iterator': 144 },
      ],
      66: [
        function(require, module, exports) {
          module.exports = {
            default: require('core-js/library/fn/weak-map'),
            __esModule: true,
          }
        },
        { 'core-js/library/fn/weak-map': 145 },
      ],
      67: [
        function(require, module, exports) {
          module.exports = {
            default: require('core-js/library/fn/weak-set'),
            __esModule: true,
          }
        },
        { 'core-js/library/fn/weak-set': 146 },
      ],
      68: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true

          exports.default = function(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function')
            }
          }
        },
        {},
      ],
      69: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true

          var _setPrototypeOf = require('../core-js/object/set-prototype-of')

          var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf)

          var _create = require('../core-js/object/create')

          var _create2 = _interopRequireDefault(_create)

          var _typeof2 = require('../helpers/typeof')

          var _typeof3 = _interopRequireDefault(_typeof2)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          exports.default = function(subClass, superClass) {
            if (typeof superClass !== 'function' && superClass !== null) {
              throw new TypeError(
                'Super expression must either be null or a function, not ' +
                  (typeof superClass === 'undefined'
                    ? 'undefined'
                    : (0, _typeof3.default)(superClass))
              )
            }

            subClass.prototype = (0, _create2.default)(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true,
                },
              }
            )
            if (superClass)
              _setPrototypeOf2.default
                ? (0, _setPrototypeOf2.default)(subClass, superClass)
                : (subClass.__proto__ = superClass)
          }
        },
        {
          '../core-js/object/create': 59,
          '../core-js/object/set-prototype-of': 62,
          '../helpers/typeof': 72,
        },
      ],
      70: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true

          exports.default = function(obj, keys) {
            var target = {}

            for (var i in obj) {
              if (keys.indexOf(i) >= 0) continue
              if (!Object.prototype.hasOwnProperty.call(obj, i)) continue
              target[i] = obj[i]
            }

            return target
          }
        },
        {},
      ],
      71: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true

          var _typeof2 = require('../helpers/typeof')

          var _typeof3 = _interopRequireDefault(_typeof2)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          exports.default = function(self, call) {
            if (!self) {
              throw new ReferenceError(
                "this hasn't been initialised - super() hasn't been called"
              )
            }

            return call &&
              ((typeof call === 'undefined'
                ? 'undefined'
                : (0, _typeof3.default)(call)) === 'object' ||
                typeof call === 'function')
              ? call
              : self
          }
        },
        { '../helpers/typeof': 72 },
      ],
      72: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true

          var _iterator = require('../core-js/symbol/iterator')

          var _iterator2 = _interopRequireDefault(_iterator)

          var _symbol = require('../core-js/symbol')

          var _symbol2 = _interopRequireDefault(_symbol)

          var _typeof = typeof _symbol2.default === 'function' &&
            typeof _iterator2.default === 'symbol'
            ? function(obj) {
                return typeof obj
              }
            : function(obj) {
                return obj &&
                  typeof _symbol2.default === 'function' &&
                  obj.constructor === _symbol2.default &&
                  obj !== _symbol2.default.prototype
                  ? 'symbol'
                  : typeof obj
              }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          exports.default = typeof _symbol2.default === 'function' &&
            _typeof(_iterator2.default) === 'symbol'
            ? function(obj) {
                return typeof obj === 'undefined' ? 'undefined' : _typeof(obj)
              }
            : function(obj) {
                return obj &&
                  typeof _symbol2.default === 'function' &&
                  obj.constructor === _symbol2.default &&
                  obj !== _symbol2.default.prototype
                  ? 'symbol'
                  : typeof obj === 'undefined' ? 'undefined' : _typeof(obj)
              }
        },
        { '../core-js/symbol': 63, '../core-js/symbol/iterator': 65 },
      ],
      73: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true

          var _symbol = require('babel-runtime/core-js/symbol')

          var _symbol2 = _interopRequireDefault(_symbol)

          exports.default = function(code, opts) {
            var stack = void 0
            try {
              throw new Error()
            } catch (error) {
              if (error.stack) {
                stack = error.stack.split('\n').slice(1).join('\n')
              }
            }

            opts = (0, _assign2.default)(
              {
                allowReturnOutsideFunction: true,
                allowSuperOutsideMethod: true,
                preserveComments: false,
              },
              opts
            )

            var _getAst = function getAst() {
              var ast = void 0

              try {
                ast = babylon.parse(code, opts)

                ast = _babelTraverse2.default.removeProperties(ast, {
                  preserveComments: opts.preserveComments,
                })

                _babelTraverse2.default.cheap(ast, function(node) {
                  node[FROM_TEMPLATE] = true
                })
              } catch (err) {
                err.stack = err.stack + 'from\n' + stack
                throw err
              }

              _getAst = function getAst() {
                return ast
              }

              return ast
            }

            return function() {
              for (
                var _len = arguments.length, args = Array(_len), _key = 0;
                _key < _len;
                _key++
              ) {
                args[_key] = arguments[_key]
              }

              return useTemplate(_getAst(), args)
            }
          }

          var _cloneDeep = require('lodash/cloneDeep')

          var _cloneDeep2 = _interopRequireDefault(_cloneDeep)

          var _assign = require('lodash/assign')

          var _assign2 = _interopRequireDefault(_assign)

          var _has = require('lodash/has')

          var _has2 = _interopRequireDefault(_has)

          var _babelTraverse = require('babel-traverse')

          var _babelTraverse2 = _interopRequireDefault(_babelTraverse)

          var _babylon = require('babylon')

          var babylon = _interopRequireWildcard(_babylon)

          var _babelTypes = require('babel-types')

          var t = _interopRequireWildcard(_babelTypes)

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj
            } else {
              var newObj = {}
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key]
                }
              }
              newObj.default = obj
              return newObj
            }
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          var FROM_TEMPLATE = '_fromTemplate'
          var TEMPLATE_SKIP = (0, _symbol2.default)()

          function useTemplate(ast, nodes) {
            ast = (0, _cloneDeep2.default)(ast)
            var _ast = ast,
              program = _ast.program

            if (nodes.length) {
              ;(0, _babelTraverse2.default)(ast, templateVisitor, null, nodes)
            }

            if (program.body.length > 1) {
              return program.body
            } else {
              return program.body[0]
            }
          }

          var templateVisitor = {
            noScope: true,

            enter: function enter(path, args) {
              var node = path.node

              if (node[TEMPLATE_SKIP]) return path.skip()

              if (t.isExpressionStatement(node)) {
                node = node.expression
              }

              var replacement = void 0

              if (t.isIdentifier(node) && node[FROM_TEMPLATE]) {
                if ((0, _has2.default)(args[0], node.name)) {
                  replacement = args[0][node.name]
                } else if (node.name[0] === '$') {
                  var i = +node.name.slice(1)
                  if (args[i]) replacement = args[i]
                }
              }

              if (replacement === null) {
                path.remove()
              }

              if (replacement) {
                replacement[TEMPLATE_SKIP] = true
                path.replaceInline(replacement)
              }
            },
            exit: function exit(_ref) {
              var node = _ref.node

              if (!node.loc) _babelTraverse2.default.clearNode(node)
            },
          }
          module.exports = exports['default']
        },
        {
          'babel-runtime/core-js/symbol': 63,
          'babel-traverse': 77,
          'babel-types': 110,
          babylon: 114,
          'lodash/assign': 449,
          'lodash/cloneDeep': 452,
          'lodash/has': 463,
        },
      ],
      74: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true
          exports.scope = exports.path = undefined

          var _weakMap = require('babel-runtime/core-js/weak-map')

          var _weakMap2 = _interopRequireDefault(_weakMap)

          exports.clear = clear
          exports.clearPath = clearPath
          exports.clearScope = clearScope

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          var path = (exports.path = new _weakMap2.default())
          var scope = (exports.scope = new _weakMap2.default())

          function clear() {
            clearPath()
            clearScope()
          }

          function clearPath() {
            exports.path = path = new _weakMap2.default()
          }

          function clearScope() {
            exports.scope = scope = new _weakMap2.default()
          }
        },
        { 'babel-runtime/core-js/weak-map': 66 },
      ],
      75: [
        function(require, module, exports) {
          ;(function(process) {
            'use strict'
            exports.__esModule = true

            var _getIterator2 = require('babel-runtime/core-js/get-iterator')

            var _getIterator3 = _interopRequireDefault(_getIterator2)

            var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck')

            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2)

            var _path2 = require('./path')

            var _path3 = _interopRequireDefault(_path2)

            var _babelTypes = require('babel-types')

            var t = _interopRequireWildcard(_babelTypes)

            function _interopRequireWildcard(obj) {
              if (obj && obj.__esModule) {
                return obj
              } else {
                var newObj = {}
                if (obj != null) {
                  for (var key in obj) {
                    if (Object.prototype.hasOwnProperty.call(obj, key))
                      newObj[key] = obj[key]
                  }
                }
                newObj.default = obj
                return newObj
              }
            }

            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj }
            }

            var testing = process.env.NODE_ENV === 'test'

            var TraversalContext = (function() {
              function TraversalContext(scope, opts, state, parentPath) {
                ;(0, _classCallCheck3.default)(this, TraversalContext)
                this.queue = null

                this.parentPath = parentPath
                this.scope = scope
                this.state = state
                this.opts = opts
              }

              TraversalContext.prototype.shouldVisit = function shouldVisit(
                node
              ) {
                var opts = this.opts
                if (opts.enter || opts.exit) return true

                if (opts[node.type]) return true

                var keys = t.VISITOR_KEYS[node.type]
                if (!keys || !keys.length) return false

                for (
                  var _iterator = keys,
                    _isArray = Array.isArray(_iterator),
                    _i = 0,
                    _iterator = _isArray
                      ? _iterator
                      : (0, _getIterator3.default)(_iterator);
                  ;

                ) {
                  var _ref

                  if (_isArray) {
                    if (_i >= _iterator.length) break
                    _ref = _iterator[_i++]
                  } else {
                    _i = _iterator.next()
                    if (_i.done) break
                    _ref = _i.value
                  }

                  var key = _ref

                  if (node[key]) return true
                }

                return false
              }

              TraversalContext.prototype.create = function create(
                node,
                obj,
                key,
                listKey
              ) {
                return _path3.default.get({
                  parentPath: this.parentPath,
                  parent: node,
                  container: obj,
                  key: key,
                  listKey: listKey,
                })
              }

              TraversalContext.prototype.maybeQueue = function maybeQueue(
                path,
                notPriority
              ) {
                if (this.trap) {
                  throw new Error('Infinite cycle detected')
                }

                if (this.queue) {
                  if (notPriority) {
                    this.queue.push(path)
                  } else {
                    this.priorityQueue.push(path)
                  }
                }
              }

              TraversalContext.prototype.visitMultiple = function visitMultiple(
                container,
                parent,
                listKey
              ) {
                if (container.length === 0) return false

                var queue = []

                for (var key = 0; key < container.length; key++) {
                  var node = container[key]
                  if (node && this.shouldVisit(node)) {
                    queue.push(this.create(parent, container, key, listKey))
                  }
                }

                return this.visitQueue(queue)
              }

              TraversalContext.prototype.visitSingle = function visitSingle(
                node,
                key
              ) {
                if (this.shouldVisit(node[key])) {
                  return this.visitQueue([this.create(node, node, key)])
                } else {
                  return false
                }
              }

              TraversalContext.prototype.visitQueue = function visitQueue(
                queue
              ) {
                this.queue = queue
                this.priorityQueue = []

                var visited = []
                var stop = false

                for (
                  var _iterator2 = queue,
                    _isArray2 = Array.isArray(_iterator2),
                    _i2 = 0,
                    _iterator2 = _isArray2
                      ? _iterator2
                      : (0, _getIterator3.default)(_iterator2);
                  ;

                ) {
                  var _ref2

                  if (_isArray2) {
                    if (_i2 >= _iterator2.length) break
                    _ref2 = _iterator2[_i2++]
                  } else {
                    _i2 = _iterator2.next()
                    if (_i2.done) break
                    _ref2 = _i2.value
                  }

                  var path = _ref2

                  path.resync()

                  if (
                    path.contexts.length === 0 ||
                    path.contexts[path.contexts.length - 1] !== this
                  ) {
                    path.pushContext(this)
                  }

                  if (path.key === null) continue

                  if (testing && queue.length >= 10000) {
                    this.trap = true
                  }

                  if (visited.indexOf(path.node) >= 0) continue
                  visited.push(path.node)

                  if (path.visit()) {
                    stop = true
                    break
                  }

                  if (this.priorityQueue.length) {
                    stop = this.visitQueue(this.priorityQueue)
                    this.priorityQueue = []
                    this.queue = queue
                    if (stop) break
                  }
                }

                for (
                  var _iterator3 = queue,
                    _isArray3 = Array.isArray(_iterator3),
                    _i3 = 0,
                    _iterator3 = _isArray3
                      ? _iterator3
                      : (0, _getIterator3.default)(_iterator3);
                  ;

                ) {
                  var _ref3

                  if (_isArray3) {
                    if (_i3 >= _iterator3.length) break
                    _ref3 = _iterator3[_i3++]
                  } else {
                    _i3 = _iterator3.next()
                    if (_i3.done) break
                    _ref3 = _i3.value
                  }

                  var _path = _ref3

                  _path.popContext()
                }

                this.queue = null

                return stop
              }

              TraversalContext.prototype.visit = function visit(node, key) {
                var nodes = node[key]
                if (!nodes) return false

                if (Array.isArray(nodes)) {
                  return this.visitMultiple(nodes, node, key)
                } else {
                  return this.visitSingle(node, key)
                }
              }

              return TraversalContext
            })()

            exports.default = TraversalContext
            module.exports = exports['default']
          }.call(this, require('_process')))
        },
        {
          './path': 84,
          _process: 507,
          'babel-runtime/core-js/get-iterator': 54,
          'babel-runtime/helpers/classCallCheck': 68,
          'babel-types': 110,
        },
      ],
      76: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true

          var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck')

          var _classCallCheck3 = _interopRequireDefault(_classCallCheck2)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          var Hub = function Hub(file, options) {
            ;(0, _classCallCheck3.default)(this, Hub)

            this.file = file
            this.options = options
          }

          exports.default = Hub
          module.exports = exports['default']
        },
        { 'babel-runtime/helpers/classCallCheck': 68 },
      ],
      77: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true
          exports.visitors = exports.Hub = exports.Scope = exports.NodePath = undefined

          var _getIterator2 = require('babel-runtime/core-js/get-iterator')

          var _getIterator3 = _interopRequireDefault(_getIterator2)

          var _path = require('./path')

          Object.defineProperty(exports, 'NodePath', {
            enumerable: true,
            get: function get() {
              return _interopRequireDefault(_path).default
            },
          })

          var _scope = require('./scope')

          Object.defineProperty(exports, 'Scope', {
            enumerable: true,
            get: function get() {
              return _interopRequireDefault(_scope).default
            },
          })

          var _hub = require('./hub')

          Object.defineProperty(exports, 'Hub', {
            enumerable: true,
            get: function get() {
              return _interopRequireDefault(_hub).default
            },
          })
          exports.default = traverse

          var _context = require('./context')

          var _context2 = _interopRequireDefault(_context)

          var _visitors = require('./visitors')

          var visitors = _interopRequireWildcard(_visitors)

          var _babelMessages = require('babel-messages')

          var messages = _interopRequireWildcard(_babelMessages)

          var _includes = require('lodash/includes')

          var _includes2 = _interopRequireDefault(_includes)

          var _babelTypes = require('babel-types')

          var t = _interopRequireWildcard(_babelTypes)

          var _cache = require('./cache')

          var cache = _interopRequireWildcard(_cache)

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj
            } else {
              var newObj = {}
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key]
                }
              }
              newObj.default = obj
              return newObj
            }
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          exports.visitors = visitors
          function traverse(parent, opts, scope, state, parentPath) {
            if (!parent) return
            if (!opts) opts = {}

            if (!opts.noScope && !scope) {
              if (parent.type !== 'Program' && parent.type !== 'File') {
                throw new Error(
                  messages.get('traverseNeedsParent', parent.type)
                )
              }
            }

            visitors.explode(opts)

            traverse.node(parent, opts, scope, state, parentPath)
          }

          traverse.visitors = visitors
          traverse.verify = visitors.verify
          traverse.explode = visitors.explode

          traverse.NodePath = require('./path')
          traverse.Scope = require('./scope')
          traverse.Hub = require('./hub')

          traverse.cheap = function(node, enter) {
            return t.traverseFast(node, enter)
          }

          traverse.node = function(
            node,
            opts,
            scope,
            state,
            parentPath,
            skipKeys
          ) {
            var keys = t.VISITOR_KEYS[node.type]
            if (!keys) return

            var context = new _context2.default(scope, opts, state, parentPath)
            for (
              var _iterator = keys,
                _isArray = Array.isArray(_iterator),
                _i = 0,
                _iterator = _isArray
                  ? _iterator
                  : (0, _getIterator3.default)(_iterator);
              ;

            ) {
              var _ref

              if (_isArray) {
                if (_i >= _iterator.length) break
                _ref = _iterator[_i++]
              } else {
                _i = _iterator.next()
                if (_i.done) break
                _ref = _i.value
              }

              var key = _ref

              if (skipKeys && skipKeys[key]) continue
              if (context.visit(node, key)) return
            }
          }

          traverse.clearNode = function(node, opts) {
            t.removeProperties(node, opts)

            cache.path.delete(node)
          }

          traverse.removeProperties = function(tree, opts) {
            t.traverseFast(tree, traverse.clearNode, opts)
            return tree
          }

          function hasBlacklistedType(path, state) {
            if (path.node.type === state.type) {
              state.has = true
              path.stop()
            }
          }

          traverse.hasType = function(tree, scope, type, blacklistTypes) {
            if ((0, _includes2.default)(blacklistTypes, tree.type)) return false

            if (tree.type === type) return true

            var state = {
              has: false,
              type: type,
            }

            traverse(
              tree,
              {
                blacklist: blacklistTypes,
                enter: hasBlacklistedType,
              },
              scope,
              state
            )

            return state.has
          }

          traverse.clearCache = function() {
            cache.clear()
          }

          traverse.clearCache.clearPath = cache.clearPath
          traverse.clearCache.clearScope = cache.clearScope

          traverse.copyCache = function(source, destination) {
            if (cache.path.has(source)) {
              cache.path.set(destination, cache.path.get(source))
            }
          }
        },
        {
          './cache': 74,
          './context': 75,
          './hub': 76,
          './path': 84,
          './scope': 96,
          './visitors': 98,
          'babel-messages': 53,
          'babel-runtime/core-js/get-iterator': 54,
          'babel-types': 110,
          'lodash/includes': 466,
        },
      ],
      78: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true

          var _getIterator2 = require('babel-runtime/core-js/get-iterator')

          var _getIterator3 = _interopRequireDefault(_getIterator2)

          exports.findParent = findParent
          exports.find = find
          exports.getFunctionParent = getFunctionParent
          exports.getStatementParent = getStatementParent
          exports.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom
          exports.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom
          exports.getAncestry = getAncestry
          exports.isAncestor = isAncestor
          exports.isDescendant = isDescendant
          exports.inType = inType
          exports.inShadow = inShadow

          var _babelTypes = require('babel-types')

          var t = _interopRequireWildcard(_babelTypes)

          var _index = require('./index')

          var _index2 = _interopRequireDefault(_index)

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj
            } else {
              var newObj = {}
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key]
                }
              }
              newObj.default = obj
              return newObj
            }
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          function findParent(callback) {
            var path = this
            while ((path = path.parentPath)) {
              if (callback(path)) return path
            }
            return null
          }

          function find(callback) {
            var path = this
            do {
              if (callback(path)) return path
            } while ((path = path.parentPath))
            return null
          }

          function getFunctionParent() {
            return this.findParent(function(path) {
              return path.isFunction() || path.isProgram()
            })
          }

          function getStatementParent() {
            var path = this
            do {
              if (Array.isArray(path.container)) {
                return path
              }
            } while ((path = path.parentPath))
          }

          function getEarliestCommonAncestorFrom(paths) {
            return this.getDeepestCommonAncestorFrom(paths, function(
              deepest,
              i,
              ancestries
            ) {
              var earliest = void 0
              var keys = t.VISITOR_KEYS[deepest.type]

              for (
                var _iterator = ancestries,
                  _isArray = Array.isArray(_iterator),
                  _i = 0,
                  _iterator = _isArray
                    ? _iterator
                    : (0, _getIterator3.default)(_iterator);
                ;

              ) {
                var _ref

                if (_isArray) {
                  if (_i >= _iterator.length) break
                  _ref = _iterator[_i++]
                } else {
                  _i = _iterator.next()
                  if (_i.done) break
                  _ref = _i.value
                }

                var ancestry = _ref

                var path = ancestry[i + 1]

                if (!earliest) {
                  earliest = path
                  continue
                }

                if (path.listKey && earliest.listKey === path.listKey) {
                  if (path.key < earliest.key) {
                    earliest = path
                    continue
                  }
                }

                var earliestKeyIndex = keys.indexOf(earliest.parentKey)
                var currentKeyIndex = keys.indexOf(path.parentKey)
                if (earliestKeyIndex > currentKeyIndex) {
                  earliest = path
                }
              }

              return earliest
            })
          }

          function getDeepestCommonAncestorFrom(paths, filter) {
            var _this = this

            if (!paths.length) {
              return this
            }

            if (paths.length === 1) {
              return paths[0]
            }

            var minDepth = Infinity

            var lastCommonIndex = void 0,
              lastCommon = void 0

            var ancestries = paths.map(function(path) {
              var ancestry = []

              do {
                ancestry.unshift(path)
              } while ((path = path.parentPath) && path !== _this)

              if (ancestry.length < minDepth) {
                minDepth = ancestry.length
              }

              return ancestry
            })

            var first = ancestries[0]

            depthLoop: for (var i = 0; i < minDepth; i++) {
              var shouldMatch = first[i]

              for (
                var _iterator2 = ancestries,
                  _isArray2 = Array.isArray(_iterator2),
                  _i2 = 0,
                  _iterator2 = _isArray2
                    ? _iterator2
                    : (0, _getIterator3.default)(_iterator2);
                ;

              ) {
                var _ref2

                if (_isArray2) {
                  if (_i2 >= _iterator2.length) break
                  _ref2 = _iterator2[_i2++]
                } else {
                  _i2 = _iterator2.next()
                  if (_i2.done) break
                  _ref2 = _i2.value
                }

                var ancestry = _ref2

                if (ancestry[i] !== shouldMatch) {
                  break depthLoop
                }
              }

              lastCommonIndex = i
              lastCommon = shouldMatch
            }

            if (lastCommon) {
              if (filter) {
                return filter(lastCommon, lastCommonIndex, ancestries)
              } else {
                return lastCommon
              }
            } else {
              throw new Error("Couldn't find intersection")
            }
          }

          function getAncestry() {
            var path = this
            var paths = []
            do {
              paths.push(path)
            } while ((path = path.parentPath))
            return paths
          }

          function isAncestor(maybeDescendant) {
            return maybeDescendant.isDescendant(this)
          }

          function isDescendant(maybeAncestor) {
            return !!this.findParent(function(parent) {
              return parent === maybeAncestor
            })
          }

          function inType() {
            var path = this
            while (path) {
              for (
                var _iterator3 = arguments,
                  _isArray3 = Array.isArray(_iterator3),
                  _i3 = 0,
                  _iterator3 = _isArray3
                    ? _iterator3
                    : (0, _getIterator3.default)(_iterator3);
                ;

              ) {
                var _ref3

                if (_isArray3) {
                  if (_i3 >= _iterator3.length) break
                  _ref3 = _iterator3[_i3++]
                } else {
                  _i3 = _iterator3.next()
                  if (_i3.done) break
                  _ref3 = _i3.value
                }

                var type = _ref3

                if (path.node.type === type) return true
              }
              path = path.parentPath
            }

            return false
          }

          function inShadow(key) {
            var parentFn = this.isFunction()
              ? this
              : this.findParent(function(p) {
                  return p.isFunction()
                })
            if (!parentFn) return

            if (
              parentFn.isFunctionExpression() ||
              parentFn.isFunctionDeclaration()
            ) {
              var shadow = parentFn.node.shadow

              if (shadow && (!key || shadow[key] !== false)) {
                return parentFn
              }
            } else if (parentFn.isArrowFunctionExpression()) {
              return parentFn
            }

            return null
          }
        },
        {
          './index': 84,
          'babel-runtime/core-js/get-iterator': 54,
          'babel-types': 110,
        },
      ],
      79: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true
          exports.shareCommentsWithSiblings = shareCommentsWithSiblings
          exports.addComment = addComment
          exports.addComments = addComments
          function shareCommentsWithSiblings() {
            if (typeof this.key === 'string') return

            var node = this.node
            if (!node) return

            var trailing = node.trailingComments
            var leading = node.leadingComments
            if (!trailing && !leading) return

            var prev = this.getSibling(this.key - 1)
            var next = this.getSibling(this.key + 1)

            if (!prev.node) prev = next
            if (!next.node) next = prev

            prev.addComments('trailing', leading)
            next.addComments('leading', trailing)
          }

          function addComment(type, content, line) {
            this.addComments(type, [
              {
                type: line ? 'CommentLine' : 'CommentBlock',
                value: content,
              },
            ])
          }

          function addComments(type, comments) {
            if (!comments) return

            var node = this.node
            if (!node) return

            var key = type + 'Comments'

            if (node[key]) {
              node[key] = node[key].concat(comments)
            } else {
              node[key] = comments
            }
          }
        },
        {},
      ],
      80: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true

          var _getIterator2 = require('babel-runtime/core-js/get-iterator')

          var _getIterator3 = _interopRequireDefault(_getIterator2)

          exports.call = call
          exports._call = _call
          exports.isBlacklisted = isBlacklisted
          exports.visit = visit
          exports.skip = skip
          exports.skipKey = skipKey
          exports.stop = stop
          exports.setScope = setScope
          exports.setContext = setContext
          exports.resync = resync
          exports._resyncParent = _resyncParent
          exports._resyncKey = _resyncKey
          exports._resyncList = _resyncList
          exports._resyncRemoved = _resyncRemoved
          exports.popContext = popContext
          exports.pushContext = pushContext
          exports.setup = setup
          exports.setKey = setKey
          exports.requeue = requeue
          exports._getQueueContexts = _getQueueContexts

          var _index = require('../index')

          var _index2 = _interopRequireDefault(_index)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          function call(key) {
            var opts = this.opts

            this.debug(function() {
              return key
            })

            if (this.node) {
              if (this._call(opts[key])) return true
            }

            if (this.node) {
              return this._call(
                opts[this.node.type] && opts[this.node.type][key]
              )
            }

            return false
          }

          function _call(fns) {
            if (!fns) return false

            for (
              var _iterator = fns,
                _isArray = Array.isArray(_iterator),
                _i = 0,
                _iterator = _isArray
                  ? _iterator
                  : (0, _getIterator3.default)(_iterator);
              ;

            ) {
              var _ref

              if (_isArray) {
                if (_i >= _iterator.length) break
                _ref = _iterator[_i++]
              } else {
                _i = _iterator.next()
                if (_i.done) break
                _ref = _i.value
              }

              var fn = _ref

              if (!fn) continue

              var node = this.node
              if (!node) return true

              var ret = fn.call(this.state, this, this.state)
              if (ret)
                throw new Error(
                  'Unexpected return value from visitor method ' + fn
                )

              if (this.node !== node) return true

              if (this.shouldStop || this.shouldSkip || this.removed)
                return true
            }

            return false
          }

          function isBlacklisted() {
            var blacklist = this.opts.blacklist
            return blacklist && blacklist.indexOf(this.node.type) > -1
          }

          function visit() {
            if (!this.node) {
              return false
            }

            if (this.isBlacklisted()) {
              return false
            }

            if (this.opts.shouldSkip && this.opts.shouldSkip(this)) {
              return false
            }

            if (this.call('enter') || this.shouldSkip) {
              this.debug(function() {
                return 'Skip...'
              })
              return this.shouldStop
            }

            this.debug(function() {
              return 'Recursing into...'
            })
            _index2.default.node(
              this.node,
              this.opts,
              this.scope,
              this.state,
              this,
              this.skipKeys
            )

            this.call('exit')

            return this.shouldStop
          }

          function skip() {
            this.shouldSkip = true
          }

          function skipKey(key) {
            this.skipKeys[key] = true
          }

          function stop() {
            this.shouldStop = true
            this.shouldSkip = true
          }

          function setScope() {
            if (this.opts && this.opts.noScope) return

            var target = this.context && this.context.scope

            if (!target) {
              var path = this.parentPath
              while (path && !target) {
                if (path.opts && path.opts.noScope) return

                target = path.scope
                path = path.parentPath
              }
            }

            this.scope = this.getScope(target)
            if (this.scope) this.scope.init()
          }

          function setContext(context) {
            this.shouldSkip = false
            this.shouldStop = false
            this.removed = false
            this.skipKeys = {}

            if (context) {
              this.context = context
              this.state = context.state
              this.opts = context.opts
            }

            this.setScope()

            return this
          }

          function resync() {
            if (this.removed) return

            this._resyncParent()
            this._resyncList()
            this._resyncKey()
          }

          function _resyncParent() {
            if (this.parentPath) {
              this.parent = this.parentPath.node
            }
          }

          function _resyncKey() {
            if (!this.container) return

            if (this.node === this.container[this.key]) return

            if (Array.isArray(this.container)) {
              for (var i = 0; i < this.container.length; i++) {
                if (this.container[i] === this.node) {
                  return this.setKey(i)
                }
              }
            } else {
              for (var key in this.container) {
                if (this.container[key] === this.node) {
                  return this.setKey(key)
                }
              }
            }

            this.key = null
          }

          function _resyncList() {
            if (!this.parent || !this.inList) return

            var newContainer = this.parent[this.listKey]
            if (this.container === newContainer) return

            this.container = newContainer || null
          }

          function _resyncRemoved() {
            if (
              this.key == null ||
              !this.container ||
              this.container[this.key] !== this.node
            ) {
              this._markRemoved()
            }
          }

          function popContext() {
            this.contexts.pop()
            this.setContext(this.contexts[this.contexts.length - 1])
          }

          function pushContext(context) {
            this.contexts.push(context)
            this.setContext(context)
          }

          function setup(parentPath, container, listKey, key) {
            this.inList = !!listKey
            this.listKey = listKey
            this.parentKey = listKey || key
            this.container = container

            this.parentPath = parentPath || this.parentPath
            this.setKey(key)
          }

          function setKey(key) {
            this.key = key
            this.node = this.container[this.key]
            this.type = this.node && this.node.type
          }

          function requeue() {
            var pathToQueue = arguments.length > 0 && arguments[0] !== undefined
              ? arguments[0]
              : this

            if (pathToQueue.removed) return

            var contexts = this.contexts

            for (
              var _iterator2 = contexts,
                _isArray2 = Array.isArray(_iterator2),
                _i2 = 0,
                _iterator2 = _isArray2
                  ? _iterator2
                  : (0, _getIterator3.default)(_iterator2);
              ;

            ) {
              var _ref2

              if (_isArray2) {
                if (_i2 >= _iterator2.length) break
                _ref2 = _iterator2[_i2++]
              } else {
                _i2 = _iterator2.next()
                if (_i2.done) break
                _ref2 = _i2.value
              }

              var context = _ref2

              context.maybeQueue(pathToQueue)
            }
          }

          function _getQueueContexts() {
            var path = this
            var contexts = this.contexts
            while (!contexts.length) {
              path = path.parentPath
              contexts = path.contexts
            }
            return contexts
          }
        },
        { '../index': 77, 'babel-runtime/core-js/get-iterator': 54 },
      ],
      81: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true
          exports.toComputedKey = toComputedKey
          exports.ensureBlock = ensureBlock
          exports.arrowFunctionToShadowed = arrowFunctionToShadowed

          var _babelTypes = require('babel-types')

          var t = _interopRequireWildcard(_babelTypes)

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj
            } else {
              var newObj = {}
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key]
                }
              }
              newObj.default = obj
              return newObj
            }
          }

          function toComputedKey() {
            var node = this.node

            var key = void 0
            if (this.isMemberExpression()) {
              key = node.property
            } else if (this.isProperty() || this.isMethod()) {
              key = node.key
            } else {
              throw new ReferenceError('todo')
            }

            if (!node.computed) {
              if (t.isIdentifier(key)) key = t.stringLiteral(key.name)
            }

            return key
          }

          function ensureBlock() {
            return t.ensureBlock(this.node)
          }

          function arrowFunctionToShadowed() {
            if (!this.isArrowFunctionExpression()) return

            this.ensureBlock()

            var node = this.node

            node.expression = false
            node.type = 'FunctionExpression'
            node.shadow = node.shadow || true
          }
        },
        { 'babel-types': 110 },
      ],
      82: [
        function(require, module, exports) {
          ;(function(global) {
            'use strict'
            exports.__esModule = true

            var _typeof2 = require('babel-runtime/helpers/typeof')

            var _typeof3 = _interopRequireDefault(_typeof2)

            var _getIterator2 = require('babel-runtime/core-js/get-iterator')

            var _getIterator3 = _interopRequireDefault(_getIterator2)

            var _map = require('babel-runtime/core-js/map')

            var _map2 = _interopRequireDefault(_map)

            exports.evaluateTruthy = evaluateTruthy
            exports.evaluate = evaluate

            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj }
            }

            var VALID_CALLEES = ['String', 'Number', 'Math']
            var INVALID_METHODS = ['random']

            function evaluateTruthy() {
              var res = this.evaluate()
              if (res.confident) return !!res.value
            }

            function evaluate() {
              var confident = true
              var deoptPath = void 0
              var seen = new _map2.default()

              function deopt(path) {
                if (!confident) return
                deoptPath = path
                confident = false
              }

              var value = evaluate(this)
              if (!confident) value = undefined
              return {
                confident: confident,
                deopt: deoptPath,
                value: value,
              }

              function evaluate(path) {
                var node = path.node

                if (seen.has(node)) {
                  var existing = seen.get(node)
                  if (existing.resolved) {
                    return existing.value
                  } else {
                    deopt(path)
                    return
                  }
                } else {
                  var item = { resolved: false }
                  seen.set(node, item)

                  var val = _evaluate(path)
                  if (confident) {
                    item.resolved = true
                    item.value = val
                  }
                  return val
                }
              }

              function _evaluate(path) {
                if (!confident) return

                var node = path.node

                if (path.isSequenceExpression()) {
                  var exprs = path.get('expressions')
                  return evaluate(exprs[exprs.length - 1])
                }

                if (
                  path.isStringLiteral() ||
                  path.isNumericLiteral() ||
                  path.isBooleanLiteral()
                ) {
                  return node.value
                }

                if (path.isNullLiteral()) {
                  return null
                }

                if (path.isTemplateLiteral()) {
                  var str = ''

                  var i = 0
                  var _exprs = path.get('expressions')

                  for (
                    var _iterator = node.quasis,
                      _isArray = Array.isArray(_iterator),
                      _i = 0,
                      _iterator = _isArray
                        ? _iterator
                        : (0, _getIterator3.default)(_iterator);
                    ;

                  ) {
                    var _ref

                    if (_isArray) {
                      if (_i >= _iterator.length) break
                      _ref = _iterator[_i++]
                    } else {
                      _i = _iterator.next()
                      if (_i.done) break
                      _ref = _i.value
                    }

                    var elem = _ref

                    if (!confident) break

                    str += elem.value.cooked

                    var expr = _exprs[i++]
                    if (expr) str += String(evaluate(expr))
                  }

                  if (!confident) return
                  return str
                }

                if (path.isConditionalExpression()) {
                  var testResult = evaluate(path.get('test'))
                  if (!confident) return
                  if (testResult) {
                    return evaluate(path.get('consequent'))
                  } else {
                    return evaluate(path.get('alternate'))
                  }
                }

                if (path.isExpressionWrapper()) {
                  return evaluate(path.get('expression'))
                }

                if (
                  path.isMemberExpression() &&
                  !path.parentPath.isCallExpression({ callee: node })
                ) {
                  var property = path.get('property')
                  var object = path.get('object')

                  if (object.isLiteral() && property.isIdentifier()) {
                    var _value = object.node.value
                    var type = typeof _value === 'undefined'
                      ? 'undefined'
                      : (0, _typeof3.default)(_value)
                    if (type === 'number' || type === 'string') {
                      return _value[property.node.name]
                    }
                  }
                }

                if (path.isReferencedIdentifier()) {
                  var binding = path.scope.getBinding(node.name)

                  if (binding && binding.constantViolations.length > 0) {
                    return deopt(binding.path)
                  }

                  if (binding && path.node.start < binding.path.node.end) {
                    return deopt(binding.path)
                  }

                  if (binding && binding.hasValue) {
                    return binding.value
                  } else {
                    if (node.name === 'undefined') {
                      return binding ? deopt(binding.path) : undefined
                    } else if (node.name === 'Infinity') {
                      return binding ? deopt(binding.path) : Infinity
                    } else if (node.name === 'NaN') {
                      return binding ? deopt(binding.path) : NaN
                    }

                    var resolved = path.resolve()
                    if (resolved === path) {
                      return deopt(path)
                    } else {
                      return evaluate(resolved)
                    }
                  }
                }

                if (path.isUnaryExpression({ prefix: true })) {
                  if (node.operator === 'void') {
                    return undefined
                  }

                  var argument = path.get('argument')
                  if (
                    node.operator === 'typeof' &&
                    (argument.isFunction() || argument.isClass())
                  ) {
                    return 'function'
                  }

                  var arg = evaluate(argument)
                  if (!confident) return
                  switch (node.operator) {
                    case '!':
                      return !arg
                    case '+':
                      return +arg
                    case '-':
                      return -arg
                    case '~':
                      return ~arg
                    case 'typeof':
                      return typeof arg === 'undefined'
                        ? 'undefined'
                        : (0, _typeof3.default)(arg)
                  }
                }

                if (path.isArrayExpression()) {
                  var arr = []
                  var elems = path.get('elements')
                  for (
                    var _iterator2 = elems,
                      _isArray2 = Array.isArray(_iterator2),
                      _i2 = 0,
                      _iterator2 = _isArray2
                        ? _iterator2
                        : (0, _getIterator3.default)(_iterator2);
                    ;

                  ) {
                    var _ref2

                    if (_isArray2) {
                      if (_i2 >= _iterator2.length) break
                      _ref2 = _iterator2[_i2++]
                    } else {
                      _i2 = _iterator2.next()
                      if (_i2.done) break
                      _ref2 = _i2.value
                    }

                    var _elem = _ref2

                    _elem = _elem.evaluate()

                    if (_elem.confident) {
                      arr.push(_elem.value)
                    } else {
                      return deopt(_elem)
                    }
                  }
                  return arr
                }

                if (path.isObjectExpression()) {
                  var obj = {}
                  var props = path.get('properties')
                  for (
                    var _iterator3 = props,
                      _isArray3 = Array.isArray(_iterator3),
                      _i3 = 0,
                      _iterator3 = _isArray3
                        ? _iterator3
                        : (0, _getIterator3.default)(_iterator3);
                    ;

                  ) {
                    var _ref3

                    if (_isArray3) {
                      if (_i3 >= _iterator3.length) break
                      _ref3 = _iterator3[_i3++]
                    } else {
                      _i3 = _iterator3.next()
                      if (_i3.done) break
                      _ref3 = _i3.value
                    }

                    var prop = _ref3

                    if (prop.isObjectMethod() || prop.isSpreadProperty()) {
                      return deopt(prop)
                    }
                    var keyPath = prop.get('key')
                    var key = keyPath
                    if (prop.node.computed) {
                      key = key.evaluate()
                      if (!key.confident) {
                        return deopt(keyPath)
                      }
                      key = key.value
                    } else if (key.isIdentifier()) {
                      key = key.node.name
                    } else {
                      key = key.node.value
                    }
                    var valuePath = prop.get('value')
                    var _value2 = valuePath.evaluate()
                    if (!_value2.confident) {
                      return deopt(valuePath)
                    }
                    _value2 = _value2.value
                    obj[key] = _value2
                  }
                  return obj
                }

                if (path.isLogicalExpression()) {
                  var wasConfident = confident
                  var left = evaluate(path.get('left'))
                  var leftConfident = confident
                  confident = wasConfident
                  var right = evaluate(path.get('right'))
                  var rightConfident = confident
                  confident = leftConfident && rightConfident

                  switch (node.operator) {
                    case '||':
                      if (left && leftConfident) {
                        confident = true
                        return left
                      }

                      if (!confident) return

                      return left || right
                    case '&&':
                      if (
                        (!left && leftConfident) ||
                        (!right && rightConfident)
                      ) {
                        confident = true
                      }

                      if (!confident) return

                      return left && right
                  }
                }

                if (path.isBinaryExpression()) {
                  var _left = evaluate(path.get('left'))
                  if (!confident) return
                  var _right = evaluate(path.get('right'))
                  if (!confident) return

                  switch (node.operator) {
                    case '-':
                      return _left - _right
                    case '+':
                      return _left + _right
                    case '/':
                      return _left / _right
                    case '*':
                      return _left * _right
                    case '%':
                      return _left % _right
                    case '**':
                      return Math.pow(_left, _right)
                    case '<':
                      return _left < _right
                    case '>':
                      return _left > _right
                    case '<=':
                      return _left <= _right
                    case '>=':
                      return _left >= _right
                    case '==':
                      return _left == _right
                    case '!=':
                      return _left != _right
                    case '===':
                      return _left === _right
                    case '!==':
                      return _left !== _right
                    case '|':
                      return _left | _right
                    case '&':
                      return _left & _right
                    case '^':
                      return _left ^ _right
                    case '<<':
                      return _left << _right
                    case '>>':
                      return _left >> _right
                    case '>>>':
                      return _left >>> _right
                  }
                }

                if (path.isCallExpression()) {
                  var callee = path.get('callee')
                  var context = void 0
                  var func = void 0

                  if (
                    callee.isIdentifier() &&
                    !path.scope.getBinding(callee.node.name, true) &&
                    VALID_CALLEES.indexOf(callee.node.name) >= 0
                  ) {
                    func = global[node.callee.name]
                  }

                  if (callee.isMemberExpression()) {
                    var _object = callee.get('object')
                    var _property = callee.get('property')

                    if (
                      _object.isIdentifier() &&
                      _property.isIdentifier() &&
                      VALID_CALLEES.indexOf(_object.node.name) >= 0 &&
                      INVALID_METHODS.indexOf(_property.node.name) < 0
                    ) {
                      context = global[_object.node.name]
                      func = context[_property.node.name]
                    }

                    if (_object.isLiteral() && _property.isIdentifier()) {
                      var _type = (0, _typeof3.default)(_object.node.value)
                      if (_type === 'string' || _type === 'number') {
                        context = _object.node.value
                        func = context[_property.node.name]
                      }
                    }
                  }

                  if (func) {
                    var args = path.get('arguments').map(evaluate)
                    if (!confident) return

                    return func.apply(context, args)
                  }
                }

                deopt(path)
              }
            }
          }.call(
            this,
            typeof global !== 'undefined'
              ? global
              : typeof self !== 'undefined'
                ? self
                : typeof window !== 'undefined' ? window : {}
          ))
        },
        {
          'babel-runtime/core-js/get-iterator': 54,
          'babel-runtime/core-js/map': 56,
          'babel-runtime/helpers/typeof': 72,
        },
      ],
      83: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true

          var _create = require('babel-runtime/core-js/object/create')

          var _create2 = _interopRequireDefault(_create)

          var _getIterator2 = require('babel-runtime/core-js/get-iterator')

          var _getIterator3 = _interopRequireDefault(_getIterator2)

          exports.getStatementParent = getStatementParent
          exports.getOpposite = getOpposite
          exports.getCompletionRecords = getCompletionRecords
          exports.getSibling = getSibling
          exports.getPrevSibling = getPrevSibling
          exports.getNextSibling = getNextSibling
          exports.getAllNextSiblings = getAllNextSiblings
          exports.getAllPrevSiblings = getAllPrevSiblings
          exports.get = get
          exports._getKey = _getKey
          exports._getPattern = _getPattern
          exports.getBindingIdentifiers = getBindingIdentifiers
          exports.getOuterBindingIdentifiers = getOuterBindingIdentifiers
          exports.getBindingIdentifierPaths = getBindingIdentifierPaths
          exports.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths

          var _index = require('./index')

          var _index2 = _interopRequireDefault(_index)

          var _babelTypes = require('babel-types')

          var t = _interopRequireWildcard(_babelTypes)

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj
            } else {
              var newObj = {}
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key]
                }
              }
              newObj.default = obj
              return newObj
            }
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          function getStatementParent() {
            var path = this

            do {
              if (
                !path.parentPath ||
                (Array.isArray(path.container) && path.isStatement())
              ) {
                break
              } else {
                path = path.parentPath
              }
            } while (path)

            if (path && (path.isProgram() || path.isFile())) {
              throw new Error(
                "File/Program node, we can't possibly find a statement parent to this"
              )
            }

            return path
          }

          function getOpposite() {
            if (this.key === 'left') {
              return this.getSibling('right')
            } else if (this.key === 'right') {
              return this.getSibling('left')
            }
          }

          function getCompletionRecords() {
            var paths = []

            var add = function add(path) {
              if (path) paths = paths.concat(path.getCompletionRecords())
            }

            if (this.isIfStatement()) {
              add(this.get('consequent'))
              add(this.get('alternate'))
            } else if (
              this.isDoExpression() ||
              this.isFor() ||
              this.isWhile()
            ) {
              add(this.get('body'))
            } else if (this.isProgram() || this.isBlockStatement()) {
              add(this.get('body').pop())
            } else if (this.isFunction()) {
              return this.get('body').getCompletionRecords()
            } else if (this.isTryStatement()) {
              add(this.get('block'))
              add(this.get('handler'))
              add(this.get('finalizer'))
            } else {
              paths.push(this)
            }

            return paths
          }

          function getSibling(key) {
            return _index2.default.get({
              parentPath: this.parentPath,
              parent: this.parent,
              container: this.container,
              listKey: this.listKey,
              key: key,
            })
          }

          function getPrevSibling() {
            return this.getSibling(this.key - 1)
          }

          function getNextSibling() {
            return this.getSibling(this.key + 1)
          }

          function getAllNextSiblings() {
            var _key = this.key
            var sibling = this.getSibling(++_key)
            var siblings = []
            while (sibling.node) {
              siblings.push(sibling)
              sibling = this.getSibling(++_key)
            }
            return siblings
          }

          function getAllPrevSiblings() {
            var _key = this.key
            var sibling = this.getSibling(--_key)
            var siblings = []
            while (sibling.node) {
              siblings.push(sibling)
              sibling = this.getSibling(--_key)
            }
            return siblings
          }

          function get(key, context) {
            if (context === true) context = this.context
            var parts = key.split('.')
            if (parts.length === 1) {
              return this._getKey(key, context)
            } else {
              return this._getPattern(parts, context)
            }
          }

          function _getKey(key, context) {
            var _this = this

            var node = this.node
            var container = node[key]

            if (Array.isArray(container)) {
              return container.map(function(_, i) {
                return _index2.default
                  .get({
                    listKey: key,
                    parentPath: _this,
                    parent: node,
                    container: container,
                    key: i,
                  })
                  .setContext(context)
              })
            } else {
              return _index2.default
                .get({
                  parentPath: this,
                  parent: node,
                  container: node,
                  key: key,
                })
                .setContext(context)
            }
          }

          function _getPattern(parts, context) {
            var path = this
            for (
              var _iterator = parts,
                _isArray = Array.isArray(_iterator),
                _i = 0,
                _iterator = _isArray
                  ? _iterator
                  : (0, _getIterator3.default)(_iterator);
              ;

            ) {
              var _ref

              if (_isArray) {
                if (_i >= _iterator.length) break
                _ref = _iterator[_i++]
              } else {
                _i = _iterator.next()
                if (_i.done) break
                _ref = _i.value
              }

              var part = _ref

              if (part === '.') {
                path = path.parentPath
              } else {
                if (Array.isArray(path)) {
                  path = path[part]
                } else {
                  path = path.get(part, context)
                }
              }
            }
            return path
          }

          function getBindingIdentifiers(duplicates) {
            return t.getBindingIdentifiers(this.node, duplicates)
          }

          function getOuterBindingIdentifiers(duplicates) {
            return t.getOuterBindingIdentifiers(this.node, duplicates)
          }

          function getBindingIdentifierPaths() {
            var duplicates = arguments.length > 0 && arguments[0] !== undefined
              ? arguments[0]
              : false
            var outerOnly = arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : false

            var path = this
            var search = [].concat(path)
            var ids = (0, _create2.default)(null)

            while (search.length) {
              var id = search.shift()
              if (!id) continue
              if (!id.node) continue

              var keys = t.getBindingIdentifiers.keys[id.node.type]

              if (id.isIdentifier()) {
                if (duplicates) {
                  var _ids = (ids[id.node.name] = ids[id.node.name] || [])
                  _ids.push(id)
                } else {
                  ids[id.node.name] = id
                }
                continue
              }

              if (id.isExportDeclaration()) {
                var declaration = id.get('declaration')
                if (declaration.isDeclaration()) {
                  search.push(declaration)
                }
                continue
              }

              if (outerOnly) {
                if (id.isFunctionDeclaration()) {
                  search.push(id.get('id'))
                  continue
                }
                if (id.isFunctionExpression()) {
                  continue
                }
              }

              if (keys) {
                for (var i = 0; i < keys.length; i++) {
                  var key = keys[i]
                  var child = id.get(key)
                  if (Array.isArray(child) || child.node) {
                    search = search.concat(child)
                  }
                }
              }
            }

            return ids
          }

          function getOuterBindingIdentifierPaths(duplicates) {
            return this.getBindingIdentifierPaths(duplicates, true)
          }
        },
        {
          './index': 84,
          'babel-runtime/core-js/get-iterator': 54,
          'babel-runtime/core-js/object/create': 59,
          'babel-types': 110,
        },
      ],
      84: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true

          var _getIterator2 = require('babel-runtime/core-js/get-iterator')

          var _getIterator3 = _interopRequireDefault(_getIterator2)

          var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck')

          var _classCallCheck3 = _interopRequireDefault(_classCallCheck2)

          var _virtualTypes = require('./lib/virtual-types')

          var virtualTypes = _interopRequireWildcard(_virtualTypes)

          var _debug2 = require('debug')

          var _debug3 = _interopRequireDefault(_debug2)

          var _invariant = require('invariant')

          var _invariant2 = _interopRequireDefault(_invariant)

          var _index = require('../index')

          var _index2 = _interopRequireDefault(_index)

          var _assign = require('lodash/assign')

          var _assign2 = _interopRequireDefault(_assign)

          var _scope = require('../scope')

          var _scope2 = _interopRequireDefault(_scope)

          var _babelTypes = require('babel-types')

          var t = _interopRequireWildcard(_babelTypes)

          var _cache = require('../cache')

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj
            } else {
              var newObj = {}
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key]
                }
              }
              newObj.default = obj
              return newObj
            }
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          var _debug = (0, _debug3.default)('babel')

          var NodePath = (function() {
            function NodePath(hub, parent) {
              ;(0, _classCallCheck3.default)(this, NodePath)

              this.parent = parent
              this.hub = hub
              this.contexts = []
              this.data = {}
              this.shouldSkip = false
              this.shouldStop = false
              this.removed = false
              this.state = null
              this.opts = null
              this.skipKeys = null
              this.parentPath = null
              this.context = null
              this.container = null
              this.listKey = null
              this.inList = false
              this.parentKey = null
              this.key = null
              this.node = null
              this.scope = null
              this.type = null
              this.typeAnnotation = null
            }

            NodePath.get = function get(_ref) {
              var hub = _ref.hub,
                parentPath = _ref.parentPath,
                parent = _ref.parent,
                container = _ref.container,
                listKey = _ref.listKey,
                key = _ref.key

              if (!hub && parentPath) {
                hub = parentPath.hub
              }

              ;(0, _invariant2.default)(
                parent,
                'To get a node path the parent needs to exist'
              )

              var targetNode = container[key]

              var paths = _cache.path.get(parent) || []
              if (!_cache.path.has(parent)) {
                _cache.path.set(parent, paths)
              }

              var path = void 0

              for (var i = 0; i < paths.length; i++) {
                var pathCheck = paths[i]
                if (pathCheck.node === targetNode) {
                  path = pathCheck
                  break
                }
              }

              if (!path) {
                path = new NodePath(hub, parent)
                paths.push(path)
              }

              path.setup(parentPath, container, listKey, key)

              return path
            }

            NodePath.prototype.getScope = function getScope(scope) {
              var ourScope = scope

              if (this.isScope()) {
                ourScope = new _scope2.default(this, scope)
              }

              return ourScope
            }

            NodePath.prototype.setData = function setData(key, val) {
              return (this.data[key] = val)
            }

            NodePath.prototype.getData = function getData(key, def) {
              var val = this.data[key]
              if (!val && def) val = this.data[key] = def
              return val
            }

            NodePath.prototype.buildCodeFrameError = function buildCodeFrameError(
              msg
            ) {
              var Error = arguments.length > 1 && arguments[1] !== undefined
                ? arguments[1]
                : SyntaxError

              return this.hub.file.buildCodeFrameError(this.node, msg, Error)
            }

            NodePath.prototype.traverse = function traverse(visitor, state) {
              ;(0, _index2.default)(this.node, visitor, this.scope, state, this)
            }

            NodePath.prototype.mark = function mark(type, message) {
              this.hub.file.metadata.marked.push({
                type: type,
                message: message,
                loc: this.node.loc,
              })
            }

            NodePath.prototype.set = function set(key, node) {
              t.validate(this.node, key, node)
              this.node[key] = node
            }

            NodePath.prototype.getPathLocation = function getPathLocation() {
              var parts = []
              var path = this
              do {
                var key = path.key
                if (path.inList) key = path.listKey + '[' + key + ']'
                parts.unshift(key)
              } while ((path = path.parentPath))
              return parts.join('.')
            }

            NodePath.prototype.debug = function debug(buildMessage) {
              if (!_debug.enabled) return
              _debug(
                this.getPathLocation() + ' ' + this.type + ': ' + buildMessage()
              )
            }

            return NodePath
          })()

          exports.default = NodePath
          ;(0, _assign2.default)(NodePath.prototype, require('./ancestry'))
          ;(0, _assign2.default)(NodePath.prototype, require('./inference'))
          ;(0, _assign2.default)(NodePath.prototype, require('./replacement'))
          ;(0, _assign2.default)(NodePath.prototype, require('./evaluation'))
          ;(0, _assign2.default)(NodePath.prototype, require('./conversion'))
          ;(0, _assign2.default)(NodePath.prototype, require('./introspection'))
          ;(0, _assign2.default)(NodePath.prototype, require('./context'))
          ;(0, _assign2.default)(NodePath.prototype, require('./removal'))
          ;(0, _assign2.default)(NodePath.prototype, require('./modification'))
          ;(0, _assign2.default)(NodePath.prototype, require('./family'))
          ;(0, _assign2.default)(NodePath.prototype, require('./comments'))

          var _loop2 = function _loop2() {
            if (_isArray) {
              if (_i >= _iterator.length) return 'break'
              _ref2 = _iterator[_i++]
            } else {
              _i = _iterator.next()
              if (_i.done) return 'break'
              _ref2 = _i.value
            }

            var type = _ref2

            var typeKey = 'is' + type
            NodePath.prototype[typeKey] = function(opts) {
              return t[typeKey](this.node, opts)
            }

            NodePath.prototype['assert' + type] = function(opts) {
              if (!this[typeKey](opts)) {
                throw new TypeError('Expected node path of type ' + type)
              }
            }
          }

          for (
            var _iterator = t.TYPES,
              _isArray = Array.isArray(_iterator),
              _i = 0,
              _iterator = _isArray
                ? _iterator
                : (0, _getIterator3.default)(_iterator);
            ;

          ) {
            var _ref2

            var _ret2 = _loop2()

            if (_ret2 === 'break') break
          }

          var _loop = function _loop(type) {
            if (type[0] === '_') return 'continue'
            if (t.TYPES.indexOf(type) < 0) t.TYPES.push(type)

            var virtualType = virtualTypes[type]

            NodePath.prototype['is' + type] = function(opts) {
              return virtualType.checkPath(this, opts)
            }
          }

          for (var type in virtualTypes) {
            var _ret = _loop(type)

            if (_ret === 'continue') continue
          }
          module.exports = exports['default']
        },
        {
          '../cache': 74,
          '../index': 77,
          '../scope': 96,
          './ancestry': 78,
          './comments': 79,
          './context': 80,
          './conversion': 81,
          './evaluation': 82,
          './family': 83,
          './inference': 85,
          './introspection': 88,
          './lib/virtual-types': 91,
          './modification': 92,
          './removal': 93,
          './replacement': 94,
          'babel-runtime/core-js/get-iterator': 54,
          'babel-runtime/helpers/classCallCheck': 68,
          'babel-types': 110,
          debug: 243,
          invariant: 285,
          'lodash/assign': 449,
        },
      ],
      85: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true

          var _getIterator2 = require('babel-runtime/core-js/get-iterator')

          var _getIterator3 = _interopRequireDefault(_getIterator2)

          exports.getTypeAnnotation = getTypeAnnotation
          exports._getTypeAnnotation = _getTypeAnnotation
          exports.isBaseType = isBaseType
          exports.couldBeBaseType = couldBeBaseType
          exports.baseTypeStrictlyMatches = baseTypeStrictlyMatches
          exports.isGenericType = isGenericType

          var _inferers = require('./inferers')

          var inferers = _interopRequireWildcard(_inferers)

          var _babelTypes = require('babel-types')

          var t = _interopRequireWildcard(_babelTypes)

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj
            } else {
              var newObj = {}
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key]
                }
              }
              newObj.default = obj
              return newObj
            }
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          function getTypeAnnotation() {
            if (this.typeAnnotation) return this.typeAnnotation

            var type = this._getTypeAnnotation() || t.anyTypeAnnotation()
            if (t.isTypeAnnotation(type)) type = type.typeAnnotation
            return (this.typeAnnotation = type)
          }

          function _getTypeAnnotation() {
            var node = this.node

            if (!node) {
              if (
                this.key === 'init' &&
                this.parentPath.isVariableDeclarator()
              ) {
                var declar = this.parentPath.parentPath
                var declarParent = declar.parentPath

                if (declar.key === 'left' && declarParent.isForInStatement()) {
                  return t.stringTypeAnnotation()
                }

                if (declar.key === 'left' && declarParent.isForOfStatement()) {
                  return t.anyTypeAnnotation()
                }

                return t.voidTypeAnnotation()
              } else {
                return
              }
            }

            if (node.typeAnnotation) {
              return node.typeAnnotation
            }

            var inferer = inferers[node.type]
            if (inferer) {
              return inferer.call(this, node)
            }

            inferer = inferers[this.parentPath.type]
            if (inferer && inferer.validParent) {
              return this.parentPath.getTypeAnnotation()
            }
          }

          function isBaseType(baseName, soft) {
            return _isBaseType(baseName, this.getTypeAnnotation(), soft)
          }

          function _isBaseType(baseName, type, soft) {
            if (baseName === 'string') {
              return t.isStringTypeAnnotation(type)
            } else if (baseName === 'number') {
              return t.isNumberTypeAnnotation(type)
            } else if (baseName === 'boolean') {
              return t.isBooleanTypeAnnotation(type)
            } else if (baseName === 'any') {
              return t.isAnyTypeAnnotation(type)
            } else if (baseName === 'mixed') {
              return t.isMixedTypeAnnotation(type)
            } else if (baseName === 'empty') {
              return t.isEmptyTypeAnnotation(type)
            } else if (baseName === 'void') {
              return t.isVoidTypeAnnotation(type)
            } else {
              if (soft) {
                return false
              } else {
                throw new Error('Unknown base type ' + baseName)
              }
            }
          }

          function couldBeBaseType(name) {
            var type = this.getTypeAnnotation()
            if (t.isAnyTypeAnnotation(type)) return true

            if (t.isUnionTypeAnnotation(type)) {
              for (
                var _iterator = type.types,
                  _isArray = Array.isArray(_iterator),
                  _i = 0,
                  _iterator = _isArray
                    ? _iterator
                    : (0, _getIterator3.default)(_iterator);
                ;

              ) {
                var _ref

                if (_isArray) {
                  if (_i >= _iterator.length) break
                  _ref = _iterator[_i++]
                } else {
                  _i = _iterator.next()
                  if (_i.done) break
                  _ref = _i.value
                }

                var type2 = _ref

                if (
                  t.isAnyTypeAnnotation(type2) ||
                  _isBaseType(name, type2, true)
                ) {
                  return true
                }
              }
              return false
            } else {
              return _isBaseType(name, type, true)
            }
          }

          function baseTypeStrictlyMatches(right) {
            var left = this.getTypeAnnotation()
            right = right.getTypeAnnotation()

            if (!t.isAnyTypeAnnotation(left) && t.isFlowBaseAnnotation(left)) {
              return right.type === left.type
            }
          }

          function isGenericType(genericName) {
            var type = this.getTypeAnnotation()
            return (
              t.isGenericTypeAnnotation(type) &&
              t.isIdentifier(type.id, { name: genericName })
            )
          }
        },
        {
          './inferers': 87,
          'babel-runtime/core-js/get-iterator': 54,
          'babel-types': 110,
        },
      ],
      86: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true

          var _getIterator2 = require('babel-runtime/core-js/get-iterator')

          var _getIterator3 = _interopRequireDefault(_getIterator2)

          exports.default = function(node) {
            if (!this.isReferenced()) return

            var binding = this.scope.getBinding(node.name)
            if (binding) {
              if (binding.identifier.typeAnnotation) {
                return binding.identifier.typeAnnotation
              } else {
                return getTypeAnnotationBindingConstantViolations(
                  this,
                  node.name
                )
              }
            }

            if (node.name === 'undefined') {
              return t.voidTypeAnnotation()
            } else if (node.name === 'NaN' || node.name === 'Infinity') {
              return t.numberTypeAnnotation()
            } else if (node.name === 'arguments') {
            }
          }

          var _babelTypes = require('babel-types')

          var t = _interopRequireWildcard(_babelTypes)

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj
            } else {
              var newObj = {}
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key]
                }
              }
              newObj.default = obj
              return newObj
            }
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          function getTypeAnnotationBindingConstantViolations(path, name) {
            var binding = path.scope.getBinding(name)

            var types = []
            path.typeAnnotation = t.unionTypeAnnotation(types)

            var functionConstantViolations = []
            var constantViolations = getConstantViolationsBefore(
              binding,
              path,
              functionConstantViolations
            )

            var testType = getConditionalAnnotation(path, name)
            if (testType) {
              var testConstantViolations = getConstantViolationsBefore(
                binding,
                testType.ifStatement
              )

              constantViolations = constantViolations.filter(function(path) {
                return testConstantViolations.indexOf(path) < 0
              })

              types.push(testType.typeAnnotation)
            }

            if (constantViolations.length) {
              constantViolations = constantViolations.concat(
                functionConstantViolations
              )

              for (
                var _iterator = constantViolations,
                  _isArray = Array.isArray(_iterator),
                  _i = 0,
                  _iterator = _isArray
                    ? _iterator
                    : (0, _getIterator3.default)(_iterator);
                ;

              ) {
                var _ref

                if (_isArray) {
                  if (_i >= _iterator.length) break
                  _ref = _iterator[_i++]
                } else {
                  _i = _iterator.next()
                  if (_i.done) break
                  _ref = _i.value
                }

                var violation = _ref

                types.push(violation.getTypeAnnotation())
              }
            }

            if (types.length) {
              return t.createUnionTypeAnnotation(types)
            }
          }

          function getConstantViolationsBefore(binding, path, functions) {
            var violations = binding.constantViolations.slice()
            violations.unshift(binding.path)
            return violations.filter(function(violation) {
              violation = violation.resolve()
              var status = violation._guessExecutionStatusRelativeTo(path)
              if (functions && status === 'function') functions.push(violation)
              return status === 'before'
            })
          }

          function inferAnnotationFromBinaryExpression(name, path) {
            var operator = path.node.operator

            var right = path.get('right').resolve()
            var left = path.get('left').resolve()

            var target = void 0
            if (left.isIdentifier({ name: name })) {
              target = right
            } else if (right.isIdentifier({ name: name })) {
              target = left
            }
            if (target) {
              if (operator === '===') {
                return target.getTypeAnnotation()
              } else if (
                t.BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0
              ) {
                return t.numberTypeAnnotation()
              } else {
                return
              }
            } else {
              if (operator !== '===') return
            }

            var typeofPath = void 0
            var typePath = void 0
            if (left.isUnaryExpression({ operator: 'typeof' })) {
              typeofPath = left
              typePath = right
            } else if (right.isUnaryExpression({ operator: 'typeof' })) {
              typeofPath = right
              typePath = left
            }
            if (!typePath && !typeofPath) return

            typePath = typePath.resolve()
            if (!typePath.isLiteral()) return

            var typeValue = typePath.node.value
            if (typeof typeValue !== 'string') return

            if (!typeofPath.get('argument').isIdentifier({ name: name })) return

            return t.createTypeAnnotationBasedOnTypeof(typePath.node.value)
          }

          function getParentConditionalPath(path) {
            var parentPath = void 0
            while ((parentPath = path.parentPath)) {
              if (
                parentPath.isIfStatement() ||
                parentPath.isConditionalExpression()
              ) {
                if (path.key === 'test') {
                  return
                } else {
                  return parentPath
                }
              } else {
                path = parentPath
              }
            }
          }

          function getConditionalAnnotation(path, name) {
            var ifStatement = getParentConditionalPath(path)
            if (!ifStatement) return

            var test = ifStatement.get('test')
            var paths = [test]
            var types = []

            do {
              var _path = paths.shift().resolve()

              if (_path.isLogicalExpression()) {
                paths.push(_path.get('left'))
                paths.push(_path.get('right'))
              }

              if (_path.isBinaryExpression()) {
                var type = inferAnnotationFromBinaryExpression(name, _path)
                if (type) types.push(type)
              }
            } while (paths.length)

            if (types.length) {
              return {
                typeAnnotation: t.createUnionTypeAnnotation(types),
                ifStatement: ifStatement,
              }
            } else {
              return getConditionalAnnotation(ifStatement, name)
            }
          }
          module.exports = exports['default']
        },
        { 'babel-runtime/core-js/get-iterator': 54, 'babel-types': 110 },
      ],
      87: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true
          exports.ClassDeclaration = exports.ClassExpression = exports.FunctionDeclaration = exports.ArrowFunctionExpression = exports.FunctionExpression = exports.Identifier = undefined

          var _infererReference = require('./inferer-reference')

          Object.defineProperty(exports, 'Identifier', {
            enumerable: true,
            get: function get() {
              return _interopRequireDefault(_infererReference).default
            },
          })
          exports.VariableDeclarator = VariableDeclarator
          exports.TypeCastExpression = TypeCastExpression
          exports.NewExpression = NewExpression
          exports.TemplateLiteral = TemplateLiteral
          exports.UnaryExpression = UnaryExpression
          exports.BinaryExpression = BinaryExpression
          exports.LogicalExpression = LogicalExpression
          exports.ConditionalExpression = ConditionalExpression
          exports.SequenceExpression = SequenceExpression
          exports.AssignmentExpression = AssignmentExpression
          exports.UpdateExpression = UpdateExpression
          exports.StringLiteral = StringLiteral
          exports.NumericLiteral = NumericLiteral
          exports.BooleanLiteral = BooleanLiteral
          exports.NullLiteral = NullLiteral
          exports.RegExpLiteral = RegExpLiteral
          exports.ObjectExpression = ObjectExpression
          exports.ArrayExpression = ArrayExpression
          exports.RestElement = RestElement
          exports.CallExpression = CallExpression
          exports.TaggedTemplateExpression = TaggedTemplateExpression

          var _babelTypes = require('babel-types')

          var t = _interopRequireWildcard(_babelTypes)

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj
            } else {
              var newObj = {}
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key]
                }
              }
              newObj.default = obj
              return newObj
            }
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          function VariableDeclarator() {
            var id = this.get('id')

            if (id.isIdentifier()) {
              return this.get('init').getTypeAnnotation()
            } else {
              return
            }
          }

          function TypeCastExpression(node) {
            return node.typeAnnotation
          }

          TypeCastExpression.validParent = true

          function NewExpression(node) {
            if (this.get('callee').isIdentifier()) {
              return t.genericTypeAnnotation(node.callee)
            }
          }

          function TemplateLiteral() {
            return t.stringTypeAnnotation()
          }

          function UnaryExpression(node) {
            var operator = node.operator

            if (operator === 'void') {
              return t.voidTypeAnnotation()
            } else if (t.NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) {
              return t.numberTypeAnnotation()
            } else if (t.STRING_UNARY_OPERATORS.indexOf(operator) >= 0) {
              return t.stringTypeAnnotation()
            } else if (t.BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) {
              return t.booleanTypeAnnotation()
            }
          }

          function BinaryExpression(node) {
            var operator = node.operator

            if (t.NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {
              return t.numberTypeAnnotation()
            } else if (t.BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) {
              return t.booleanTypeAnnotation()
            } else if (operator === '+') {
              var right = this.get('right')
              var left = this.get('left')

              if (left.isBaseType('number') && right.isBaseType('number')) {
                return t.numberTypeAnnotation()
              } else if (
                left.isBaseType('string') ||
                right.isBaseType('string')
              ) {
                return t.stringTypeAnnotation()
              }

              return t.unionTypeAnnotation([
                t.stringTypeAnnotation(),
                t.numberTypeAnnotation(),
              ])
            }
          }

          function LogicalExpression() {
            return t.createUnionTypeAnnotation([
              this.get('left').getTypeAnnotation(),
              this.get('right').getTypeAnnotation(),
            ])
          }

          function ConditionalExpression() {
            return t.createUnionTypeAnnotation([
              this.get('consequent').getTypeAnnotation(),
              this.get('alternate').getTypeAnnotation(),
            ])
          }

          function SequenceExpression() {
            return this.get('expressions').pop().getTypeAnnotation()
          }

          function AssignmentExpression() {
            return this.get('right').getTypeAnnotation()
          }

          function UpdateExpression(node) {
            var operator = node.operator
            if (operator === '++' || operator === '--') {
              return t.numberTypeAnnotation()
            }
          }

          function StringLiteral() {
            return t.stringTypeAnnotation()
          }

          function NumericLiteral() {
            return t.numberTypeAnnotation()
          }

          function BooleanLiteral() {
            return t.booleanTypeAnnotation()
          }

          function NullLiteral() {
            return t.nullLiteralTypeAnnotation()
          }

          function RegExpLiteral() {
            return t.genericTypeAnnotation(t.identifier('RegExp'))
          }

          function ObjectExpression() {
            return t.genericTypeAnnotation(t.identifier('Object'))
          }

          function ArrayExpression() {
            return t.genericTypeAnnotation(t.identifier('Array'))
          }

          function RestElement() {
            return ArrayExpression()
          }

          RestElement.validParent = true

          function Func() {
            return t.genericTypeAnnotation(t.identifier('Function'))
          }

          exports.FunctionExpression = Func
          exports.ArrowFunctionExpression = Func
          exports.FunctionDeclaration = Func
          exports.ClassExpression = Func
          exports.ClassDeclaration = Func
          function CallExpression() {
            return resolveCall(this.get('callee'))
          }

          function TaggedTemplateExpression() {
            return resolveCall(this.get('tag'))
          }

          function resolveCall(callee) {
            callee = callee.resolve()

            if (callee.isFunction()) {
              if (callee.is('async')) {
                if (callee.is('generator')) {
                  return t.genericTypeAnnotation(t.identifier('AsyncIterator'))
                } else {
                  return t.genericTypeAnnotation(t.identifier('Promise'))
                }
              } else {
                if (callee.node.returnType) {
                  return callee.node.returnType
                } else {
                }
              }
            }
          }
        },
        { './inferer-reference': 86, 'babel-types': 110 },
      ],
      88: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true
          exports.is = undefined

          var _getIterator2 = require('babel-runtime/core-js/get-iterator')

          var _getIterator3 = _interopRequireDefault(_getIterator2)

          exports.matchesPattern = matchesPattern
          exports.has = has
          exports.isStatic = isStatic
          exports.isnt = isnt
          exports.equals = equals
          exports.isNodeType = isNodeType
          exports.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression
          exports.canSwapBetweenExpressionAndStatement = canSwapBetweenExpressionAndStatement
          exports.isCompletionRecord = isCompletionRecord
          exports.isStatementOrBlock = isStatementOrBlock
          exports.referencesImport = referencesImport
          exports.getSource = getSource
          exports.willIMaybeExecuteBefore = willIMaybeExecuteBefore
          exports._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo
          exports._guessExecutionStatusRelativeToDifferentFunctions = _guessExecutionStatusRelativeToDifferentFunctions
          exports.resolve = resolve
          exports._resolve = _resolve

          var _includes = require('lodash/includes')

          var _includes2 = _interopRequireDefault(_includes)

          var _babelTypes = require('babel-types')

          var t = _interopRequireWildcard(_babelTypes)

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj
            } else {
              var newObj = {}
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key]
                }
              }
              newObj.default = obj
              return newObj
            }
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          function matchesPattern(pattern, allowPartial) {
            if (!this.isMemberExpression()) return false

            var parts = pattern.split('.')
            var search = [this.node]
            var i = 0

            function matches(name) {
              var part = parts[i]
              return part === '*' || name === part
            }

            while (search.length) {
              var node = search.shift()

              if (allowPartial && i === parts.length) {
                return true
              }

              if (t.isIdentifier(node)) {
                if (!matches(node.name)) return false
              } else if (t.isLiteral(node)) {
                if (!matches(node.value)) return false
              } else if (t.isMemberExpression(node)) {
                if (node.computed && !t.isLiteral(node.property)) {
                  return false
                } else {
                  search.unshift(node.property)
                  search.unshift(node.object)
                  continue
                }
              } else if (t.isThisExpression(node)) {
                if (!matches('this')) return false
              } else {
                return false
              }

              if (++i > parts.length) {
                return false
              }
            }

            return i === parts.length
          }

          function has(key) {
            var val = this.node && this.node[key]
            if (val && Array.isArray(val)) {
              return !!val.length
            } else {
              return !!val
            }
          }

          function isStatic() {
            return this.scope.isStatic(this.node)
          }

          var is = (exports.is = has)

          function isnt(key) {
            return !this.has(key)
          }

          function equals(key, value) {
            return this.node[key] === value
          }

          function isNodeType(type) {
            return t.isType(this.type, type)
          }

          function canHaveVariableDeclarationOrExpression() {
            return (
              (this.key === 'init' || this.key === 'left') &&
              this.parentPath.isFor()
            )
          }

          function canSwapBetweenExpressionAndStatement(replacement) {
            if (
              this.key !== 'body' ||
              !this.parentPath.isArrowFunctionExpression()
            ) {
              return false
            }

            if (this.isExpression()) {
              return t.isBlockStatement(replacement)
            } else if (this.isBlockStatement()) {
              return t.isExpression(replacement)
            }

            return false
          }

          function isCompletionRecord(allowInsideFunction) {
            var path = this
            var first = true

            do {
              var container = path.container

              if (path.isFunction() && !first) {
                return !!allowInsideFunction
              }

              first = false

              if (
                Array.isArray(container) &&
                path.key !== container.length - 1
              ) {
                return false
              }
            } while ((path = path.parentPath) && !path.isProgram())

            return true
          }

          function isStatementOrBlock() {
            if (
              this.parentPath.isLabeledStatement() ||
              t.isBlockStatement(this.container)
            ) {
              return false
            } else {
              return (0, _includes2.default)(
                t.STATEMENT_OR_BLOCK_KEYS,
                this.key
              )
            }
          }

          function referencesImport(moduleSource, importName) {
            if (!this.isReferencedIdentifier()) return false

            var binding = this.scope.getBinding(this.node.name)
            if (!binding || binding.kind !== 'module') return false

            var path = binding.path
            var parent = path.parentPath
            if (!parent.isImportDeclaration()) return false

            if (parent.node.source.value === moduleSource) {
              if (!importName) return true
            } else {
              return false
            }

            if (path.isImportDefaultSpecifier() && importName === 'default') {
              return true
            }

            if (path.isImportNamespaceSpecifier() && importName === '*') {
              return true
            }

            if (
              path.isImportSpecifier() &&
              path.node.imported.name === importName
            ) {
              return true
            }

            return false
          }

          function getSource() {
            var node = this.node
            if (node.end) {
              return this.hub.file.code.slice(node.start, node.end)
            } else {
              return ''
            }
          }

          function willIMaybeExecuteBefore(target) {
            return this._guessExecutionStatusRelativeTo(target) !== 'after'
          }

          function _guessExecutionStatusRelativeTo(target) {
            var targetFuncParent = target.scope.getFunctionParent()
            var selfFuncParent = this.scope.getFunctionParent()

            if (targetFuncParent.node !== selfFuncParent.node) {
              var status = this._guessExecutionStatusRelativeToDifferentFunctions(
                targetFuncParent
              )
              if (status) {
                return status
              } else {
                target = targetFuncParent.path
              }
            }

            var targetPaths = target.getAncestry()
            if (targetPaths.indexOf(this) >= 0) return 'after'

            var selfPaths = this.getAncestry()

            var commonPath = void 0
            var targetIndex = void 0
            var selfIndex = void 0
            for (selfIndex = 0; selfIndex < selfPaths.length; selfIndex++) {
              var selfPath = selfPaths[selfIndex]
              targetIndex = targetPaths.indexOf(selfPath)
              if (targetIndex >= 0) {
                commonPath = selfPath
                break
              }
            }
            if (!commonPath) {
              return 'before'
            }

            var targetRelationship = targetPaths[targetIndex - 1]
            var selfRelationship = selfPaths[selfIndex - 1]
            if (!targetRelationship || !selfRelationship) {
              return 'before'
            }

            if (
              targetRelationship.listKey &&
              targetRelationship.container === selfRelationship.container
            ) {
              return targetRelationship.key > selfRelationship.key
                ? 'before'
                : 'after'
            }

            var targetKeyPosition = t.VISITOR_KEYS[
              targetRelationship.type
            ].indexOf(targetRelationship.key)
            var selfKeyPosition = t.VISITOR_KEYS[selfRelationship.type].indexOf(
              selfRelationship.key
            )
            return targetKeyPosition > selfKeyPosition ? 'before' : 'after'
          }

          function _guessExecutionStatusRelativeToDifferentFunctions(
            targetFuncParent
          ) {
            var targetFuncPath = targetFuncParent.path
            if (!targetFuncPath.isFunctionDeclaration()) return

            var binding = targetFuncPath.scope.getBinding(
              targetFuncPath.node.id.name
            )

            if (!binding.references) return 'before'

            var referencePaths = binding.referencePaths

            for (
              var _iterator = referencePaths,
                _isArray = Array.isArray(_iterator),
                _i = 0,
                _iterator = _isArray
                  ? _iterator
                  : (0, _getIterator3.default)(_iterator);
              ;

            ) {
              var _ref

              if (_isArray) {
                if (_i >= _iterator.length) break
                _ref = _iterator[_i++]
              } else {
                _i = _iterator.next()
                if (_i.done) break
                _ref = _i.value
              }

              var path = _ref

              if (
                path.key !== 'callee' ||
                !path.parentPath.isCallExpression()
              ) {
                return
              }
            }

            var allStatus = void 0

            for (
              var _iterator2 = referencePaths,
                _isArray2 = Array.isArray(_iterator2),
                _i2 = 0,
                _iterator2 = _isArray2
                  ? _iterator2
                  : (0, _getIterator3.default)(_iterator2);
              ;

            ) {
              var _ref2

              if (_isArray2) {
                if (_i2 >= _iterator2.length) break
                _ref2 = _iterator2[_i2++]
              } else {
                _i2 = _iterator2.next()
                if (_i2.done) break
                _ref2 = _i2.value
              }

              var _path = _ref2

              var childOfFunction = !!_path.find(function(path) {
                return path.node === targetFuncPath.node
              })
              if (childOfFunction) continue

              var status = this._guessExecutionStatusRelativeTo(_path)

              if (allStatus) {
                if (allStatus !== status) return
              } else {
                allStatus = status
              }
            }

            return allStatus
          }

          function resolve(dangerous, resolved) {
            return this._resolve(dangerous, resolved) || this
          }

          function _resolve(dangerous, resolved) {
            if (resolved && resolved.indexOf(this) >= 0) return

            resolved = resolved || []
            resolved.push(this)

            if (this.isVariableDeclarator()) {
              if (this.get('id').isIdentifier()) {
                return this.get('init').resolve(dangerous, resolved)
              } else {
              }
            } else if (this.isReferencedIdentifier()) {
              var binding = this.scope.getBinding(this.node.name)
              if (!binding) return

              if (!binding.constant) return

              if (binding.kind === 'module') return

              if (binding.path !== this) {
                var ret = binding.path.resolve(dangerous, resolved)

                if (
                  this.find(function(parent) {
                    return parent.node === ret.node
                  })
                )
                  return
                return ret
              }
            } else if (this.isTypeCastExpression()) {
              return this.get('expression').resolve(dangerous, resolved)
            } else if (dangerous && this.isMemberExpression()) {
              var targetKey = this.toComputedKey()
              if (!t.isLiteral(targetKey)) return

              var targetName = targetKey.value

              var target = this.get('object').resolve(dangerous, resolved)

              if (target.isObjectExpression()) {
                var props = target.get('properties')
                for (
                  var _iterator3 = props,
                    _isArray3 = Array.isArray(_iterator3),
                    _i3 = 0,
                    _iterator3 = _isArray3
                      ? _iterator3
                      : (0, _getIterator3.default)(_iterator3);
                  ;

                ) {
                  var _ref3

                  if (_isArray3) {
                    if (_i3 >= _iterator3.length) break
                    _ref3 = _iterator3[_i3++]
                  } else {
                    _i3 = _iterator3.next()
                    if (_i3.done) break
                    _ref3 = _i3.value
                  }

                  var prop = _ref3

                  if (!prop.isProperty()) continue

                  var key = prop.get('key')

                  var match =
                    prop.isnt('computed') &&
                    key.isIdentifier({ name: targetName })

                  match = match || key.isLiteral({ value: targetName })

                  if (match)
                    return prop.get('value').resolve(dangerous, resolved)
                }
              } else if (target.isArrayExpression() && !isNaN(+targetName)) {
                var elems = target.get('elements')
                var elem = elems[targetName]
                if (elem) return elem.resolve(dangerous, resolved)
              }
            }
          }
        },
        {
          'babel-runtime/core-js/get-iterator': 54,
          'babel-types': 110,
          'lodash/includes': 466,
        },
      ],
      89: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true

          var _getIterator2 = require('babel-runtime/core-js/get-iterator')

          var _getIterator3 = _interopRequireDefault(_getIterator2)

          var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck')

          var _classCallCheck3 = _interopRequireDefault(_classCallCheck2)

          var _babelTypes = require('babel-types')

          var t = _interopRequireWildcard(_babelTypes)

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj
            } else {
              var newObj = {}
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key]
                }
              }
              newObj.default = obj
              return newObj
            }
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          var referenceVisitor = {
            ReferencedIdentifier: function ReferencedIdentifier(path, state) {
              if (
                path.isJSXIdentifier() &&
                _babelTypes.react.isCompatTag(path.node.name) &&
                !path.parentPath.isJSXMemberExpression()
              ) {
                return
              }

              if (path.node.name === 'this') {
                var scope = path.scope
                do {
                  if (
                    scope.path.isFunction() &&
                    !scope.path.isArrowFunctionExpression()
                  )
                    break
                } while ((scope = scope.parent))
                if (scope) state.breakOnScopePaths.push(scope.path)
              }

              var binding = path.scope.getBinding(path.node.name)
              if (!binding) return

              if (binding !== state.scope.getBinding(path.node.name)) return

              state.bindings[path.node.name] = binding
            },
          }

          var PathHoister = (function() {
            function PathHoister(path, scope) {
              ;(0, _classCallCheck3.default)(this, PathHoister)

              this.breakOnScopePaths = []

              this.bindings = {}

              this.scopes = []

              this.scope = scope
              this.path = path

              this.attachAfter = false
            }

            PathHoister.prototype.isCompatibleScope = function isCompatibleScope(
              scope
            ) {
              for (var key in this.bindings) {
                var binding = this.bindings[key]
                if (!scope.bindingIdentifierEquals(key, binding.identifier)) {
                  return false
                }
              }

              return true
            }

            PathHoister.prototype.getCompatibleScopes = function getCompatibleScopes() {
              var scope = this.path.scope
              do {
                if (this.isCompatibleScope(scope)) {
                  this.scopes.push(scope)
                } else {
                  break
                }

                if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {
                  break
                }
              } while ((scope = scope.parent))
            }

            PathHoister.prototype.getAttachmentPath = function getAttachmentPath() {
              var path = this._getAttachmentPath()
              if (!path) return

              var targetScope = path.scope

              if (targetScope.path === path) {
                targetScope = path.scope.parent
              }

              if (
                targetScope.path.isProgram() ||
                targetScope.path.isFunction()
              ) {
                for (var name in this.bindings) {
                  if (!targetScope.hasOwnBinding(name)) continue

                  var binding = this.bindings[name]

                  if (binding.kind === 'param') continue

                  if (
                    this.getAttachmentParentForPath(binding.path).key > path.key
                  ) {
                    this.attachAfter = true
                    path = binding.path

                    for (
                      var _iterator = binding.constantViolations,
                        _isArray = Array.isArray(_iterator),
                        _i = 0,
                        _iterator = _isArray
                          ? _iterator
                          : (0, _getIterator3.default)(_iterator);
                      ;

                    ) {
                      var _ref

                      if (_isArray) {
                        if (_i >= _iterator.length) break
                        _ref = _iterator[_i++]
                      } else {
                        _i = _iterator.next()
                        if (_i.done) break
                        _ref = _i.value
                      }

                      var violationPath = _ref

                      if (
                        this.getAttachmentParentForPath(violationPath).key >
                        path.key
                      ) {
                        path = violationPath
                      }
                    }
                  }
                }
              }

              return path
            }

            PathHoister.prototype._getAttachmentPath = function _getAttachmentPath() {
              var scopes = this.scopes

              var scope = scopes.pop()

              if (!scope) return

              if (scope.path.isFunction()) {
                if (this.hasOwnParamBindings(scope)) {
                  if (this.scope === scope) return

                  return scope.path.get('body').get('body')[0]
                } else {
                  return this.getNextScopeAttachmentParent()
                }
              } else if (scope.path.isProgram()) {
                return this.getNextScopeAttachmentParent()
              }
            }

            PathHoister.prototype.getNextScopeAttachmentParent = function getNextScopeAttachmentParent() {
              var scope = this.scopes.pop()
              if (scope) return this.getAttachmentParentForPath(scope.path)
            }

            PathHoister.prototype.getAttachmentParentForPath = function getAttachmentParentForPath(
              path
            ) {
              do {
                if (
                  !path.parentPath ||
                  (Array.isArray(path.container) && path.isStatement()) ||
                  (path.isVariableDeclarator() &&
                    path.parentPath.node !== null &&
                    path.parentPath.node.declarations.length > 1)
                )
                  return path
              } while ((path = path.parentPath))
            }

            PathHoister.prototype.hasOwnParamBindings = function hasOwnParamBindings(
              scope
            ) {
              for (var name in this.bindings) {
                if (!scope.hasOwnBinding(name)) continue

                var binding = this.bindings[name]

                if (binding.kind === 'param' && binding.constant) return true
              }
              return false
            }

            PathHoister.prototype.run = function run() {
              var node = this.path.node
              if (node._hoisted) return
              node._hoisted = true

              this.path.traverse(referenceVisitor, this)

              this.getCompatibleScopes()

              var attachTo = this.getAttachmentPath()
              if (!attachTo) return

              if (
                attachTo.getFunctionParent() === this.path.getFunctionParent()
              )
                return

              var uid = attachTo.scope.generateUidIdentifier('ref')
              var declarator = t.variableDeclarator(uid, this.path.node)

              var insertFn = this.attachAfter ? 'insertAfter' : 'insertBefore'
              attachTo[insertFn]([
                attachTo.isVariableDeclarator()
                  ? declarator
                  : t.variableDeclaration('var', [declarator]),
              ])

              var parent = this.path.parentPath
              if (
                parent.isJSXElement() &&
                this.path.container === parent.node.children
              ) {
                uid = t.JSXExpressionContainer(uid)
              }

              this.path.replaceWith(uid)
            }

            return PathHoister
          })()

          exports.default = PathHoister
          module.exports = exports['default']
        },
        {
          'babel-runtime/core-js/get-iterator': 54,
          'babel-runtime/helpers/classCallCheck': 68,
          'babel-types': 110,
        },
      ],
      90: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true
          var hooks = (exports.hooks = [
            function(self, parent) {
              var removeParent =
                (self.key === 'test' &&
                  (parent.isWhile() || parent.isSwitchCase())) ||
                (self.key === 'declaration' && parent.isExportDeclaration()) ||
                (self.key === 'body' && parent.isLabeledStatement()) ||
                (self.listKey === 'declarations' &&
                  parent.isVariableDeclaration() &&
                  parent.node.declarations.length === 1) ||
                (self.key === 'expression' && parent.isExpressionStatement())

              if (removeParent) {
                parent.remove()
                return true
              }
            },
            function(self, parent) {
              if (
                parent.isSequenceExpression() &&
                parent.node.expressions.length === 1
              ) {
                parent.replaceWith(parent.node.expressions[0])
                return true
              }
            },
            function(self, parent) {
              if (parent.isBinary()) {
                if (self.key === 'left') {
                  parent.replaceWith(parent.node.right)
                } else {
                  parent.replaceWith(parent.node.left)
                }
                return true
              }
            },
            function(self, parent) {
              if (
                (parent.isIfStatement() &&
                  (self.key === 'consequent' || self.key === 'alternate')) ||
                (self.key === 'body' &&
                  (parent.isLoop() || parent.isArrowFunctionExpression()))
              ) {
                self.replaceWith({
                  type: 'BlockStatement',
                  body: [],
                })
                return true
              }
            },
          ])
        },
        {},
      ],
      91: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true
          exports.Flow = exports.Pure = exports.Generated = exports.User = exports.Var = exports.BlockScoped = exports.Referenced = exports.Scope = exports.Expression = exports.Statement = exports.BindingIdentifier = exports.ReferencedMemberExpression = exports.ReferencedIdentifier = undefined

          var _babelTypes = require('babel-types')

          var t = _interopRequireWildcard(_babelTypes)

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj
            } else {
              var newObj = {}
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key]
                }
              }
              newObj.default = obj
              return newObj
            }
          }

          var ReferencedIdentifier = (exports.ReferencedIdentifier = {
            types: ['Identifier', 'JSXIdentifier'],
            checkPath: function checkPath(_ref, opts) {
              var node = _ref.node,
                parent = _ref.parent

              if (
                !t.isIdentifier(node, opts) &&
                !t.isJSXMemberExpression(parent, opts)
              ) {
                if (t.isJSXIdentifier(node, opts)) {
                  if (_babelTypes.react.isCompatTag(node.name)) return false
                } else {
                  return false
                }
              }

              return t.isReferenced(node, parent)
            },
          })

          var ReferencedMemberExpression = (exports.ReferencedMemberExpression = {
            types: ['MemberExpression'],
            checkPath: function checkPath(_ref2) {
              var node = _ref2.node,
                parent = _ref2.parent

              return t.isMemberExpression(node) && t.isReferenced(node, parent)
            },
          })

          var BindingIdentifier = (exports.BindingIdentifier = {
            types: ['Identifier'],
            checkPath: function checkPath(_ref3) {
              var node = _ref3.node,
                parent = _ref3.parent

              return t.isIdentifier(node) && t.isBinding(node, parent)
            },
          })

          var Statement = (exports.Statement = {
            types: ['Statement'],
            checkPath: function checkPath(_ref4) {
              var node = _ref4.node,
                parent = _ref4.parent

              if (t.isStatement(node)) {
                if (t.isVariableDeclaration(node)) {
                  if (t.isForXStatement(parent, { left: node })) return false
                  if (t.isForStatement(parent, { init: node })) return false
                }

                return true
              } else {
                return false
              }
            },
          })

          var Expression = (exports.Expression = {
            types: ['Expression'],
            checkPath: function checkPath(path) {
              if (path.isIdentifier()) {
                return path.isReferencedIdentifier()
              } else {
                return t.isExpression(path.node)
              }
            },
          })

          var Scope = (exports.Scope = {
            types: ['Scopable'],
            checkPath: function checkPath(path) {
              return t.isScope(path.node, path.parent)
            },
          })

          var Referenced = (exports.Referenced = {
            checkPath: function checkPath(path) {
              return t.isReferenced(path.node, path.parent)
            },
          })

          var BlockScoped = (exports.BlockScoped = {
            checkPath: function checkPath(path) {
              return t.isBlockScoped(path.node)
            },
          })

          var Var = (exports.Var = {
            types: ['VariableDeclaration'],
            checkPath: function checkPath(path) {
              return t.isVar(path.node)
            },
          })

          var User = (exports.User = {
            checkPath: function checkPath(path) {
              return path.node && !!path.node.loc
            },
          })

          var Generated = (exports.Generated = {
            checkPath: function checkPath(path) {
              return !path.isUser()
            },
          })

          var Pure = (exports.Pure = {
            checkPath: function checkPath(path, opts) {
              return path.scope.isPure(path.node, opts)
            },
          })

          var Flow = (exports.Flow = {
            types: [
              'Flow',
              'ImportDeclaration',
              'ExportDeclaration',
              'ImportSpecifier',
            ],
            checkPath: function checkPath(_ref5) {
              var node = _ref5.node

              if (t.isFlow(node)) {
                return true
              } else if (t.isImportDeclaration(node)) {
                return (
                  node.importKind === 'type' || node.importKind === 'typeof'
                )
              } else if (t.isExportDeclaration(node)) {
                return node.exportKind === 'type'
              } else if (t.isImportSpecifier(node)) {
                return (
                  node.importKind === 'type' || node.importKind === 'typeof'
                )
              } else {
                return false
              }
            },
          })
        },
        { 'babel-types': 110 },
      ],
      92: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true

          var _typeof2 = require('babel-runtime/helpers/typeof')

          var _typeof3 = _interopRequireDefault(_typeof2)

          var _getIterator2 = require('babel-runtime/core-js/get-iterator')

          var _getIterator3 = _interopRequireDefault(_getIterator2)

          exports.insertBefore = insertBefore
          exports._containerInsert = _containerInsert
          exports._containerInsertBefore = _containerInsertBefore
          exports._containerInsertAfter = _containerInsertAfter
          exports._maybePopFromStatements = _maybePopFromStatements
          exports.insertAfter = insertAfter
          exports.updateSiblingKeys = updateSiblingKeys
          exports._verifyNodeList = _verifyNodeList
          exports.unshiftContainer = unshiftContainer
          exports.pushContainer = pushContainer
          exports.hoist = hoist

          var _cache = require('../cache')

          var _hoister = require('./lib/hoister')

          var _hoister2 = _interopRequireDefault(_hoister)

          var _index = require('./index')

          var _index2 = _interopRequireDefault(_index)

          var _babelTypes = require('babel-types')

          var t = _interopRequireWildcard(_babelTypes)

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj
            } else {
              var newObj = {}
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key]
                }
              }
              newObj.default = obj
              return newObj
            }
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          function insertBefore(nodes) {
            this._assertUnremoved()

            nodes = this._verifyNodeList(nodes)

            if (
              this.parentPath.isExpressionStatement() ||
              this.parentPath.isLabeledStatement()
            ) {
              return this.parentPath.insertBefore(nodes)
            } else if (
              this.isNodeType('Expression') ||
              (this.parentPath.isForStatement() && this.key === 'init')
            ) {
              if (this.node) nodes.push(this.node)
              this.replaceExpressionWithStatements(nodes)
            } else {
              this._maybePopFromStatements(nodes)
              if (Array.isArray(this.container)) {
                return this._containerInsertBefore(nodes)
              } else if (this.isStatementOrBlock()) {
                if (this.node) nodes.push(this.node)
                this._replaceWith(t.blockStatement(nodes))
              } else {
                throw new Error(
                  "We don't know what to do with this node type. " +
                    "We were previously a Statement but we can't fit in here?"
                )
              }
            }

            return [this]
          }

          function _containerInsert(from, nodes) {
            this.updateSiblingKeys(from, nodes.length)

            var paths = []

            for (var i = 0; i < nodes.length; i++) {
              var to = from + i
              var node = nodes[i]
              this.container.splice(to, 0, node)

              if (this.context) {
                var path = this.context.create(
                  this.parent,
                  this.container,
                  to,
                  this.listKey
                )

                if (this.context.queue) path.pushContext(this.context)
                paths.push(path)
              } else {
                paths.push(
                  _index2.default.get({
                    parentPath: this.parentPath,
                    parent: this.parent,
                    container: this.container,
                    listKey: this.listKey,
                    key: to,
                  })
                )
              }
            }

            var contexts = this._getQueueContexts()

            for (
              var _iterator = paths,
                _isArray = Array.isArray(_iterator),
                _i = 0,
                _iterator = _isArray
                  ? _iterator
                  : (0, _getIterator3.default)(_iterator);
              ;

            ) {
              var _ref

              if (_isArray) {
                if (_i >= _iterator.length) break
                _ref = _iterator[_i++]
              } else {
                _i = _iterator.next()
                if (_i.done) break
                _ref = _i.value
              }

              var _path = _ref

              _path.setScope()
              _path.debug(function() {
                return 'Inserted.'
              })

              for (
                var _iterator2 = contexts,
                  _isArray2 = Array.isArray(_iterator2),
                  _i2 = 0,
                  _iterator2 = _isArray2
                    ? _iterator2
                    : (0, _getIterator3.default)(_iterator2);
                ;

              ) {
                var _ref2

                if (_isArray2) {
                  if (_i2 >= _iterator2.length) break
                  _ref2 = _iterator2[_i2++]
                } else {
                  _i2 = _iterator2.next()
                  if (_i2.done) break
                  _ref2 = _i2.value
                }

                var context = _ref2

                context.maybeQueue(_path, true)
              }
            }

            return paths
          }

          function _containerInsertBefore(nodes) {
            return this._containerInsert(this.key, nodes)
          }

          function _containerInsertAfter(nodes) {
            return this._containerInsert(this.key + 1, nodes)
          }

          function _maybePopFromStatements(nodes) {
            var last = nodes[nodes.length - 1]
            var isIdentifier =
              t.isIdentifier(last) ||
              (t.isExpressionStatement(last) && t.isIdentifier(last.expression))

            if (isIdentifier && !this.isCompletionRecord()) {
              nodes.pop()
            }
          }

          function insertAfter(nodes) {
            this._assertUnremoved()

            nodes = this._verifyNodeList(nodes)

            if (
              this.parentPath.isExpressionStatement() ||
              this.parentPath.isLabeledStatement()
            ) {
              return this.parentPath.insertAfter(nodes)
            } else if (
              this.isNodeType('Expression') ||
              (this.parentPath.isForStatement() && this.key === 'init')
            ) {
              if (this.node) {
                var temp = this.scope.generateDeclaredUidIdentifier()
                nodes.unshift(
                  t.expressionStatement(
                    t.assignmentExpression('=', temp, this.node)
                  )
                )
                nodes.push(t.expressionStatement(temp))
              }
              this.replaceExpressionWithStatements(nodes)
            } else {
              this._maybePopFromStatements(nodes)
              if (Array.isArray(this.container)) {
                return this._containerInsertAfter(nodes)
              } else if (this.isStatementOrBlock()) {
                if (this.node) nodes.unshift(this.node)
                this._replaceWith(t.blockStatement(nodes))
              } else {
                throw new Error(
                  "We don't know what to do with this node type. " +
                    "We were previously a Statement but we can't fit in here?"
                )
              }
            }

            return [this]
          }

          function updateSiblingKeys(fromIndex, incrementBy) {
            if (!this.parent) return

            var paths = _cache.path.get(this.parent)
            for (var i = 0; i < paths.length; i++) {
              var path = paths[i]
              if (path.key >= fromIndex) {
                path.key += incrementBy
              }
            }
          }

          function _verifyNodeList(nodes) {
            if (!nodes) {
              return []
            }

            if (nodes.constructor !== Array) {
              nodes = [nodes]
            }

            for (var i = 0; i < nodes.length; i++) {
              var node = nodes[i]
              var msg = void 0

              if (!node) {
                msg = 'has falsy node'
              } else if (
                (typeof node === 'undefined'
                  ? 'undefined'
                  : (0, _typeof3.default)(node)) !== 'object'
              ) {
                msg = 'contains a non-object node'
              } else if (!node.type) {
                msg = 'without a type'
              } else if (node instanceof _index2.default) {
                msg = 'has a NodePath when it expected a raw object'
              }

              if (msg) {
                var type = Array.isArray(node)
                  ? 'array'
                  : typeof node === 'undefined'
                    ? 'undefined'
                    : (0, _typeof3.default)(node)
                throw new Error(
                  'Node list ' +
                    msg +
                    ' with the index of ' +
                    i +
                    ' and type of ' +
                    type
                )
              }
            }

            return nodes
          }

          function unshiftContainer(listKey, nodes) {
            this._assertUnremoved()

            nodes = this._verifyNodeList(nodes)

            var path = _index2.default.get({
              parentPath: this,
              parent: this.node,
              container: this.node[listKey],
              listKey: listKey,
              key: 0,
            })

            return path.insertBefore(nodes)
          }

          function pushContainer(listKey, nodes) {
            this._assertUnremoved()

            nodes = this._verifyNodeList(nodes)

            var container = this.node[listKey]
            var path = _index2.default.get({
              parentPath: this,
              parent: this.node,
              container: container,
              listKey: listKey,
              key: container.length,
            })

            return path.replaceWithMultiple(nodes)
          }

          function hoist() {
            var scope = arguments.length > 0 && arguments[0] !== undefined
              ? arguments[0]
              : this.scope

            var hoister = new _hoister2.default(this, scope)
            return hoister.run()
          }
        },
        {
          '../cache': 74,
          './index': 84,
          './lib/hoister': 89,
          'babel-runtime/core-js/get-iterator': 54,
          'babel-runtime/helpers/typeof': 72,
          'babel-types': 110,
        },
      ],
      93: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true

          var _getIterator2 = require('babel-runtime/core-js/get-iterator')

          var _getIterator3 = _interopRequireDefault(_getIterator2)

          exports.remove = remove
          exports._callRemovalHooks = _callRemovalHooks
          exports._remove = _remove
          exports._markRemoved = _markRemoved
          exports._assertUnremoved = _assertUnremoved

          var _removalHooks = require('./lib/removal-hooks')

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          function remove() {
            this._assertUnremoved()

            this.resync()

            if (this._callRemovalHooks()) {
              this._markRemoved()
              return
            }

            this.shareCommentsWithSiblings()
            this._remove()
            this._markRemoved()
          }

          function _callRemovalHooks() {
            for (
              var _iterator = _removalHooks.hooks,
                _isArray = Array.isArray(_iterator),
                _i = 0,
                _iterator = _isArray
                  ? _iterator
                  : (0, _getIterator3.default)(_iterator);
              ;

            ) {
              var _ref

              if (_isArray) {
                if (_i >= _iterator.length) break
                _ref = _iterator[_i++]
              } else {
                _i = _iterator.next()
                if (_i.done) break
                _ref = _i.value
              }

              var fn = _ref

              if (fn(this, this.parentPath)) return true
            }
          }

          function _remove() {
            if (Array.isArray(this.container)) {
              this.container.splice(this.key, 1)
              this.updateSiblingKeys(this.key, -1)
            } else {
              this._replaceWith(null)
            }
          }

          function _markRemoved() {
            this.shouldSkip = true
            this.removed = true
            this.node = null
          }

          function _assertUnremoved() {
            if (this.removed) {
              throw this.buildCodeFrameError(
                'NodePath has been removed so is read-only.'
              )
            }
          }
        },
        { './lib/removal-hooks': 90, 'babel-runtime/core-js/get-iterator': 54 },
      ],
      94: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true

          var _getIterator2 = require('babel-runtime/core-js/get-iterator')

          var _getIterator3 = _interopRequireDefault(_getIterator2)

          exports.replaceWithMultiple = replaceWithMultiple
          exports.replaceWithSourceString = replaceWithSourceString
          exports.replaceWith = replaceWith
          exports._replaceWith = _replaceWith
          exports.replaceExpressionWithStatements = replaceExpressionWithStatements
          exports.replaceInline = replaceInline

          var _babelCodeFrame = require('babel-code-frame')

          var _babelCodeFrame2 = _interopRequireDefault(_babelCodeFrame)

          var _index = require('../index')

          var _index2 = _interopRequireDefault(_index)

          var _index3 = require('./index')

          var _index4 = _interopRequireDefault(_index3)

          var _babylon = require('babylon')

          var _babelTypes = require('babel-types')

          var t = _interopRequireWildcard(_babelTypes)

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj
            } else {
              var newObj = {}
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key]
                }
              }
              newObj.default = obj
              return newObj
            }
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          var hoistVariablesVisitor = {
            Function: function Function(path) {
              path.skip()
            },
            VariableDeclaration: function VariableDeclaration(path) {
              if (path.node.kind !== 'var') return

              var bindings = path.getBindingIdentifiers()
              for (var key in bindings) {
                path.scope.push({ id: bindings[key] })
              }

              var exprs = []

              for (
                var _iterator = path.node.declarations,
                  _isArray = Array.isArray(_iterator),
                  _i = 0,
                  _iterator = _isArray
                    ? _iterator
                    : (0, _getIterator3.default)(_iterator);
                ;

              ) {
                var _ref

                if (_isArray) {
                  if (_i >= _iterator.length) break
                  _ref = _iterator[_i++]
                } else {
                  _i = _iterator.next()
                  if (_i.done) break
                  _ref = _i.value
                }

                var declar = _ref

                if (declar.init) {
                  exprs.push(
                    t.expressionStatement(
                      t.assignmentExpression('=', declar.id, declar.init)
                    )
                  )
                }
              }

              path.replaceWithMultiple(exprs)
            },
          }

          function replaceWithMultiple(nodes) {
            this.resync()

            nodes = this._verifyNodeList(nodes)
            t.inheritLeadingComments(nodes[0], this.node)
            t.inheritTrailingComments(nodes[nodes.length - 1], this.node)
            this.node = this.container[this.key] = null
            this.insertAfter(nodes)

            if (this.node) {
              this.requeue()
            } else {
              this.remove()
            }
          }

          function replaceWithSourceString(replacement) {
            this.resync()

            try {
              replacement = '(' + replacement + ')'
              replacement = (0, _babylon.parse)(replacement)
            } catch (err) {
              var loc = err.loc
              if (loc) {
                err.message += ' - make sure this is an expression.'
                err.message +=
                  '\n' +
                  (0, _babelCodeFrame2.default)(
                    replacement,
                    loc.line,
                    loc.column + 1
                  )
              }
              throw err
            }

            replacement = replacement.program.body[0].expression
            _index2.default.removeProperties(replacement)
            return this.replaceWith(replacement)
          }

          function replaceWith(replacement) {
            this.resync()

            if (this.removed) {
              throw new Error(
                "You can't replace this node, we've already removed it"
              )
            }

            if (replacement instanceof _index4.default) {
              replacement = replacement.node
            }

            if (!replacement) {
              throw new Error(
                'You passed `path.replaceWith()` a falsy node, use `path.remove()` instead'
              )
            }

            if (this.node === replacement) {
              return
            }

            if (this.isProgram() && !t.isProgram(replacement)) {
              throw new Error(
                'You can only replace a Program root node with another Program node'
              )
            }

            if (Array.isArray(replacement)) {
              throw new Error(
                "Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`"
              )
            }

            if (typeof replacement === 'string') {
              throw new Error(
                "Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`"
              )
            }

            if (this.isNodeType('Statement') && t.isExpression(replacement)) {
              if (
                !this.canHaveVariableDeclarationOrExpression() &&
                !this.canSwapBetweenExpressionAndStatement(replacement)
              ) {
                replacement = t.expressionStatement(replacement)
              }
            }

            if (this.isNodeType('Expression') && t.isStatement(replacement)) {
              if (
                !this.canHaveVariableDeclarationOrExpression() &&
                !this.canSwapBetweenExpressionAndStatement(replacement)
              ) {
                return this.replaceExpressionWithStatements([replacement])
              }
            }

            var oldNode = this.node
            if (oldNode) {
              t.inheritsComments(replacement, oldNode)
              t.removeComments(oldNode)
            }

            this._replaceWith(replacement)
            this.type = replacement.type

            this.setScope()

            this.requeue()
          }

          function _replaceWith(node) {
            if (!this.container) {
              throw new ReferenceError('Container is falsy')
            }

            if (this.inList) {
              t.validate(this.parent, this.key, [node])
            } else {
              t.validate(this.parent, this.key, node)
            }

            this.debug(function() {
              return 'Replace with ' + (node && node.type)
            })

            this.node = this.container[this.key] = node
          }

          function replaceExpressionWithStatements(nodes) {
            this.resync()

            var toSequenceExpression = t.toSequenceExpression(nodes, this.scope)

            if (t.isSequenceExpression(toSequenceExpression)) {
              var exprs = toSequenceExpression.expressions

              if (
                exprs.length >= 2 &&
                this.parentPath.isExpressionStatement()
              ) {
                this._maybePopFromStatements(exprs)
              }

              if (exprs.length === 1) {
                this.replaceWith(exprs[0])
              } else {
                this.replaceWith(toSequenceExpression)
              }
            } else if (toSequenceExpression) {
              this.replaceWith(toSequenceExpression)
            } else {
              var container = t.functionExpression(
                null,
                [],
                t.blockStatement(nodes)
              )
              container.shadow = true

              this.replaceWith(t.callExpression(container, []))
              this.traverse(hoistVariablesVisitor)

              var completionRecords = this.get('callee').getCompletionRecords()
              for (
                var _iterator2 = completionRecords,
                  _isArray2 = Array.isArray(_iterator2),
                  _i2 = 0,
                  _iterator2 = _isArray2
                    ? _iterator2
                    : (0, _getIterator3.default)(_iterator2);
                ;

              ) {
                var _ref2

                if (_isArray2) {
                  if (_i2 >= _iterator2.length) break
                  _ref2 = _iterator2[_i2++]
                } else {
                  _i2 = _iterator2.next()
                  if (_i2.done) break
                  _ref2 = _i2.value
                }

                var path = _ref2

                if (!path.isExpressionStatement()) continue

                var loop = path.findParent(function(path) {
                  return path.isLoop()
                })
                if (loop) {
                  var uid = loop.getData('expressionReplacementReturnUid')

                  if (!uid) {
                    var callee = this.get('callee')
                    uid = callee.scope.generateDeclaredUidIdentifier('ret')
                    callee
                      .get('body')
                      .pushContainer('body', t.returnStatement(uid))
                    loop.setData('expressionReplacementReturnUid', uid)
                  } else {
                    uid = t.identifier(uid.name)
                  }

                  path
                    .get('expression')
                    .replaceWith(
                      t.assignmentExpression('=', uid, path.node.expression)
                    )
                } else {
                  path.replaceWith(t.returnStatement(path.node.expression))
                }
              }

              return this.node
            }
          }

          function replaceInline(nodes) {
            this.resync()

            if (Array.isArray(nodes)) {
              if (Array.isArray(this.container)) {
                nodes = this._verifyNodeList(nodes)
                this._containerInsertAfter(nodes)
                return this.remove()
              } else {
                return this.replaceWithMultiple(nodes)
              }
            } else {
              return this.replaceWith(nodes)
            }
          }
        },
        {
          '../index': 77,
          './index': 84,
          'babel-code-frame': 4,
          'babel-runtime/core-js/get-iterator': 54,
          'babel-types': 110,
          babylon: 114,
        },
      ],
      95: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true

          var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck')

          var _classCallCheck3 = _interopRequireDefault(_classCallCheck2)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          var Binding = (function() {
            function Binding(_ref) {
              var existing = _ref.existing,
                identifier = _ref.identifier,
                scope = _ref.scope,
                path = _ref.path,
                kind = _ref.kind
              ;(0, _classCallCheck3.default)(this, Binding)

              this.identifier = identifier
              this.scope = scope
              this.path = path
              this.kind = kind

              this.constantViolations = []
              this.constant = true

              this.referencePaths = []
              this.referenced = false
              this.references = 0

              this.clearValue()

              if (existing) {
                this.constantViolations = [].concat(
                  existing.path,
                  existing.constantViolations,
                  this.constantViolations
                )
              }
            }

            Binding.prototype.deoptValue = function deoptValue() {
              this.clearValue()
              this.hasDeoptedValue = true
            }

            Binding.prototype.setValue = function setValue(value) {
              if (this.hasDeoptedValue) return
              this.hasValue = true
              this.value = value
            }

            Binding.prototype.clearValue = function clearValue() {
              this.hasDeoptedValue = false
              this.hasValue = false
              this.value = null
            }

            Binding.prototype.reassign = function reassign(path) {
              this.constant = false
              if (this.constantViolations.indexOf(path) !== -1) {
                return
              }
              this.constantViolations.push(path)
            }

            Binding.prototype.reference = function reference(path) {
              if (this.referencePaths.indexOf(path) !== -1) {
                return
              }
              this.referenced = true
              this.references++
              this.referencePaths.push(path)
            }

            Binding.prototype.dereference = function dereference() {
              this.references--
              this.referenced = !!this.references
            }

            return Binding
          })()

          exports.default = Binding
          module.exports = exports['default']
        },
        { 'babel-runtime/helpers/classCallCheck': 68 },
      ],
      96: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true

          var _keys = require('babel-runtime/core-js/object/keys')

          var _keys2 = _interopRequireDefault(_keys)

          var _create = require('babel-runtime/core-js/object/create')

          var _create2 = _interopRequireDefault(_create)

          var _map = require('babel-runtime/core-js/map')

          var _map2 = _interopRequireDefault(_map)

          var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck')

          var _classCallCheck3 = _interopRequireDefault(_classCallCheck2)

          var _getIterator2 = require('babel-runtime/core-js/get-iterator')

          var _getIterator3 = _interopRequireDefault(_getIterator2)

          var _includes = require('lodash/includes')

          var _includes2 = _interopRequireDefault(_includes)

          var _repeat = require('lodash/repeat')

          var _repeat2 = _interopRequireDefault(_repeat)

          var _renamer = require('./lib/renamer')

          var _renamer2 = _interopRequireDefault(_renamer)

          var _index = require('../index')

          var _index2 = _interopRequireDefault(_index)

          var _defaults = require('lodash/defaults')

          var _defaults2 = _interopRequireDefault(_defaults)

          var _babelMessages = require('babel-messages')

          var messages = _interopRequireWildcard(_babelMessages)

          var _binding2 = require('./binding')

          var _binding3 = _interopRequireDefault(_binding2)

          var _globals = require('globals')

          var _globals2 = _interopRequireDefault(_globals)

          var _babelTypes = require('babel-types')

          var t = _interopRequireWildcard(_babelTypes)

          var _cache = require('../cache')

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj
            } else {
              var newObj = {}
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key]
                }
              }
              newObj.default = obj
              return newObj
            }
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          var _crawlCallsCount = 0

          function getCache(path, parentScope, self) {
            var scopes = _cache.scope.get(path.node) || []

            for (
              var _iterator = scopes,
                _isArray = Array.isArray(_iterator),
                _i = 0,
                _iterator = _isArray
                  ? _iterator
                  : (0, _getIterator3.default)(_iterator);
              ;

            ) {
              var _ref

              if (_isArray) {
                if (_i >= _iterator.length) break
                _ref = _iterator[_i++]
              } else {
                _i = _iterator.next()
                if (_i.done) break
                _ref = _i.value
              }

              var scope = _ref

              if (scope.parent === parentScope && scope.path === path)
                return scope
            }

            scopes.push(self)

            if (!_cache.scope.has(path.node)) {
              _cache.scope.set(path.node, scopes)
            }
          }

          function gatherNodeParts(node, parts) {
            if (t.isModuleDeclaration(node)) {
              if (node.source) {
                gatherNodeParts(node.source, parts)
              } else if (node.specifiers && node.specifiers.length) {
                for (
                  var _iterator2 = node.specifiers,
                    _isArray2 = Array.isArray(_iterator2),
                    _i2 = 0,
                    _iterator2 = _isArray2
                      ? _iterator2
                      : (0, _getIterator3.default)(_iterator2);
                  ;

                ) {
                  var _ref2

                  if (_isArray2) {
                    if (_i2 >= _iterator2.length) break
                    _ref2 = _iterator2[_i2++]
                  } else {
                    _i2 = _iterator2.next()
                    if (_i2.done) break
                    _ref2 = _i2.value
                  }

                  var specifier = _ref2

                  gatherNodeParts(specifier, parts)
                }
              } else if (node.declaration) {
                gatherNodeParts(node.declaration, parts)
              }
            } else if (t.isModuleSpecifier(node)) {
              gatherNodeParts(node.local, parts)
            } else if (t.isMemberExpression(node)) {
              gatherNodeParts(node.object, parts)
              gatherNodeParts(node.property, parts)
            } else if (t.isIdentifier(node)) {
              parts.push(node.name)
            } else if (t.isLiteral(node)) {
              parts.push(node.value)
            } else if (t.isCallExpression(node)) {
              gatherNodeParts(node.callee, parts)
            } else if (t.isObjectExpression(node) || t.isObjectPattern(node)) {
              for (
                var _iterator3 = node.properties,
                  _isArray3 = Array.isArray(_iterator3),
                  _i3 = 0,
                  _iterator3 = _isArray3
                    ? _iterator3
                    : (0, _getIterator3.default)(_iterator3);
                ;

              ) {
                var _ref3

                if (_isArray3) {
                  if (_i3 >= _iterator3.length) break
                  _ref3 = _iterator3[_i3++]
                } else {
                  _i3 = _iterator3.next()
                  if (_i3.done) break
                  _ref3 = _i3.value
                }

                var prop = _ref3

                gatherNodeParts(prop.key || prop.argument, parts)
              }
            }
          }

          var collectorVisitor = {
            For: function For(path) {
              for (
                var _iterator4 = t.FOR_INIT_KEYS,
                  _isArray4 = Array.isArray(_iterator4),
                  _i4 = 0,
                  _iterator4 = _isArray4
                    ? _iterator4
                    : (0, _getIterator3.default)(_iterator4);
                ;

              ) {
                var _ref4

                if (_isArray4) {
                  if (_i4 >= _iterator4.length) break
                  _ref4 = _iterator4[_i4++]
                } else {
                  _i4 = _iterator4.next()
                  if (_i4.done) break
                  _ref4 = _i4.value
                }

                var key = _ref4

                var declar = path.get(key)
                if (declar.isVar())
                  path.scope.getFunctionParent().registerBinding('var', declar)
              }
            },
            Declaration: function Declaration(path) {
              if (path.isBlockScoped()) return

              if (
                path.isExportDeclaration() &&
                path.get('declaration').isDeclaration()
              )
                return

              path.scope.getFunctionParent().registerDeclaration(path)
            },
            ReferencedIdentifier: function ReferencedIdentifier(path, state) {
              state.references.push(path)
            },
            ForXStatement: function ForXStatement(path, state) {
              var left = path.get('left')
              if (left.isPattern() || left.isIdentifier()) {
                state.constantViolations.push(left)
              }
            },

            ExportDeclaration: {
              exit: function exit(path) {
                var node = path.node,
                  scope = path.scope

                var declar = node.declaration
                if (
                  t.isClassDeclaration(declar) ||
                  t.isFunctionDeclaration(declar)
                ) {
                  var _id = declar.id
                  if (!_id) return

                  var binding = scope.getBinding(_id.name)
                  if (binding) binding.reference(path)
                } else if (t.isVariableDeclaration(declar)) {
                  for (
                    var _iterator5 = declar.declarations,
                      _isArray5 = Array.isArray(_iterator5),
                      _i5 = 0,
                      _iterator5 = _isArray5
                        ? _iterator5
                        : (0, _getIterator3.default)(_iterator5);
                    ;

                  ) {
                    var _ref5

                    if (_isArray5) {
                      if (_i5 >= _iterator5.length) break
                      _ref5 = _iterator5[_i5++]
                    } else {
                      _i5 = _iterator5.next()
                      if (_i5.done) break
                      _ref5 = _i5.value
                    }

                    var decl = _ref5

                    var ids = t.getBindingIdentifiers(decl)
                    for (var name in ids) {
                      var _binding = scope.getBinding(name)
                      if (_binding) _binding.reference(path)
                    }
                  }
                }
              },
            },

            LabeledStatement: function LabeledStatement(path) {
              path.scope.getProgramParent().addGlobal(path.node)
              path.scope.getBlockParent().registerDeclaration(path)
            },
            AssignmentExpression: function AssignmentExpression(path, state) {
              state.assignments.push(path)
            },
            UpdateExpression: function UpdateExpression(path, state) {
              state.constantViolations.push(path.get('argument'))
            },
            UnaryExpression: function UnaryExpression(path, state) {
              if (path.node.operator === 'delete') {
                state.constantViolations.push(path.get('argument'))
              }
            },
            BlockScoped: function BlockScoped(path) {
              var scope = path.scope
              if (scope.path === path) scope = scope.parent
              scope.getBlockParent().registerDeclaration(path)
            },
            ClassDeclaration: function ClassDeclaration(path) {
              var id = path.node.id
              if (!id) return

              var name = id.name
              path.scope.bindings[name] = path.scope.getBinding(name)
            },
            Block: function Block(path) {
              var paths = path.get('body')
              for (
                var _iterator6 = paths,
                  _isArray6 = Array.isArray(_iterator6),
                  _i6 = 0,
                  _iterator6 = _isArray6
                    ? _iterator6
                    : (0, _getIterator3.default)(_iterator6);
                ;

              ) {
                var _ref6

                if (_isArray6) {
                  if (_i6 >= _iterator6.length) break
                  _ref6 = _iterator6[_i6++]
                } else {
                  _i6 = _iterator6.next()
                  if (_i6.done) break
                  _ref6 = _i6.value
                }

                var bodyPath = _ref6

                if (bodyPath.isFunctionDeclaration()) {
                  path.scope.getBlockParent().registerDeclaration(bodyPath)
                }
              }
            },
          }

          var uid = 0

          var Scope = (function() {
            function Scope(path, parentScope) {
              ;(0, _classCallCheck3.default)(this, Scope)

              if (parentScope && parentScope.block === path.node) {
                return parentScope
              }

              var cached = getCache(path, parentScope, this)
              if (cached) return cached

              this.uid = uid++
              this.parent = parentScope
              this.hub = path.hub

              this.parentBlock = path.parent
              this.block = path.node
              this.path = path

              this.labels = new _map2.default()
            }

            Scope.prototype.traverse = function traverse(node, opts, state) {
              ;(0, _index2.default)(node, opts, this, state, this.path)
            }

            Scope.prototype.generateDeclaredUidIdentifier = function generateDeclaredUidIdentifier() {
              var name = arguments.length > 0 && arguments[0] !== undefined
                ? arguments[0]
                : 'temp'

              var id = this.generateUidIdentifier(name)
              this.push({ id: id })
              return id
            }

            Scope.prototype.generateUidIdentifier = function generateUidIdentifier() {
              var name = arguments.length > 0 && arguments[0] !== undefined
                ? arguments[0]
                : 'temp'

              return t.identifier(this.generateUid(name))
            }

            Scope.prototype.generateUid = function generateUid() {
              var name = arguments.length > 0 && arguments[0] !== undefined
                ? arguments[0]
                : 'temp'

              name = t
                .toIdentifier(name)
                .replace(/^_+/, '')
                .replace(/[0-9]+$/g, '')

              var uid = void 0
              var i = 0
              do {
                uid = this._generateUid(name, i)
                i++
              } while (
                this.hasLabel(uid) ||
                this.hasBinding(uid) ||
                this.hasGlobal(uid) ||
                this.hasReference(uid)
              )

              var program = this.getProgramParent()
              program.references[uid] = true
              program.uids[uid] = true

              return uid
            }

            Scope.prototype._generateUid = function _generateUid(name, i) {
              var id = name
              if (i > 1) id += i
              return '_' + id
            }

            Scope.prototype.generateUidIdentifierBasedOnNode = function generateUidIdentifierBasedOnNode(
              parent,
              defaultName
            ) {
              var node = parent

              if (t.isAssignmentExpression(parent)) {
                node = parent.left
              } else if (t.isVariableDeclarator(parent)) {
                node = parent.id
              } else if (t.isObjectProperty(node) || t.isObjectMethod(node)) {
                node = node.key
              }

              var parts = []
              gatherNodeParts(node, parts)

              var id = parts.join('$')
              id = id.replace(/^_/, '') || defaultName || 'ref'

              return this.generateUidIdentifier(id.slice(0, 20))
            }

            Scope.prototype.isStatic = function isStatic(node) {
              if (t.isThisExpression(node) || t.isSuper(node)) {
                return true
              }

              if (t.isIdentifier(node)) {
                var binding = this.getBinding(node.name)
                if (binding) {
                  return binding.constant
                } else {
                  return this.hasBinding(node.name)
                }
              }

              return false
            }

            Scope.prototype.maybeGenerateMemoised = function maybeGenerateMemoised(
              node,
              dontPush
            ) {
              if (this.isStatic(node)) {
                return null
              } else {
                var _id2 = this.generateUidIdentifierBasedOnNode(node)
                if (!dontPush) this.push({ id: _id2 })
                return _id2
              }
            }

            Scope.prototype.checkBlockScopedCollisions = function checkBlockScopedCollisions(
              local,
              kind,
              name,
              id
            ) {
              if (kind === 'param') return

              if (kind === 'hoisted' && local.kind === 'let') return

              var duplicate =
                kind === 'let' ||
                local.kind === 'let' ||
                local.kind === 'const' ||
                local.kind === 'module' ||
                (local.kind === 'param' && (kind === 'let' || kind === 'const'))

              if (duplicate) {
                throw this.hub.file.buildCodeFrameError(
                  id,
                  messages.get('scopeDuplicateDeclaration', name),
                  TypeError
                )
              }
            }

            Scope.prototype.rename = function rename(oldName, newName, block) {
              var binding = this.getBinding(oldName)
              if (binding) {
                newName = newName || this.generateUidIdentifier(oldName).name
                return new _renamer2.default(binding, oldName, newName).rename(
                  block
                )
              }
            }

            Scope.prototype._renameFromMap = function _renameFromMap(
              map,
              oldName,
              newName,
              value
            ) {
              if (map[oldName]) {
                map[newName] = value
                map[oldName] = null
              }
            }

            Scope.prototype.dump = function dump() {
              var sep = (0, _repeat2.default)('-', 60)
              console.log(sep)
              var scope = this
              do {
                console.log('#', scope.block.type)
                for (var name in scope.bindings) {
                  var binding = scope.bindings[name]
                  console.log(' -', name, {
                    constant: binding.constant,
                    references: binding.references,
                    violations: binding.constantViolations.length,
                    kind: binding.kind,
                  })
                }
              } while ((scope = scope.parent))
              console.log(sep)
            }

            Scope.prototype.toArray = function toArray(node, i) {
              var file = this.hub.file

              if (t.isIdentifier(node)) {
                var binding = this.getBinding(node.name)
                if (
                  binding &&
                  binding.constant &&
                  binding.path.isGenericType('Array')
                )
                  return node
              }

              if (t.isArrayExpression(node)) {
                return node
              }

              if (t.isIdentifier(node, { name: 'arguments' })) {
                return t.callExpression(
                  t.memberExpression(
                    t.memberExpression(
                      t.memberExpression(
                        t.identifier('Array'),
                        t.identifier('prototype')
                      ),
                      t.identifier('slice')
                    ),
                    t.identifier('call')
                  ),
                  [node]
                )
              }

              var helperName = 'toArray'
              var args = [node]
              if (i === true) {
                helperName = 'toConsumableArray'
              } else if (i) {
                args.push(t.numericLiteral(i))
                helperName = 'slicedToArray'
              }
              return t.callExpression(file.addHelper(helperName), args)
            }

            Scope.prototype.hasLabel = function hasLabel(name) {
              return !!this.getLabel(name)
            }

            Scope.prototype.getLabel = function getLabel(name) {
              return this.labels.get(name)
            }

            Scope.prototype.registerLabel = function registerLabel(path) {
              this.labels.set(path.node.label.name, path)
            }

            Scope.prototype.registerDeclaration = function registerDeclaration(
              path
            ) {
              if (path.isLabeledStatement()) {
                this.registerLabel(path)
              } else if (path.isFunctionDeclaration()) {
                this.registerBinding('hoisted', path.get('id'), path)
              } else if (path.isVariableDeclaration()) {
                var declarations = path.get('declarations')
                for (
                  var _iterator7 = declarations,
                    _isArray7 = Array.isArray(_iterator7),
                    _i7 = 0,
                    _iterator7 = _isArray7
                      ? _iterator7
                      : (0, _getIterator3.default)(_iterator7);
                  ;

                ) {
                  var _ref7

                  if (_isArray7) {
                    if (_i7 >= _iterator7.length) break
                    _ref7 = _iterator7[_i7++]
                  } else {
                    _i7 = _iterator7.next()
                    if (_i7.done) break
                    _ref7 = _i7.value
                  }

                  var declar = _ref7

                  this.registerBinding(path.node.kind, declar)
                }
              } else if (path.isClassDeclaration()) {
                this.registerBinding('let', path)
              } else if (path.isImportDeclaration()) {
                var specifiers = path.get('specifiers')
                for (
                  var _iterator8 = specifiers,
                    _isArray8 = Array.isArray(_iterator8),
                    _i8 = 0,
                    _iterator8 = _isArray8
                      ? _iterator8
                      : (0, _getIterator3.default)(_iterator8);
                  ;

                ) {
                  var _ref8

                  if (_isArray8) {
                    if (_i8 >= _iterator8.length) break
                    _ref8 = _iterator8[_i8++]
                  } else {
                    _i8 = _iterator8.next()
                    if (_i8.done) break
                    _ref8 = _i8.value
                  }

                  var specifier = _ref8

                  this.registerBinding('module', specifier)
                }
              } else if (path.isExportDeclaration()) {
                var _declar = path.get('declaration')
                if (
                  _declar.isClassDeclaration() ||
                  _declar.isFunctionDeclaration() ||
                  _declar.isVariableDeclaration()
                ) {
                  this.registerDeclaration(_declar)
                }
              } else {
                this.registerBinding('unknown', path)
              }
            }

            Scope.prototype.buildUndefinedNode = function buildUndefinedNode() {
              if (this.hasBinding('undefined')) {
                return t.unaryExpression('void', t.numericLiteral(0), true)
              } else {
                return t.identifier('undefined')
              }
            }

            Scope.prototype.registerConstantViolation = function registerConstantViolation(
              path
            ) {
              var ids = path.getBindingIdentifiers()
              for (var name in ids) {
                var binding = this.getBinding(name)
                if (binding) binding.reassign(path)
              }
            }

            Scope.prototype.registerBinding = function registerBinding(
              kind,
              path
            ) {
              var bindingPath = arguments.length > 2 &&
                arguments[2] !== undefined
                ? arguments[2]
                : path

              if (!kind) throw new ReferenceError('no `kind`')

              if (path.isVariableDeclaration()) {
                var declarators = path.get('declarations')
                for (
                  var _iterator9 = declarators,
                    _isArray9 = Array.isArray(_iterator9),
                    _i9 = 0,
                    _iterator9 = _isArray9
                      ? _iterator9
                      : (0, _getIterator3.default)(_iterator9);
                  ;

                ) {
                  var _ref9

                  if (_isArray9) {
                    if (_i9 >= _iterator9.length) break
                    _ref9 = _iterator9[_i9++]
                  } else {
                    _i9 = _iterator9.next()
                    if (_i9.done) break
                    _ref9 = _i9.value
                  }

                  var declar = _ref9

                  this.registerBinding(kind, declar)
                }
                return
              }

              var parent = this.getProgramParent()
              var ids = path.getBindingIdentifiers(true)

              for (var name in ids) {
                for (
                  var _iterator10 = ids[name],
                    _isArray10 = Array.isArray(_iterator10),
                    _i10 = 0,
                    _iterator10 = _isArray10
                      ? _iterator10
                      : (0, _getIterator3.default)(_iterator10);
                  ;

                ) {
                  var _ref10

                  if (_isArray10) {
                    if (_i10 >= _iterator10.length) break
                    _ref10 = _iterator10[_i10++]
                  } else {
                    _i10 = _iterator10.next()
                    if (_i10.done) break
                    _ref10 = _i10.value
                  }

                  var _id3 = _ref10

                  var local = this.getOwnBinding(name)
                  if (local) {
                    if (local.identifier === _id3) continue

                    this.checkBlockScopedCollisions(local, kind, name, _id3)
                  }

                  if (local && local.path.isFlow()) local = null

                  parent.references[name] = true

                  this.bindings[name] = new _binding3.default({
                    identifier: _id3,
                    existing: local,
                    scope: this,
                    path: bindingPath,
                    kind: kind,
                  })
                }
              }
            }

            Scope.prototype.addGlobal = function addGlobal(node) {
              this.globals[node.name] = node
            }

            Scope.prototype.hasUid = function hasUid(name) {
              var scope = this

              do {
                if (scope.uids[name]) return true
              } while ((scope = scope.parent))

              return false
            }

            Scope.prototype.hasGlobal = function hasGlobal(name) {
              var scope = this

              do {
                if (scope.globals[name]) return true
              } while ((scope = scope.parent))

              return false
            }

            Scope.prototype.hasReference = function hasReference(name) {
              var scope = this

              do {
                if (scope.references[name]) return true
              } while ((scope = scope.parent))

              return false
            }

            Scope.prototype.isPure = function isPure(node, constantsOnly) {
              if (t.isIdentifier(node)) {
                var binding = this.getBinding(node.name)
                if (!binding) return false
                if (constantsOnly) return binding.constant
                return true
              } else if (t.isClass(node)) {
                if (
                  node.superClass &&
                  !this.isPure(node.superClass, constantsOnly)
                )
                  return false
                return this.isPure(node.body, constantsOnly)
              } else if (t.isClassBody(node)) {
                for (
                  var _iterator11 = node.body,
                    _isArray11 = Array.isArray(_iterator11),
                    _i11 = 0,
                    _iterator11 = _isArray11
                      ? _iterator11
                      : (0, _getIterator3.default)(_iterator11);
                  ;

                ) {
                  var _ref11

                  if (_isArray11) {
                    if (_i11 >= _iterator11.length) break
                    _ref11 = _iterator11[_i11++]
                  } else {
                    _i11 = _iterator11.next()
                    if (_i11.done) break
                    _ref11 = _i11.value
                  }

                  var method = _ref11

                  if (!this.isPure(method, constantsOnly)) return false
                }
                return true
              } else if (t.isBinary(node)) {
                return (
                  this.isPure(node.left, constantsOnly) &&
                  this.isPure(node.right, constantsOnly)
                )
              } else if (t.isArrayExpression(node)) {
                for (
                  var _iterator12 = node.elements,
                    _isArray12 = Array.isArray(_iterator12),
                    _i12 = 0,
                    _iterator12 = _isArray12
                      ? _iterator12
                      : (0, _getIterator3.default)(_iterator12);
                  ;

                ) {
                  var _ref12

                  if (_isArray12) {
                    if (_i12 >= _iterator12.length) break
                    _ref12 = _iterator12[_i12++]
                  } else {
                    _i12 = _iterator12.next()
                    if (_i12.done) break
                    _ref12 = _i12.value
                  }

                  var elem = _ref12

                  if (!this.isPure(elem, constantsOnly)) return false
                }
                return true
              } else if (t.isObjectExpression(node)) {
                for (
                  var _iterator13 = node.properties,
                    _isArray13 = Array.isArray(_iterator13),
                    _i13 = 0,
                    _iterator13 = _isArray13
                      ? _iterator13
                      : (0, _getIterator3.default)(_iterator13);
                  ;

                ) {
                  var _ref13

                  if (_isArray13) {
                    if (_i13 >= _iterator13.length) break
                    _ref13 = _iterator13[_i13++]
                  } else {
                    _i13 = _iterator13.next()
                    if (_i13.done) break
                    _ref13 = _i13.value
                  }

                  var prop = _ref13

                  if (!this.isPure(prop, constantsOnly)) return false
                }
                return true
              } else if (t.isClassMethod(node)) {
                if (node.computed && !this.isPure(node.key, constantsOnly))
                  return false
                if (node.kind === 'get' || node.kind === 'set') return false
                return true
              } else if (t.isClassProperty(node) || t.isObjectProperty(node)) {
                if (node.computed && !this.isPure(node.key, constantsOnly))
                  return false
                return this.isPure(node.value, constantsOnly)
              } else if (t.isUnaryExpression(node)) {
                return this.isPure(node.argument, constantsOnly)
              } else {
                return t.isPureish(node)
              }
            }

            Scope.prototype.setData = function setData(key, val) {
              return (this.data[key] = val)
            }

            Scope.prototype.getData = function getData(key) {
              var scope = this
              do {
                var data = scope.data[key]
                if (data != null) return data
              } while ((scope = scope.parent))
            }

            Scope.prototype.removeData = function removeData(key) {
              var scope = this
              do {
                var data = scope.data[key]
                if (data != null) scope.data[key] = null
              } while ((scope = scope.parent))
            }

            Scope.prototype.init = function init() {
              if (!this.references) this.crawl()
            }

            Scope.prototype.crawl = function crawl() {
              _crawlCallsCount++
              this._crawl()
              _crawlCallsCount--
            }

            Scope.prototype._crawl = function _crawl() {
              var path = this.path

              this.references = (0, _create2.default)(null)
              this.bindings = (0, _create2.default)(null)
              this.globals = (0, _create2.default)(null)
              this.uids = (0, _create2.default)(null)
              this.data = (0, _create2.default)(null)

              if (path.isLoop()) {
                for (
                  var _iterator14 = t.FOR_INIT_KEYS,
                    _isArray14 = Array.isArray(_iterator14),
                    _i14 = 0,
                    _iterator14 = _isArray14
                      ? _iterator14
                      : (0, _getIterator3.default)(_iterator14);
                  ;

                ) {
                  var _ref14

                  if (_isArray14) {
                    if (_i14 >= _iterator14.length) break
                    _ref14 = _iterator14[_i14++]
                  } else {
                    _i14 = _iterator14.next()
                    if (_i14.done) break
                    _ref14 = _i14.value
                  }

                  var key = _ref14

                  var node = path.get(key)
                  if (node.isBlockScoped())
                    this.registerBinding(node.node.kind, node)
                }
              }

              if (path.isFunctionExpression() && path.has('id')) {
                if (!path.get('id').node[t.NOT_LOCAL_BINDING]) {
                  this.registerBinding('local', path.get('id'), path)
                }
              }

              if (path.isClassExpression() && path.has('id')) {
                if (!path.get('id').node[t.NOT_LOCAL_BINDING]) {
                  this.registerBinding('local', path)
                }
              }

              if (path.isFunction()) {
                var params = path.get('params')
                for (
                  var _iterator15 = params,
                    _isArray15 = Array.isArray(_iterator15),
                    _i15 = 0,
                    _iterator15 = _isArray15
                      ? _iterator15
                      : (0, _getIterator3.default)(_iterator15);
                  ;

                ) {
                  var _ref15

                  if (_isArray15) {
                    if (_i15 >= _iterator15.length) break
                    _ref15 = _iterator15[_i15++]
                  } else {
                    _i15 = _iterator15.next()
                    if (_i15.done) break
                    _ref15 = _i15.value
                  }

                  var param = _ref15

                  this.registerBinding('param', param)
                }
              }

              if (path.isCatchClause()) {
                this.registerBinding('let', path)
              }

              var parent = this.getProgramParent()
              if (parent.crawling) return

              var state = {
                references: [],
                constantViolations: [],
                assignments: [],
              }

              this.crawling = true
              path.traverse(collectorVisitor, state)
              this.crawling = false

              for (
                var _iterator16 = state.assignments,
                  _isArray16 = Array.isArray(_iterator16),
                  _i16 = 0,
                  _iterator16 = _isArray16
                    ? _iterator16
                    : (0, _getIterator3.default)(_iterator16);
                ;

              ) {
                var _ref16

                if (_isArray16) {
                  if (_i16 >= _iterator16.length) break
                  _ref16 = _iterator16[_i16++]
                } else {
                  _i16 = _iterator16.next()
                  if (_i16.done) break
                  _ref16 = _i16.value
                }

                var _path = _ref16

                var ids = _path.getBindingIdentifiers()
                var programParent = void 0
                for (var name in ids) {
                  if (_path.scope.getBinding(name)) continue

                  programParent =
                    programParent || _path.scope.getProgramParent()
                  programParent.addGlobal(ids[name])
                }

                _path.scope.registerConstantViolation(_path)
              }

              for (
                var _iterator17 = state.references,
                  _isArray17 = Array.isArray(_iterator17),
                  _i17 = 0,
                  _iterator17 = _isArray17
                    ? _iterator17
                    : (0, _getIterator3.default)(_iterator17);
                ;

              ) {
                var _ref17

                if (_isArray17) {
                  if (_i17 >= _iterator17.length) break
                  _ref17 = _iterator17[_i17++]
                } else {
                  _i17 = _iterator17.next()
                  if (_i17.done) break
                  _ref17 = _i17.value
                }

                var ref = _ref17

                var binding = ref.scope.getBinding(ref.node.name)
                if (binding) {
                  binding.reference(ref)
                } else {
                  ref.scope.getProgramParent().addGlobal(ref.node)
                }
              }

              for (
                var _iterator18 = state.constantViolations,
                  _isArray18 = Array.isArray(_iterator18),
                  _i18 = 0,
                  _iterator18 = _isArray18
                    ? _iterator18
                    : (0, _getIterator3.default)(_iterator18);
                ;

              ) {
                var _ref18

                if (_isArray18) {
                  if (_i18 >= _iterator18.length) break
                  _ref18 = _iterator18[_i18++]
                } else {
                  _i18 = _iterator18.next()
                  if (_i18.done) break
                  _ref18 = _i18.value
                }

                var _path2 = _ref18

                _path2.scope.registerConstantViolation(_path2)
              }
            }

            Scope.prototype.push = function push(opts) {
              var path = this.path

              if (!path.isBlockStatement() && !path.isProgram()) {
                path = this.getBlockParent().path
              }

              if (path.isSwitchStatement()) {
                path = this.getFunctionParent().path
              }

              if (path.isLoop() || path.isCatchClause() || path.isFunction()) {
                t.ensureBlock(path.node)
                path = path.get('body')
              }

              var unique = opts.unique
              var kind = opts.kind || 'var'
              var blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist

              var dataKey = 'declaration:' + kind + ':' + blockHoist
              var declarPath = !unique && path.getData(dataKey)

              if (!declarPath) {
                var declar = t.variableDeclaration(kind, [])
                declar._generated = true
                declar._blockHoist = blockHoist

                var _path$unshiftContaine = path.unshiftContainer('body', [
                  declar,
                ])

                declarPath = _path$unshiftContaine[0]

                if (!unique) path.setData(dataKey, declarPath)
              }

              var declarator = t.variableDeclarator(opts.id, opts.init)
              declarPath.node.declarations.push(declarator)
              this.registerBinding(kind, declarPath.get('declarations').pop())
            }

            Scope.prototype.getProgramParent = function getProgramParent() {
              var scope = this
              do {
                if (scope.path.isProgram()) {
                  return scope
                }
              } while ((scope = scope.parent))
              throw new Error("We couldn't find a Function or Program...")
            }

            Scope.prototype.getFunctionParent = function getFunctionParent() {
              var scope = this
              do {
                if (scope.path.isFunctionParent()) {
                  return scope
                }
              } while ((scope = scope.parent))
              throw new Error("We couldn't find a Function or Program...")
            }

            Scope.prototype.getBlockParent = function getBlockParent() {
              var scope = this
              do {
                if (scope.path.isBlockParent()) {
                  return scope
                }
              } while ((scope = scope.parent))
              throw new Error(
                "We couldn't find a BlockStatement, For, Switch, Function, Loop or Program..."
              )
            }

            Scope.prototype.getAllBindings = function getAllBindings() {
              var ids = (0, _create2.default)(null)

              var scope = this
              do {
                ;(0, _defaults2.default)(ids, scope.bindings)
                scope = scope.parent
              } while (scope)

              return ids
            }

            Scope.prototype.getAllBindingsOfKind = function getAllBindingsOfKind() {
              var ids = (0, _create2.default)(null)

              for (
                var _iterator19 = arguments,
                  _isArray19 = Array.isArray(_iterator19),
                  _i19 = 0,
                  _iterator19 = _isArray19
                    ? _iterator19
                    : (0, _getIterator3.default)(_iterator19);
                ;

              ) {
                var _ref19

                if (_isArray19) {
                  if (_i19 >= _iterator19.length) break
                  _ref19 = _iterator19[_i19++]
                } else {
                  _i19 = _iterator19.next()
                  if (_i19.done) break
                  _ref19 = _i19.value
                }

                var kind = _ref19

                var scope = this
                do {
                  for (var name in scope.bindings) {
                    var binding = scope.bindings[name]
                    if (binding.kind === kind) ids[name] = binding
                  }
                  scope = scope.parent
                } while (scope)
              }

              return ids
            }

            Scope.prototype.bindingIdentifierEquals = function bindingIdentifierEquals(
              name,
              node
            ) {
              return this.getBindingIdentifier(name) === node
            }

            Scope.prototype.warnOnFlowBinding = function warnOnFlowBinding(
              binding
            ) {
              if (_crawlCallsCount === 0 && binding && binding.path.isFlow()) {
                console.warn(
                  '\n        You or one of the Babel plugins you are using are using Flow declarations as bindings.\n        Support for this will be removed in version 6.8. To find out the caller, grep for this\n        message and change it to a `console.trace()`.\n      '
                )
              }
              return binding
            }

            Scope.prototype.getBinding = function getBinding(name) {
              var scope = this

              do {
                var binding = scope.getOwnBinding(name)
                if (binding) return this.warnOnFlowBinding(binding)
              } while ((scope = scope.parent))
            }

            Scope.prototype.getOwnBinding = function getOwnBinding(name) {
              return this.warnOnFlowBinding(this.bindings[name])
            }

            Scope.prototype.getBindingIdentifier = function getBindingIdentifier(
              name
            ) {
              var info = this.getBinding(name)
              return info && info.identifier
            }

            Scope.prototype.getOwnBindingIdentifier = function getOwnBindingIdentifier(
              name
            ) {
              var binding = this.bindings[name]
              return binding && binding.identifier
            }

            Scope.prototype.hasOwnBinding = function hasOwnBinding(name) {
              return !!this.getOwnBinding(name)
            }

            Scope.prototype.hasBinding = function hasBinding(name, noGlobals) {
              if (!name) return false
              if (this.hasOwnBinding(name)) return true
              if (this.parentHasBinding(name, noGlobals)) return true
              if (this.hasUid(name)) return true
              if (!noGlobals && (0, _includes2.default)(Scope.globals, name))
                return true
              if (
                !noGlobals &&
                (0, _includes2.default)(Scope.contextVariables, name)
              )
                return true
              return false
            }

            Scope.prototype.parentHasBinding = function parentHasBinding(
              name,
              noGlobals
            ) {
              return this.parent && this.parent.hasBinding(name, noGlobals)
            }

            Scope.prototype.moveBindingTo = function moveBindingTo(
              name,
              scope
            ) {
              var info = this.getBinding(name)
              if (info) {
                info.scope.removeOwnBinding(name)
                info.scope = scope
                scope.bindings[name] = info
              }
            }

            Scope.prototype.removeOwnBinding = function removeOwnBinding(name) {
              delete this.bindings[name]
            }

            Scope.prototype.removeBinding = function removeBinding(name) {
              var info = this.getBinding(name)
              if (info) {
                info.scope.removeOwnBinding(name)
              }

              var scope = this
              do {
                if (scope.uids[name]) {
                  scope.uids[name] = false
                }
              } while ((scope = scope.parent))
            }

            return Scope
          })()

          Scope.globals = (0, _keys2.default)(_globals2.default.builtin)
          Scope.contextVariables = ['arguments', 'undefined', 'Infinity', 'NaN']
          exports.default = Scope
          module.exports = exports['default']
        },
        {
          '../cache': 74,
          '../index': 77,
          './binding': 95,
          './lib/renamer': 97,
          'babel-messages': 53,
          'babel-runtime/core-js/get-iterator': 54,
          'babel-runtime/core-js/map': 56,
          'babel-runtime/core-js/object/create': 59,
          'babel-runtime/core-js/object/keys': 61,
          'babel-runtime/helpers/classCallCheck': 68,
          'babel-types': 110,
          globals: 264,
          'lodash/defaults': 455,
          'lodash/includes': 466,
          'lodash/repeat': 489,
        },
      ],
      97: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true

          var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck')

          var _classCallCheck3 = _interopRequireDefault(_classCallCheck2)

          var _binding = require('../binding')

          var _binding2 = _interopRequireDefault(_binding)

          var _babelTypes = require('babel-types')

          var t = _interopRequireWildcard(_babelTypes)

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj
            } else {
              var newObj = {}
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key]
                }
              }
              newObj.default = obj
              return newObj
            }
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          var renameVisitor = {
            ReferencedIdentifier: function ReferencedIdentifier(_ref, state) {
              var node = _ref.node

              if (node.name === state.oldName) {
                node.name = state.newName
              }
            },
            Scope: function Scope(path, state) {
              if (
                !path.scope.bindingIdentifierEquals(
                  state.oldName,
                  state.binding.identifier
                )
              ) {
                path.skip()
              }
            },
            'AssignmentExpression|Declaration': function AssignmentExpressionDeclaration(
              path,
              state
            ) {
              var ids = path.getOuterBindingIdentifiers()

              for (var name in ids) {
                if (name === state.oldName) ids[name].name = state.newName
              }
            },
          }

          var Renamer = (function() {
            function Renamer(binding, oldName, newName) {
              ;(0, _classCallCheck3.default)(this, Renamer)

              this.newName = newName
              this.oldName = oldName
              this.binding = binding
            }

            Renamer.prototype.maybeConvertFromExportDeclaration = function maybeConvertFromExportDeclaration(
              parentDeclar
            ) {
              var exportDeclar =
                parentDeclar.parentPath.isExportDeclaration() &&
                parentDeclar.parentPath
              if (!exportDeclar) return

              var isDefault = exportDeclar.isExportDefaultDeclaration()

              if (
                isDefault &&
                (parentDeclar.isFunctionDeclaration() ||
                  parentDeclar.isClassDeclaration()) &&
                !parentDeclar.node.id
              ) {
                parentDeclar.node.id = parentDeclar.scope.generateUidIdentifier(
                  'default'
                )
              }

              var bindingIdentifiers = parentDeclar.getOuterBindingIdentifiers()
              var specifiers = []

              for (var name in bindingIdentifiers) {
                var localName = name === this.oldName ? this.newName : name
                var exportedName = isDefault ? 'default' : name
                specifiers.push(
                  t.exportSpecifier(
                    t.identifier(localName),
                    t.identifier(exportedName)
                  )
                )
              }

              if (specifiers.length) {
                var aliasDeclar = t.exportNamedDeclaration(null, specifiers)

                if (parentDeclar.isFunctionDeclaration()) {
                  aliasDeclar._blockHoist = 3
                }

                exportDeclar.insertAfter(aliasDeclar)
                exportDeclar.replaceWith(parentDeclar.node)
              }
            }

            Renamer.prototype.maybeConvertFromClassFunctionDeclaration = function maybeConvertFromClassFunctionDeclaration(
              path
            ) {
              return

              if (!path.isFunctionDeclaration() && !path.isClassDeclaration())
                return
              if (this.binding.kind !== 'hoisted') return

              path.node.id = t.identifier(this.oldName)
              path.node._blockHoist = 3

              path.replaceWith(
                t.variableDeclaration('let', [
                  t.variableDeclarator(
                    t.identifier(this.newName),
                    t.toExpression(path.node)
                  ),
                ])
              )
            }

            Renamer.prototype.maybeConvertFromClassFunctionExpression = function maybeConvertFromClassFunctionExpression(
              path
            ) {
              return

              if (!path.isFunctionExpression() && !path.isClassExpression())
                return
              if (this.binding.kind !== 'local') return

              path.node.id = t.identifier(this.oldName)

              this.binding.scope.parent.push({
                id: t.identifier(this.newName),
              })

              path.replaceWith(
                t.assignmentExpression(
                  '=',
                  t.identifier(this.newName),
                  path.node
                )
              )
            }

            Renamer.prototype.rename = function rename(block) {
              var binding = this.binding,
                oldName = this.oldName,
                newName = this.newName
              var scope = binding.scope,
                path = binding.path

              var parentDeclar = path.find(function(path) {
                return path.isDeclaration() || path.isFunctionExpression()
              })
              if (parentDeclar) {
                this.maybeConvertFromExportDeclaration(parentDeclar)
              }

              scope.traverse(block || scope.block, renameVisitor, this)

              if (!block) {
                scope.removeOwnBinding(oldName)
                scope.bindings[newName] = binding
                this.binding.identifier.name = newName
              }

              if (binding.type === 'hoisted') {
              }

              if (parentDeclar) {
                this.maybeConvertFromClassFunctionDeclaration(parentDeclar)
                this.maybeConvertFromClassFunctionExpression(parentDeclar)
              }
            }

            return Renamer
          })()

          exports.default = Renamer
          module.exports = exports['default']
        },
        {
          '../binding': 95,
          'babel-runtime/helpers/classCallCheck': 68,
          'babel-types': 110,
        },
      ],
      98: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true

          var _typeof2 = require('babel-runtime/helpers/typeof')

          var _typeof3 = _interopRequireDefault(_typeof2)

          var _keys = require('babel-runtime/core-js/object/keys')

          var _keys2 = _interopRequireDefault(_keys)

          var _getIterator2 = require('babel-runtime/core-js/get-iterator')

          var _getIterator3 = _interopRequireDefault(_getIterator2)

          exports.explode = explode
          exports.verify = verify
          exports.merge = merge

          var _virtualTypes = require('./path/lib/virtual-types')

          var virtualTypes = _interopRequireWildcard(_virtualTypes)

          var _babelMessages = require('babel-messages')

          var messages = _interopRequireWildcard(_babelMessages)

          var _babelTypes = require('babel-types')

          var t = _interopRequireWildcard(_babelTypes)

          var _clone = require('lodash/clone')

          var _clone2 = _interopRequireDefault(_clone)

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj
            } else {
              var newObj = {}
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key]
                }
              }
              newObj.default = obj
              return newObj
            }
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          function explode(visitor) {
            if (visitor._exploded) return visitor
            visitor._exploded = true

            for (var nodeType in visitor) {
              if (shouldIgnoreKey(nodeType)) continue

              var parts = nodeType.split('|')
              if (parts.length === 1) continue

              var fns = visitor[nodeType]
              delete visitor[nodeType]

              for (
                var _iterator = parts,
                  _isArray = Array.isArray(_iterator),
                  _i = 0,
                  _iterator = _isArray
                    ? _iterator
                    : (0, _getIterator3.default)(_iterator);
                ;

              ) {
                var _ref

                if (_isArray) {
                  if (_i >= _iterator.length) break
                  _ref = _iterator[_i++]
                } else {
                  _i = _iterator.next()
                  if (_i.done) break
                  _ref = _i.value
                }

                var part = _ref

                visitor[part] = fns
              }
            }

            verify(visitor)

            delete visitor.__esModule

            ensureEntranceObjects(visitor)

            ensureCallbackArrays(visitor)

            for (
              var _iterator2 = (0, _keys2.default)(visitor),
                _isArray2 = Array.isArray(_iterator2),
                _i2 = 0,
                _iterator2 = _isArray2
                  ? _iterator2
                  : (0, _getIterator3.default)(_iterator2);
              ;

            ) {
              var _ref2

              if (_isArray2) {
                if (_i2 >= _iterator2.length) break
                _ref2 = _iterator2[_i2++]
              } else {
                _i2 = _iterator2.next()
                if (_i2.done) break
                _ref2 = _i2.value
              }

              var _nodeType3 = _ref2

              if (shouldIgnoreKey(_nodeType3)) continue

              var wrapper = virtualTypes[_nodeType3]
              if (!wrapper) continue

              var _fns2 = visitor[_nodeType3]
              for (var type in _fns2) {
                _fns2[type] = wrapCheck(wrapper, _fns2[type])
              }

              delete visitor[_nodeType3]

              if (wrapper.types) {
                for (
                  var _iterator4 = wrapper.types,
                    _isArray4 = Array.isArray(_iterator4),
                    _i4 = 0,
                    _iterator4 = _isArray4
                      ? _iterator4
                      : (0, _getIterator3.default)(_iterator4);
                  ;

                ) {
                  var _ref4

                  if (_isArray4) {
                    if (_i4 >= _iterator4.length) break
                    _ref4 = _iterator4[_i4++]
                  } else {
                    _i4 = _iterator4.next()
                    if (_i4.done) break
                    _ref4 = _i4.value
                  }

                  var _type = _ref4

                  if (visitor[_type]) {
                    mergePair(visitor[_type], _fns2)
                  } else {
                    visitor[_type] = _fns2
                  }
                }
              } else {
                mergePair(visitor, _fns2)
              }
            }

            for (var _nodeType in visitor) {
              if (shouldIgnoreKey(_nodeType)) continue

              var _fns = visitor[_nodeType]

              var aliases = t.FLIPPED_ALIAS_KEYS[_nodeType]

              var deprecratedKey = t.DEPRECATED_KEYS[_nodeType]
              if (deprecratedKey) {
                console.trace(
                  'Visitor defined for ' +
                    _nodeType +
                    ' but it has been renamed to ' +
                    deprecratedKey
                )
                aliases = [deprecratedKey]
              }

              if (!aliases) continue

              delete visitor[_nodeType]

              for (
                var _iterator3 = aliases,
                  _isArray3 = Array.isArray(_iterator3),
                  _i3 = 0,
                  _iterator3 = _isArray3
                    ? _iterator3
                    : (0, _getIterator3.default)(_iterator3);
                ;

              ) {
                var _ref3

                if (_isArray3) {
                  if (_i3 >= _iterator3.length) break
                  _ref3 = _iterator3[_i3++]
                } else {
                  _i3 = _iterator3.next()
                  if (_i3.done) break
                  _ref3 = _i3.value
                }

                var alias = _ref3

                var existing = visitor[alias]
                if (existing) {
                  mergePair(existing, _fns)
                } else {
                  visitor[alias] = (0, _clone2.default)(_fns)
                }
              }
            }

            for (var _nodeType2 in visitor) {
              if (shouldIgnoreKey(_nodeType2)) continue

              ensureCallbackArrays(visitor[_nodeType2])
            }

            return visitor
          }

          function verify(visitor) {
            if (visitor._verified) return

            if (typeof visitor === 'function') {
              throw new Error(messages.get('traverseVerifyRootFunction'))
            }

            for (var nodeType in visitor) {
              if (nodeType === 'enter' || nodeType === 'exit') {
                validateVisitorMethods(nodeType, visitor[nodeType])
              }

              if (shouldIgnoreKey(nodeType)) continue

              if (t.TYPES.indexOf(nodeType) < 0) {
                throw new Error(
                  messages.get('traverseVerifyNodeType', nodeType)
                )
              }

              var visitors = visitor[nodeType]
              if (
                (typeof visitors === 'undefined'
                  ? 'undefined'
                  : (0, _typeof3.default)(visitors)) === 'object'
              ) {
                for (var visitorKey in visitors) {
                  if (visitorKey === 'enter' || visitorKey === 'exit') {
                    validateVisitorMethods(
                      nodeType + '.' + visitorKey,
                      visitors[visitorKey]
                    )
                  } else {
                    throw new Error(
                      messages.get(
                        'traverseVerifyVisitorProperty',
                        nodeType,
                        visitorKey
                      )
                    )
                  }
                }
              }
            }

            visitor._verified = true
          }

          function validateVisitorMethods(path, val) {
            var fns = [].concat(val)
            for (
              var _iterator5 = fns,
                _isArray5 = Array.isArray(_iterator5),
                _i5 = 0,
                _iterator5 = _isArray5
                  ? _iterator5
                  : (0, _getIterator3.default)(_iterator5);
              ;

            ) {
              var _ref5

              if (_isArray5) {
                if (_i5 >= _iterator5.length) break
                _ref5 = _iterator5[_i5++]
              } else {
                _i5 = _iterator5.next()
                if (_i5.done) break
                _ref5 = _i5.value
              }

              var fn = _ref5

              if (typeof fn !== 'function') {
                throw new TypeError(
                  'Non-function found defined in ' +
                    path +
                    ' with type ' +
                    (typeof fn === 'undefined'
                      ? 'undefined'
                      : (0, _typeof3.default)(fn))
                )
              }
            }
          }

          function merge(visitors) {
            var states = arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : []
            var wrapper = arguments[2]

            var rootVisitor = {}

            for (var i = 0; i < visitors.length; i++) {
              var visitor = visitors[i]
              var state = states[i]

              explode(visitor)

              for (var type in visitor) {
                var visitorType = visitor[type]

                if (state || wrapper) {
                  visitorType = wrapWithStateOrWrapper(
                    visitorType,
                    state,
                    wrapper
                  )
                }

                var nodeVisitor = (rootVisitor[type] = rootVisitor[type] || {})
                mergePair(nodeVisitor, visitorType)
              }
            }

            return rootVisitor
          }

          function wrapWithStateOrWrapper(oldVisitor, state, wrapper) {
            var newVisitor = {}

            var _loop = function _loop(key) {
              var fns = oldVisitor[key]

              if (!Array.isArray(fns)) return 'continue'

              fns = fns.map(function(fn) {
                var newFn = fn

                if (state) {
                  newFn = function newFn(path) {
                    return fn.call(state, path, state)
                  }
                }

                if (wrapper) {
                  newFn = wrapper(state.key, key, newFn)
                }

                return newFn
              })

              newVisitor[key] = fns
            }

            for (var key in oldVisitor) {
              var _ret = _loop(key)

              if (_ret === 'continue') continue
            }

            return newVisitor
          }

          function ensureEntranceObjects(obj) {
            for (var key in obj) {
              if (shouldIgnoreKey(key)) continue

              var fns = obj[key]
              if (typeof fns === 'function') {
                obj[key] = { enter: fns }
              }
            }
          }

          function ensureCallbackArrays(obj) {
            if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter]
            if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit]
          }

          function wrapCheck(wrapper, fn) {
            var newFn = function newFn(path) {
              if (wrapper.checkPath(path)) {
                return fn.apply(this, arguments)
              }
            }
            newFn.toString = function() {
              return fn.toString()
            }
            return newFn
          }

          function shouldIgnoreKey(key) {
            if (key[0] === '_') return true

            if (key === 'enter' || key === 'exit' || key === 'shouldSkip')
              return true

            if (key === 'blacklist' || key === 'noScope' || key === 'skipKeys')
              return true

            return false
          }

          function mergePair(dest, src) {
            for (var key in src) {
              dest[key] = [].concat(dest[key] || [], src[key])
            }
          }
        },
        {
          './path/lib/virtual-types': 91,
          'babel-messages': 53,
          'babel-runtime/core-js/get-iterator': 54,
          'babel-runtime/core-js/object/keys': 61,
          'babel-runtime/helpers/typeof': 72,
          'babel-types': 110,
          'lodash/clone': 451,
        },
      ],
      99: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true
          exports.NOT_LOCAL_BINDING = exports.BLOCK_SCOPED_SYMBOL = exports.INHERIT_KEYS = exports.UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = exports.NUMBER_UNARY_OPERATORS = exports.BOOLEAN_UNARY_OPERATORS = exports.BINARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = exports.EQUALITY_BINARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = exports.UPDATE_OPERATORS = exports.LOGICAL_OPERATORS = exports.COMMENT_KEYS = exports.FOR_INIT_KEYS = exports.FLATTENABLE_KEYS = exports.STATEMENT_OR_BLOCK_KEYS = undefined

          var _for = require('babel-runtime/core-js/symbol/for')

          var _for2 = _interopRequireDefault(_for)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          var STATEMENT_OR_BLOCK_KEYS = (exports.STATEMENT_OR_BLOCK_KEYS = [
            'consequent',
            'body',
            'alternate',
          ])
          var FLATTENABLE_KEYS = (exports.FLATTENABLE_KEYS = [
            'body',
            'expressions',
          ])
          var FOR_INIT_KEYS = (exports.FOR_INIT_KEYS = ['left', 'init'])
          var COMMENT_KEYS = (exports.COMMENT_KEYS = [
            'leadingComments',
            'trailingComments',
            'innerComments',
          ])

          var LOGICAL_OPERATORS = (exports.LOGICAL_OPERATORS = ['||', '&&'])
          var UPDATE_OPERATORS = (exports.UPDATE_OPERATORS = ['++', '--'])

          var BOOLEAN_NUMBER_BINARY_OPERATORS = (exports.BOOLEAN_NUMBER_BINARY_OPERATORS = [
            '>',
            '<',
            '>=',
            '<=',
          ])
          var EQUALITY_BINARY_OPERATORS = (exports.EQUALITY_BINARY_OPERATORS = [
            '==',
            '===',
            '!=',
            '!==',
          ])
          var COMPARISON_BINARY_OPERATORS = (exports.COMPARISON_BINARY_OPERATORS = [].concat(
            EQUALITY_BINARY_OPERATORS,
            ['in', 'instanceof']
          ))
          var BOOLEAN_BINARY_OPERATORS = (exports.BOOLEAN_BINARY_OPERATORS = [].concat(
            COMPARISON_BINARY_OPERATORS,
            BOOLEAN_NUMBER_BINARY_OPERATORS
          ))
          var NUMBER_BINARY_OPERATORS = (exports.NUMBER_BINARY_OPERATORS = [
            '-',
            '/',
            '%',
            '*',
            '**',
            '&',
            '|',
            '>>',
            '>>>',
            '<<',
            '^',
          ])
          var BINARY_OPERATORS = (exports.BINARY_OPERATORS = ['+'].concat(
            NUMBER_BINARY_OPERATORS,
            BOOLEAN_BINARY_OPERATORS
          ))

          var BOOLEAN_UNARY_OPERATORS = (exports.BOOLEAN_UNARY_OPERATORS = [
            'delete',
            '!',
          ])
          var NUMBER_UNARY_OPERATORS = (exports.NUMBER_UNARY_OPERATORS = [
            '+',
            '-',
            '++',
            '--',
            '~',
          ])
          var STRING_UNARY_OPERATORS = (exports.STRING_UNARY_OPERATORS = [
            'typeof',
          ])
          var UNARY_OPERATORS = (exports.UNARY_OPERATORS = ['void'].concat(
            BOOLEAN_UNARY_OPERATORS,
            NUMBER_UNARY_OPERATORS,
            STRING_UNARY_OPERATORS
          ))

          var INHERIT_KEYS = (exports.INHERIT_KEYS = {
            optional: ['typeAnnotation', 'typeParameters', 'returnType'],
            force: ['start', 'loc', 'end'],
          })

          var BLOCK_SCOPED_SYMBOL = (exports.BLOCK_SCOPED_SYMBOL = (
            0,
            _for2.default
          )('var used to be block scoped'))
          var NOT_LOCAL_BINDING = (exports.NOT_LOCAL_BINDING = (
            0,
            _for2.default
          )('should not be considered a local binding'))
        },
        { 'babel-runtime/core-js/symbol/for': 64 },
      ],
      100: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true

          var _maxSafeInteger = require('babel-runtime/core-js/number/max-safe-integer')

          var _maxSafeInteger2 = _interopRequireDefault(_maxSafeInteger)

          var _stringify = require('babel-runtime/core-js/json/stringify')

          var _stringify2 = _interopRequireDefault(_stringify)

          var _getIterator2 = require('babel-runtime/core-js/get-iterator')

          var _getIterator3 = _interopRequireDefault(_getIterator2)

          exports.toComputedKey = toComputedKey
          exports.toSequenceExpression = toSequenceExpression
          exports.toKeyAlias = toKeyAlias
          exports.toIdentifier = toIdentifier
          exports.toBindingIdentifierName = toBindingIdentifierName
          exports.toStatement = toStatement
          exports.toExpression = toExpression
          exports.toBlock = toBlock
          exports.valueToNode = valueToNode

          var _isPlainObject = require('lodash/isPlainObject')

          var _isPlainObject2 = _interopRequireDefault(_isPlainObject)

          var _isRegExp = require('lodash/isRegExp')

          var _isRegExp2 = _interopRequireDefault(_isRegExp)

          var _index = require('./index')

          var t = _interopRequireWildcard(_index)

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj
            } else {
              var newObj = {}
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key]
                }
              }
              newObj.default = obj
              return newObj
            }
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          function toComputedKey(node) {
            var key = arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : node.key || node.property

            if (!node.computed) {
              if (t.isIdentifier(key)) key = t.stringLiteral(key.name)
            }
            return key
          }

          function toSequenceExpression(nodes, scope) {
            if (!nodes || !nodes.length) return

            var declars = []
            var bailed = false

            var result = convert(nodes)
            if (bailed) return

            for (var i = 0; i < declars.length; i++) {
              scope.push(declars[i])
            }

            return result

            function convert(nodes) {
              var ensureLastUndefined = false
              var exprs = []

              for (
                var _iterator = nodes,
                  _isArray = Array.isArray(_iterator),
                  _i = 0,
                  _iterator = _isArray
                    ? _iterator
                    : (0, _getIterator3.default)(_iterator);
                ;

              ) {
                var _ref

                if (_isArray) {
                  if (_i >= _iterator.length) break
                  _ref = _iterator[_i++]
                } else {
                  _i = _iterator.next()
                  if (_i.done) break
                  _ref = _i.value
                }

                var node = _ref

                if (t.isExpression(node)) {
                  exprs.push(node)
                } else if (t.isExpressionStatement(node)) {
                  exprs.push(node.expression)
                } else if (t.isVariableDeclaration(node)) {
                  if (node.kind !== 'var') return (bailed = true)

                  for (
                    var _iterator2 = node.declarations,
                      _isArray2 = Array.isArray(_iterator2),
                      _i2 = 0,
                      _iterator2 = _isArray2
                        ? _iterator2
                        : (0, _getIterator3.default)(_iterator2);
                    ;

                  ) {
                    var _ref2

                    if (_isArray2) {
                      if (_i2 >= _iterator2.length) break
                      _ref2 = _iterator2[_i2++]
                    } else {
                      _i2 = _iterator2.next()
                      if (_i2.done) break
                      _ref2 = _i2.value
                    }

                    var declar = _ref2

                    var bindings = t.getBindingIdentifiers(declar)
                    for (var key in bindings) {
                      declars.push({
                        kind: node.kind,
                        id: bindings[key],
                      })
                    }

                    if (declar.init) {
                      exprs.push(
                        t.assignmentExpression('=', declar.id, declar.init)
                      )
                    }
                  }

                  ensureLastUndefined = true
                  continue
                } else if (t.isIfStatement(node)) {
                  var consequent = node.consequent
                    ? convert([node.consequent])
                    : scope.buildUndefinedNode()
                  var alternate = node.alternate
                    ? convert([node.alternate])
                    : scope.buildUndefinedNode()
                  if (!consequent || !alternate) return (bailed = true)

                  exprs.push(
                    t.conditionalExpression(node.test, consequent, alternate)
                  )
                } else if (t.isBlockStatement(node)) {
                  exprs.push(convert(node.body))
                } else if (t.isEmptyStatement(node)) {
                  ensureLastUndefined = true
                  continue
                } else {
                  return (bailed = true)
                }

                ensureLastUndefined = false
              }

              if (ensureLastUndefined || exprs.length === 0) {
                exprs.push(scope.buildUndefinedNode())
              }

              if (exprs.length === 1) {
                return exprs[0]
              } else {
                return t.sequenceExpression(exprs)
              }
            }
          }

          function toKeyAlias(node) {
            var key = arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : node.key

            var alias = void 0

            if (node.kind === 'method') {
              return toKeyAlias.increment() + ''
            } else if (t.isIdentifier(key)) {
              alias = key.name
            } else if (t.isStringLiteral(key)) {
              alias = (0, _stringify2.default)(key.value)
            } else {
              alias = (0, _stringify2.default)(
                t.removePropertiesDeep(t.cloneDeep(key))
              )
            }

            if (node.computed) {
              alias = '[' + alias + ']'
            }

            if (node.static) {
              alias = 'static:' + alias
            }

            return alias
          }

          toKeyAlias.uid = 0

          toKeyAlias.increment = function() {
            if (toKeyAlias.uid >= _maxSafeInteger2.default) {
              return (toKeyAlias.uid = 0)
            } else {
              return toKeyAlias.uid++
            }
          }

          function toIdentifier(name) {
            name = name + ''

            name = name.replace(/[^a-zA-Z0-9$_]/g, '-')

            name = name.replace(/^[-0-9]+/, '')

            name = name.replace(/[-\s]+(.)?/g, function(match, c) {
              return c ? c.toUpperCase() : ''
            })

            if (!t.isValidIdentifier(name)) {
              name = '_' + name
            }

            return name || '_'
          }

          function toBindingIdentifierName(name) {
            name = toIdentifier(name)
            if (name === 'eval' || name === 'arguments') name = '_' + name
            return name
          }

          function toStatement(node, ignore) {
            if (t.isStatement(node)) {
              return node
            }

            var mustHaveId = false
            var newType = void 0

            if (t.isClass(node)) {
              mustHaveId = true
              newType = 'ClassDeclaration'
            } else if (t.isFunction(node)) {
              mustHaveId = true
              newType = 'FunctionDeclaration'
            } else if (t.isAssignmentExpression(node)) {
              return t.expressionStatement(node)
            }

            if (mustHaveId && !node.id) {
              newType = false
            }

            if (!newType) {
              if (ignore) {
                return false
              } else {
                throw new Error('cannot turn ' + node.type + ' to a statement')
              }
            }

            node.type = newType

            return node
          }

          function toExpression(node) {
            if (t.isExpressionStatement(node)) {
              node = node.expression
            }

            if (t.isExpression(node)) {
              return node
            }

            if (t.isClass(node)) {
              node.type = 'ClassExpression'
            } else if (t.isFunction(node)) {
              node.type = 'FunctionExpression'
            }

            if (!t.isExpression(node)) {
              throw new Error('cannot turn ' + node.type + ' to an expression')
            }

            return node
          }

          function toBlock(node, parent) {
            if (t.isBlockStatement(node)) {
              return node
            }

            if (t.isEmptyStatement(node)) {
              node = []
            }

            if (!Array.isArray(node)) {
              if (!t.isStatement(node)) {
                if (t.isFunction(parent)) {
                  node = t.returnStatement(node)
                } else {
                  node = t.expressionStatement(node)
                }
              }

              node = [node]
            }

            return t.blockStatement(node)
          }

          function valueToNode(value) {
            if (value === undefined) {
              return t.identifier('undefined')
            }

            if (value === true || value === false) {
              return t.booleanLiteral(value)
            }

            if (value === null) {
              return t.nullLiteral()
            }

            if (typeof value === 'string') {
              return t.stringLiteral(value)
            }

            if (typeof value === 'number') {
              return t.numericLiteral(value)
            }

            if ((0, _isRegExp2.default)(value)) {
              var pattern = value.source
              var flags = value.toString().match(/\/([a-z]+|)$/)[1]
              return t.regExpLiteral(pattern, flags)
            }

            if (Array.isArray(value)) {
              return t.arrayExpression(value.map(t.valueToNode))
            }

            if ((0, _isPlainObject2.default)(value)) {
              var props = []
              for (var key in value) {
                var nodeKey = void 0
                if (t.isValidIdentifier(key)) {
                  nodeKey = t.identifier(key)
                } else {
                  nodeKey = t.stringLiteral(key)
                }
                props.push(t.objectProperty(nodeKey, t.valueToNode(value[key])))
              }
              return t.objectExpression(props)
            }

            throw new Error("don't know how to turn this value into a node")
          }
        },
        {
          './index': 110,
          'babel-runtime/core-js/get-iterator': 54,
          'babel-runtime/core-js/json/stringify': 55,
          'babel-runtime/core-js/number/max-safe-integer': 57,
          'lodash/isPlainObject': 477,
          'lodash/isRegExp': 478,
        },
      ],
      101: [
        function(require, module, exports) {
          'use strict'
          var _index = require('../index')

          var t = _interopRequireWildcard(_index)

          var _constants = require('../constants')

          var _index2 = require('./index')

          var _index3 = _interopRequireDefault(_index2)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj
            } else {
              var newObj = {}
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key]
                }
              }
              newObj.default = obj
              return newObj
            }
          }

          ;(0, _index3.default)('ArrayExpression', {
            fields: {
              elements: {
                validate: (0, _index2.chain)(
                  (0, _index2.assertValueType)('array'),
                  (0, _index2.assertEach)(
                    (0, _index2.assertNodeOrValueType)(
                      'null',
                      'Expression',
                      'SpreadElement'
                    )
                  )
                ),
                default: [],
              },
            },
            visitor: ['elements'],
            aliases: ['Expression'],
          })
          ;(0, _index3.default)('AssignmentExpression', {
            fields: {
              operator: {
                validate: (0, _index2.assertValueType)('string'),
              },
              left: {
                validate: (0, _index2.assertNodeType)('LVal'),
              },
              right: {
                validate: (0, _index2.assertNodeType)('Expression'),
              },
            },
            builder: ['operator', 'left', 'right'],
            visitor: ['left', 'right'],
            aliases: ['Expression'],
          })
          ;(0, _index3.default)('BinaryExpression', {
            builder: ['operator', 'left', 'right'],
            fields: {
              operator: {
                validate: _index2.assertOneOf.apply(
                  undefined,
                  _constants.BINARY_OPERATORS
                ),
              },
              left: {
                validate: (0, _index2.assertNodeType)('Expression'),
              },
              right: {
                validate: (0, _index2.assertNodeType)('Expression'),
              },
            },
            visitor: ['left', 'right'],
            aliases: ['Binary', 'Expression'],
          })
          ;(0, _index3.default)('Directive', {
            visitor: ['value'],
            fields: {
              value: {
                validate: (0, _index2.assertNodeType)('DirectiveLiteral'),
              },
            },
          })
          ;(0, _index3.default)('DirectiveLiteral', {
            builder: ['value'],
            fields: {
              value: {
                validate: (0, _index2.assertValueType)('string'),
              },
            },
          })
          ;(0, _index3.default)('BlockStatement', {
            builder: ['body', 'directives'],
            visitor: ['directives', 'body'],
            fields: {
              directives: {
                validate: (0, _index2.chain)(
                  (0, _index2.assertValueType)('array'),
                  (0, _index2.assertEach)(
                    (0, _index2.assertNodeType)('Directive')
                  )
                ),
                default: [],
              },
              body: {
                validate: (0, _index2.chain)(
                  (0, _index2.assertValueType)('array'),
                  (0, _index2.assertEach)(
                    (0, _index2.assertNodeType)('Statement')
                  )
                ),
              },
            },
            aliases: ['Scopable', 'BlockParent', 'Block', 'Statement'],
          })
          ;(0, _index3.default)('BreakStatement', {
            visitor: ['label'],
            fields: {
              label: {
                validate: (0, _index2.assertNodeType)('Identifier'),
                optional: true,
              },
            },
            aliases: ['Statement', 'Terminatorless', 'CompletionStatement'],
          })
          ;(0, _index3.default)('CallExpression', {
            visitor: ['callee', 'arguments'],
            fields: {
              callee: {
                validate: (0, _index2.assertNodeType)('Expression'),
              },
              arguments: {
                validate: (0, _index2.chain)(
                  (0, _index2.assertValueType)('array'),
                  (0, _index2.assertEach)(
                    (0, _index2.assertNodeType)('Expression', 'SpreadElement')
                  )
                ),
              },
            },
            aliases: ['Expression'],
          })
          ;(0, _index3.default)('CatchClause', {
            visitor: ['param', 'body'],
            fields: {
              param: {
                validate: (0, _index2.assertNodeType)('Identifier'),
              },
              body: {
                validate: (0, _index2.assertNodeType)('BlockStatement'),
              },
            },
            aliases: ['Scopable'],
          })
          ;(0, _index3.default)('ConditionalExpression', {
            visitor: ['test', 'consequent', 'alternate'],
            fields: {
              test: {
                validate: (0, _index2.assertNodeType)('Expression'),
              },
              consequent: {
                validate: (0, _index2.assertNodeType)('Expression'),
              },
              alternate: {
                validate: (0, _index2.assertNodeType)('Expression'),
              },
            },
            aliases: ['Expression', 'Conditional'],
          })
          ;(0, _index3.default)('ContinueStatement', {
            visitor: ['label'],
            fields: {
              label: {
                validate: (0, _index2.assertNodeType)('Identifier'),
                optional: true,
              },
            },
            aliases: ['Statement', 'Terminatorless', 'CompletionStatement'],
          })
          ;(0, _index3.default)('DebuggerStatement', {
            aliases: ['Statement'],
          })
          ;(0, _index3.default)('DoWhileStatement', {
            visitor: ['test', 'body'],
            fields: {
              test: {
                validate: (0, _index2.assertNodeType)('Expression'),
              },
              body: {
                validate: (0, _index2.assertNodeType)('Statement'),
              },
            },
            aliases: ['Statement', 'BlockParent', 'Loop', 'While', 'Scopable'],
          })
          ;(0, _index3.default)('EmptyStatement', {
            aliases: ['Statement'],
          })
          ;(0, _index3.default)('ExpressionStatement', {
            visitor: ['expression'],
            fields: {
              expression: {
                validate: (0, _index2.assertNodeType)('Expression'),
              },
            },
            aliases: ['Statement', 'ExpressionWrapper'],
          })
          ;(0, _index3.default)('File', {
            builder: ['program', 'comments', 'tokens'],
            visitor: ['program'],
            fields: {
              program: {
                validate: (0, _index2.assertNodeType)('Program'),
              },
            },
          })
          ;(0, _index3.default)('ForInStatement', {
            visitor: ['left', 'right', 'body'],
            aliases: [
              'Scopable',
              'Statement',
              'For',
              'BlockParent',
              'Loop',
              'ForXStatement',
            ],
            fields: {
              left: {
                validate: (0, _index2.assertNodeType)(
                  'VariableDeclaration',
                  'LVal'
                ),
              },
              right: {
                validate: (0, _index2.assertNodeType)('Expression'),
              },
              body: {
                validate: (0, _index2.assertNodeType)('Statement'),
              },
            },
          })
          ;(0, _index3.default)('ForStatement', {
            visitor: ['init', 'test', 'update', 'body'],
            aliases: ['Scopable', 'Statement', 'For', 'BlockParent', 'Loop'],
            fields: {
              init: {
                validate: (0, _index2.assertNodeType)(
                  'VariableDeclaration',
                  'Expression'
                ),
                optional: true,
              },
              test: {
                validate: (0, _index2.assertNodeType)('Expression'),
                optional: true,
              },
              update: {
                validate: (0, _index2.assertNodeType)('Expression'),
                optional: true,
              },
              body: {
                validate: (0, _index2.assertNodeType)('Statement'),
              },
            },
          })
          ;(0, _index3.default)('FunctionDeclaration', {
            builder: ['id', 'params', 'body', 'generator', 'async'],
            visitor: ['id', 'params', 'body', 'returnType', 'typeParameters'],
            fields: {
              id: {
                validate: (0, _index2.assertNodeType)('Identifier'),
              },
              params: {
                validate: (0, _index2.chain)(
                  (0, _index2.assertValueType)('array'),
                  (0, _index2.assertEach)((0, _index2.assertNodeType)('LVal'))
                ),
              },
              body: {
                validate: (0, _index2.assertNodeType)('BlockStatement'),
              },
              generator: {
                default: false,
                validate: (0, _index2.assertValueType)('boolean'),
              },
              async: {
                default: false,
                validate: (0, _index2.assertValueType)('boolean'),
              },
            },
            aliases: [
              'Scopable',
              'Function',
              'BlockParent',
              'FunctionParent',
              'Statement',
              'Pureish',
              'Declaration',
            ],
          })
          ;(0, _index3.default)('FunctionExpression', {
            inherits: 'FunctionDeclaration',
            aliases: [
              'Scopable',
              'Function',
              'BlockParent',
              'FunctionParent',
              'Expression',
              'Pureish',
            ],
            fields: {
              id: {
                validate: (0, _index2.assertNodeType)('Identifier'),
                optional: true,
              },
              params: {
                validate: (0, _index2.chain)(
                  (0, _index2.assertValueType)('array'),
                  (0, _index2.assertEach)((0, _index2.assertNodeType)('LVal'))
                ),
              },
              body: {
                validate: (0, _index2.assertNodeType)('BlockStatement'),
              },
              generator: {
                default: false,
                validate: (0, _index2.assertValueType)('boolean'),
              },
              async: {
                default: false,
                validate: (0, _index2.assertValueType)('boolean'),
              },
            },
          })
          ;(0, _index3.default)('Identifier', {
            builder: ['name'],
            visitor: ['typeAnnotation'],
            aliases: ['Expression', 'LVal'],
            fields: {
              name: {
                validate: function validate(node, key, val) {
                  if (!t.isValidIdentifier(val)) {
                  }
                },
              },
              decorators: {
                validate: (0, _index2.chain)(
                  (0, _index2.assertValueType)('array'),
                  (0, _index2.assertEach)(
                    (0, _index2.assertNodeType)('Decorator')
                  )
                ),
              },
            },
          })
          ;(0, _index3.default)('IfStatement', {
            visitor: ['test', 'consequent', 'alternate'],
            aliases: ['Statement', 'Conditional'],
            fields: {
              test: {
                validate: (0, _index2.assertNodeType)('Expression'),
              },
              consequent: {
                validate: (0, _index2.assertNodeType)('Statement'),
              },
              alternate: {
                optional: true,
                validate: (0, _index2.assertNodeType)('Statement'),
              },
            },
          })
          ;(0, _index3.default)('LabeledStatement', {
            visitor: ['label', 'body'],
            aliases: ['Statement'],
            fields: {
              label: {
                validate: (0, _index2.assertNodeType)('Identifier'),
              },
              body: {
                validate: (0, _index2.assertNodeType)('Statement'),
              },
            },
          })
          ;(0, _index3.default)('StringLiteral', {
            builder: ['value'],
            fields: {
              value: {
                validate: (0, _index2.assertValueType)('string'),
              },
            },
            aliases: ['Expression', 'Pureish', 'Literal', 'Immutable'],
          })
          ;(0, _index3.default)('NumericLiteral', {
            builder: ['value'],
            deprecatedAlias: 'NumberLiteral',
            fields: {
              value: {
                validate: (0, _index2.assertValueType)('number'),
              },
            },
            aliases: ['Expression', 'Pureish', 'Literal', 'Immutable'],
          })
          ;(0, _index3.default)('NullLiteral', {
            aliases: ['Expression', 'Pureish', 'Literal', 'Immutable'],
          })
          ;(0, _index3.default)('BooleanLiteral', {
            builder: ['value'],
            fields: {
              value: {
                validate: (0, _index2.assertValueType)('boolean'),
              },
            },
            aliases: ['Expression', 'Pureish', 'Literal', 'Immutable'],
          })
          ;(0, _index3.default)('RegExpLiteral', {
            builder: ['pattern', 'flags'],
            deprecatedAlias: 'RegexLiteral',
            aliases: ['Expression', 'Literal'],
            fields: {
              pattern: {
                validate: (0, _index2.assertValueType)('string'),
              },
              flags: {
                validate: (0, _index2.assertValueType)('string'),
                default: '',
              },
            },
          })
          ;(0, _index3.default)('LogicalExpression', {
            builder: ['operator', 'left', 'right'],
            visitor: ['left', 'right'],
            aliases: ['Binary', 'Expression'],
            fields: {
              operator: {
                validate: _index2.assertOneOf.apply(
                  undefined,
                  _constants.LOGICAL_OPERATORS
                ),
              },
              left: {
                validate: (0, _index2.assertNodeType)('Expression'),
              },
              right: {
                validate: (0, _index2.assertNodeType)('Expression'),
              },
            },
          })
          ;(0, _index3.default)('MemberExpression', {
            builder: ['object', 'property', 'computed'],
            visitor: ['object', 'property'],
            aliases: ['Expression', 'LVal'],
            fields: {
              object: {
                validate: (0, _index2.assertNodeType)('Expression'),
              },
              property: {
                validate: function validate(node, key, val) {
                  var expectedType = node.computed ? 'Expression' : 'Identifier'
                  ;(0, _index2.assertNodeType)(expectedType)(node, key, val)
                },
              },
              computed: {
                default: false,
              },
            },
          })
          ;(0, _index3.default)('NewExpression', {
            visitor: ['callee', 'arguments'],
            aliases: ['Expression'],
            fields: {
              callee: {
                validate: (0, _index2.assertNodeType)('Expression'),
              },
              arguments: {
                validate: (0, _index2.chain)(
                  (0, _index2.assertValueType)('array'),
                  (0, _index2.assertEach)(
                    (0, _index2.assertNodeType)('Expression', 'SpreadElement')
                  )
                ),
              },
            },
          })
          ;(0, _index3.default)('Program', {
            visitor: ['directives', 'body'],
            builder: ['body', 'directives'],
            fields: {
              directives: {
                validate: (0, _index2.chain)(
                  (0, _index2.assertValueType)('array'),
                  (0, _index2.assertEach)(
                    (0, _index2.assertNodeType)('Directive')
                  )
                ),
                default: [],
              },
              body: {
                validate: (0, _index2.chain)(
                  (0, _index2.assertValueType)('array'),
                  (0, _index2.assertEach)(
                    (0, _index2.assertNodeType)('Statement')
                  )
                ),
              },
            },
            aliases: ['Scopable', 'BlockParent', 'Block', 'FunctionParent'],
          })
          ;(0, _index3.default)('ObjectExpression', {
            visitor: ['properties'],
            aliases: ['Expression'],
            fields: {
              properties: {
                validate: (0, _index2.chain)(
                  (0, _index2.assertValueType)('array'),
                  (0, _index2.assertEach)(
                    (0, _index2.assertNodeType)(
                      'ObjectMethod',
                      'ObjectProperty',
                      'SpreadProperty'
                    )
                  )
                ),
              },
            },
          })
          ;(0, _index3.default)('ObjectMethod', {
            builder: ['kind', 'key', 'params', 'body', 'computed'],
            fields: {
              kind: {
                validate: (0, _index2.chain)(
                  (0, _index2.assertValueType)('string'),
                  (0, _index2.assertOneOf)('method', 'get', 'set')
                ),
                default: 'method',
              },
              computed: {
                validate: (0, _index2.assertValueType)('boolean'),
                default: false,
              },
              key: {
                validate: function validate(node, key, val) {
                  var expectedTypes = node.computed
                    ? ['Expression']
                    : ['Identifier', 'StringLiteral', 'NumericLiteral']
                  _index2.assertNodeType.apply(undefined, expectedTypes)(
                    node,
                    key,
                    val
                  )
                },
              },
              decorators: {
                validate: (0, _index2.chain)(
                  (0, _index2.assertValueType)('array'),
                  (0, _index2.assertEach)(
                    (0, _index2.assertNodeType)('Decorator')
                  )
                ),
              },
              body: {
                validate: (0, _index2.assertNodeType)('BlockStatement'),
              },
              generator: {
                default: false,
                validate: (0, _index2.assertValueType)('boolean'),
              },
              async: {
                default: false,
                validate: (0, _index2.assertValueType)('boolean'),
              },
            },
            visitor: [
              'key',
              'params',
              'body',
              'decorators',
              'returnType',
              'typeParameters',
            ],
            aliases: [
              'UserWhitespacable',
              'Function',
              'Scopable',
              'BlockParent',
              'FunctionParent',
              'Method',
              'ObjectMember',
            ],
          })
          ;(0, _index3.default)('ObjectProperty', {
            builder: ['key', 'value', 'computed', 'shorthand', 'decorators'],
            fields: {
              computed: {
                validate: (0, _index2.assertValueType)('boolean'),
                default: false,
              },
              key: {
                validate: function validate(node, key, val) {
                  var expectedTypes = node.computed
                    ? ['Expression']
                    : ['Identifier', 'StringLiteral', 'NumericLiteral']
                  _index2.assertNodeType.apply(undefined, expectedTypes)(
                    node,
                    key,
                    val
                  )
                },
              },
              value: {
                validate: (0, _index2.assertNodeType)('Expression'),
              },
              shorthand: {
                validate: (0, _index2.assertValueType)('boolean'),
                default: false,
              },
              decorators: {
                validate: (0, _index2.chain)(
                  (0, _index2.assertValueType)('array'),
                  (0, _index2.assertEach)(
                    (0, _index2.assertNodeType)('Decorator')
                  )
                ),
                optional: true,
              },
            },
            visitor: ['key', 'value', 'decorators'],
            aliases: ['UserWhitespacable', 'Property', 'ObjectMember'],
          })
          ;(0, _index3.default)('RestElement', {
            visitor: ['argument', 'typeAnnotation'],
            aliases: ['LVal'],
            fields: {
              argument: {
                validate: (0, _index2.assertNodeType)('LVal'),
              },
              decorators: {
                validate: (0, _index2.chain)(
                  (0, _index2.assertValueType)('array'),
                  (0, _index2.assertEach)(
                    (0, _index2.assertNodeType)('Decorator')
                  )
                ),
              },
            },
          })
          ;(0, _index3.default)('ReturnStatement', {
            visitor: ['argument'],
            aliases: ['Statement', 'Terminatorless', 'CompletionStatement'],
            fields: {
              argument: {
                validate: (0, _index2.assertNodeType)('Expression'),
                optional: true,
              },
            },
          })
          ;(0, _index3.default)('SequenceExpression', {
            visitor: ['expressions'],
            fields: {
              expressions: {
                validate: (0, _index2.chain)(
                  (0, _index2.assertValueType)('array'),
                  (0, _index2.assertEach)(
                    (0, _index2.assertNodeType)('Expression')
                  )
                ),
              },
            },
            aliases: ['Expression'],
          })
          ;(0, _index3.default)('SwitchCase', {
            visitor: ['test', 'consequent'],
            fields: {
              test: {
                validate: (0, _index2.assertNodeType)('Expression'),
                optional: true,
              },
              consequent: {
                validate: (0, _index2.chain)(
                  (0, _index2.assertValueType)('array'),
                  (0, _index2.assertEach)(
                    (0, _index2.assertNodeType)('Statement')
                  )
                ),
              },
            },
          })
          ;(0, _index3.default)('SwitchStatement', {
            visitor: ['discriminant', 'cases'],
            aliases: ['Statement', 'BlockParent', 'Scopable'],
            fields: {
              discriminant: {
                validate: (0, _index2.assertNodeType)('Expression'),
              },
              cases: {
                validate: (0, _index2.chain)(
                  (0, _index2.assertValueType)('array'),
                  (0, _index2.assertEach)(
                    (0, _index2.assertNodeType)('SwitchCase')
                  )
                ),
              },
            },
          })
          ;(0, _index3.default)('ThisExpression', {
            aliases: ['Expression'],
          })
          ;(0, _index3.default)('ThrowStatement', {
            visitor: ['argument'],
            aliases: ['Statement', 'Terminatorless', 'CompletionStatement'],
            fields: {
              argument: {
                validate: (0, _index2.assertNodeType)('Expression'),
              },
            },
          })
          ;(0, _index3.default)('TryStatement', {
            visitor: ['block', 'handler', 'finalizer'],
            aliases: ['Statement'],
            fields: {
              body: {
                validate: (0, _index2.assertNodeType)('BlockStatement'),
              },
              handler: {
                optional: true,
                handler: (0, _index2.assertNodeType)('BlockStatement'),
              },
              finalizer: {
                optional: true,
                validate: (0, _index2.assertNodeType)('BlockStatement'),
              },
            },
          })
          ;(0, _index3.default)('UnaryExpression', {
            builder: ['operator', 'argument', 'prefix'],
            fields: {
              prefix: {
                default: true,
              },
              argument: {
                validate: (0, _index2.assertNodeType)('Expression'),
              },
              operator: {
                validate: _index2.assertOneOf.apply(
                  undefined,
                  _constants.UNARY_OPERATORS
                ),
              },
            },
            visitor: ['argument'],
            aliases: ['UnaryLike', 'Expression'],
          })
          ;(0, _index3.default)('UpdateExpression', {
            builder: ['operator', 'argument', 'prefix'],
            fields: {
              prefix: {
                default: false,
              },
              argument: {
                validate: (0, _index2.assertNodeType)('Expression'),
              },
              operator: {
                validate: _index2.assertOneOf.apply(
                  undefined,
                  _constants.UPDATE_OPERATORS
                ),
              },
            },
            visitor: ['argument'],
            aliases: ['Expression'],
          })
          ;(0, _index3.default)('VariableDeclaration', {
            builder: ['kind', 'declarations'],
            visitor: ['declarations'],
            aliases: ['Statement', 'Declaration'],
            fields: {
              kind: {
                validate: (0, _index2.chain)(
                  (0, _index2.assertValueType)('string'),
                  (0, _index2.assertOneOf)('var', 'let', 'const')
                ),
              },
              declarations: {
                validate: (0, _index2.chain)(
                  (0, _index2.assertValueType)('array'),
                  (0, _index2.assertEach)(
                    (0, _index2.assertNodeType)('VariableDeclarator')
                  )
                ),
              },
            },
          })
          ;(0, _index3.default)('VariableDeclarator', {
            visitor: ['id', 'init'],
            fields: {
              id: {
                validate: (0, _index2.assertNodeType)('LVal'),
              },
              init: {
                optional: true,
                validate: (0, _index2.assertNodeType)('Expression'),
              },
            },
          })
          ;(0, _index3.default)('WhileStatement', {
            visitor: ['test', 'body'],
            aliases: ['Statement', 'BlockParent', 'Loop', 'While', 'Scopable'],
            fields: {
              test: {
                validate: (0, _index2.assertNodeType)('Expression'),
              },
              body: {
                validate: (0, _index2.assertNodeType)(
                  'BlockStatement',
                  'Statement'
                ),
              },
            },
          })
          ;(0, _index3.default)('WithStatement', {
            visitor: ['object', 'body'],
            aliases: ['Statement'],
            fields: {
              object: {
                object: (0, _index2.assertNodeType)('Expression'),
              },
              body: {
                validate: (0, _index2.assertNodeType)(
                  'BlockStatement',
                  'Statement'
                ),
              },
            },
          })
        },
        { '../constants': 99, '../index': 110, './index': 105 },
      ],
      102: [
        function(require, module, exports) {
          'use strict'
          var _index = require('./index')

          var _index2 = _interopRequireDefault(_index)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          ;(0, _index2.default)('AssignmentPattern', {
            visitor: ['left', 'right'],
            aliases: ['Pattern', 'LVal'],
            fields: {
              left: {
                validate: (0, _index.assertNodeType)('Identifier'),
              },
              right: {
                validate: (0, _index.assertNodeType)('Expression'),
              },
              decorators: {
                validate: (0, _index.chain)(
                  (0, _index.assertValueType)('array'),
                  (0, _index.assertEach)(
                    (0, _index.assertNodeType)('Decorator')
                  )
                ),
              },
            },
          })
          ;(0, _index2.default)('ArrayPattern', {
            visitor: ['elements', 'typeAnnotation'],
            aliases: ['Pattern', 'LVal'],
            fields: {
              elements: {
                validate: (0, _index.chain)(
                  (0, _index.assertValueType)('array'),
                  (0, _index.assertEach)(
                    (0, _index.assertNodeType)('Expression')
                  )
                ),
              },
              decorators: {
                validate: (0, _index.chain)(
                  (0, _index.assertValueType)('array'),
                  (0, _index.assertEach)(
                    (0, _index.assertNodeType)('Decorator')
                  )
                ),
              },
            },
          })
          ;(0, _index2.default)('ArrowFunctionExpression', {
            builder: ['params', 'body', 'async'],
            visitor: ['params', 'body', 'returnType', 'typeParameters'],
            aliases: [
              'Scopable',
              'Function',
              'BlockParent',
              'FunctionParent',
              'Expression',
              'Pureish',
            ],
            fields: {
              params: {
                validate: (0, _index.chain)(
                  (0, _index.assertValueType)('array'),
                  (0, _index.assertEach)((0, _index.assertNodeType)('LVal'))
                ),
              },
              body: {
                validate: (0, _index.assertNodeType)(
                  'BlockStatement',
                  'Expression'
                ),
              },
              async: {
                validate: (0, _index.assertValueType)('boolean'),
                default: false,
              },
            },
          })
          ;(0, _index2.default)('ClassBody', {
            visitor: ['body'],
            fields: {
              body: {
                validate: (0, _index.chain)(
                  (0, _index.assertValueType)('array'),
                  (0, _index.assertEach)(
                    (0, _index.assertNodeType)('ClassMethod', 'ClassProperty')
                  )
                ),
              },
            },
          })
          ;(0, _index2.default)('ClassDeclaration', {
            builder: ['id', 'superClass', 'body', 'decorators'],
            visitor: [
              'id',
              'body',
              'superClass',
              'mixins',
              'typeParameters',
              'superTypeParameters',
              'implements',
              'decorators',
            ],
            aliases: [
              'Scopable',
              'Class',
              'Statement',
              'Declaration',
              'Pureish',
            ],
            fields: {
              id: {
                validate: (0, _index.assertNodeType)('Identifier'),
              },
              body: {
                validate: (0, _index.assertNodeType)('ClassBody'),
              },
              superClass: {
                optional: true,
                validate: (0, _index.assertNodeType)('Expression'),
              },
              decorators: {
                validate: (0, _index.chain)(
                  (0, _index.assertValueType)('array'),
                  (0, _index.assertEach)(
                    (0, _index.assertNodeType)('Decorator')
                  )
                ),
              },
            },
          })
          ;(0, _index2.default)('ClassExpression', {
            inherits: 'ClassDeclaration',
            aliases: ['Scopable', 'Class', 'Expression', 'Pureish'],
            fields: {
              id: {
                optional: true,
                validate: (0, _index.assertNodeType)('Identifier'),
              },
              body: {
                validate: (0, _index.assertNodeType)('ClassBody'),
              },
              superClass: {
                optional: true,
                validate: (0, _index.assertNodeType)('Expression'),
              },
              decorators: {
                validate: (0, _index.chain)(
                  (0, _index.assertValueType)('array'),
                  (0, _index.assertEach)(
                    (0, _index.assertNodeType)('Decorator')
                  )
                ),
              },
            },
          })
          ;(0, _index2.default)('ExportAllDeclaration', {
            visitor: ['source'],
            aliases: [
              'Statement',
              'Declaration',
              'ModuleDeclaration',
              'ExportDeclaration',
            ],
            fields: {
              source: {
                validate: (0, _index.assertNodeType)('StringLiteral'),
              },
            },
          })
          ;(0, _index2.default)('ExportDefaultDeclaration', {
            visitor: ['declaration'],
            aliases: [
              'Statement',
              'Declaration',
              'ModuleDeclaration',
              'ExportDeclaration',
            ],
            fields: {
              declaration: {
                validate: (0, _index.assertNodeType)(
                  'FunctionDeclaration',
                  'ClassDeclaration',
                  'Expression'
                ),
              },
            },
          })
          ;(0, _index2.default)('ExportNamedDeclaration', {
            visitor: ['declaration', 'specifiers', 'source'],
            aliases: [
              'Statement',
              'Declaration',
              'ModuleDeclaration',
              'ExportDeclaration',
            ],
            fields: {
              declaration: {
                validate: (0, _index.assertNodeType)('Declaration'),
                optional: true,
              },
              specifiers: {
                validate: (0, _index.chain)(
                  (0, _index.assertValueType)('array'),
                  (0, _index.assertEach)(
                    (0, _index.assertNodeType)('ExportSpecifier')
                  )
                ),
              },
              source: {
                validate: (0, _index.assertNodeType)('StringLiteral'),
                optional: true,
              },
            },
          })
          ;(0, _index2.default)('ExportSpecifier', {
            visitor: ['local', 'exported'],
            aliases: ['ModuleSpecifier'],
            fields: {
              local: {
                validate: (0, _index.assertNodeType)('Identifier'),
              },
              exported: {
                validate: (0, _index.assertNodeType)('Identifier'),
              },
            },
          })
          ;(0, _index2.default)('ForOfStatement', {
            visitor: ['left', 'right', 'body'],
            aliases: [
              'Scopable',
              'Statement',
              'For',
              'BlockParent',
              'Loop',
              'ForXStatement',
            ],
            fields: {
              left: {
                validate: (0, _index.assertNodeType)(
                  'VariableDeclaration',
                  'LVal'
                ),
              },
              right: {
                validate: (0, _index.assertNodeType)('Expression'),
              },
              body: {
                validate: (0, _index.assertNodeType)('Statement'),
              },
            },
          })
          ;(0, _index2.default)('ImportDeclaration', {
            visitor: ['specifiers', 'source'],
            aliases: ['Statement', 'Declaration', 'ModuleDeclaration'],
            fields: {
              specifiers: {
                validate: (0, _index.chain)(
                  (0, _index.assertValueType)('array'),
                  (0, _index.assertEach)(
                    (0, _index.assertNodeType)(
                      'ImportSpecifier',
                      'ImportDefaultSpecifier',
                      'ImportNamespaceSpecifier'
                    )
                  )
                ),
              },
              source: {
                validate: (0, _index.assertNodeType)('StringLiteral'),
              },
            },
          })
          ;(0, _index2.default)('ImportDefaultSpecifier', {
            visitor: ['local'],
            aliases: ['ModuleSpecifier'],
            fields: {
              local: {
                validate: (0, _index.assertNodeType)('Identifier'),
              },
            },
          })
          ;(0, _index2.default)('ImportNamespaceSpecifier', {
            visitor: ['local'],
            aliases: ['ModuleSpecifier'],
            fields: {
              local: {
                validate: (0, _index.assertNodeType)('Identifier'),
              },
            },
          })
          ;(0, _index2.default)('ImportSpecifier', {
            visitor: ['local', 'imported'],
            aliases: ['ModuleSpecifier'],
            fields: {
              local: {
                validate: (0, _index.assertNodeType)('Identifier'),
              },
              imported: {
                validate: (0, _index.assertNodeType)('Identifier'),
              },
              importKind: {
                validate: (0, _index.assertOneOf)(null, 'type', 'typeof'),
              },
            },
          })
          ;(0, _index2.default)('MetaProperty', {
            visitor: ['meta', 'property'],
            aliases: ['Expression'],
            fields: {
              meta: {
                validate: (0, _index.assertValueType)('string'),
              },
              property: {
                validate: (0, _index.assertValueType)('string'),
              },
            },
          })
          ;(0, _index2.default)('ClassMethod', {
            aliases: [
              'Function',
              'Scopable',
              'BlockParent',
              'FunctionParent',
              'Method',
            ],
            builder: ['kind', 'key', 'params', 'body', 'computed', 'static'],
            visitor: [
              'key',
              'params',
              'body',
              'decorators',
              'returnType',
              'typeParameters',
            ],
            fields: {
              kind: {
                validate: (0, _index.chain)(
                  (0, _index.assertValueType)('string'),
                  (0, _index.assertOneOf)('get', 'set', 'method', 'constructor')
                ),
                default: 'method',
              },
              computed: {
                default: false,
                validate: (0, _index.assertValueType)('boolean'),
              },
              static: {
                default: false,
                validate: (0, _index.assertValueType)('boolean'),
              },
              key: {
                validate: function validate(node, key, val) {
                  var expectedTypes = node.computed
                    ? ['Expression']
                    : ['Identifier', 'StringLiteral', 'NumericLiteral']
                  _index.assertNodeType.apply(undefined, expectedTypes)(
                    node,
                    key,
                    val
                  )
                },
              },
              params: {
                validate: (0, _index.chain)(
                  (0, _index.assertValueType)('array'),
                  (0, _index.assertEach)((0, _index.assertNodeType)('LVal'))
                ),
              },
              body: {
                validate: (0, _index.assertNodeType)('BlockStatement'),
              },
              generator: {
                default: false,
                validate: (0, _index.assertValueType)('boolean'),
              },
              async: {
                default: false,
                validate: (0, _index.assertValueType)('boolean'),
              },
            },
          })
          ;(0, _index2.default)('ObjectPattern', {
            visitor: ['properties', 'typeAnnotation'],
            aliases: ['Pattern', 'LVal'],
            fields: {
              properties: {
                validate: (0, _index.chain)(
                  (0, _index.assertValueType)('array'),
                  (0, _index.assertEach)(
                    (0, _index.assertNodeType)('RestProperty', 'Property')
                  )
                ),
              },
              decorators: {
                validate: (0, _index.chain)(
                  (0, _index.assertValueType)('array'),
                  (0, _index.assertEach)(
                    (0, _index.assertNodeType)('Decorator')
                  )
                ),
              },
            },
          })
          ;(0, _index2.default)('SpreadElement', {
            visitor: ['argument'],
            aliases: ['UnaryLike'],
            fields: {
              argument: {
                validate: (0, _index.assertNodeType)('Expression'),
              },
            },
          })
          ;(0, _index2.default)('Super', {
            aliases: ['Expression'],
          })
          ;(0, _index2.default)('TaggedTemplateExpression', {
            visitor: ['tag', 'quasi'],
            aliases: ['Expression'],
            fields: {
              tag: {
                validate: (0, _index.assertNodeType)('Expression'),
              },
              quasi: {
                validate: (0, _index.assertNodeType)('TemplateLiteral'),
              },
            },
          })
          ;(0, _index2.default)('TemplateElement', {
            builder: ['value', 'tail'],
            fields: {
              value: {},
              tail: {
                validate: (0, _index.assertValueType)('boolean'),
                default: false,
              },
            },
          })
          ;(0, _index2.default)('TemplateLiteral', {
            visitor: ['quasis', 'expressions'],
            aliases: ['Expression', 'Literal'],
            fields: {
              quasis: {
                validate: (0, _index.chain)(
                  (0, _index.assertValueType)('array'),
                  (0, _index.assertEach)(
                    (0, _index.assertNodeType)('TemplateElement')
                  )
                ),
              },
              expressions: {
                validate: (0, _index.chain)(
                  (0, _index.assertValueType)('array'),
                  (0, _index.assertEach)(
                    (0, _index.assertNodeType)('Expression')
                  )
                ),
              },
            },
          })
          ;(0, _index2.default)('YieldExpression', {
            builder: ['argument', 'delegate'],
            visitor: ['argument'],
            aliases: ['Expression', 'Terminatorless'],
            fields: {
              delegate: {
                validate: (0, _index.assertValueType)('boolean'),
                default: false,
              },
              argument: {
                optional: true,
                validate: (0, _index.assertNodeType)('Expression'),
              },
            },
          })
        },
        { './index': 105 },
      ],
      103: [
        function(require, module, exports) {
          'use strict'
          var _index = require('./index')

          var _index2 = _interopRequireDefault(_index)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          ;(0, _index2.default)('AwaitExpression', {
            builder: ['argument'],
            visitor: ['argument'],
            aliases: ['Expression', 'Terminatorless'],
            fields: {
              argument: {
                validate: (0, _index.assertNodeType)('Expression'),
              },
            },
          })
          ;(0, _index2.default)('ForAwaitStatement', {
            visitor: ['left', 'right', 'body'],
            aliases: [
              'Scopable',
              'Statement',
              'For',
              'BlockParent',
              'Loop',
              'ForXStatement',
            ],
            fields: {
              left: {
                validate: (0, _index.assertNodeType)(
                  'VariableDeclaration',
                  'LVal'
                ),
              },
              right: {
                validate: (0, _index.assertNodeType)('Expression'),
              },
              body: {
                validate: (0, _index.assertNodeType)('Statement'),
              },
            },
          })
          ;(0, _index2.default)('BindExpression', {
            visitor: ['object', 'callee'],
            aliases: ['Expression'],
            fields: {},
          })
          ;(0, _index2.default)('Import', {
            aliases: ['Expression'],
          })
          ;(0, _index2.default)('Decorator', {
            visitor: ['expression'],
            fields: {
              expression: {
                validate: (0, _index.assertNodeType)('Expression'),
              },
            },
          })
          ;(0, _index2.default)('DoExpression', {
            visitor: ['body'],
            aliases: ['Expression'],
            fields: {
              body: {
                validate: (0, _index.assertNodeType)('BlockStatement'),
              },
            },
          })
          ;(0, _index2.default)('ExportDefaultSpecifier', {
            visitor: ['exported'],
            aliases: ['ModuleSpecifier'],
            fields: {
              exported: {
                validate: (0, _index.assertNodeType)('Identifier'),
              },
            },
          })
          ;(0, _index2.default)('ExportNamespaceSpecifier', {
            visitor: ['exported'],
            aliases: ['ModuleSpecifier'],
            fields: {
              exported: {
                validate: (0, _index.assertNodeType)('Identifier'),
              },
            },
          })
          ;(0, _index2.default)('RestProperty', {
            visitor: ['argument'],
            aliases: ['UnaryLike'],
            fields: {
              argument: {
                validate: (0, _index.assertNodeType)('LVal'),
              },
            },
          })
          ;(0, _index2.default)('SpreadProperty', {
            visitor: ['argument'],
            aliases: ['UnaryLike'],
            fields: {
              argument: {
                validate: (0, _index.assertNodeType)('Expression'),
              },
            },
          })
        },
        { './index': 105 },
      ],
      104: [
        function(require, module, exports) {
          'use strict'
          var _index = require('./index')

          var _index2 = _interopRequireDefault(_index)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          ;(0, _index2.default)('AnyTypeAnnotation', {
            aliases: ['Flow', 'FlowBaseAnnotation'],
            fields: {},
          })
          ;(0, _index2.default)('ArrayTypeAnnotation', {
            visitor: ['elementType'],
            aliases: ['Flow'],
            fields: {},
          })
          ;(0, _index2.default)('BooleanTypeAnnotation', {
            aliases: ['Flow', 'FlowBaseAnnotation'],
            fields: {},
          })
          ;(0, _index2.default)('BooleanLiteralTypeAnnotation', {
            aliases: ['Flow'],
            fields: {},
          })
          ;(0, _index2.default)('NullLiteralTypeAnnotation', {
            aliases: ['Flow', 'FlowBaseAnnotation'],
            fields: {},
          })
          ;(0, _index2.default)('ClassImplements', {
            visitor: ['id', 'typeParameters'],
            aliases: ['Flow'],
            fields: {},
          })
          ;(0, _index2.default)('ClassProperty', {
            visitor: ['key', 'value', 'typeAnnotation', 'decorators'],
            builder: [
              'key',
              'value',
              'typeAnnotation',
              'decorators',
              'computed',
            ],
            aliases: ['Property'],
            fields: {
              computed: {
                validate: (0, _index.assertValueType)('boolean'),
                default: false,
              },
            },
          })
          ;(0, _index2.default)('DeclareClass', {
            visitor: ['id', 'typeParameters', 'extends', 'body'],
            aliases: ['Flow', 'FlowDeclaration', 'Statement', 'Declaration'],
            fields: {},
          })
          ;(0, _index2.default)('DeclareFunction', {
            visitor: ['id'],
            aliases: ['Flow', 'FlowDeclaration', 'Statement', 'Declaration'],
            fields: {},
          })
          ;(0, _index2.default)('DeclareInterface', {
            visitor: ['id', 'typeParameters', 'extends', 'body'],
            aliases: ['Flow', 'FlowDeclaration', 'Statement', 'Declaration'],
            fields: {},
          })
          ;(0, _index2.default)('DeclareModule', {
            visitor: ['id', 'body'],
            aliases: ['Flow', 'FlowDeclaration', 'Statement', 'Declaration'],
            fields: {},
          })
          ;(0, _index2.default)('DeclareModuleExports', {
            visitor: ['typeAnnotation'],
            aliases: ['Flow', 'FlowDeclaration', 'Statement', 'Declaration'],
            fields: {},
          })
          ;(0, _index2.default)('DeclareTypeAlias', {
            visitor: ['id', 'typeParameters', 'right'],
            aliases: ['Flow', 'FlowDeclaration', 'Statement', 'Declaration'],
            fields: {},
          })
          ;(0, _index2.default)('DeclareVariable', {
            visitor: ['id'],
            aliases: ['Flow', 'FlowDeclaration', 'Statement', 'Declaration'],
            fields: {},
          })
          ;(0, _index2.default)('ExistentialTypeParam', {
            aliases: ['Flow'],
          })
          ;(0, _index2.default)('FunctionTypeAnnotation', {
            visitor: ['typeParameters', 'params', 'rest', 'returnType'],
            aliases: ['Flow'],
            fields: {},
          })
          ;(0, _index2.default)('FunctionTypeParam', {
            visitor: ['name', 'typeAnnotation'],
            aliases: ['Flow'],
            fields: {},
          })
          ;(0, _index2.default)('GenericTypeAnnotation', {
            visitor: ['id', 'typeParameters'],
            aliases: ['Flow'],
            fields: {},
          })
          ;(0, _index2.default)('InterfaceExtends', {
            visitor: ['id', 'typeParameters'],
            aliases: ['Flow'],
            fields: {},
          })
          ;(0, _index2.default)('InterfaceDeclaration', {
            visitor: ['id', 'typeParameters', 'extends', 'body'],
            aliases: ['Flow', 'FlowDeclaration', 'Statement', 'Declaration'],
            fields: {},
          })
          ;(0, _index2.default)('IntersectionTypeAnnotation', {
            visitor: ['types'],
            aliases: ['Flow'],
            fields: {},
          })
          ;(0, _index2.default)('MixedTypeAnnotation', {
            aliases: ['Flow', 'FlowBaseAnnotation'],
          })
          ;(0, _index2.default)('EmptyTypeAnnotation', {
            aliases: ['Flow', 'FlowBaseAnnotation'],
          })
          ;(0, _index2.default)('NullableTypeAnnotation', {
            visitor: ['typeAnnotation'],
            aliases: ['Flow'],
            fields: {},
          })
          ;(0, _index2.default)('NumericLiteralTypeAnnotation', {
            aliases: ['Flow'],
            fields: {},
          })
          ;(0, _index2.default)('NumberTypeAnnotation', {
            aliases: ['Flow', 'FlowBaseAnnotation'],
            fields: {},
          })
          ;(0, _index2.default)('StringLiteralTypeAnnotation', {
            aliases: ['Flow'],
            fields: {},
          })
          ;(0, _index2.default)('StringTypeAnnotation', {
            aliases: ['Flow', 'FlowBaseAnnotation'],
            fields: {},
          })
          ;(0, _index2.default)('ThisTypeAnnotation', {
            aliases: ['Flow', 'FlowBaseAnnotation'],
            fields: {},
          })
          ;(0, _index2.default)('TupleTypeAnnotation', {
            visitor: ['types'],
            aliases: ['Flow'],
            fields: {},
          })
          ;(0, _index2.default)('TypeofTypeAnnotation', {
            visitor: ['argument'],
            aliases: ['Flow'],
            fields: {},
          })
          ;(0, _index2.default)('TypeAlias', {
            visitor: ['id', 'typeParameters', 'right'],
            aliases: ['Flow', 'FlowDeclaration', 'Statement', 'Declaration'],
            fields: {},
          })
          ;(0, _index2.default)('TypeAnnotation', {
            visitor: ['typeAnnotation'],
            aliases: ['Flow'],
            fields: {},
          })
          ;(0, _index2.default)('TypeCastExpression', {
            visitor: ['expression', 'typeAnnotation'],
            aliases: ['Flow', 'ExpressionWrapper', 'Expression'],
            fields: {},
          })
          ;(0, _index2.default)('TypeParameter', {
            visitor: ['bound'],
            aliases: ['Flow'],
            fields: {},
          })
          ;(0, _index2.default)('TypeParameterDeclaration', {
            visitor: ['params'],
            aliases: ['Flow'],
            fields: {},
          })
          ;(0, _index2.default)('TypeParameterInstantiation', {
            visitor: ['params'],
            aliases: ['Flow'],
            fields: {},
          })
          ;(0, _index2.default)('ObjectTypeAnnotation', {
            visitor: ['properties', 'indexers', 'callProperties'],
            aliases: ['Flow'],
            fields: {},
          })
          ;(0, _index2.default)('ObjectTypeCallProperty', {
            visitor: ['value'],
            aliases: ['Flow', 'UserWhitespacable'],
            fields: {},
          })
          ;(0, _index2.default)('ObjectTypeIndexer', {
            visitor: ['id', 'key', 'value'],
            aliases: ['Flow', 'UserWhitespacable'],
            fields: {},
          })
          ;(0, _index2.default)('ObjectTypeProperty', {
            visitor: ['key', 'value'],
            aliases: ['Flow', 'UserWhitespacable'],
            fields: {},
          })
          ;(0, _index2.default)('QualifiedTypeIdentifier', {
            visitor: ['id', 'qualification'],
            aliases: ['Flow'],
            fields: {},
          })
          ;(0, _index2.default)('UnionTypeAnnotation', {
            visitor: ['types'],
            aliases: ['Flow'],
            fields: {},
          })
          ;(0, _index2.default)('VoidTypeAnnotation', {
            aliases: ['Flow', 'FlowBaseAnnotation'],
            fields: {},
          })
        },
        { './index': 105 },
      ],
      105: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true
          exports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.NODE_FIELDS = exports.ALIAS_KEYS = exports.VISITOR_KEYS = undefined

          var _getIterator2 = require('babel-runtime/core-js/get-iterator')

          var _getIterator3 = _interopRequireDefault(_getIterator2)

          var _stringify = require('babel-runtime/core-js/json/stringify')

          var _stringify2 = _interopRequireDefault(_stringify)

          var _typeof2 = require('babel-runtime/helpers/typeof')

          var _typeof3 = _interopRequireDefault(_typeof2)

          exports.assertEach = assertEach
          exports.assertOneOf = assertOneOf
          exports.assertNodeType = assertNodeType
          exports.assertNodeOrValueType = assertNodeOrValueType
          exports.assertValueType = assertValueType
          exports.chain = chain
          exports.default = defineType

          var _index = require('../index')

          var t = _interopRequireWildcard(_index)

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj
            } else {
              var newObj = {}
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key]
                }
              }
              newObj.default = obj
              return newObj
            }
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          var VISITOR_KEYS = (exports.VISITOR_KEYS = {})
          var ALIAS_KEYS = (exports.ALIAS_KEYS = {})
          var NODE_FIELDS = (exports.NODE_FIELDS = {})
          var BUILDER_KEYS = (exports.BUILDER_KEYS = {})
          var DEPRECATED_KEYS = (exports.DEPRECATED_KEYS = {})

          function getType(val) {
            if (Array.isArray(val)) {
              return 'array'
            } else if (val === null) {
              return 'null'
            } else if (val === undefined) {
              return 'undefined'
            } else {
              return typeof val === 'undefined'
                ? 'undefined'
                : (0, _typeof3.default)(val)
            }
          }

          function assertEach(callback) {
            function validator(node, key, val) {
              if (!Array.isArray(val)) return

              for (var i = 0; i < val.length; i++) {
                callback(node, key + '[' + i + ']', val[i])
              }
            }
            validator.each = callback
            return validator
          }

          function assertOneOf() {
            for (
              var _len = arguments.length, vals = Array(_len), _key = 0;
              _key < _len;
              _key++
            ) {
              vals[_key] = arguments[_key]
            }

            function validate(node, key, val) {
              if (vals.indexOf(val) < 0) {
                throw new TypeError(
                  'Property ' +
                    key +
                    ' expected value to be one of ' +
                    (0, _stringify2.default)(vals) +
                    ' but got ' +
                    (0, _stringify2.default)(val)
                )
              }
            }

            validate.oneOf = vals

            return validate
          }

          function assertNodeType() {
            for (
              var _len2 = arguments.length, types = Array(_len2), _key2 = 0;
              _key2 < _len2;
              _key2++
            ) {
              types[_key2] = arguments[_key2]
            }

            function validate(node, key, val) {
              var valid = false

              for (
                var _iterator = types,
                  _isArray = Array.isArray(_iterator),
                  _i = 0,
                  _iterator = _isArray
                    ? _iterator
                    : (0, _getIterator3.default)(_iterator);
                ;

              ) {
                var _ref

                if (_isArray) {
                  if (_i >= _iterator.length) break
                  _ref = _iterator[_i++]
                } else {
                  _i = _iterator.next()
                  if (_i.done) break
                  _ref = _i.value
                }

                var type = _ref

                if (t.is(type, val)) {
                  valid = true
                  break
                }
              }

              if (!valid) {
                throw new TypeError(
                  'Property ' +
                    key +
                    ' of ' +
                    node.type +
                    ' expected node to be of a type ' +
                    (0, _stringify2.default)(types) +
                    ' ' +
                    ('but instead got ' +
                      (0, _stringify2.default)(val && val.type))
                )
              }
            }

            validate.oneOfNodeTypes = types

            return validate
          }

          function assertNodeOrValueType() {
            for (
              var _len3 = arguments.length, types = Array(_len3), _key3 = 0;
              _key3 < _len3;
              _key3++
            ) {
              types[_key3] = arguments[_key3]
            }

            function validate(node, key, val) {
              var valid = false

              for (
                var _iterator2 = types,
                  _isArray2 = Array.isArray(_iterator2),
                  _i2 = 0,
                  _iterator2 = _isArray2
                    ? _iterator2
                    : (0, _getIterator3.default)(_iterator2);
                ;

              ) {
                var _ref2

                if (_isArray2) {
                  if (_i2 >= _iterator2.length) break
                  _ref2 = _iterator2[_i2++]
                } else {
                  _i2 = _iterator2.next()
                  if (_i2.done) break
                  _ref2 = _i2.value
                }

                var type = _ref2

                if (getType(val) === type || t.is(type, val)) {
                  valid = true
                  break
                }
              }

              if (!valid) {
                throw new TypeError(
                  'Property ' +
                    key +
                    ' of ' +
                    node.type +
                    ' expected node to be of a type ' +
                    (0, _stringify2.default)(types) +
                    ' ' +
                    ('but instead got ' +
                      (0, _stringify2.default)(val && val.type))
                )
              }
            }

            validate.oneOfNodeOrValueTypes = types

            return validate
          }

          function assertValueType(type) {
            function validate(node, key, val) {
              var valid = getType(val) === type

              if (!valid) {
                throw new TypeError(
                  'Property ' +
                    key +
                    ' expected type of ' +
                    type +
                    ' but got ' +
                    getType(val)
                )
              }
            }

            validate.type = type

            return validate
          }

          function chain() {
            for (
              var _len4 = arguments.length, fns = Array(_len4), _key4 = 0;
              _key4 < _len4;
              _key4++
            ) {
              fns[_key4] = arguments[_key4]
            }

            function validate() {
              for (
                var _iterator3 = fns,
                  _isArray3 = Array.isArray(_iterator3),
                  _i3 = 0,
                  _iterator3 = _isArray3
                    ? _iterator3
                    : (0, _getIterator3.default)(_iterator3);
                ;

              ) {
                var _ref3

                if (_isArray3) {
                  if (_i3 >= _iterator3.length) break
                  _ref3 = _iterator3[_i3++]
                } else {
                  _i3 = _iterator3.next()
                  if (_i3.done) break
                  _ref3 = _i3.value
                }

                var fn = _ref3

                fn.apply(undefined, arguments)
              }
            }
            validate.chainOf = fns
            return validate
          }

          function defineType(type) {
            var opts = arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : {}

            var inherits = (opts.inherits && store[opts.inherits]) || {}

            opts.fields = opts.fields || inherits.fields || {}
            opts.visitor = opts.visitor || inherits.visitor || []
            opts.aliases = opts.aliases || inherits.aliases || []
            opts.builder =
              opts.builder || inherits.builder || opts.visitor || []

            if (opts.deprecatedAlias) {
              DEPRECATED_KEYS[opts.deprecatedAlias] = type
            }

            for (
              var _iterator4 = opts.visitor.concat(opts.builder),
                _isArray4 = Array.isArray(_iterator4),
                _i4 = 0,
                _iterator4 = _isArray4
                  ? _iterator4
                  : (0, _getIterator3.default)(_iterator4);
              ;

            ) {
              var _ref4

              if (_isArray4) {
                if (_i4 >= _iterator4.length) break
                _ref4 = _iterator4[_i4++]
              } else {
                _i4 = _iterator4.next()
                if (_i4.done) break
                _ref4 = _i4.value
              }

              var _key5 = _ref4

              opts.fields[_key5] = opts.fields[_key5] || {}
            }

            for (var key in opts.fields) {
              var field = opts.fields[key]

              if (opts.builder.indexOf(key) === -1) {
                field.optional = true
              }
              if (field.default === undefined) {
                field.default = null
              } else if (!field.validate) {
                field.validate = assertValueType(getType(field.default))
              }
            }

            VISITOR_KEYS[type] = opts.visitor
            BUILDER_KEYS[type] = opts.builder
            NODE_FIELDS[type] = opts.fields
            ALIAS_KEYS[type] = opts.aliases

            store[type] = opts
          }

          var store = {}
        },
        {
          '../index': 110,
          'babel-runtime/core-js/get-iterator': 54,
          'babel-runtime/core-js/json/stringify': 55,
          'babel-runtime/helpers/typeof': 72,
        },
      ],
      106: [
        function(require, module, exports) {
          'use strict'
          require('./index')

          require('./core')

          require('./es2015')

          require('./flow')

          require('./jsx')

          require('./misc')

          require('./experimental')
        },
        {
          './core': 101,
          './es2015': 102,
          './experimental': 103,
          './flow': 104,
          './index': 105,
          './jsx': 107,
          './misc': 108,
        },
      ],
      107: [
        function(require, module, exports) {
          'use strict'
          var _index = require('./index')

          var _index2 = _interopRequireDefault(_index)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          ;(0, _index2.default)('JSXAttribute', {
            visitor: ['name', 'value'],
            aliases: ['JSX', 'Immutable'],
            fields: {
              name: {
                validate: (0, _index.assertNodeType)(
                  'JSXIdentifier',
                  'JSXNamespacedName'
                ),
              },
              value: {
                optional: true,
                validate: (0, _index.assertNodeType)(
                  'JSXElement',
                  'StringLiteral',
                  'JSXExpressionContainer'
                ),
              },
            },
          })
          ;(0, _index2.default)('JSXClosingElement', {
            visitor: ['name'],
            aliases: ['JSX', 'Immutable'],
            fields: {
              name: {
                validate: (0, _index.assertNodeType)(
                  'JSXIdentifier',
                  'JSXMemberExpression'
                ),
              },
            },
          })
          ;(0, _index2.default)('JSXElement', {
            builder: [
              'openingElement',
              'closingElement',
              'children',
              'selfClosing',
            ],
            visitor: ['openingElement', 'children', 'closingElement'],
            aliases: ['JSX', 'Immutable', 'Expression'],
            fields: {
              openingElement: {
                validate: (0, _index.assertNodeType)('JSXOpeningElement'),
              },
              closingElement: {
                optional: true,
                validate: (0, _index.assertNodeType)('JSXClosingElement'),
              },
              children: {
                validate: (0, _index.chain)(
                  (0, _index.assertValueType)('array'),
                  (0, _index.assertEach)(
                    (0, _index.assertNodeType)(
                      'JSXText',
                      'JSXExpressionContainer',
                      'JSXSpreadChild',
                      'JSXElement'
                    )
                  )
                ),
              },
            },
          })
          ;(0, _index2.default)('JSXEmptyExpression', {
            aliases: ['JSX', 'Expression'],
          })
          ;(0, _index2.default)('JSXExpressionContainer', {
            visitor: ['expression'],
            aliases: ['JSX', 'Immutable'],
            fields: {
              expression: {
                validate: (0, _index.assertNodeType)('Expression'),
              },
            },
          })
          ;(0, _index2.default)('JSXSpreadChild', {
            visitor: ['expression'],
            aliases: ['JSX', 'Immutable'],
            fields: {
              expression: {
                validate: (0, _index.assertNodeType)('Expression'),
              },
            },
          })
          ;(0, _index2.default)('JSXIdentifier', {
            builder: ['name'],
            aliases: ['JSX', 'Expression'],
            fields: {
              name: {
                validate: (0, _index.assertValueType)('string'),
              },
            },
          })
          ;(0, _index2.default)('JSXMemberExpression', {
            visitor: ['object', 'property'],
            aliases: ['JSX', 'Expression'],
            fields: {
              object: {
                validate: (0, _index.assertNodeType)(
                  'JSXMemberExpression',
                  'JSXIdentifier'
                ),
              },
              property: {
                validate: (0, _index.assertNodeType)('JSXIdentifier'),
              },
            },
          })
          ;(0, _index2.default)('JSXNamespacedName', {
            visitor: ['namespace', 'name'],
            aliases: ['JSX'],
            fields: {
              namespace: {
                validate: (0, _index.assertNodeType)('JSXIdentifier'),
              },
              name: {
                validate: (0, _index.assertNodeType)('JSXIdentifier'),
              },
            },
          })
          ;(0, _index2.default)('JSXOpeningElement', {
            builder: ['name', 'attributes', 'selfClosing'],
            visitor: ['name', 'attributes'],
            aliases: ['JSX', 'Immutable'],
            fields: {
              name: {
                validate: (0, _index.assertNodeType)(
                  'JSXIdentifier',
                  'JSXMemberExpression'
                ),
              },
              selfClosing: {
                default: false,
                validate: (0, _index.assertValueType)('boolean'),
              },
              attributes: {
                validate: (0, _index.chain)(
                  (0, _index.assertValueType)('array'),
                  (0, _index.assertEach)(
                    (0, _index.assertNodeType)(
                      'JSXAttribute',
                      'JSXSpreadAttribute'
                    )
                  )
                ),
              },
            },
          })
          ;(0, _index2.default)('JSXSpreadAttribute', {
            visitor: ['argument'],
            aliases: ['JSX'],
            fields: {
              argument: {
                validate: (0, _index.assertNodeType)('Expression'),
              },
            },
          })
          ;(0, _index2.default)('JSXText', {
            aliases: ['JSX', 'Immutable'],
            builder: ['value'],
            fields: {
              value: {
                validate: (0, _index.assertValueType)('string'),
              },
            },
          })
        },
        { './index': 105 },
      ],
      108: [
        function(require, module, exports) {
          'use strict'
          var _index = require('./index')

          var _index2 = _interopRequireDefault(_index)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          ;(0, _index2.default)('Noop', {
            visitor: [],
          })
          ;(0, _index2.default)('ParenthesizedExpression', {
            visitor: ['expression'],
            aliases: ['Expression', 'ExpressionWrapper'],
            fields: {
              expression: {
                validate: (0, _index.assertNodeType)('Expression'),
              },
            },
          })
        },
        { './index': 105 },
      ],
      109: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true
          exports.createUnionTypeAnnotation = createUnionTypeAnnotation
          exports.removeTypeDuplicates = removeTypeDuplicates
          exports.createTypeAnnotationBasedOnTypeof = createTypeAnnotationBasedOnTypeof

          var _index = require('./index')

          var t = _interopRequireWildcard(_index)

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj
            } else {
              var newObj = {}
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key]
                }
              }
              newObj.default = obj
              return newObj
            }
          }

          function createUnionTypeAnnotation(types) {
            var flattened = removeTypeDuplicates(types)

            if (flattened.length === 1) {
              return flattened[0]
            } else {
              return t.unionTypeAnnotation(flattened)
            }
          }

          function removeTypeDuplicates(nodes) {
            var generics = {}
            var bases = {}

            var typeGroups = []

            var types = []

            for (var i = 0; i < nodes.length; i++) {
              var node = nodes[i]
              if (!node) continue

              if (types.indexOf(node) >= 0) {
                continue
              }

              if (t.isAnyTypeAnnotation(node)) {
                return [node]
              }

              if (t.isFlowBaseAnnotation(node)) {
                bases[node.type] = node
                continue
              }

              if (t.isUnionTypeAnnotation(node)) {
                if (typeGroups.indexOf(node.types) < 0) {
                  nodes = nodes.concat(node.types)
                  typeGroups.push(node.types)
                }
                continue
              }

              if (t.isGenericTypeAnnotation(node)) {
                var name = node.id.name

                if (generics[name]) {
                  var existing = generics[name]
                  if (existing.typeParameters) {
                    if (node.typeParameters) {
                      existing.typeParameters.params = removeTypeDuplicates(
                        existing.typeParameters.params.concat(
                          node.typeParameters.params
                        )
                      )
                    }
                  } else {
                    existing = node.typeParameters
                  }
                } else {
                  generics[name] = node
                }

                continue
              }

              types.push(node)
            }

            for (var type in bases) {
              types.push(bases[type])
            }

            for (var _name in generics) {
              types.push(generics[_name])
            }

            return types
          }

          function createTypeAnnotationBasedOnTypeof(type) {
            if (type === 'string') {
              return t.stringTypeAnnotation()
            } else if (type === 'number') {
              return t.numberTypeAnnotation()
            } else if (type === 'undefined') {
              return t.voidTypeAnnotation()
            } else if (type === 'boolean') {
              return t.booleanTypeAnnotation()
            } else if (type === 'function') {
              return t.genericTypeAnnotation(t.identifier('Function'))
            } else if (type === 'object') {
              return t.genericTypeAnnotation(t.identifier('Object'))
            } else if (type === 'symbol') {
              return t.genericTypeAnnotation(t.identifier('Symbol'))
            } else {
              throw new Error('Invalid typeof value')
            }
          }
        },
        { './index': 110 },
      ],
      110: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true
          exports.createTypeAnnotationBasedOnTypeof = exports.removeTypeDuplicates = exports.createUnionTypeAnnotation = exports.valueToNode = exports.toBlock = exports.toExpression = exports.toStatement = exports.toBindingIdentifierName = exports.toIdentifier = exports.toKeyAlias = exports.toSequenceExpression = exports.toComputedKey = exports.isNodesEquivalent = exports.isImmutable = exports.isScope = exports.isSpecifierDefault = exports.isVar = exports.isBlockScoped = exports.isLet = exports.isValidIdentifier = exports.isReferenced = exports.isBinding = exports.getOuterBindingIdentifiers = exports.getBindingIdentifiers = exports.TYPES = exports.react = exports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.NODE_FIELDS = exports.ALIAS_KEYS = exports.VISITOR_KEYS = exports.NOT_LOCAL_BINDING = exports.BLOCK_SCOPED_SYMBOL = exports.INHERIT_KEYS = exports.UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = exports.NUMBER_UNARY_OPERATORS = exports.BOOLEAN_UNARY_OPERATORS = exports.BINARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = exports.EQUALITY_BINARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = exports.UPDATE_OPERATORS = exports.LOGICAL_OPERATORS = exports.COMMENT_KEYS = exports.FOR_INIT_KEYS = exports.FLATTENABLE_KEYS = exports.STATEMENT_OR_BLOCK_KEYS = undefined

          var _getOwnPropertySymbols = require('babel-runtime/core-js/object/get-own-property-symbols')

          var _getOwnPropertySymbols2 = _interopRequireDefault(
            _getOwnPropertySymbols
          )

          var _getIterator2 = require('babel-runtime/core-js/get-iterator')

          var _getIterator3 = _interopRequireDefault(_getIterator2)

          var _keys = require('babel-runtime/core-js/object/keys')

          var _keys2 = _interopRequireDefault(_keys)

          var _stringify = require('babel-runtime/core-js/json/stringify')

          var _stringify2 = _interopRequireDefault(_stringify)

          var _constants = require('./constants')

          Object.defineProperty(exports, 'STATEMENT_OR_BLOCK_KEYS', {
            enumerable: true,
            get: function get() {
              return _constants.STATEMENT_OR_BLOCK_KEYS
            },
          })
          Object.defineProperty(exports, 'FLATTENABLE_KEYS', {
            enumerable: true,
            get: function get() {
              return _constants.FLATTENABLE_KEYS
            },
          })
          Object.defineProperty(exports, 'FOR_INIT_KEYS', {
            enumerable: true,
            get: function get() {
              return _constants.FOR_INIT_KEYS
            },
          })
          Object.defineProperty(exports, 'COMMENT_KEYS', {
            enumerable: true,
            get: function get() {
              return _constants.COMMENT_KEYS
            },
          })
          Object.defineProperty(exports, 'LOGICAL_OPERATORS', {
            enumerable: true,
            get: function get() {
              return _constants.LOGICAL_OPERATORS
            },
          })
          Object.defineProperty(exports, 'UPDATE_OPERATORS', {
            enumerable: true,
            get: function get() {
              return _constants.UPDATE_OPERATORS
            },
          })
          Object.defineProperty(exports, 'BOOLEAN_NUMBER_BINARY_OPERATORS', {
            enumerable: true,
            get: function get() {
              return _constants.BOOLEAN_NUMBER_BINARY_OPERATORS
            },
          })
          Object.defineProperty(exports, 'EQUALITY_BINARY_OPERATORS', {
            enumerable: true,
            get: function get() {
              return _constants.EQUALITY_BINARY_OPERATORS
            },
          })
          Object.defineProperty(exports, 'COMPARISON_BINARY_OPERATORS', {
            enumerable: true,
            get: function get() {
              return _constants.COMPARISON_BINARY_OPERATORS
            },
          })
          Object.defineProperty(exports, 'BOOLEAN_BINARY_OPERATORS', {
            enumerable: true,
            get: function get() {
              return _constants.BOOLEAN_BINARY_OPERATORS
            },
          })
          Object.defineProperty(exports, 'NUMBER_BINARY_OPERATORS', {
            enumerable: true,
            get: function get() {
              return _constants.NUMBER_BINARY_OPERATORS
            },
          })
          Object.defineProperty(exports, 'BINARY_OPERATORS', {
            enumerable: true,
            get: function get() {
              return _constants.BINARY_OPERATORS
            },
          })
          Object.defineProperty(exports, 'BOOLEAN_UNARY_OPERATORS', {
            enumerable: true,
            get: function get() {
              return _constants.BOOLEAN_UNARY_OPERATORS
            },
          })
          Object.defineProperty(exports, 'NUMBER_UNARY_OPERATORS', {
            enumerable: true,
            get: function get() {
              return _constants.NUMBER_UNARY_OPERATORS
            },
          })
          Object.defineProperty(exports, 'STRING_UNARY_OPERATORS', {
            enumerable: true,
            get: function get() {
              return _constants.STRING_UNARY_OPERATORS
            },
          })
          Object.defineProperty(exports, 'UNARY_OPERATORS', {
            enumerable: true,
            get: function get() {
              return _constants.UNARY_OPERATORS
            },
          })
          Object.defineProperty(exports, 'INHERIT_KEYS', {
            enumerable: true,
            get: function get() {
              return _constants.INHERIT_KEYS
            },
          })
          Object.defineProperty(exports, 'BLOCK_SCOPED_SYMBOL', {
            enumerable: true,
            get: function get() {
              return _constants.BLOCK_SCOPED_SYMBOL
            },
          })
          Object.defineProperty(exports, 'NOT_LOCAL_BINDING', {
            enumerable: true,
            get: function get() {
              return _constants.NOT_LOCAL_BINDING
            },
          })
          exports.is = is
          exports.isType = isType
          exports.validate = validate
          exports.shallowEqual = shallowEqual
          exports.appendToMemberExpression = appendToMemberExpression
          exports.prependToMemberExpression = prependToMemberExpression
          exports.ensureBlock = ensureBlock
          exports.clone = clone
          exports.cloneWithoutLoc = cloneWithoutLoc
          exports.cloneDeep = cloneDeep
          exports.buildMatchMemberExpression = buildMatchMemberExpression
          exports.removeComments = removeComments
          exports.inheritsComments = inheritsComments
          exports.inheritTrailingComments = inheritTrailingComments
          exports.inheritLeadingComments = inheritLeadingComments
          exports.inheritInnerComments = inheritInnerComments
          exports.inherits = inherits
          exports.assertNode = assertNode
          exports.isNode = isNode
          exports.traverseFast = traverseFast
          exports.removeProperties = removeProperties
          exports.removePropertiesDeep = removePropertiesDeep

          var _retrievers = require('./retrievers')

          Object.defineProperty(exports, 'getBindingIdentifiers', {
            enumerable: true,
            get: function get() {
              return _retrievers.getBindingIdentifiers
            },
          })
          Object.defineProperty(exports, 'getOuterBindingIdentifiers', {
            enumerable: true,
            get: function get() {
              return _retrievers.getOuterBindingIdentifiers
            },
          })

          var _validators = require('./validators')

          Object.defineProperty(exports, 'isBinding', {
            enumerable: true,
            get: function get() {
              return _validators.isBinding
            },
          })
          Object.defineProperty(exports, 'isReferenced', {
            enumerable: true,
            get: function get() {
              return _validators.isReferenced
            },
          })
          Object.defineProperty(exports, 'isValidIdentifier', {
            enumerable: true,
            get: function get() {
              return _validators.isValidIdentifier
            },
          })
          Object.defineProperty(exports, 'isLet', {
            enumerable: true,
            get: function get() {
              return _validators.isLet
            },
          })
          Object.defineProperty(exports, 'isBlockScoped', {
            enumerable: true,
            get: function get() {
              return _validators.isBlockScoped
            },
          })
          Object.defineProperty(exports, 'isVar', {
            enumerable: true,
            get: function get() {
              return _validators.isVar
            },
          })
          Object.defineProperty(exports, 'isSpecifierDefault', {
            enumerable: true,
            get: function get() {
              return _validators.isSpecifierDefault
            },
          })
          Object.defineProperty(exports, 'isScope', {
            enumerable: true,
            get: function get() {
              return _validators.isScope
            },
          })
          Object.defineProperty(exports, 'isImmutable', {
            enumerable: true,
            get: function get() {
              return _validators.isImmutable
            },
          })
          Object.defineProperty(exports, 'isNodesEquivalent', {
            enumerable: true,
            get: function get() {
              return _validators.isNodesEquivalent
            },
          })

          var _converters = require('./converters')

          Object.defineProperty(exports, 'toComputedKey', {
            enumerable: true,
            get: function get() {
              return _converters.toComputedKey
            },
          })
          Object.defineProperty(exports, 'toSequenceExpression', {
            enumerable: true,
            get: function get() {
              return _converters.toSequenceExpression
            },
          })
          Object.defineProperty(exports, 'toKeyAlias', {
            enumerable: true,
            get: function get() {
              return _converters.toKeyAlias
            },
          })
          Object.defineProperty(exports, 'toIdentifier', {
            enumerable: true,
            get: function get() {
              return _converters.toIdentifier
            },
          })
          Object.defineProperty(exports, 'toBindingIdentifierName', {
            enumerable: true,
            get: function get() {
              return _converters.toBindingIdentifierName
            },
          })
          Object.defineProperty(exports, 'toStatement', {
            enumerable: true,
            get: function get() {
              return _converters.toStatement
            },
          })
          Object.defineProperty(exports, 'toExpression', {
            enumerable: true,
            get: function get() {
              return _converters.toExpression
            },
          })
          Object.defineProperty(exports, 'toBlock', {
            enumerable: true,
            get: function get() {
              return _converters.toBlock
            },
          })
          Object.defineProperty(exports, 'valueToNode', {
            enumerable: true,
            get: function get() {
              return _converters.valueToNode
            },
          })

          var _flow = require('./flow')

          Object.defineProperty(exports, 'createUnionTypeAnnotation', {
            enumerable: true,
            get: function get() {
              return _flow.createUnionTypeAnnotation
            },
          })
          Object.defineProperty(exports, 'removeTypeDuplicates', {
            enumerable: true,
            get: function get() {
              return _flow.removeTypeDuplicates
            },
          })
          Object.defineProperty(exports, 'createTypeAnnotationBasedOnTypeof', {
            enumerable: true,
            get: function get() {
              return _flow.createTypeAnnotationBasedOnTypeof
            },
          })

          var _toFastProperties = require('to-fast-properties')

          var _toFastProperties2 = _interopRequireDefault(_toFastProperties)

          var _clone = require('lodash/clone')

          var _clone2 = _interopRequireDefault(_clone)

          var _uniq = require('lodash/uniq')

          var _uniq2 = _interopRequireDefault(_uniq)

          require('./definitions/init')

          var _definitions = require('./definitions')

          var _react2 = require('./react')

          var _react = _interopRequireWildcard(_react2)

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj
            } else {
              var newObj = {}
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key]
                }
              }
              newObj.default = obj
              return newObj
            }
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          var t = exports

          function registerType(type) {
            var is = t['is' + type]
            if (!is) {
              is = t['is' + type] = function(node, opts) {
                return t.is(type, node, opts)
              }
            }

            t['assert' + type] = function(node, opts) {
              opts = opts || {}
              if (!is(node, opts)) {
                throw new Error(
                  'Expected type ' +
                    (0, _stringify2.default)(type) +
                    ' with option ' +
                    (0, _stringify2.default)(opts)
                )
              }
            }
          }

          exports.VISITOR_KEYS = _definitions.VISITOR_KEYS
          exports.ALIAS_KEYS = _definitions.ALIAS_KEYS
          exports.NODE_FIELDS = _definitions.NODE_FIELDS
          exports.BUILDER_KEYS = _definitions.BUILDER_KEYS
          exports.DEPRECATED_KEYS = _definitions.DEPRECATED_KEYS
          exports.react = _react

          for (var type in t.VISITOR_KEYS) {
            registerType(type)
          }

          t.FLIPPED_ALIAS_KEYS = {}
          ;(0, _keys2.default)(t.ALIAS_KEYS).forEach(function(type) {
            t.ALIAS_KEYS[type].forEach(function(alias) {
              var types = (t.FLIPPED_ALIAS_KEYS[alias] =
                t.FLIPPED_ALIAS_KEYS[alias] || [])
              types.push(type)
            })
          })
          ;(0, _keys2.default)(t.FLIPPED_ALIAS_KEYS).forEach(function(type) {
            t[type.toUpperCase() + '_TYPES'] = t.FLIPPED_ALIAS_KEYS[type]
            registerType(type)
          })

          var TYPES = (exports.TYPES = (0, _keys2.default)(t.VISITOR_KEYS)
            .concat((0, _keys2.default)(t.FLIPPED_ALIAS_KEYS))
            .concat((0, _keys2.default)(t.DEPRECATED_KEYS)))

          function is(type, node, opts) {
            if (!node) return false

            var matches = isType(node.type, type)
            if (!matches) return false

            if (typeof opts === 'undefined') {
              return true
            } else {
              return t.shallowEqual(node, opts)
            }
          }

          function isType(nodeType, targetType) {
            if (nodeType === targetType) return true

            if (t.ALIAS_KEYS[targetType]) return false

            var aliases = t.FLIPPED_ALIAS_KEYS[targetType]
            if (aliases) {
              if (aliases[0] === nodeType) return true

              for (
                var _iterator = aliases,
                  _isArray = Array.isArray(_iterator),
                  _i = 0,
                  _iterator = _isArray
                    ? _iterator
                    : (0, _getIterator3.default)(_iterator);
                ;

              ) {
                var _ref

                if (_isArray) {
                  if (_i >= _iterator.length) break
                  _ref = _iterator[_i++]
                } else {
                  _i = _iterator.next()
                  if (_i.done) break
                  _ref = _i.value
                }

                var alias = _ref

                if (nodeType === alias) return true
              }
            }

            return false
          }

          ;(0, _keys2.default)(t.BUILDER_KEYS).forEach(function(type) {
            var keys = t.BUILDER_KEYS[type]

            function builder() {
              if (arguments.length > keys.length) {
                throw new Error(
                  't.' +
                    type +
                    ': Too many arguments passed. Received ' +
                    arguments.length +
                    ' but can receive ' +
                    ('no more than ' + keys.length)
                )
              }

              var node = {}
              node.type = type

              var i = 0

              for (
                var _iterator2 = keys,
                  _isArray2 = Array.isArray(_iterator2),
                  _i2 = 0,
                  _iterator2 = _isArray2
                    ? _iterator2
                    : (0, _getIterator3.default)(_iterator2);
                ;

              ) {
                var _ref2

                if (_isArray2) {
                  if (_i2 >= _iterator2.length) break
                  _ref2 = _iterator2[_i2++]
                } else {
                  _i2 = _iterator2.next()
                  if (_i2.done) break
                  _ref2 = _i2.value
                }

                var _key = _ref2

                var field = t.NODE_FIELDS[type][_key]

                var arg = arguments[i++]
                if (arg === undefined) arg = (0, _clone2.default)(field.default)

                node[_key] = arg
              }

              for (var key in node) {
                validate(node, key, node[key])
              }

              return node
            }

            t[type] = builder
            t[type[0].toLowerCase() + type.slice(1)] = builder
          })

          var _loop = function _loop(_type) {
            var newType = t.DEPRECATED_KEYS[_type]

            function proxy(fn) {
              return function() {
                console.trace(
                  'The node type ' + _type + ' has been renamed to ' + newType
                )
                return fn.apply(this, arguments)
              }
            }

            t[_type] = t[_type[0].toLowerCase() + _type.slice(1)] = proxy(
              t[newType]
            )
            t['is' + _type] = proxy(t['is' + newType])
            t['assert' + _type] = proxy(t['assert' + newType])
          }

          for (var _type in t.DEPRECATED_KEYS) {
            _loop(_type)
          }

          function validate(node, key, val) {
            if (!node) return

            var fields = t.NODE_FIELDS[node.type]
            if (!fields) return

            var field = fields[key]
            if (!field || !field.validate) return
            if (field.optional && val == null) return

            field.validate(node, key, val)
          }

          function shallowEqual(actual, expected) {
            var keys = (0, _keys2.default)(expected)

            for (
              var _iterator3 = keys,
                _isArray3 = Array.isArray(_iterator3),
                _i3 = 0,
                _iterator3 = _isArray3
                  ? _iterator3
                  : (0, _getIterator3.default)(_iterator3);
              ;

            ) {
              var _ref3

              if (_isArray3) {
                if (_i3 >= _iterator3.length) break
                _ref3 = _iterator3[_i3++]
              } else {
                _i3 = _iterator3.next()
                if (_i3.done) break
                _ref3 = _i3.value
              }

              var key = _ref3

              if (actual[key] !== expected[key]) {
                return false
              }
            }

            return true
          }

          function appendToMemberExpression(member, append, computed) {
            member.object = t.memberExpression(
              member.object,
              member.property,
              member.computed
            )
            member.property = append
            member.computed = !!computed
            return member
          }

          function prependToMemberExpression(member, prepend) {
            member.object = t.memberExpression(prepend, member.object)
            return member
          }

          function ensureBlock(node) {
            var key = arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : 'body'

            return (node[key] = t.toBlock(node[key], node))
          }

          function clone(node) {
            if (!node) return node
            var newNode = {}
            for (var key in node) {
              if (key[0] === '_') continue
              newNode[key] = node[key]
            }
            return newNode
          }

          function cloneWithoutLoc(node) {
            var newNode = clone(node)
            delete newNode.loc
            return newNode
          }

          function cloneDeep(node) {
            if (!node) return node
            var newNode = {}

            for (var key in node) {
              if (key[0] === '_') continue

              var val = node[key]

              if (val) {
                if (val.type) {
                  val = t.cloneDeep(val)
                } else if (Array.isArray(val)) {
                  val = val.map(t.cloneDeep)
                }
              }

              newNode[key] = val
            }

            return newNode
          }

          function buildMatchMemberExpression(match, allowPartial) {
            var parts = match.split('.')

            return function(member) {
              if (!t.isMemberExpression(member)) return false

              var search = [member]
              var i = 0

              while (search.length) {
                var node = search.shift()

                if (allowPartial && i === parts.length) {
                  return true
                }

                if (t.isIdentifier(node)) {
                  if (parts[i] !== node.name) return false
                } else if (t.isStringLiteral(node)) {
                  if (parts[i] !== node.value) return false
                } else if (t.isMemberExpression(node)) {
                  if (node.computed && !t.isStringLiteral(node.property)) {
                    return false
                  } else {
                    search.push(node.object)
                    search.push(node.property)
                    continue
                  }
                } else {
                  return false
                }

                if (++i > parts.length) {
                  return false
                }
              }

              return true
            }
          }

          function removeComments(node) {
            for (
              var _iterator4 = t.COMMENT_KEYS,
                _isArray4 = Array.isArray(_iterator4),
                _i4 = 0,
                _iterator4 = _isArray4
                  ? _iterator4
                  : (0, _getIterator3.default)(_iterator4);
              ;

            ) {
              var _ref4

              if (_isArray4) {
                if (_i4 >= _iterator4.length) break
                _ref4 = _iterator4[_i4++]
              } else {
                _i4 = _iterator4.next()
                if (_i4.done) break
                _ref4 = _i4.value
              }

              var key = _ref4

              delete node[key]
            }
            return node
          }

          function inheritsComments(child, parent) {
            inheritTrailingComments(child, parent)
            inheritLeadingComments(child, parent)
            inheritInnerComments(child, parent)
            return child
          }

          function inheritTrailingComments(child, parent) {
            _inheritComments('trailingComments', child, parent)
          }

          function inheritLeadingComments(child, parent) {
            _inheritComments('leadingComments', child, parent)
          }

          function inheritInnerComments(child, parent) {
            _inheritComments('innerComments', child, parent)
          }

          function _inheritComments(key, child, parent) {
            if (child && parent) {
              child[key] = (0, _uniq2.default)(
                [].concat(child[key], parent[key]).filter(Boolean)
              )
            }
          }

          function inherits(child, parent) {
            if (!child || !parent) return child

            for (
              var _iterator5 = t.INHERIT_KEYS.optional,
                _isArray5 = Array.isArray(_iterator5),
                _i5 = 0,
                _iterator5 = _isArray5
                  ? _iterator5
                  : (0, _getIterator3.default)(_iterator5);
              ;

            ) {
              var _ref5

              if (_isArray5) {
                if (_i5 >= _iterator5.length) break
                _ref5 = _iterator5[_i5++]
              } else {
                _i5 = _iterator5.next()
                if (_i5.done) break
                _ref5 = _i5.value
              }

              var _key2 = _ref5

              if (child[_key2] == null) {
                child[_key2] = parent[_key2]
              }
            }

            for (var key in parent) {
              if (key[0] === '_') child[key] = parent[key]
            }

            for (
              var _iterator6 = t.INHERIT_KEYS.force,
                _isArray6 = Array.isArray(_iterator6),
                _i6 = 0,
                _iterator6 = _isArray6
                  ? _iterator6
                  : (0, _getIterator3.default)(_iterator6);
              ;

            ) {
              var _ref6

              if (_isArray6) {
                if (_i6 >= _iterator6.length) break
                _ref6 = _iterator6[_i6++]
              } else {
                _i6 = _iterator6.next()
                if (_i6.done) break
                _ref6 = _i6.value
              }

              var _key3 = _ref6

              child[_key3] = parent[_key3]
            }

            t.inheritsComments(child, parent)

            return child
          }

          function assertNode(node) {
            if (!isNode(node)) {
              throw new TypeError('Not a valid node ' + (node && node.type))
            }
          }

          function isNode(node) {
            return !!(node && _definitions.VISITOR_KEYS[node.type])
          }

          ;(0, _toFastProperties2.default)(t)
          ;(0, _toFastProperties2.default)(t.VISITOR_KEYS)

          function traverseFast(node, enter, opts) {
            if (!node) return

            var keys = t.VISITOR_KEYS[node.type]
            if (!keys) return

            opts = opts || {}
            enter(node, opts)

            for (
              var _iterator7 = keys,
                _isArray7 = Array.isArray(_iterator7),
                _i7 = 0,
                _iterator7 = _isArray7
                  ? _iterator7
                  : (0, _getIterator3.default)(_iterator7);
              ;

            ) {
              var _ref7

              if (_isArray7) {
                if (_i7 >= _iterator7.length) break
                _ref7 = _iterator7[_i7++]
              } else {
                _i7 = _iterator7.next()
                if (_i7.done) break
                _ref7 = _i7.value
              }

              var key = _ref7

              var subNode = node[key]

              if (Array.isArray(subNode)) {
                for (
                  var _iterator8 = subNode,
                    _isArray8 = Array.isArray(_iterator8),
                    _i8 = 0,
                    _iterator8 = _isArray8
                      ? _iterator8
                      : (0, _getIterator3.default)(_iterator8);
                  ;

                ) {
                  var _ref8

                  if (_isArray8) {
                    if (_i8 >= _iterator8.length) break
                    _ref8 = _iterator8[_i8++]
                  } else {
                    _i8 = _iterator8.next()
                    if (_i8.done) break
                    _ref8 = _i8.value
                  }

                  var _node = _ref8

                  traverseFast(_node, enter, opts)
                }
              } else {
                traverseFast(subNode, enter, opts)
              }
            }
          }

          var CLEAR_KEYS = ['tokens', 'start', 'end', 'loc', 'raw', 'rawValue']

          var CLEAR_KEYS_PLUS_COMMENTS = t.COMMENT_KEYS
            .concat(['comments'])
            .concat(CLEAR_KEYS)

          function removeProperties(node, opts) {
            opts = opts || {}
            var map = opts.preserveComments
              ? CLEAR_KEYS
              : CLEAR_KEYS_PLUS_COMMENTS
            for (
              var _iterator9 = map,
                _isArray9 = Array.isArray(_iterator9),
                _i9 = 0,
                _iterator9 = _isArray9
                  ? _iterator9
                  : (0, _getIterator3.default)(_iterator9);
              ;

            ) {
              var _ref9

              if (_isArray9) {
                if (_i9 >= _iterator9.length) break
                _ref9 = _iterator9[_i9++]
              } else {
                _i9 = _iterator9.next()
                if (_i9.done) break
                _ref9 = _i9.value
              }

              var _key4 = _ref9

              if (node[_key4] != null) node[_key4] = undefined
            }

            for (var key in node) {
              if (key[0] === '_' && node[key] != null) node[key] = undefined
            }

            var syms = (0, _getOwnPropertySymbols2.default)(node)
            for (
              var _iterator10 = syms,
                _isArray10 = Array.isArray(_iterator10),
                _i10 = 0,
                _iterator10 = _isArray10
                  ? _iterator10
                  : (0, _getIterator3.default)(_iterator10);
              ;

            ) {
              var _ref10

              if (_isArray10) {
                if (_i10 >= _iterator10.length) break
                _ref10 = _iterator10[_i10++]
              } else {
                _i10 = _iterator10.next()
                if (_i10.done) break
                _ref10 = _i10.value
              }

              var sym = _ref10

              node[sym] = null
            }
          }

          function removePropertiesDeep(tree, opts) {
            traverseFast(tree, removeProperties, opts)
            return tree
          }
        },
        {
          './constants': 99,
          './converters': 100,
          './definitions': 105,
          './definitions/init': 106,
          './flow': 109,
          './react': 111,
          './retrievers': 112,
          './validators': 113,
          'babel-runtime/core-js/get-iterator': 54,
          'babel-runtime/core-js/json/stringify': 55,
          'babel-runtime/core-js/object/get-own-property-symbols': 60,
          'babel-runtime/core-js/object/keys': 61,
          'lodash/clone': 451,
          'lodash/uniq': 499,
          'to-fast-properties': 558,
        },
      ],
      111: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true
          exports.isReactComponent = undefined
          exports.isCompatTag = isCompatTag
          exports.buildChildren = buildChildren

          var _index = require('./index')

          var t = _interopRequireWildcard(_index)

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj
            } else {
              var newObj = {}
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key]
                }
              }
              newObj.default = obj
              return newObj
            }
          }

          var isReactComponent = (exports.isReactComponent = t.buildMatchMemberExpression(
            'React.Component'
          ))

          function isCompatTag(tagName) {
            return !!tagName && /^[a-z]|\-/.test(tagName)
          }

          function cleanJSXElementLiteralChild(child, args) {
            var lines = child.value.split(/\r\n|\n|\r/)

            var lastNonEmptyLine = 0

            for (var i = 0; i < lines.length; i++) {
              if (lines[i].match(/[^ \t]/)) {
                lastNonEmptyLine = i
              }
            }

            var str = ''

            for (var _i = 0; _i < lines.length; _i++) {
              var line = lines[_i]

              var isFirstLine = _i === 0
              var isLastLine = _i === lines.length - 1
              var isLastNonEmptyLine = _i === lastNonEmptyLine

              var trimmedLine = line.replace(/\t/g, ' ')

              if (!isFirstLine) {
                trimmedLine = trimmedLine.replace(/^[ ]+/, '')
              }

              if (!isLastLine) {
                trimmedLine = trimmedLine.replace(/[ ]+$/, '')
              }

              if (trimmedLine) {
                if (!isLastNonEmptyLine) {
                  trimmedLine += ' '
                }

                str += trimmedLine
              }
            }

            if (str) args.push(t.stringLiteral(str))
          }

          function buildChildren(node) {
            var elems = []

            for (var i = 0; i < node.children.length; i++) {
              var child = node.children[i]

              if (t.isJSXText(child)) {
                cleanJSXElementLiteralChild(child, elems)
                continue
              }

              if (t.isJSXExpressionContainer(child)) child = child.expression
              if (t.isJSXEmptyExpression(child)) continue

              elems.push(child)
            }

            return elems
          }
        },
        { './index': 110 },
      ],
      112: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true

          var _create = require('babel-runtime/core-js/object/create')

          var _create2 = _interopRequireDefault(_create)

          exports.getBindingIdentifiers = getBindingIdentifiers
          exports.getOuterBindingIdentifiers = getOuterBindingIdentifiers

          var _index = require('./index')

          var t = _interopRequireWildcard(_index)

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj
            } else {
              var newObj = {}
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key]
                }
              }
              newObj.default = obj
              return newObj
            }
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          function getBindingIdentifiers(node, duplicates, outerOnly) {
            var search = [].concat(node)
            var ids = (0, _create2.default)(null)

            while (search.length) {
              var id = search.shift()
              if (!id) continue

              var keys = t.getBindingIdentifiers.keys[id.type]

              if (t.isIdentifier(id)) {
                if (duplicates) {
                  var _ids = (ids[id.name] = ids[id.name] || [])
                  _ids.push(id)
                } else {
                  ids[id.name] = id
                }
                continue
              }

              if (t.isExportDeclaration(id)) {
                if (t.isDeclaration(id.declaration)) {
                  search.push(id.declaration)
                }
                continue
              }

              if (outerOnly) {
                if (t.isFunctionDeclaration(id)) {
                  search.push(id.id)
                  continue
                }

                if (t.isFunctionExpression(id)) {
                  continue
                }
              }

              if (keys) {
                for (var i = 0; i < keys.length; i++) {
                  var key = keys[i]
                  if (id[key]) {
                    search = search.concat(id[key])
                  }
                }
              }
            }

            return ids
          }

          getBindingIdentifiers.keys = {
            DeclareClass: ['id'],
            DeclareFunction: ['id'],
            DeclareModule: ['id'],
            DeclareVariable: ['id'],
            InterfaceDeclaration: ['id'],
            TypeAlias: ['id'],

            CatchClause: ['param'],
            LabeledStatement: ['label'],
            UnaryExpression: ['argument'],
            AssignmentExpression: ['left'],

            ImportSpecifier: ['local'],
            ImportNamespaceSpecifier: ['local'],
            ImportDefaultSpecifier: ['local'],
            ImportDeclaration: ['specifiers'],

            ExportSpecifier: ['exported'],
            ExportNamespaceSpecifier: ['exported'],
            ExportDefaultSpecifier: ['exported'],

            FunctionDeclaration: ['id', 'params'],
            FunctionExpression: ['id', 'params'],

            ClassDeclaration: ['id'],
            ClassExpression: ['id'],

            RestElement: ['argument'],
            UpdateExpression: ['argument'],

            RestProperty: ['argument'],
            ObjectProperty: ['value'],

            AssignmentPattern: ['left'],
            ArrayPattern: ['elements'],
            ObjectPattern: ['properties'],

            VariableDeclaration: ['declarations'],
            VariableDeclarator: ['id'],
          }

          function getOuterBindingIdentifiers(node, duplicates) {
            return getBindingIdentifiers(node, duplicates, true)
          }
        },
        { './index': 110, 'babel-runtime/core-js/object/create': 59 },
      ],
      113: [
        function(require, module, exports) {
          'use strict'
          exports.__esModule = true

          var _keys = require('babel-runtime/core-js/object/keys')

          var _keys2 = _interopRequireDefault(_keys)

          var _typeof2 = require('babel-runtime/helpers/typeof')

          var _typeof3 = _interopRequireDefault(_typeof2)

          var _getIterator2 = require('babel-runtime/core-js/get-iterator')

          var _getIterator3 = _interopRequireDefault(_getIterator2)

          exports.isBinding = isBinding
          exports.isReferenced = isReferenced
          exports.isValidIdentifier = isValidIdentifier
          exports.isLet = isLet
          exports.isBlockScoped = isBlockScoped
          exports.isVar = isVar
          exports.isSpecifierDefault = isSpecifierDefault
          exports.isScope = isScope
          exports.isImmutable = isImmutable
          exports.isNodesEquivalent = isNodesEquivalent

          var _retrievers = require('./retrievers')

          var _esutils = require('esutils')

          var _esutils2 = _interopRequireDefault(_esutils)

          var _index = require('./index')

          var t = _interopRequireWildcard(_index)

          var _constants = require('./constants')

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj
            } else {
              var newObj = {}
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key]
                }
              }
              newObj.default = obj
              return newObj
            }
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          function isBinding(node, parent) {
            var keys = _retrievers.getBindingIdentifiers.keys[parent.type]
            if (keys) {
              for (var i = 0; i < keys.length; i++) {
                var key = keys[i]
                var val = parent[key]
                if (Array.isArray(val)) {
                  if (val.indexOf(node) >= 0) return true
                } else {
                  if (val === node) return true
                }
              }
            }

            return false
          }

          function isReferenced(node, parent) {
            switch (parent.type) {
              case 'BindExpression':
                return parent.object === node || parent.callee === node

              case 'MemberExpression':
              case 'JSXMemberExpression':
                if (parent.property === node && parent.computed) {
                  return true
                } else if (parent.object === node) {
                  return true
                } else {
                  return false
                }

              case 'MetaProperty':
                return false

              case 'ObjectProperty':
                if (parent.key === node) {
                  return parent.computed
                }

              case 'VariableDeclarator':
                return parent.id !== node

              case 'ArrowFunctionExpression':
              case 'FunctionDeclaration':
              case 'FunctionExpression':
                for (
                  var _iterator = parent.params,
                    _isArray = Array.isArray(_iterator),
                    _i = 0,
                    _iterator = _isArray
                      ? _iterator
                      : (0, _getIterator3.default)(_iterator);
                  ;

                ) {
                  var _ref

                  if (_isArray) {
                    if (_i >= _iterator.length) break
                    _ref = _iterator[_i++]
                  } else {
                    _i = _iterator.next()
                    if (_i.done) break
                    _ref = _i.value
                  }

                  var param = _ref

                  if (param === node) return false
                }

                return parent.id !== node

              case 'ExportSpecifier':
                if (parent.source) {
                  return false
                } else {
                  return parent.local === node
                }

              case 'ExportNamespaceSpecifier':
              case 'ExportDefaultSpecifier':
                return false

              case 'JSXAttribute':
                return parent.name !== node

              case 'ClassProperty':
                if (parent.key === node) {
                  return parent.computed
                } else {
                  return parent.value === node
                }

              case 'ImportDefaultSpecifier':
              case 'ImportNamespaceSpecifier':
              case 'ImportSpecifier':
                return false

              case 'ClassDeclaration':
              case 'ClassExpression':
                return parent.id !== node

              case 'ClassMethod':
              case 'ObjectMethod':
                return parent.key === node && parent.computed

              case 'LabeledStatement':
                return false

              case 'CatchClause':
                return parent.param !== node

              case 'RestElement':
                return false

              case 'AssignmentExpression':
                return parent.right === node

              case 'AssignmentPattern':
                return parent.right === node

              case 'ObjectPattern':
              case 'ArrayPattern':
                return false
            }

            return true
          }

          function isValidIdentifier(name) {
            if (
              typeof name !== 'string' ||
              _esutils2.default.keyword.isReservedWordES6(name, true)
            ) {
              return false
            } else if (name === 'await') {
              return false
            } else {
              return _esutils2.default.keyword.isIdentifierNameES6(name)
            }
          }

          function isLet(node) {
            return (
              t.isVariableDeclaration(node) &&
              (node.kind !== 'var' || node[_constants.BLOCK_SCOPED_SYMBOL])
            )
          }

          function isBlockScoped(node) {
            return (
              t.isFunctionDeclaration(node) ||
              t.isClassDeclaration(node) ||
              t.isLet(node)
            )
          }

          function isVar(node) {
            return (
              t.isVariableDeclaration(node, { kind: 'var' }) &&
              !node[_constants.BLOCK_SCOPED_SYMBOL]
            )
          }

          function isSpecifierDefault(specifier) {
            return (
              t.isImportDefaultSpecifier(specifier) ||
              t.isIdentifier(specifier.imported || specifier.exported, {
                name: 'default',
              })
            )
          }

          function isScope(node, parent) {
            if (
              t.isBlockStatement(node) &&
              t.isFunction(parent, { body: node })
            ) {
              return false
            }

            return t.isScopable(node)
          }

          function isImmutable(node) {
            if (t.isType(node.type, 'Immutable')) return true

            if (t.isIdentifier(node)) {
              if (node.name === 'undefined') {
                return true
              } else {
                return false
              }
            }

            return false
          }

          function isNodesEquivalent(a, b) {
            if (
              (typeof a === 'undefined'
                ? 'undefined'
                : (0, _typeof3.default)(a)) !== 'object' ||
              (typeof a === 'undefined'
                ? 'undefined'
                : (0, _typeof3.default)(a)) !== 'object' ||
              a == null ||
              b == null
            ) {
              return a === b
            }

            if (a.type !== b.type) {
              return false
            }

            var fields = (0, _keys2.default)(t.NODE_FIELDS[a.type] || a.type)

            for (
              var _iterator2 = fields,
                _isArray2 = Array.isArray(_iterator2),
                _i2 = 0,
                _iterator2 = _isArray2
                  ? _iterator2
                  : (0, _getIterator3.default)(_iterator2);
              ;

            ) {
              var _ref2

              if (_isArray2) {
                if (_i2 >= _iterator2.length) break
                _ref2 = _iterator2[_i2++]
              } else {
                _i2 = _iterator2.next()
                if (_i2.done) break
                _ref2 = _i2.value
              }

              var field = _ref2

              if (
                (0, _typeof3.default)(a[field]) !==
                (0, _typeof3.default)(b[field])
              ) {
                return false
              }

              if (Array.isArray(a[field])) {
                if (!Array.isArray(b[field])) {
                  return false
                }
                if (a[field].length !== b[field].length) {
                  return false
                }

                for (var i = 0; i < a[field].length; i++) {
                  if (!isNodesEquivalent(a[field][i], b[field][i])) {
                    return false
                  }
                }
                continue
              }

              if (!isNodesEquivalent(a[field], b[field])) {
                return false
              }
            }

            return true
          }
        },
        {
          './constants': 99,
          './index': 110,
          './retrievers': 112,
          'babel-runtime/core-js/get-iterator': 54,
          'babel-runtime/core-js/object/keys': 61,
          'babel-runtime/helpers/typeof': 72,
          esutils: 251,
        },
      ],
      114: [
        function(require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', { value: true })

          /* eslint max-len: 0 */

          // This is a trick taken from Esprima. It turns out that, on
          // non-Chrome browsers, to check whether a string is in a set, a
          // predicate containing a big ugly `switch` statement is faster than
          // a regular expression, and on Chrome the two are about on par.
          // This function uses `eval` (non-lexical) to produce such a
          // predicate from a space-separated string of words.
          //
          // It starts by sorting the words by length.

          function makePredicate(words) {
            words = words.split(' ')
            return function(str) {
              return words.indexOf(str) >= 0
            }
          }

          // Reserved word lists for various dialects of the language

          var reservedWords = {
            6: makePredicate('enum await'),
            strict: makePredicate(
              'implements interface let package private protected public static yield'
            ),
            strictBind: makePredicate('eval arguments'),
          }

          // And the keywords

          var isKeyword = makePredicate(
            'break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this let const class extends export import yield super'
          )

          // ## Character categories

          // Big ugly regular expressions that match characters in the
          // whitespace, identifier, and identifier-start categories. These
          // are only applied when a character is found to actually have a
          // code point above 128.
          // Generated by `bin/generate-identifier-regex.js`.

          var nonASCIIidentifierStartChars =
            '\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC'
          var nonASCIIidentifierChars =
            '\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D4-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFB-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA900-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F'

          var nonASCIIidentifierStart = new RegExp(
            '[' + nonASCIIidentifierStartChars + ']'
          )
          var nonASCIIidentifier = new RegExp(
            '[' + nonASCIIidentifierStartChars + nonASCIIidentifierChars + ']'
          )

          nonASCIIidentifierStartChars = nonASCIIidentifierChars = null

          // These are a run-length and offset encoded representation of the
          // >0xffff code points that are a valid part of identifiers. The
          // offset starts at 0x10000, and each pair of numbers represents an
          // offset to the next range, and then a size of the range. They were
          // generated by `bin/generate-identifier-regex.js`.
          // eslint-disable-next-line comma-spacing
          var astralIdentifierStartCodes = [
            0,
            11,
            2,
            25,
            2,
            18,
            2,
            1,
            2,
            14,
            3,
            13,
            35,
            122,
            70,
            52,
            268,
            28,
            4,
            48,
            48,
            31,
            17,
            26,
            6,
            37,
            11,
            29,
            3,
            35,
            5,
            7,
            2,
            4,
            43,
            157,
            19,
            35,
            5,
            35,
            5,
            39,
            9,
            51,
            157,
            310,
            10,
            21,
            11,
            7,
            153,
            5,
            3,
            0,
            2,
            43,
            2,
            1,
            4,
            0,
            3,
            22,
            11,
            22,
            10,
            30,
            66,
            18,
            2,
            1,
            11,
            21,
            11,
            25,
            71,
            55,
            7,
            1,
            65,
            0,
            16,
            3,
            2,
            2,
            2,
            26,
            45,
            28,
            4,
            28,
            36,
            7,
            2,
            27,
            28,
            53,
            11,
            21,
            11,
            18,
            14,
            17,
            111,
            72,
            56,
            50,
            14,
            50,
            785,
            52,
            76,
            44,
            33,
            24,
            27,
            35,
            42,
            34,
            4,
            0,
            13,
            47,
            15,
            3,
            22,
            0,
            2,
            0,
            36,
            17,
            2,
            24,
            85,
            6,
            2,
            0,
            2,
            3,
            2,
            14,
            2,
            9,
            8,
            46,
            39,
            7,
            3,
            1,
            3,
            21,
            2,
            6,
            2,
            1,
            2,
            4,
            4,
            0,
            19,
            0,
            13,
            4,
            159,
            52,
            19,
            3,
            54,
            47,
            21,
            1,
            2,
            0,
            185,
            46,
            42,
            3,
            37,
            47,
            21,
            0,
            60,
            42,
            86,
            25,
            391,
            63,
            32,
            0,
            449,
            56,
            264,
            8,
            2,
            36,
            18,
            0,
            50,
            29,
            881,
            921,
            103,
            110,
            18,
            195,
            2749,
            1070,
            4050,
            582,
            8634,
            568,
            8,
            30,
            114,
            29,
            19,
            47,
            17,
            3,
            32,
            20,
            6,
            18,
            881,
            68,
            12,
            0,
            67,
            12,
            65,
            0,
            32,
            6124,
            20,
            754,
            9486,
            1,
            3071,
            106,
            6,
            12,
            4,
            8,
            8,
            9,
            5991,
            84,
            2,
            70,
            2,
            1,
            3,
            0,
            3,
            1,
            3,
            3,
            2,
            11,
            2,
            0,
            2,
            6,
            2,
            64,
            2,
            3,
            3,
            7,
            2,
            6,
            2,
            27,
            2,
            3,
            2,
            4,
            2,
            0,
            4,
            6,
            2,
            339,
            3,
            24,
            2,
            24,
            2,
            30,
            2,
            24,
            2,
            30,
            2,
            24,
            2,
            30,
            2,
            24,
            2,
            30,
            2,
            24,
            2,
            7,
            4149,
            196,
            60,
            67,
            1213,
            3,
            2,
            26,
            2,
            1,
            2,
            0,
            3,
            0,
            2,
            9,
            2,
            3,
            2,
            0,
            2,
            0,
            7,
            0,
            5,
            0,
            2,
            0,
            2,
            0,
            2,
            2,
            2,
            1,
            2,
            0,
            3,
            0,
            2,
            0,
            2,
            0,
            2,
            0,
            2,
            0,
            2,
            1,
            2,
            0,
            3,
            3,
            2,
            6,
            2,
            3,
            2,
            3,
            2,
            0,
            2,
            9,
            2,
            16,
            6,
            2,
            2,
            4,
            2,
            16,
            4421,
            42710,
            42,
            4148,
            12,
            221,
            3,
            5761,
            10591,
            541,
          ]
          // eslint-disable-next-line comma-spacing
          var astralIdentifierCodes = [
            509,
            0,
            227,
            0,
            150,
            4,
            294,
            9,
            1368,
            2,
            2,
            1,
            6,
            3,
            41,
            2,
            5,
            0,
            166,
            1,
            1306,
            2,
            54,
            14,
            32,
            9,
            16,
            3,
            46,
            10,
            54,
            9,
            7,
            2,
            37,
            13,
            2,
            9,
            52,
            0,
            13,
            2,
            49,
            13,
            10,
            2,
            4,
            9,
            83,
            11,
            7,
            0,
            161,
            11,
            6,
            9,
            7,
            3,
            57,
            0,
            2,
            6,
            3,
            1,
            3,
            2,
            10,
            0,
            11,
            1,
            3,
            6,
            4,
            4,
            193,
            17,
            10,
            9,
            87,
            19,
            13,
            9,
            214,
            6,
            3,
            8,
            28,
            1,
            83,
            16,
            16,
            9,
            82,
            12,
            9,
            9,
            84,
            14,
            5,
            9,
            423,
            9,
            838,
            7,
            2,
            7,
            17,
            9,
            57,
            21,
            2,
            13,
            19882,
            9,
            135,
            4,
            60,
            6,
            26,
            9,
            1016,
            45,
            17,
            3,
            19723,
            1,
            5319,
            4,
            4,
            5,
            9,
            7,
            3,
            6,
            31,
            3,
            149,
            2,
            1418,
            49,
            513,
            54,
            5,
            49,
            9,
            0,
            15,
            0,
            23,
            4,
            2,
            14,
            1361,
            6,
            2,
            16,
            3,
            6,
            2,
            1,
            2,
            4,
            2214,
            6,
            110,
            6,
            6,
            9,
            792487,
            239,
          ]

          // This has a complexity linear to the value of the code. The
          // assumption is that looking up astral identifier characters is
          // rare.
          function isInAstralSet(code, set) {
            var pos = 0x10000
            for (var i = 0; i < set.length; i += 2) {
              pos += set[i]
              if (pos > code) return false

              pos += set[i + 1]
              if (pos >= code) return true
            }
          }

          // Test whether a given character code starts an identifier.

          function isIdentifierStart(code) {
            if (code < 65) return code === 36
            if (code < 91) return true
            if (code < 97) return code === 95
            if (code < 123) return true
            if (code <= 0xffff)
              return (
                code >= 0xaa &&
                nonASCIIidentifierStart.test(String.fromCharCode(code))
              )
            return isInAstralSet(code, astralIdentifierStartCodes)
          }

          // Test whether a given character is part of an identifier.

          function isIdentifierChar(code) {
            if (code < 48) return code === 36
            if (code < 58) return true
            if (code < 65) return false
            if (code < 91) return true
            if (code < 97) return code === 95
            if (code < 123) return true
            if (code <= 0xffff)
              return (
                code >= 0xaa &&
                nonASCIIidentifier.test(String.fromCharCode(code))
              )
            return (
              isInAstralSet(code, astralIdentifierStartCodes) ||
              isInAstralSet(code, astralIdentifierCodes)
            )
          }

          // A second optional argument can be given to further configure
          var defaultOptions = {
            // Source type ("script" or "module") for different semantics
            sourceType: 'script',
            // Source filename.
            sourceFilename: undefined,
            // Line from which to start counting source. Useful for
            // integration with other tools.
            startLine: 1,
            // When enabled, a return at the top level is not considered an
            // error.
            allowReturnOutsideFunction: false,
            // When enabled, import/export statements are not constrained to
            // appearing at the top of the program.
            allowImportExportEverywhere: false,
            // TODO
            allowSuperOutsideMethod: false,
            // An array of plugins to enable
            plugins: [],
            // TODO
            strictMode: null,
          }

          // Interpret and default an options object

          function getOptions(opts) {
            var options = {}
            for (var key in defaultOptions) {
              options[key] = opts && key in opts
                ? opts[key]
                : defaultOptions[key]
            }
            return options
          }

          var _typeof = typeof Symbol === 'function' &&
            typeof Symbol.iterator === 'symbol'
            ? function(obj) {
                return typeof obj
              }
            : function(obj) {
                return obj &&
                  typeof Symbol === 'function' &&
                  obj.constructor === Symbol &&
                  obj !== Symbol.prototype
                  ? 'symbol'
                  : typeof obj
              }

          var classCallCheck = function(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function')
            }
          }

          var inherits = function(subClass, superClass) {
            if (typeof superClass !== 'function' && superClass !== null) {
              throw new TypeError(
                'Super expression must either be null or a function, not ' +
                  typeof superClass
              )
            }

            subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true,
                },
              }
            )
            if (superClass)
              Object.setPrototypeOf
                ? Object.setPrototypeOf(subClass, superClass)
                : (subClass.__proto__ = superClass)
          }

          var possibleConstructorReturn = function(self, call) {
            if (!self) {
              throw new ReferenceError(
                "this hasn't been initialised - super() hasn't been called"
              )
            }

            return call &&
              (typeof call === 'object' || typeof call === 'function')
              ? call
              : self
          }

          // ## Token types

          // The assignment of fine-grained, information-carrying type objects
          // allows the tokenizer to store the information it has about a
          // token in a way that is very cheap for the parser to look up.

          // All token type variables start with an underscore, to make them
          // easy to recognize.

          // The `beforeExpr` property is used to disambiguate between regular
          // expressions and divisions. It is set on all token types that can
          // be followed by an expression (thus, a slash after them would be a
          // regular expression).
          //
          // `isLoop` marks a keyword as starting a loop, which is important
          // to know when parsing a label, in order to allow or disallow
          // continue jumps to that label.

          var beforeExpr = true
          var startsExpr = true
          var isLoop = true
          var isAssign = true
          var prefix = true
          var postfix = true

          var TokenType = function TokenType(label) {
            var conf = arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : {}
            classCallCheck(this, TokenType)

            this.label = label
            this.keyword = conf.keyword
            this.beforeExpr = !!conf.beforeExpr
            this.startsExpr = !!conf.startsExpr
            this.rightAssociative = !!conf.rightAssociative
            this.isLoop = !!conf.isLoop
            this.isAssign = !!conf.isAssign
            this.prefix = !!conf.prefix
            this.postfix = !!conf.postfix
            this.binop = conf.binop || null
            this.updateContext = null
          }

          var KeywordTokenType = (function(_TokenType) {
            inherits(KeywordTokenType, _TokenType)

            function KeywordTokenType(name) {
              var options = arguments.length > 1 && arguments[1] !== undefined
                ? arguments[1]
                : {}
              classCallCheck(this, KeywordTokenType)

              options.keyword = name

              return possibleConstructorReturn(
                this,
                _TokenType.call(this, name, options)
              )
            }

            return KeywordTokenType
          })(TokenType)

          var BinopTokenType = (function(_TokenType2) {
            inherits(BinopTokenType, _TokenType2)

            function BinopTokenType(name, prec) {
              classCallCheck(this, BinopTokenType)
              return possibleConstructorReturn(
                this,
                _TokenType2.call(this, name, {
                  beforeExpr: beforeExpr,
                  binop: prec,
                })
              )
            }

            return BinopTokenType
          })(TokenType)

          var types = {
            num: new TokenType('num', { startsExpr: startsExpr }),
            regexp: new TokenType('regexp', { startsExpr: startsExpr }),
            string: new TokenType('string', { startsExpr: startsExpr }),
            name: new TokenType('name', { startsExpr: startsExpr }),
            eof: new TokenType('eof'),

            // Punctuation token types.
            bracketL: new TokenType('[', {
              beforeExpr: beforeExpr,
              startsExpr: startsExpr,
            }),
            bracketR: new TokenType(']'),
            braceL: new TokenType('{', {
              beforeExpr: beforeExpr,
              startsExpr: startsExpr,
            }),
            braceBarL: new TokenType('{|', {
              beforeExpr: beforeExpr,
              startsExpr: startsExpr,
            }),
            braceR: new TokenType('}'),
            braceBarR: new TokenType('|}'),
            parenL: new TokenType('(', {
              beforeExpr: beforeExpr,
              startsExpr: startsExpr,
            }),
            parenR: new TokenType(')'),
            comma: new TokenType(',', { beforeExpr: beforeExpr }),
            semi: new TokenType(';', { beforeExpr: beforeExpr }),
            colon: new TokenType(':', { beforeExpr: beforeExpr }),
            doubleColon: new TokenType('::', { beforeExpr: beforeExpr }),
            dot: new TokenType('.'),
            question: new TokenType('?', { beforeExpr: beforeExpr }),
            arrow: new TokenType('=>', { beforeExpr: beforeExpr }),
            template: new TokenType('template'),
            ellipsis: new TokenType('...', { beforeExpr: beforeExpr }),
            backQuote: new TokenType('`', { startsExpr: startsExpr }),
            dollarBraceL: new TokenType('${', {
              beforeExpr: beforeExpr,
              startsExpr: startsExpr,
            }),
            at: new TokenType('@'),

            // Operators. These carry several kinds of properties to help the
            // parser use them properly (the presence of these properties is
            // what categorizes them as operators).
            //
            // `binop`, when present, specifies that this operator is a binary
            // operator, and will refer to its precedence.
            //
            // `prefix` and `postfix` mark the operator as a prefix or postfix
            // unary operator.
            //
            // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
            // binary operators with a very low precedence, that should result
            // in AssignmentExpression nodes.

            eq: new TokenType('=', {
              beforeExpr: beforeExpr,
              isAssign: isAssign,
            }),
            assign: new TokenType('_=', {
              beforeExpr: beforeExpr,
              isAssign: isAssign,
            }),
            incDec: new TokenType('++/--', {
              prefix: prefix,
              postfix: postfix,
              startsExpr: startsExpr,
            }),
            prefix: new TokenType('prefix', {
              beforeExpr: beforeExpr,
              prefix: prefix,
              startsExpr: startsExpr,
            }),
            logicalOR: new BinopTokenType('||', 1),
            logicalAND: new BinopTokenType('&&', 2),
            bitwiseOR: new BinopTokenType('|', 3),
            bitwiseXOR: new BinopTokenType('^', 4),
            bitwiseAND: new BinopTokenType('&', 5),
            equality: new BinopTokenType('==/!=', 6),
            relational: new BinopTokenType('</>', 7),
            bitShift: new BinopTokenType('<</>>', 8),
            plusMin: new TokenType('+/-', {
              beforeExpr: beforeExpr,
              binop: 9,
              prefix: prefix,
              startsExpr: startsExpr,
            }),
            modulo: new BinopTokenType('%', 10),
            star: new BinopTokenType('*', 10),
            slash: new BinopTokenType('/', 10),
            exponent: new TokenType('**', {
              beforeExpr: beforeExpr,
              binop: 11,
              rightAssociative: true,
            }),
          }

          var keywords = {
            break: new KeywordTokenType('break'),
            case: new KeywordTokenType('case', { beforeExpr: beforeExpr }),
            catch: new KeywordTokenType('catch'),
            continue: new KeywordTokenType('continue'),
            debugger: new KeywordTokenType('debugger'),
            default: new KeywordTokenType('default', {
              beforeExpr: beforeExpr,
            }),
            do: new KeywordTokenType('do', {
              isLoop: isLoop,
              beforeExpr: beforeExpr,
            }),
            else: new KeywordTokenType('else', { beforeExpr: beforeExpr }),
            finally: new KeywordTokenType('finally'),
            for: new KeywordTokenType('for', { isLoop: isLoop }),
            function: new KeywordTokenType('function', {
              startsExpr: startsExpr,
            }),
            if: new KeywordTokenType('if'),
            return: new KeywordTokenType('return', { beforeExpr: beforeExpr }),
            switch: new KeywordTokenType('switch'),
            throw: new KeywordTokenType('throw', { beforeExpr: beforeExpr }),
            try: new KeywordTokenType('try'),
            var: new KeywordTokenType('var'),
            let: new KeywordTokenType('let'),
            const: new KeywordTokenType('const'),
            while: new KeywordTokenType('while', { isLoop: isLoop }),
            with: new KeywordTokenType('with'),
            new: new KeywordTokenType('new', {
              beforeExpr: beforeExpr,
              startsExpr: startsExpr,
            }),
            this: new KeywordTokenType('this', { startsExpr: startsExpr }),
            super: new KeywordTokenType('super', { startsExpr: startsExpr }),
            class: new KeywordTokenType('class'),
            extends: new KeywordTokenType('extends', {
              beforeExpr: beforeExpr,
            }),
            export: new KeywordTokenType('export'),
            import: new KeywordTokenType('import', { startsExpr: startsExpr }),
            yield: new KeywordTokenType('yield', {
              beforeExpr: beforeExpr,
              startsExpr: startsExpr,
            }),
            null: new KeywordTokenType('null', { startsExpr: startsExpr }),
            true: new KeywordTokenType('true', { startsExpr: startsExpr }),
            false: new KeywordTokenType('false', { startsExpr: startsExpr }),
            in: new KeywordTokenType('in', {
              beforeExpr: beforeExpr,
              binop: 7,
            }),
            instanceof: new KeywordTokenType('instanceof', {
              beforeExpr: beforeExpr,
              binop: 7,
            }),
            typeof: new KeywordTokenType('typeof', {
              beforeExpr: beforeExpr,
              prefix: prefix,
              startsExpr: startsExpr,
            }),
            void: new KeywordTokenType('void', {
              beforeExpr: beforeExpr,
              prefix: prefix,
              startsExpr: startsExpr,
            }),
            delete: new KeywordTokenType('delete', {
              beforeExpr: beforeExpr,
              prefix: prefix,
              startsExpr: startsExpr,
            }),
          }

          // Map keyword names to token types.
          Object.keys(keywords).forEach(function(name) {
            types['_' + name] = keywords[name]
          })

          // Matches a whole line break (where CRLF is considered a single
          // line break). Used to count lines.

          var lineBreak = /\r\n?|\n|\u2028|\u2029/
          var lineBreakG = new RegExp(lineBreak.source, 'g')

          function isNewLine(code) {
            return (
              code === 10 || code === 13 || code === 0x2028 || code === 0x2029
            )
          }

          var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/

          // The algorithm used to determine whether a regexp can appear at a
          // given point in the program is loosely based on sweet.js' approach.
          // See https://github.com/mozilla/sweet.js/wiki/design

          var TokContext = function TokContext(
            token,
            isExpr,
            preserveSpace,
            override
          ) {
            classCallCheck(this, TokContext)

            this.token = token
            this.isExpr = !!isExpr
            this.preserveSpace = !!preserveSpace
            this.override = override
          }

          var types$1 = {
            braceStatement: new TokContext('{', false),
            braceExpression: new TokContext('{', true),
            templateQuasi: new TokContext('${', true),
            parenStatement: new TokContext('(', false),
            parenExpression: new TokContext('(', true),
            template: new TokContext('`', true, true, function(p) {
              return p.readTmplToken()
            }),
            functionExpression: new TokContext('function', true),
          }

          // Token-specific context update code

          types.parenR.updateContext = types.braceR.updateContext = function() {
            if (this.state.context.length === 1) {
              this.state.exprAllowed = true
              return
            }

            var out = this.state.context.pop()
            if (
              out === types$1.braceStatement &&
              this.curContext() === types$1.functionExpression
            ) {
              this.state.context.pop()
              this.state.exprAllowed = false
            } else if (out === types$1.templateQuasi) {
              this.state.exprAllowed = true
            } else {
              this.state.exprAllowed = !out.isExpr
            }
          }

          types.name.updateContext = function(prevType) {
            this.state.exprAllowed = false

            if (
              prevType === types._let ||
              prevType === types._const ||
              prevType === types._var
            ) {
              if (lineBreak.test(this.input.slice(this.state.end))) {
                this.state.exprAllowed = true
              }
            }
          }

          types.braceL.updateContext = function(prevType) {
            this.state.context.push(
              this.braceIsBlock(prevType)
                ? types$1.braceStatement
                : types$1.braceExpression
            )
            this.state.exprAllowed = true
          }

          types.dollarBraceL.updateContext = function() {
            this.state.context.push(types$1.templateQuasi)
            this.state.exprAllowed = true
          }

          types.parenL.updateContext = function(prevType) {
            var statementParens =
              prevType === types._if ||
              prevType === types._for ||
              prevType === types._with ||
              prevType === types._while
            this.state.context.push(
              statementParens ? types$1.parenStatement : types$1.parenExpression
            )
            this.state.exprAllowed = true
          }

          types.incDec.updateContext = function() {
            // tokExprAllowed stays unchanged
          }

          types._function.updateContext = function() {
            if (this.curContext() !== types$1.braceStatement) {
              this.state.context.push(types$1.functionExpression)
            }

            this.state.exprAllowed = false
          }

          types.backQuote.updateContext = function() {
            if (this.curContext() === types$1.template) {
              this.state.context.pop()
            } else {
              this.state.context.push(types$1.template)
            }
            this.state.exprAllowed = false
          }

          // These are used when `options.locations` is on, for the
          // `startLoc` and `endLoc` properties.

          var Position = function Position(line, col) {
            classCallCheck(this, Position)

            this.line = line
            this.column = col
          }

          var SourceLocation = function SourceLocation(start, end) {
            classCallCheck(this, SourceLocation)

            this.start = start
            this.end = end
          }

          // The `getLineInfo` function is mostly useful when the
          // `locations` option is off (for performance reasons) and you
          // want to find the line/column position for a given character
          // offset. `input` should be the code string that the offset refers
          // into.

          function getLineInfo(input, offset) {
            for (var line = 1, cur = 0; ; ) {
              lineBreakG.lastIndex = cur
              var match = lineBreakG.exec(input)
              if (match && match.index < offset) {
                ++line
                cur = match.index + match[0].length
              } else {
                return new Position(line, offset - cur)
              }
            }
          }

          var State = (function() {
            function State() {
              classCallCheck(this, State)
            }

            State.prototype.init = function init(options, input) {
              this.strict = options.strictMode === false
                ? false
                : options.sourceType === 'module'

              this.input = input

              this.potentialArrowAt = -1

              this.inMethod = this.inFunction = this.inGenerator = this.inAsync = this.inPropertyName = this.inType = this.noAnonFunctionType = false

              this.labels = []

              this.decorators = []

              this.tokens = []

              this.comments = []

              this.trailingComments = []
              this.leadingComments = []
              this.commentStack = []

              this.pos = this.lineStart = 0
              this.curLine = options.startLine

              this.type = types.eof
              this.value = null
              this.start = this.end = this.pos
              this.startLoc = this.endLoc = this.curPosition()

              this.lastTokEndLoc = this.lastTokStartLoc = null
              this.lastTokStart = this.lastTokEnd = this.pos

              this.context = [types$1.braceStatement]
              this.exprAllowed = true

              this.containsEsc = this.containsOctal = false
              this.octalPosition = null

              this.invalidTemplateEscapePosition = null

              this.exportedIdentifiers = []

              return this
            }

            // TODO

            // TODO

            // Used to signify the start of a potential arrow function

            // Flags to track whether we are in a function, a generator.

            // Labels in scope.

            // Leading decorators.

            // Token store.

            // Comment store.

            // Comment attachment store

            // The current position of the tokenizer in the input.

            // Properties of the current token:
            // Its type

            // For tokens that include more information than their type, the value

            // Its start and end offset

            // And, if locations are used, the {line, column} object
            // corresponding to those offsets

            // Position information for the previous token

            // The context stack is used to superficially track syntactic
            // context to predict whether a regular expression is allowed in a
            // given position.

            // Used to signal to callers of `readWord1` whether the word
            // contained any escape sequences. This is needed because words with
            // escape sequences must not be interpreted as keywords.

            // TODO

            // Names of exports store. `default` is stored as a name for both
            // `export default foo;` and `export { foo as default };`.

            State.prototype.curPosition = function curPosition() {
              return new Position(this.curLine, this.pos - this.lineStart)
            }

            State.prototype.clone = function clone(skipArrays) {
              var state = new State()
              for (var key in this) {
                var val = this[key]

                if ((!skipArrays || key === 'context') && Array.isArray(val)) {
                  val = val.slice()
                }

                state[key] = val
              }
              return state
            }

            return State
          })()

          // Object type used to represent tokens. Note that normally, tokens
          // simply exist as properties on the parser object. This is only
          // used for the onToken callback and the external tokenizer.

          var Token = function Token(state) {
            classCallCheck(this, Token)

            this.type = state.type
            this.value = state.value
            this.start = state.start
            this.end = state.end
            this.loc = new SourceLocation(state.startLoc, state.endLoc)
          }

          // ## Tokenizer

          function codePointToString(code) {
            // UTF-16 Decoding
            if (code <= 0xffff) {
              return String.fromCharCode(code)
            } else {
              return String.fromCharCode(
                ((code - 0x10000) >> 10) + 0xd800,
                ((code - 0x10000) & 1023) + 0xdc00
              )
            }
          }

          var Tokenizer = (function() {
            function Tokenizer(options, input) {
              classCallCheck(this, Tokenizer)

              this.state = new State()
              this.state.init(options, input)
            }

            // Move to the next token

            Tokenizer.prototype.next = function next() {
              if (!this.isLookahead) {
                this.state.tokens.push(new Token(this.state))
              }

              this.state.lastTokEnd = this.state.end
              this.state.lastTokStart = this.state.start
              this.state.lastTokEndLoc = this.state.endLoc
              this.state.lastTokStartLoc = this.state.startLoc
              this.nextToken()
            }

            // TODO

            Tokenizer.prototype.eat = function eat(type) {
              if (this.match(type)) {
                this.next()
                return true
              } else {
                return false
              }
            }

            // TODO

            Tokenizer.prototype.match = function match(type) {
              return this.state.type === type
            }

            // TODO

            Tokenizer.prototype.isKeyword = function isKeyword$$1(word) {
              return isKeyword(word)
            }

            // TODO

            Tokenizer.prototype.lookahead = function lookahead() {
              var old = this.state
              this.state = old.clone(true)

              this.isLookahead = true
              this.next()
              this.isLookahead = false

              var curr = this.state.clone(true)
              this.state = old
              return curr
            }

            // Toggle strict mode. Re-reads the next number or string to please
            // pedantic tests (`"use strict"; 010;` should fail).

            Tokenizer.prototype.setStrict = function setStrict(strict) {
              this.state.strict = strict
              if (!this.match(types.num) && !this.match(types.string)) return
              this.state.pos = this.state.start
              while (this.state.pos < this.state.lineStart) {
                this.state.lineStart =
                  this.input.lastIndexOf('\n', this.state.lineStart - 2) + 1
                --this.state.curLine
              }
              this.nextToken()
            }

            Tokenizer.prototype.curContext = function curContext() {
              return this.state.context[this.state.context.length - 1]
            }

            // Read a single token, updating the parser object's token-related
            // properties.

            Tokenizer.prototype.nextToken = function nextToken() {
              var curContext = this.curContext()
              if (!curContext || !curContext.preserveSpace) this.skipSpace()

              this.state.containsOctal = false
              this.state.octalPosition = null
              this.state.start = this.state.pos
              this.state.startLoc = this.state.curPosition()
              if (this.state.pos >= this.input.length)
                return this.finishToken(types.eof)

              if (curContext.override) {
                return curContext.override(this)
              } else {
                return this.readToken(this.fullCharCodeAtPos())
              }
            }

            Tokenizer.prototype.readToken = function readToken(code) {
              // Identifier or keyword. '\uXXXX' sequences are allowed in
              // identifiers, so '\' also dispatches to that.
              if (isIdentifierStart(code) || code === 92 /* '\' */) {
                return this.readWord()
              } else {
                return this.getTokenFromCode(code)
              }
            }

            Tokenizer.prototype.fullCharCodeAtPos = function fullCharCodeAtPos() {
              var code = this.input.charCodeAt(this.state.pos)
              if (code <= 0xd7ff || code >= 0xe000) return code

              var next = this.input.charCodeAt(this.state.pos + 1)
              return (code << 10) + next - 0x35fdc00
            }

            Tokenizer.prototype.pushComment = function pushComment(
              block,
              text,
              start,
              end,
              startLoc,
              endLoc
            ) {
              var comment = {
                type: block ? 'CommentBlock' : 'CommentLine',
                value: text,
                start: start,
                end: end,
                loc: new SourceLocation(startLoc, endLoc),
              }

              if (!this.isLookahead) {
                this.state.tokens.push(comment)
                this.state.comments.push(comment)
                this.addComment(comment)
              }
            }

            Tokenizer.prototype.skipBlockComment = function skipBlockComment() {
              var startLoc = this.state.curPosition()
              var start = this.state.pos
              var end = this.input.indexOf('*/', (this.state.pos += 2))
              if (end === -1)
                this.raise(this.state.pos - 2, 'Unterminated comment')

              this.state.pos = end + 2
              lineBreakG.lastIndex = start
              var match = void 0
              while (
                (match = lineBreakG.exec(this.input)) &&
                match.index < this.state.pos
              ) {
                ++this.state.curLine
                this.state.lineStart = match.index + match[0].length
              }

              this.pushComment(
                true,
                this.input.slice(start + 2, end),
                start,
                this.state.pos,
                startLoc,
                this.state.curPosition()
              )
            }

            Tokenizer.prototype.skipLineComment = function skipLineComment(
              startSkip
            ) {
              var start = this.state.pos
              var startLoc = this.state.curPosition()
              var ch = this.input.charCodeAt((this.state.pos += startSkip))
              while (
                this.state.pos < this.input.length &&
                ch !== 10 &&
                ch !== 13 &&
                ch !== 8232 &&
                ch !== 8233
              ) {
                ++this.state.pos
                ch = this.input.charCodeAt(this.state.pos)
              }

              this.pushComment(
                false,
                this.input.slice(start + startSkip, this.state.pos),
                start,
                this.state.pos,
                startLoc,
                this.state.curPosition()
              )
            }

            // Called at the start of the parse and after every token. Skips
            // whitespace and comments, and.

            Tokenizer.prototype.skipSpace = function skipSpace() {
              loop: while (this.state.pos < this.input.length) {
                var ch = this.input.charCodeAt(this.state.pos)
                switch (ch) {
                  case 32:
                  case 160:
                    // ' '
                    ++this.state.pos
                    break

                  case 13:
                    if (this.input.charCodeAt(this.state.pos + 1) === 10) {
                      ++this.state.pos
                    }

                  case 10:
                  case 8232:
                  case 8233:
                    ++this.state.pos
                    ++this.state.curLine
                    this.state.lineStart = this.state.pos
                    break

                  case 47:
                    // '/'
                    switch (this.input.charCodeAt(this.state.pos + 1)) {
                      case 42:
                        // '*'
                        this.skipBlockComment()
                        break

                      case 47:
                        this.skipLineComment(2)
                        break

                      default:
                        break loop
                    }
                    break

                  default:
                    if (
                      (ch > 8 && ch < 14) ||
                      (ch >= 5760 &&
                        nonASCIIwhitespace.test(String.fromCharCode(ch)))
                    ) {
                      ++this.state.pos
                    } else {
                      break loop
                    }
                }
              }
            }

            // Called at the end of every token. Sets `end`, `val`, and
            // maintains `context` and `exprAllowed`, and skips the space after
            // the token, so that the next one's `start` will point at the
            // right position.

            Tokenizer.prototype.finishToken = function finishToken(type, val) {
              this.state.end = this.state.pos
              this.state.endLoc = this.state.curPosition()
              var prevType = this.state.type
              this.state.type = type
              this.state.value = val

              this.updateContext(prevType)
            }

            // ### Token reading

            // This is the function that is called to fetch the next token. It
            // is somewhat obscure, because it works in character codes rather
            // than characters, and because operator parsing has been inlined
            // into it.
            //
            // All in the name of speed.
            //

            Tokenizer.prototype.readToken_dot = function readToken_dot() {
              var next = this.input.charCodeAt(this.state.pos + 1)
              if (next >= 48 && next <= 57) {
                return this.readNumber(true)
              }

              var next2 = this.input.charCodeAt(this.state.pos + 2)
              if (next === 46 && next2 === 46) {
                // 46 = dot '.'
                this.state.pos += 3
                return this.finishToken(types.ellipsis)
              } else {
                ++this.state.pos
                return this.finishToken(types.dot)
              }
            }

            Tokenizer.prototype.readToken_slash = function readToken_slash() {
              // '/'
              if (this.state.exprAllowed) {
                ++this.state.pos
                return this.readRegexp()
              }

              var next = this.input.charCodeAt(this.state.pos + 1)
              if (next === 61) {
                return this.finishOp(types.assign, 2)
              } else {
                return this.finishOp(types.slash, 1)
              }
            }

            Tokenizer.prototype.readToken_mult_modulo = function readToken_mult_modulo(
              code
            ) {
              // '%*'
              var type = code === 42 ? types.star : types.modulo
              var width = 1
              var next = this.input.charCodeAt(this.state.pos + 1)

              if (next === 42) {
                // '*'
                width++
                next = this.input.charCodeAt(this.state.pos + 2)
                type = types.exponent
              }

              if (next === 61) {
                width++
                type = types.assign
              }

              return this.finishOp(type, width)
            }

            Tokenizer.prototype.readToken_pipe_amp = function readToken_pipe_amp(
              code
            ) {
              // '|&'
              var next = this.input.charCodeAt(this.state.pos + 1)
              if (next === code)
                return this.finishOp(
                  code === 124 ? types.logicalOR : types.logicalAND,
                  2
                )
              if (next === 61) return this.finishOp(types.assign, 2)
              if (code === 124 && next === 125 && this.hasPlugin('flow'))
                return this.finishOp(types.braceBarR, 2)
              return this.finishOp(
                code === 124 ? types.bitwiseOR : types.bitwiseAND,
                1
              )
            }

            Tokenizer.prototype.readToken_caret = function readToken_caret() {
              // '^'
              var next = this.input.charCodeAt(this.state.pos + 1)
              if (next === 61) {
                return this.finishOp(types.assign, 2)
              } else {
                return this.finishOp(types.bitwiseXOR, 1)
              }
            }

            Tokenizer.prototype.readToken_plus_min = function readToken_plus_min(
              code
            ) {
              // '+-'
              var next = this.input.charCodeAt(this.state.pos + 1)

              if (next === code) {
                if (
                  next === 45 &&
                  this.input.charCodeAt(this.state.pos + 2) === 62 &&
                  lineBreak.test(
                    this.input.slice(this.state.lastTokEnd, this.state.pos)
                  )
                ) {
                  // A `-->` line comment
                  this.skipLineComment(3)
                  this.skipSpace()
                  return this.nextToken()
                }
                return this.finishOp(types.incDec, 2)
              }

              if (next === 61) {
                return this.finishOp(types.assign, 2)
              } else {
                return this.finishOp(types.plusMin, 1)
              }
            }

            Tokenizer.prototype.readToken_lt_gt = function readToken_lt_gt(
              code
            ) {
              // '<>'
              var next = this.input.charCodeAt(this.state.pos + 1)
              var size = 1

              if (next === code) {
                size = code === 62 &&
                  this.input.charCodeAt(this.state.pos + 2) === 62
                  ? 3
                  : 2
                if (this.input.charCodeAt(this.state.pos + size) === 61)
                  return this.finishOp(types.assign, size + 1)
                return this.finishOp(types.bitShift, size)
              }

              if (
                next === 33 &&
                code === 60 &&
                this.input.charCodeAt(this.state.pos + 2) === 45 &&
                this.input.charCodeAt(this.state.pos + 3) === 45
              ) {
                if (this.inModule) this.unexpected()
                // `<!--`, an XML-style comment that should be interpreted as a line comment
                this.skipLineComment(4)
                this.skipSpace()
                return this.nextToken()
              }

              if (next === 61) {
                // <= | >=
                size = 2
              }

              return this.finishOp(types.relational, size)
            }

            Tokenizer.prototype.readToken_eq_excl = function readToken_eq_excl(
              code
            ) {
              // '=!'
              var next = this.input.charCodeAt(this.state.pos + 1)
              if (next === 61)
                return this.finishOp(
                  types.equality,
                  this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2
                )
              if (code === 61 && next === 62) {
                // '=>'
                this.state.pos += 2
                return this.finishToken(types.arrow)
              }
              return this.finishOp(code === 61 ? types.eq : types.prefix, 1)
            }

            Tokenizer.prototype.getTokenFromCode = function getTokenFromCode(
              code
            ) {
              switch (code) {
                // The interpretation of a dot depends on whether it is followed
                // by a digit or another two dots.
                case 46:
                  // '.'
                  return this.readToken_dot()

                // Punctuation tokens.
                case 40:
                  ++this.state.pos
                  return this.finishToken(types.parenL)
                case 41:
                  ++this.state.pos
                  return this.finishToken(types.parenR)
                case 59:
                  ++this.state.pos
                  return this.finishToken(types.semi)
                case 44:
                  ++this.state.pos
                  return this.finishToken(types.comma)
                case 91:
                  ++this.state.pos
                  return this.finishToken(types.bracketL)
                case 93:
                  ++this.state.pos
                  return this.finishToken(types.bracketR)

                case 123:
                  if (
                    this.hasPlugin('flow') &&
                    this.input.charCodeAt(this.state.pos + 1) === 124
                  ) {
                    return this.finishOp(types.braceBarL, 2)
                  } else {
                    ++this.state.pos
                    return this.finishToken(types.braceL)
                  }

                case 125:
                  ++this.state.pos
                  return this.finishToken(types.braceR)

                case 58:
                  if (
                    this.hasPlugin('functionBind') &&
                    this.input.charCodeAt(this.state.pos + 1) === 58
                  ) {
                    return this.finishOp(types.doubleColon, 2)
                  } else {
                    ++this.state.pos
                    return this.finishToken(types.colon)
                  }

                case 63:
                  ++this.state.pos
                  return this.finishToken(types.question)
                case 64:
                  ++this.state.pos
                  return this.finishToken(types.at)

                case 96:
                  // '`'
                  ++this.state.pos
                  return this.finishToken(types.backQuote)

                case 48:
                  // '0'
                  var next = this.input.charCodeAt(this.state.pos + 1)
                  if (next === 120 || next === 88)
                    return this.readRadixNumber(16) // '0x', '0X' - hex number
                  if (next === 111 || next === 79)
                    return this.readRadixNumber(8) // '0o', '0O' - octal number
                  if (next === 98 || next === 66) return this.readRadixNumber(2) // '0b', '0B' - binary number
                // Anything else beginning with a digit is an integer, octal
                // number, or float.
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                case 56:
                case 57:
                  // 1-9
                  return this.readNumber(false)

                // Quotes produce strings.
                case 34:
                case 39:
                  // '"', "'"
                  return this.readString(code)

                // Operators are parsed inline in tiny state machines. '=' (61) is
                // often referred to. `finishOp` simply skips the amount of
                // characters it is given as second argument, and returns a token
                // of the type given by its first argument.

                case 47:
                  // '/'
                  return this.readToken_slash()

                case 37:
                case 42:
                  // '%*'
                  return this.readToken_mult_modulo(code)

                case 124:
                case 38:
                  // '|&'
                  return this.readToken_pipe_amp(code)

                case 94:
                  // '^'
                  return this.readToken_caret()

                case 43:
                case 45:
                  // '+-'
                  return this.readToken_plus_min(code)

                case 60:
                case 62:
                  // '<>'
                  return this.readToken_lt_gt(code)

                case 61:
                case 33:
                  // '=!'
                  return this.readToken_eq_excl(code)

                case 126:
                  // '~'
                  return this.finishOp(types.prefix, 1)
              }

              this.raise(
                this.state.pos,
                "Unexpected character '" + codePointToString(code) + "'"
              )
            }

            Tokenizer.prototype.finishOp = function finishOp(type, size) {
              var str = this.input.slice(this.state.pos, this.state.pos + size)
              this.state.pos += size
              return this.finishToken(type, str)
            }

            Tokenizer.prototype.readRegexp = function readRegexp() {
              var start = this.state.pos
              var escaped = void 0,
                inClass = void 0
              for (;;) {
                if (this.state.pos >= this.input.length)
                  this.raise(start, 'Unterminated regular expression')
                var ch = this.input.charAt(this.state.pos)
                if (lineBreak.test(ch)) {
                  this.raise(start, 'Unterminated regular expression')
                }
                if (escaped) {
                  escaped = false
                } else {
                  if (ch === '[') {
                    inClass = true
                  } else if (ch === ']' && inClass) {
                    inClass = false
                  } else if (ch === '/' && !inClass) {
                    break
                  }
                  escaped = ch === '\\'
                }
                ++this.state.pos
              }
              var content = this.input.slice(start, this.state.pos)
              ++this.state.pos
              // Need to use `readWord1` because '\uXXXX' sequences are allowed
              // here (don't ask).
              var mods = this.readWord1()
              if (mods) {
                var validFlags = /^[gmsiyu]*$/
                if (!validFlags.test(mods))
                  this.raise(start, 'Invalid regular expression flag')
              }
              return this.finishToken(types.regexp, {
                pattern: content,
                flags: mods,
              })
            }

            // Read an integer in the given radix. Return null if zero digits
            // were read, the integer value otherwise. When `len` is given, this
            // will return `null` unless the integer has exactly `len` digits.

            Tokenizer.prototype.readInt = function readInt(radix, len) {
              var start = this.state.pos
              var total = 0

              for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
                var code = this.input.charCodeAt(this.state.pos)
                var val = void 0
                if (code >= 97) {
                  val = code - 97 + 10 // a
                } else if (code >= 65) {
                  val = code - 65 + 10 // A
                } else if (code >= 48 && code <= 57) {
                  val = code - 48 // 0-9
                } else {
                  val = Infinity
                }
                if (val >= radix) break
                ++this.state.pos
                total = total * radix + val
              }
              if (
                this.state.pos === start ||
                (len != null && this.state.pos - start !== len)
              )
                return null

              return total
            }

            Tokenizer.prototype.readRadixNumber = function readRadixNumber(
              radix
            ) {
              this.state.pos += 2 // 0x
              var val = this.readInt(radix)
              if (val == null)
                this.raise(
                  this.state.start + 2,
                  'Expected number in radix ' + radix
                )
              if (isIdentifierStart(this.fullCharCodeAtPos()))
                this.raise(this.state.pos, 'Identifier directly after number')
              return this.finishToken(types.num, val)
            }

            // Read an integer, octal integer, or floating-point number.

            Tokenizer.prototype.readNumber = function readNumber(
              startsWithDot
            ) {
              var start = this.state.pos
              var octal = this.input.charCodeAt(this.state.pos) === 48
              var isFloat = false

              if (!startsWithDot && this.readInt(10) === null)
                this.raise(start, 'Invalid number')
              var next = this.input.charCodeAt(this.state.pos)
              if (next === 46) {
                // '.'
                ++this.state.pos
                this.readInt(10)
                isFloat = true
                next = this.input.charCodeAt(this.state.pos)
              }
              if (next === 69 || next === 101) {
                // 'eE'
                next = this.input.charCodeAt(++this.state.pos)
                if (next === 43 || next === 45) ++this.state.pos // '+-'
                if (this.readInt(10) === null)
                  this.raise(start, 'Invalid number')
                isFloat = true
              }
              if (isIdentifierStart(this.fullCharCodeAtPos()))
                this.raise(this.state.pos, 'Identifier directly after number')

              var str = this.input.slice(start, this.state.pos)
              var val = void 0
              if (isFloat) {
                val = parseFloat(str)
              } else if (!octal || str.length === 1) {
                val = parseInt(str, 10)
              } else if (/[89]/.test(str) || this.state.strict) {
                this.raise(start, 'Invalid number')
              } else {
                val = parseInt(str, 8)
              }
              return this.finishToken(types.num, val)
            }

            // Read a string value, interpreting backslash-escapes.

            Tokenizer.prototype.readCodePoint = function readCodePoint(
              throwOnInvalid
            ) {
              var ch = this.input.charCodeAt(this.state.pos)
              var code = void 0

              if (ch === 123) {
                // '{'
                var codePos = ++this.state.pos
                code = this.readHexChar(
                  this.input.indexOf('}', this.state.pos) - this.state.pos,
                  throwOnInvalid
                )
                ++this.state.pos
                if (code === null) {
                  --this.state.invalidTemplateEscapePosition // to point to the '\'' instead of the 'u'
                } else if (code > 0x10ffff) {
                  if (throwOnInvalid) {
                    this.raise(codePos, 'Code point out of bounds')
                  } else {
                    this.state.invalidTemplateEscapePosition = codePos - 2
                    return null
                  }
                }
              } else {
                code = this.readHexChar(4, throwOnInvalid)
              }
              return code
            }

            Tokenizer.prototype.readString = function readString(quote) {
              var out = '',
                chunkStart = ++this.state.pos
              for (;;) {
                if (this.state.pos >= this.input.length)
                  this.raise(this.state.start, 'Unterminated string constant')
                var ch = this.input.charCodeAt(this.state.pos)
                if (ch === quote) break
                if (ch === 92) {
                  // '\'
                  out += this.input.slice(chunkStart, this.state.pos)
                  out += this.readEscapedChar(false)
                  chunkStart = this.state.pos
                } else {
                  if (isNewLine(ch))
                    this.raise(this.state.start, 'Unterminated string constant')
                  ++this.state.pos
                }
              }
              out += this.input.slice(chunkStart, this.state.pos++)
              return this.finishToken(types.string, out)
            }

            // Reads template string tokens.

            Tokenizer.prototype.readTmplToken = function readTmplToken() {
              var out = '',
                chunkStart = this.state.pos,
                containsInvalid = false
              for (;;) {
                if (this.state.pos >= this.input.length)
                  this.raise(this.state.start, 'Unterminated template')
                var ch = this.input.charCodeAt(this.state.pos)
                if (
                  ch === 96 ||
                  (ch === 36 &&
                    this.input.charCodeAt(this.state.pos + 1) === 123)
                ) {
                  // '`', '${'
                  if (
                    this.state.pos === this.state.start &&
                    this.match(types.template)
                  ) {
                    if (ch === 36) {
                      this.state.pos += 2
                      return this.finishToken(types.dollarBraceL)
                    } else {
                      ++this.state.pos
                      return this.finishToken(types.backQuote)
                    }
                  }
                  out += this.input.slice(chunkStart, this.state.pos)
                  return this.finishToken(
                    types.template,
                    containsInvalid ? null : out
                  )
                }
                if (ch === 92) {
                  // '\'
                  out += this.input.slice(chunkStart, this.state.pos)
                  var escaped = this.readEscapedChar(true)
                  if (escaped === null) {
                    containsInvalid = true
                  } else {
                    out += escaped
                  }
                  chunkStart = this.state.pos
                } else if (isNewLine(ch)) {
                  out += this.input.slice(chunkStart, this.state.pos)
                  ++this.state.pos
                  switch (ch) {
                    case 13:
                      if (this.input.charCodeAt(this.state.pos) === 10)
                        ++this.state.pos
                    case 10:
                      out += '\n'
                      break
                    default:
                      out += String.fromCharCode(ch)
                      break
                  }
                  ++this.state.curLine
                  this.state.lineStart = this.state.pos
                  chunkStart = this.state.pos
                } else {
                  ++this.state.pos
                }
              }
            }

            // Used to read escaped characters

            Tokenizer.prototype.readEscapedChar = function readEscapedChar(
              inTemplate
            ) {
              var throwOnInvalid = !inTemplate
              var ch = this.input.charCodeAt(++this.state.pos)
              ++this.state.pos
              switch (ch) {
                case 110:
                  return '\n' // 'n' -> '\n'
                case 114:
                  return '\r' // 'r' -> '\r'
                case 120: {
                  // 'x'
                  var code = this.readHexChar(2, throwOnInvalid)
                  return code === null ? null : String.fromCharCode(code)
                }
                case 117: {
                  // 'u'
                  var _code = this.readCodePoint(throwOnInvalid)
                  return _code === null ? null : codePointToString(_code)
                }
                case 116:
                  return '\t' // 't' -> '\t'
                case 98:
                  return '\b' // 'b' -> '\b'
                case 118:
                  return '\x0B' // 'v' -> '\u000b'
                case 102:
                  return '\f' // 'f' -> '\f'
                case 13:
                  if (this.input.charCodeAt(this.state.pos) === 10)
                    ++this.state.pos // '\r\n'
                case 10:
                  // ' \n'
                  this.state.lineStart = this.state.pos
                  ++this.state.curLine
                  return ''
                default:
                  if (ch >= 48 && ch <= 55) {
                    var codePos = this.state.pos - 1
                    var octalStr = this.input
                      .substr(this.state.pos - 1, 3)
                      .match(/^[0-7]+/)[0]
                    var octal = parseInt(octalStr, 8)
                    if (octal > 255) {
                      octalStr = octalStr.slice(0, -1)
                      octal = parseInt(octalStr, 8)
                    }
                    if (octal > 0) {
                      if (inTemplate) {
                        this.state.invalidTemplateEscapePosition = codePos
                        return null
                      } else if (this.state.strict) {
                        this.raise(codePos, 'Octal literal in strict mode')
                      } else if (!this.state.containsOctal) {
                        // These properties are only used to throw an error for an octal which occurs
                        // in a directive which occurs prior to a "use strict" directive.
                        this.state.containsOctal = true
                        this.state.octalPosition = codePos
                      }
                    }
                    this.state.pos += octalStr.length - 1
                    return String.fromCharCode(octal)
                  }
                  return String.fromCharCode(ch)
              }
            }

            // Used to read character escape sequences ('\x', '\u').

            Tokenizer.prototype.readHexChar = function readHexChar(
              len,
              throwOnInvalid
            ) {
              var codePos = this.state.pos
              var n = this.readInt(16, len)
              if (n === null) {
                if (throwOnInvalid) {
                  this.raise(codePos, 'Bad character escape sequence')
                } else {
                  this.state.pos = codePos - 1
                  this.state.invalidTemplateEscapePosition = codePos - 1
                }
              }
              return n
            }

            // Read an identifier, and return it as a string. Sets `this.state.containsEsc`
            // to whether the word contained a '\u' escape.
            //
            // Incrementally adds only escaped chars, adding other chunks as-is
            // as a micro-optimization.

            Tokenizer.prototype.readWord1 = function readWord1() {
              this.state.containsEsc = false
              var word = '',
                first = true,
                chunkStart = this.state.pos
              while (this.state.pos < this.input.length) {
                var ch = this.fullCharCodeAtPos()
                if (isIdentifierChar(ch)) {
                  this.state.pos += ch <= 0xffff ? 1 : 2
                } else if (ch === 92) {
                  // "\"
                  this.state.containsEsc = true

                  word += this.input.slice(chunkStart, this.state.pos)
                  var escStart = this.state.pos

                  if (this.input.charCodeAt(++this.state.pos) !== 117) {
                    // "u"
                    this.raise(
                      this.state.pos,
                      'Expecting Unicode escape sequence \\uXXXX'
                    )
                  }

                  ++this.state.pos
                  var esc = this.readCodePoint(true)
                  if (
                    !(first ? isIdentifierStart : isIdentifierChar)(esc, true)
                  ) {
                    this.raise(escStart, 'Invalid Unicode escape')
                  }

                  word += codePointToString(esc)
                  chunkStart = this.state.pos
                } else {
                  break
                }
                first = false
              }
              return word + this.input.slice(chunkStart, this.state.pos)
            }

            // Read an identifier or keyword token. Will check for reserved
            // words when necessary.

            Tokenizer.prototype.readWord = function readWord() {
              var word = this.readWord1()
              var type = types.name
              if (!this.state.containsEsc && this.isKeyword(word)) {
                type = keywords[word]
              }
              return this.finishToken(type, word)
            }

            Tokenizer.prototype.braceIsBlock = function braceIsBlock(prevType) {
              if (prevType === types.colon) {
                var parent = this.curContext()
                if (
                  parent === types$1.braceStatement ||
                  parent === types$1.braceExpression
                ) {
                  return !parent.isExpr
                }
              }

              if (prevType === types._return) {
                return lineBreak.test(
                  this.input.slice(this.state.lastTokEnd, this.state.start)
                )
              }

              if (
                prevType === types._else ||
                prevType === types.semi ||
                prevType === types.eof ||
                prevType === types.parenR
              ) {
                return true
              }

              if (prevType === types.braceL) {
                return this.curContext() === types$1.braceStatement
              }

              return !this.state.exprAllowed
            }

            Tokenizer.prototype.updateContext = function updateContext(
              prevType
            ) {
              var type = this.state.type
              var update = void 0

              if (type.keyword && prevType === types.dot) {
                this.state.exprAllowed = false
              } else if ((update = type.updateContext)) {
                update.call(this, prevType)
              } else {
                this.state.exprAllowed = type.beforeExpr
              }
            }

            return Tokenizer
          })()

          var plugins = {}
          var frozenDeprecatedWildcardPluginList = [
            'jsx',
            'doExpressions',
            'objectRestSpread',
            'decorators',
            'classProperties',
            'exportExtensions',
            'asyncGenerators',
            'functionBind',
            'functionSent',
            'dynamicImport',
            'flow',
          ]

          var Parser = (function(_Tokenizer) {
            inherits(Parser, _Tokenizer)

            function Parser(options, input) {
              classCallCheck(this, Parser)

              options = getOptions(options)

              var _this = possibleConstructorReturn(
                this,
                _Tokenizer.call(this, options, input)
              )

              _this.options = options
              _this.inModule = _this.options.sourceType === 'module'
              _this.input = input
              _this.plugins = _this.loadPlugins(_this.options.plugins)
              _this.filename = options.sourceFilename

              // If enabled, skip leading hashbang line.
              if (
                _this.state.pos === 0 &&
                _this.input[0] === '#' &&
                _this.input[1] === '!'
              ) {
                _this.skipLineComment(2)
              }
              return _this
            }

            Parser.prototype.isReservedWord = function isReservedWord(word) {
              if (word === 'await') {
                return this.inModule
              } else {
                return reservedWords[6](word)
              }
            }

            Parser.prototype.hasPlugin = function hasPlugin(name) {
              if (
                this.plugins['*'] &&
                frozenDeprecatedWildcardPluginList.indexOf(name) > -1
              ) {
                return true
              }

              return !!this.plugins[name]
            }

            Parser.prototype.extend = function extend(name, f) {
              this[name] = f(this[name])
            }

            Parser.prototype.loadAllPlugins = function loadAllPlugins() {
              var _this2 = this

              // ensure flow plugin loads last, also ensure estree is not loaded with *
              var pluginNames = Object.keys(plugins).filter(function(name) {
                return name !== 'flow' && name !== 'estree'
              })
              pluginNames.push('flow')

              pluginNames.forEach(function(name) {
                var plugin = plugins[name]
                if (plugin) plugin(_this2)
              })
            }

            Parser.prototype.loadPlugins = function loadPlugins(pluginList) {
              // TODO: Deprecate "*" option in next major version of Babylon
              if (pluginList.indexOf('*') >= 0) {
                this.loadAllPlugins()

                return { '*': true }
              }

              var pluginMap = {}

              if (pluginList.indexOf('flow') >= 0) {
                // ensure flow plugin loads last
                pluginList = pluginList.filter(function(plugin) {
                  return plugin !== 'flow'
                })
                pluginList.push('flow')
              }

              if (pluginList.indexOf('estree') >= 0) {
                // ensure estree plugin loads first
                pluginList = pluginList.filter(function(plugin) {
                  return plugin !== 'estree'
                })
                pluginList.unshift('estree')
              }

              for (
                var _iterator = pluginList,
                  _isArray = Array.isArray(_iterator),
                  _i = 0,
                  _iterator = _isArray
                    ? _iterator
                    : _iterator[Symbol.iterator]();
                ;

              ) {
                var _ref

                if (_isArray) {
                  if (_i >= _iterator.length) break
                  _ref = _iterator[_i++]
                } else {
                  _i = _iterator.next()
                  if (_i.done) break
                  _ref = _i.value
                }

                var name = _ref

                if (!pluginMap[name]) {
                  pluginMap[name] = true

                  var plugin = plugins[name]
                  if (plugin) plugin(this)
                }
              }

              return pluginMap
            }

            Parser.prototype.parse = function parse() {
              var file = this.startNode()
              var program = this.startNode()
              this.nextToken()
              return this.parseTopLevel(file, program)
            }

            return Parser
          })(Tokenizer)

          var pp = Parser.prototype

          // ## Parser utilities

          // TODO

          pp.addExtra = function(node, key, val) {
            if (!node) return

            var extra = (node.extra = node.extra || {})
            extra[key] = val
          }

          // TODO

          pp.isRelational = function(op) {
            return this.match(types.relational) && this.state.value === op
          }

          // TODO

          pp.expectRelational = function(op) {
            if (this.isRelational(op)) {
              this.next()
            } else {
              this.unexpected(null, types.relational)
            }
          }

          // Tests whether parsed token is a contextual keyword.

          pp.isContextual = function(name) {
            return this.match(types.name) && this.state.value === name
          }

          // Consumes contextual keyword if possible.

          pp.eatContextual = function(name) {
            return this.state.value === name && this.eat(types.name)
          }

          // Asserts that following token is given contextual keyword.

          pp.expectContextual = function(name, message) {
            if (!this.eatContextual(name)) this.unexpected(null, message)
          }

          // Test whether a semicolon can be inserted at the current position.

          pp.canInsertSemicolon = function() {
            return (
              this.match(types.eof) ||
              this.match(types.braceR) ||
              lineBreak.test(
                this.input.slice(this.state.lastTokEnd, this.state.start)
              )
            )
          }

          // TODO

          pp.isLineTerminator = function() {
            return this.eat(types.semi) || this.canInsertSemicolon()
          }

          // Consume a semicolon, or, failing that, see if we are allowed to
          // pretend that there is a semicolon at this position.

          pp.semicolon = function() {
            if (!this.isLineTerminator()) this.unexpected(null, types.semi)
          }

          // Expect a token of a given type. If found, consume it, otherwise,
          // raise an unexpected token error at given pos.

          pp.expect = function(type, pos) {
            return this.eat(type) || this.unexpected(pos, type)
          }

          // Raise an unexpected token error. Can take the expected token type
          // instead of a message string.

          pp.unexpected = function(pos) {
            var messageOrType = arguments.length > 1 &&
              arguments[1] !== undefined
              ? arguments[1]
              : 'Unexpected token'

            if (
              messageOrType &&
              (typeof messageOrType === 'undefined'
                ? 'undefined'
                : _typeof(messageOrType)) === 'object' &&
              messageOrType.label
            ) {
              messageOrType =
                'Unexpected token, expected ' + messageOrType.label
            }
            this.raise(pos != null ? pos : this.state.start, messageOrType)
          }

          /* eslint max-len: 0 */

          var pp$1 = Parser.prototype

          // ### Statement parsing

          // Parse a program. Initializes the parser, reads any number of
          // statements, and wraps them in a Program node.  Optionally takes a
          // `program` argument.  If present, the statements will be appended
          // to its body instead of creating a new node.

          pp$1.parseTopLevel = function(file, program) {
            program.sourceType = this.options.sourceType

            this.parseBlockBody(program, true, true, types.eof)

            file.program = this.finishNode(program, 'Program')
            file.comments = this.state.comments
            file.tokens = this.state.tokens

            return this.finishNode(file, 'File')
          }

          var loopLabel = { kind: 'loop' }
          var switchLabel = { kind: 'switch' }

          // TODO

          pp$1.stmtToDirective = function(stmt) {
            var expr = stmt.expression

            var directiveLiteral = this.startNodeAt(expr.start, expr.loc.start)
            var directive = this.startNodeAt(stmt.start, stmt.loc.start)

            var raw = this.input.slice(expr.start, expr.end)
            var val = (directiveLiteral.value = raw.slice(1, -1)) // remove quotes

            this.addExtra(directiveLiteral, 'raw', raw)
            this.addExtra(directiveLiteral, 'rawValue', val)

            directive.value = this.finishNodeAt(
              directiveLiteral,
              'DirectiveLiteral',
              expr.end,
              expr.loc.end
            )

            return this.finishNodeAt(
              directive,
              'Directive',
              stmt.end,
              stmt.loc.end
            )
          }

          // Parse a single statement.
          //
          // If expecting a statement and finding a slash operator, parse a
          // regular expression literal. This is to handle cases like
          // `if (foo) /blah/.exec(foo)`, where looking at the previous token
          // does not help.

          pp$1.parseStatement = function(declaration, topLevel) {
            if (this.match(types.at)) {
              this.parseDecorators(true)
            }

            var starttype = this.state.type
            var node = this.startNode()

            // Most types of statements are recognized by the keyword they
            // start with. Many are trivial to parse, some require a bit of
            // complexity.

            switch (starttype) {
              case types._break:
              case types._continue:
                return this.parseBreakContinueStatement(node, starttype.keyword)
              case types._debugger:
                return this.parseDebuggerStatement(node)
              case types._do:
                return this.parseDoStatement(node)
              case types._for:
                return this.parseForStatement(node)
              case types._function:
                if (!declaration) this.unexpected()
                return this.parseFunctionStatement(node)

              case types._class:
                if (!declaration) this.unexpected()
                return this.parseClass(node, true)

              case types._if:
                return this.parseIfStatement(node)
              case types._return:
                return this.parseReturnStatement(node)
              case types._switch:
                return this.parseSwitchStatement(node)
              case types._throw:
                return this.parseThrowStatement(node)
              case types._try:
                return this.parseTryStatement(node)

              case types._let:
              case types._const:
                if (!declaration) this.unexpected() // NOTE: falls through to _var

              case types._var:
                return this.parseVarStatement(node, starttype)

              case types._while:
                return this.parseWhileStatement(node)
              case types._with:
                return this.parseWithStatement(node)
              case types.braceL:
                return this.parseBlock()
              case types.semi:
                return this.parseEmptyStatement(node)
              case types._export:
              case types._import:
                if (
                  this.hasPlugin('dynamicImport') &&
                  this.lookahead().type === types.parenL
                )
                  break

                if (!this.options.allowImportExportEverywhere) {
                  if (!topLevel) {
                    this.raise(
                      this.state.start,
                      "'import' and 'export' may only appear at the top level"
                    )
                  }

                  if (!this.inModule) {
                    this.raise(
                      this.state.start,
                      "'import' and 'export' may appear only with 'sourceType: module'"
                    )
                  }
                }
                return starttype === types._import
                  ? this.parseImport(node)
                  : this.parseExport(node)

              case types.name:
                if (this.state.value === 'async') {
                  // peek ahead and see if next token is a function
                  var state = this.state.clone()
                  this.next()
                  if (
                    this.match(types._function) &&
                    !this.canInsertSemicolon()
                  ) {
                    this.expect(types._function)
                    return this.parseFunction(node, true, false, true)
                  } else {
                    this.state = state
                  }
                }
            }

            // If the statement does not start with a statement keyword or a
            // brace, it's an ExpressionStatement or LabeledStatement. We
            // simply start parsing an expression, and afterwards, if the
            // next token is a colon and the expression was a simple
            // Identifier node, we switch to interpreting it as a label.
            var maybeName = this.state.value
            var expr = this.parseExpression()

            if (
              starttype === types.name &&
              expr.type === 'Identifier' &&
              this.eat(types.colon)
            ) {
              return this.parseLabeledStatement(node, maybeName, expr)
            } else {
              return this.parseExpressionStatement(node, expr)
            }
          }

          pp$1.takeDecorators = function(node) {
            if (this.state.decorators.length) {
              node.decorators = this.state.decorators
              this.state.decorators = []
            }
          }

          pp$1.parseDecorators = function(allowExport) {
            while (this.match(types.at)) {
              var decorator = this.parseDecorator()
              this.state.decorators.push(decorator)
            }

            if (allowExport && this.match(types._export)) {
              return
            }

            if (!this.match(types._class)) {
              this.raise(
                this.state.start,
                'Leading decorators must be attached to a class declaration'
              )
            }
          }

          pp$1.parseDecorator = function() {
            if (!this.hasPlugin('decorators')) {
              this.unexpected()
            }
            var node = this.startNode()
            this.next()
            node.expression = this.parseMaybeAssign()
            return this.finishNode(node, 'Decorator')
          }

          pp$1.parseBreakContinueStatement = function(node, keyword) {
            var isBreak = keyword === 'break'
            this.next()

            if (this.isLineTerminator()) {
              node.label = null
            } else if (!this.match(types.name)) {
              this.unexpected()
            } else {
              node.label = this.parseIdentifier()
              this.semicolon()
            }

            // Verify that there is an actual destination to break or
            // continue to.
            var i = void 0
            for (i = 0; i < this.state.labels.length; ++i) {
              var lab = this.state.labels[i]
              if (node.label == null || lab.name === node.label.name) {
                if (lab.kind != null && (isBreak || lab.kind === 'loop')) break
                if (node.label && isBreak) break
              }
            }
            if (i === this.state.labels.length)
              this.raise(node.start, 'Unsyntactic ' + keyword)
            return this.finishNode(
              node,
              isBreak ? 'BreakStatement' : 'ContinueStatement'
            )
          }

          pp$1.parseDebuggerStatement = function(node) {
            this.next()
            this.semicolon()
            return this.finishNode(node, 'DebuggerStatement')
          }

          pp$1.parseDoStatement = function(node) {
            this.next()
            this.state.labels.push(loopLabel)
            node.body = this.parseStatement(false)
            this.state.labels.pop()
            this.expect(types._while)
            node.test = this.parseParenExpression()
            this.eat(types.semi)
            return this.finishNode(node, 'DoWhileStatement')
          }

          // Disambiguating between a `for` and a `for`/`in` or `for`/`of`
          // loop is non-trivial. Basically, we have to parse the init `var`
          // statement or expression, disallowing the `in` operator (see
          // the second parameter to `parseExpression`), and then check
          // whether the next token is `in` or `of`. When there is no init
          // part (semicolon immediately after the opening parenthesis), it
          // is a regular `for` loop.

          pp$1.parseForStatement = function(node) {
            this.next()
            this.state.labels.push(loopLabel)

            var forAwait = false
            if (
              this.hasPlugin('asyncGenerators') &&
              this.state.inAsync &&
              this.isContextual('await')
            ) {
              forAwait = true
              this.next()
            }
            this.expect(types.parenL)

            if (this.match(types.semi)) {
              if (forAwait) {
                this.unexpected()
              }
              return this.parseFor(node, null)
            }

            if (
              this.match(types._var) ||
              this.match(types._let) ||
              this.match(types._const)
            ) {
              var _init = this.startNode()
              var varKind = this.state.type
              this.next()
              this.parseVar(_init, true, varKind)
              this.finishNode(_init, 'VariableDeclaration')

              if (this.match(types._in) || this.isContextual('of')) {
                if (
                  _init.declarations.length === 1 &&
                  !_init.declarations[0].init
                ) {
                  return this.parseForIn(node, _init, forAwait)
                }
              }
              if (forAwait) {
                this.unexpected()
              }
              return this.parseFor(node, _init)
            }

            var refShorthandDefaultPos = { start: 0 }
            var init = this.parseExpression(true, refShorthandDefaultPos)
            if (this.match(types._in) || this.isContextual('of')) {
              var description = this.isContextual('of')
                ? 'for-of statement'
                : 'for-in statement'
              this.toAssignable(init, undefined, description)
              this.checkLVal(init, undefined, undefined, description)
              return this.parseForIn(node, init, forAwait)
            } else if (refShorthandDefaultPos.start) {
              this.unexpected(refShorthandDefaultPos.start)
            }
            if (forAwait) {
              this.unexpected()
            }
            return this.parseFor(node, init)
          }

          pp$1.parseFunctionStatement = function(node) {
            this.next()
            return this.parseFunction(node, true)
          }

          pp$1.parseIfStatement = function(node) {
            this.next()
            node.test = this.parseParenExpression()
            node.consequent = this.parseStatement(false)
            node.alternate = this.eat(types._else)
              ? this.parseStatement(false)
              : null
            return this.finishNode(node, 'IfStatement')
          }

          pp$1.parseReturnStatement = function(node) {
            if (
              !this.state.inFunction &&
              !this.options.allowReturnOutsideFunction
            ) {
              this.raise(this.state.start, "'return' outside of function")
            }

            this.next()

            // In `return` (and `break`/`continue`), the keywords with
            // optional arguments, we eagerly look for a semicolon or the
            // possibility to insert one.

            if (this.isLineTerminator()) {
              node.argument = null
            } else {
              node.argument = this.parseExpression()
              this.semicolon()
            }

            return this.finishNode(node, 'ReturnStatement')
          }

          pp$1.parseSwitchStatement = function(node) {
            this.next()
            node.discriminant = this.parseParenExpression()
            node.cases = []
            this.expect(types.braceL)
            this.state.labels.push(switchLabel)

            // Statements under must be grouped (by label) in SwitchCase
            // nodes. `cur` is used to keep the node that we are currently
            // adding statements to.

            var cur = void 0
            for (var sawDefault; !this.match(types.braceR); ) {
              if (this.match(types._case) || this.match(types._default)) {
                var isCase = this.match(types._case)
                if (cur) this.finishNode(cur, 'SwitchCase')
                node.cases.push((cur = this.startNode()))
                cur.consequent = []
                this.next()
                if (isCase) {
                  cur.test = this.parseExpression()
                } else {
                  if (sawDefault)
                    this.raise(
                      this.state.lastTokStart,
                      'Multiple default clauses'
                    )
                  sawDefault = true
                  cur.test = null
                }
                this.expect(types.colon)
              } else {
                if (cur) {
                  cur.consequent.push(this.parseStatement(true))
                } else {
                  this.unexpected()
                }
              }
            }
            if (cur) this.finishNode(cur, 'SwitchCase')
            this.next() // Closing brace
            this.state.labels.pop()
            return this.finishNode(node, 'SwitchStatement')
          }

          pp$1.parseThrowStatement = function(node) {
            this.next()
            if (
              lineBreak.test(
                this.input.slice(this.state.lastTokEnd, this.state.start)
              )
            )
              this.raise(this.state.lastTokEnd, 'Illegal newline after throw')
            node.argument = this.parseExpression()
            this.semicolon()
            return this.finishNode(node, 'ThrowStatement')
          }

          // Reused empty array added for node fields that are always empty.

          var empty = []

          pp$1.parseTryStatement = function(node) {
            this.next()

            node.block = this.parseBlock()
            node.handler = null

            if (this.match(types._catch)) {
              var clause = this.startNode()
              this.next()

              this.expect(types.parenL)
              clause.param = this.parseBindingAtom()
              this.checkLVal(
                clause.param,
                true,
                Object.create(null),
                'catch clause'
              )
              this.expect(types.parenR)

              clause.body = this.parseBlock()
              node.handler = this.finishNode(clause, 'CatchClause')
            }

            node.guardedHandlers = empty
            node.finalizer = this.eat(types._finally) ? this.parseBlock() : null

            if (!node.handler && !node.finalizer) {
              this.raise(node.start, 'Missing catch or finally clause')
            }

            return this.finishNode(node, 'TryStatement')
          }

          pp$1.parseVarStatement = function(node, kind) {
            this.next()
            this.parseVar(node, false, kind)
            this.semicolon()
            return this.finishNode(node, 'VariableDeclaration')
          }

          pp$1.parseWhileStatement = function(node) {
            this.next()
            node.test = this.parseParenExpression()
            this.state.labels.push(loopLabel)
            node.body = this.parseStatement(false)
            this.state.labels.pop()
            return this.finishNode(node, 'WhileStatement')
          }

          pp$1.parseWithStatement = function(node) {
            if (this.state.strict)
              this.raise(this.state.start, "'with' in strict mode")
            this.next()
            node.object = this.parseParenExpression()
            node.body = this.parseStatement(false)
            return this.finishNode(node, 'WithStatement')
          }

          pp$1.parseEmptyStatement = function(node) {
            this.next()
            return this.finishNode(node, 'EmptyStatement')
          }

          pp$1.parseLabeledStatement = function(node, maybeName, expr) {
            for (
              var _iterator = this.state.labels,
                _isArray = Array.isArray(_iterator),
                _i = 0,
                _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();
              ;

            ) {
              var _ref

              if (_isArray) {
                if (_i >= _iterator.length) break
                _ref = _iterator[_i++]
              } else {
                _i = _iterator.next()
                if (_i.done) break
                _ref = _i.value
              }

              var _label = _ref

              if (_label.name === maybeName) {
                this.raise(
                  expr.start,
                  "Label '" + maybeName + "' is already declared"
                )
              }
            }

            var kind = this.state.type.isLoop
              ? 'loop'
              : this.match(types._switch) ? 'switch' : null
            for (var i = this.state.labels.length - 1; i >= 0; i--) {
              var label = this.state.labels[i]
              if (label.statementStart === node.start) {
                label.statementStart = this.state.start
                label.kind = kind
              } else {
                break
              }
            }

            this.state.labels.push({
              name: maybeName,
              kind: kind,
              statementStart: this.state.start,
            })
            node.body = this.parseStatement(true)
            this.state.labels.pop()
            node.label = expr
            return this.finishNode(node, 'LabeledStatement')
          }

          pp$1.parseExpressionStatement = function(node, expr) {
            node.expression = expr
            this.semicolon()
            return this.finishNode(node, 'ExpressionStatement')
          }

          // Parse a semicolon-enclosed block of statements, handling `"use
          // strict"` declarations when `allowStrict` is true (used for
          // function bodies).

          pp$1.parseBlock = function(allowDirectives) {
            var node = this.startNode()
            this.expect(types.braceL)
            this.parseBlockBody(node, allowDirectives, false, types.braceR)
            return this.finishNode(node, 'BlockStatement')
          }

          pp$1.isValidDirective = function(stmt) {
            return (
              stmt.type === 'ExpressionStatement' &&
              stmt.expression.type === 'StringLiteral' &&
              !stmt.expression.extra.parenthesized
            )
          }

          pp$1.parseBlockBody = function(node, allowDirectives, topLevel, end) {
            node.body = []
            node.directives = []

            var parsedNonDirective = false
            var oldStrict = void 0
            var octalPosition = void 0

            while (!this.eat(end)) {
              if (
                !parsedNonDirective &&
                this.state.containsOctal &&
                !octalPosition
              ) {
                octalPosition = this.state.octalPosition
              }

              var stmt = this.parseStatement(true, topLevel)

              if (
                allowDirectives &&
                !parsedNonDirective &&
                this.isValidDirective(stmt)
              ) {
                var directive = this.stmtToDirective(stmt)
                node.directives.push(directive)

                if (
                  oldStrict === undefined &&
                  directive.value.value === 'use strict'
                ) {
                  oldStrict = this.state.strict
                  this.setStrict(true)

                  if (octalPosition) {
                    this.raise(octalPosition, 'Octal literal in strict mode')
                  }
                }

                continue
              }

              parsedNonDirective = true
              node.body.push(stmt)
            }

            if (oldStrict === false) {
              this.setStrict(false)
            }
          }

          // Parse a regular `for` loop. The disambiguation code in
          // `parseStatement` will already have parsed the init statement or
          // expression.

          pp$1.parseFor = function(node, init) {
            node.init = init
            this.expect(types.semi)
            node.test = this.match(types.semi) ? null : this.parseExpression()
            this.expect(types.semi)
            node.update = this.match(types.parenR)
              ? null
              : this.parseExpression()
            this.expect(types.parenR)
            node.body = this.parseStatement(false)
            this.state.labels.pop()
            return this.finishNode(node, 'ForStatement')
          }

          // Parse a `for`/`in` and `for`/`of` loop, which are almost
          // same from parser's perspective.

          pp$1.parseForIn = function(node, init, forAwait) {
            var type = void 0
            if (forAwait) {
              this.eatContextual('of')
              type = 'ForAwaitStatement'
            } else {
              type = this.match(types._in) ? 'ForInStatement' : 'ForOfStatement'
              this.next()
            }
            node.left = init
            node.right = this.parseExpression()
            this.expect(types.parenR)
            node.body = this.parseStatement(false)
            this.state.labels.pop()
            return this.finishNode(node, type)
          }

          // Parse a list of variable declarations.

          pp$1.parseVar = function(node, isFor, kind) {
            node.declarations = []
            node.kind = kind.keyword
            for (;;) {
              var decl = this.startNode()
              this.parseVarHead(decl)
              if (this.eat(types.eq)) {
                decl.init = this.parseMaybeAssign(isFor)
              } else if (
                kind === types._const &&
                !(this.match(types._in) || this.isContextual('of'))
              ) {
                this.unexpected()
              } else if (
                decl.id.type !== 'Identifier' &&
                !(isFor && (this.match(types._in) || this.isContextual('of')))
              ) {
                this.raise(
                  this.state.lastTokEnd,
                  'Complex binding patterns require an initialization value'
                )
              } else {
                decl.init = null
              }
              node.declarations.push(
                this.finishNode(decl, 'VariableDeclarator')
              )
              if (!this.eat(types.comma)) break
            }
            return node
          }

          pp$1.parseVarHead = function(decl) {
            decl.id = this.parseBindingAtom()
            this.checkLVal(decl.id, true, undefined, 'variable declaration')
          }

          // Parse a function declaration or literal (depending on the
          // `isStatement` parameter).

          pp$1.parseFunction = function(
            node,
            isStatement,
            allowExpressionBody,
            isAsync,
            optionalId
          ) {
            var oldInMethod = this.state.inMethod
            this.state.inMethod = false

            this.initFunction(node, isAsync)

            if (this.match(types.star)) {
              if (node.async && !this.hasPlugin('asyncGenerators')) {
                this.unexpected()
              } else {
                node.generator = true
                this.next()
              }
            }

            if (
              isStatement &&
              !optionalId &&
              !this.match(types.name) &&
              !this.match(types._yield)
            ) {
              this.unexpected()
            }

            if (this.match(types.name) || this.match(types._yield)) {
              node.id = this.parseBindingIdentifier()
            }

            this.parseFunctionParams(node)
            this.parseFunctionBody(node, allowExpressionBody)

            this.state.inMethod = oldInMethod

            return this.finishNode(
              node,
              isStatement ? 'FunctionDeclaration' : 'FunctionExpression'
            )
          }

          pp$1.parseFunctionParams = function(node) {
            this.expect(types.parenL)
            node.params = this.parseBindingList(types.parenR)
          }

          // Parse a class declaration or literal (depending on the
          // `isStatement` parameter).

          pp$1.parseClass = function(node, isStatement, optionalId) {
            this.next()
            this.takeDecorators(node)
            this.parseClassId(node, isStatement, optionalId)
            this.parseClassSuper(node)
            this.parseClassBody(node)
            return this.finishNode(
              node,
              isStatement ? 'ClassDeclaration' : 'ClassExpression'
            )
          }

          pp$1.isClassProperty = function() {
            return (
              this.match(types.eq) ||
              this.match(types.semi) ||
              this.match(types.braceR)
            )
          }

          pp$1.isClassMethod = function() {
            return this.match(types.parenL)
          }

          pp$1.isNonstaticConstructor = function(method) {
            return (
              !method.computed &&
              !method.static &&
              (method.key.name === 'constructor' || // Identifier
                method.key.value === 'constructor') // Literal
            )
          }

          pp$1.parseClassBody = function(node) {
            // class bodies are implicitly strict
            var oldStrict = this.state.strict
            this.state.strict = true

            var hadConstructorCall = false
            var hadConstructor = false
            var decorators = []
            var classBody = this.startNode()

            classBody.body = []

            this.expect(types.braceL)

            while (!this.eat(types.braceR)) {
              if (this.eat(types.semi)) {
                if (decorators.length > 0) {
                  this.raise(
                    this.state.lastTokEnd,
                    'Decorators must not be followed by a semicolon'
                  )
                }
                continue
              }

              if (this.match(types.at)) {
                decorators.push(this.parseDecorator())
                continue
              }

              var method = this.startNode()

              // steal the decorators if there are any
              if (decorators.length) {
                method.decorators = decorators
                decorators = []
              }

              method.static = false
              if (this.match(types.name) && this.state.value === 'static') {
                var key = this.parseIdentifier(true) // eats 'static'
                if (this.isClassMethod()) {
                  // a method named 'static'
                  method.kind = 'method'
                  method.computed = false
                  method.key = key
                  this.parseClassMethod(classBody, method, false, false)
                  continue
                } else if (this.isClassProperty()) {
                  // a property named 'static'
                  method.computed = false
                  method.key = key
                  classBody.body.push(this.parseClassProperty(method))
                  continue
                }
                // otherwise something static
                method.static = true
              }

              if (this.eat(types.star)) {
                // a generator
                method.kind = 'method'
                this.parsePropertyName(method)
                if (this.isNonstaticConstructor(method)) {
                  this.raise(
                    method.key.start,
                    "Constructor can't be a generator"
                  )
                }
                if (
                  !method.computed &&
                  method.static &&
                  (method.key.name === 'prototype' ||
                    method.key.value === 'prototype')
                ) {
                  this.raise(
                    method.key.start,
                    'Classes may not have static property named prototype'
                  )
                }
                this.parseClassMethod(classBody, method, true, false)
              } else {
                var isSimple = this.match(types.name)
                var _key = this.parsePropertyName(method)
                if (
                  !method.computed &&
                  method.static &&
                  (method.key.name === 'prototype' ||
                    method.key.value === 'prototype')
                ) {
                  this.raise(
                    method.key.start,
                    'Classes may not have static property named prototype'
                  )
                }
                if (this.isClassMethod()) {
                  // a normal method
                  if (this.isNonstaticConstructor(method)) {
                    if (hadConstructor) {
                      this.raise(
                        _key.start,
                        'Duplicate constructor in the same class'
                      )
                    } else if (method.decorators) {
                      this.raise(
                        method.start,
                        "You can't attach decorators to a class constructor"
                      )
                    }
                    hadConstructor = true
                    method.kind = 'constructor'
                  } else {
                    method.kind = 'method'
                  }
                  this.parseClassMethod(classBody, method, false, false)
                } else if (this.isClassProperty()) {
                  // a normal property
                  if (this.isNonstaticConstructor(method)) {
                    this.raise(
                      method.key.start,
                      "Classes may not have a non-static field named 'constructor'"
                    )
                  }
                  classBody.body.push(this.parseClassProperty(method))
                } else if (
                  isSimple &&
                  _key.name === 'async' &&
                  !this.isLineTerminator()
                ) {
                  // an async method
                  var isGenerator =
                    this.hasPlugin('asyncGenerators') && this.eat(types.star)
                  method.kind = 'method'
                  this.parsePropertyName(method)
                  if (this.isNonstaticConstructor(method)) {
                    this.raise(
                      method.key.start,
                      "Constructor can't be an async function"
                    )
                  }
                  this.parseClassMethod(classBody, method, isGenerator, true)
                } else if (
                  isSimple &&
                  (_key.name === 'get' || _key.name === 'set') &&
                  !(this.isLineTerminator() && this.match(types.star))
                ) {
                  // `get\n*` is an uninitialized property named 'get' followed by a generator.
                  // a getter or setter
                  method.kind = _key.name
                  this.parsePropertyName(method)
                  if (this.isNonstaticConstructor(method)) {
                    this.raise(
                      method.key.start,
                      "Constructor can't have get/set modifier"
                    )
                  }
                  this.parseClassMethod(classBody, method, false, false)
                  this.checkGetterSetterParamCount(method)
                } else if (
                  this.hasPlugin('classConstructorCall') &&
                  isSimple &&
                  _key.name === 'call' &&
                  this.match(types.name) &&
                  this.state.value === 'constructor'
                ) {
                  // a (deprecated) call constructor
                  if (hadConstructorCall) {
                    this.raise(
                      method.start,
                      'Duplicate constructor call in the same class'
                    )
                  } else if (method.decorators) {
                    this.raise(
                      method.start,
                      "You can't attach decorators to a class constructor"
                    )
                  }
                  hadConstructorCall = true
                  method.kind = 'constructorCall'
                  this.parsePropertyName(method) // consume "constructor" and make it the method's name
                  this.parseClassMethod(classBody, method, false, false)
                } else if (this.isLineTerminator()) {
                  // an uninitialized class property (due to ASI, since we don't otherwise recognize the next token)
                  if (this.isNonstaticConstructor(method)) {
                    this.raise(
                      method.key.start,
                      "Classes may not have a non-static field named 'constructor'"
                    )
                  }
                  classBody.body.push(this.parseClassProperty(method))
                } else {
                  this.unexpected()
                }
              }
            }

            if (decorators.length) {
              this.raise(
                this.state.start,
                'You have trailing decorators with no method'
              )
            }

            node.body = this.finishNode(classBody, 'ClassBody')

            this.state.strict = oldStrict
          }

          pp$1.parseClassProperty = function(node) {
            if (this.match(types.eq)) {
              if (!this.hasPlugin('classProperties')) this.unexpected()
              this.next()
              node.value = this.parseMaybeAssign()
            } else {
              node.value = null
            }
            this.semicolon()
            return this.finishNode(node, 'ClassProperty')
          }

          pp$1.parseClassMethod = function(
            classBody,
            method,
            isGenerator,
            isAsync
          ) {
            this.parseMethod(method, isGenerator, isAsync)
            classBody.body.push(this.finishNode(method, 'ClassMethod'))
          }

          pp$1.parseClassId = function(node, isStatement, optionalId) {
            if (this.match(types.name)) {
              node.id = this.parseIdentifier()
            } else {
              if (optionalId || !isStatement) {
                node.id = null
              } else {
                this.unexpected()
              }
            }
          }

          pp$1.parseClassSuper = function(node) {
            node.superClass = this.eat(types._extends)
              ? this.parseExprSubscripts()
              : null
          }

          // Parses module export declaration.

          pp$1.parseExport = function(node) {
            this.next()
            // export * from '...'
            if (this.match(types.star)) {
              var specifier = this.startNode()
              this.next()
              if (
                this.hasPlugin('exportExtensions') &&
                this.eatContextual('as')
              ) {
                specifier.exported = this.parseIdentifier()
                node.specifiers = [
                  this.finishNode(specifier, 'ExportNamespaceSpecifier'),
                ]
                this.parseExportSpecifiersMaybe(node)
                this.parseExportFrom(node, true)
              } else {
                this.parseExportFrom(node, true)
                return this.finishNode(node, 'ExportAllDeclaration')
              }
            } else if (
              this.hasPlugin('exportExtensions') &&
              this.isExportDefaultSpecifier()
            ) {
              var _specifier = this.startNode()
              _specifier.exported = this.parseIdentifier(true)
              node.specifiers = [
                this.finishNode(_specifier, 'ExportDefaultSpecifier'),
              ]
              if (
                this.match(types.comma) &&
                this.lookahead().type === types.star
              ) {
                this.expect(types.comma)
                var _specifier2 = this.startNode()
                this.expect(types.star)
                this.expectContextual('as')
                _specifier2.exported = this.parseIdentifier()
                node.specifiers.push(
                  this.finishNode(_specifier2, 'ExportNamespaceSpecifier')
                )
              } else {
                this.parseExportSpecifiersMaybe(node)
              }
              this.parseExportFrom(node, true)
            } else if (this.eat(types._default)) {
              // export default ...
              var expr = this.startNode()
              var needsSemi = false
              if (this.eat(types._function)) {
                expr = this.parseFunction(expr, true, false, false, true)
              } else if (this.match(types._class)) {
                expr = this.parseClass(expr, true, true)
              } else {
                needsSemi = true
                expr = this.parseMaybeAssign()
              }
              node.declaration = expr
              if (needsSemi) this.semicolon()
              this.checkExport(node, true, true)
              return this.finishNode(node, 'ExportDefaultDeclaration')
            } else if (this.shouldParseExportDeclaration()) {
              node.specifiers = []
              node.source = null
              node.declaration = this.parseExportDeclaration(node)
            } else {
              // export { x, y as z } [from '...']
              node.declaration = null
              node.specifiers = this.parseExportSpecifiers()
              this.parseExportFrom(node)
            }
            this.checkExport(node, true)
            return this.finishNode(node, 'ExportNamedDeclaration')
          }

          pp$1.parseExportDeclaration = function() {
            return this.parseStatement(true)
          }

          pp$1.isExportDefaultSpecifier = function() {
            if (this.match(types.name)) {
              return (
                this.state.value !== 'type' &&
                this.state.value !== 'async' &&
                this.state.value !== 'interface'
              )
            }

            if (!this.match(types._default)) {
              return false
            }

            var lookahead = this.lookahead()
            return (
              lookahead.type === types.comma ||
              (lookahead.type === types.name && lookahead.value === 'from')
            )
          }

          pp$1.parseExportSpecifiersMaybe = function(node) {
            if (this.eat(types.comma)) {
              node.specifiers = node.specifiers.concat(
                this.parseExportSpecifiers()
              )
            }
          }

          pp$1.parseExportFrom = function(node, expect) {
            if (this.eatContextual('from')) {
              node.source = this.match(types.string)
                ? this.parseExprAtom()
                : this.unexpected()
              this.checkExport(node)
            } else {
              if (expect) {
                this.unexpected()
              } else {
                node.source = null
              }
            }

            this.semicolon()
          }

          pp$1.shouldParseExportDeclaration = function() {
            return (
              this.state.type.keyword === 'var' ||
              this.state.type.keyword === 'const' ||
              this.state.type.keyword === 'let' ||
              this.state.type.keyword === 'function' ||
              this.state.type.keyword === 'class' ||
              this.isContextual('async')
            )
          }

          pp$1.checkExport = function(node, checkNames, isDefault) {
            if (checkNames) {
              // Check for duplicate exports
              if (isDefault) {
                // Default exports
                this.checkDuplicateExports(node, 'default')
              } else if (node.specifiers && node.specifiers.length) {
                // Named exports
                for (
                  var _iterator2 = node.specifiers,
                    _isArray2 = Array.isArray(_iterator2),
                    _i2 = 0,
                    _iterator2 = _isArray2
                      ? _iterator2
                      : _iterator2[Symbol.iterator]();
                  ;

                ) {
                  var _ref2

                  if (_isArray2) {
                    if (_i2 >= _iterator2.length) break
                    _ref2 = _iterator2[_i2++]
                  } else {
                    _i2 = _iterator2.next()
                    if (_i2.done) break
                    _ref2 = _i2.value
                  }

                  var specifier = _ref2

                  this.checkDuplicateExports(specifier, specifier.exported.name)
                }
              } else if (node.declaration) {
                // Exported declarations
                if (
                  node.declaration.type === 'FunctionDeclaration' ||
                  node.declaration.type === 'ClassDeclaration'
                ) {
                  this.checkDuplicateExports(node, node.declaration.id.name)
                } else if (node.declaration.type === 'VariableDeclaration') {
                  for (
                    var _iterator3 = node.declaration.declarations,
                      _isArray3 = Array.isArray(_iterator3),
                      _i3 = 0,
                      _iterator3 = _isArray3
                        ? _iterator3
                        : _iterator3[Symbol.iterator]();
                    ;

                  ) {
                    var _ref3

                    if (_isArray3) {
                      if (_i3 >= _iterator3.length) break
                      _ref3 = _iterator3[_i3++]
                    } else {
                      _i3 = _iterator3.next()
                      if (_i3.done) break
                      _ref3 = _i3.value
                    }

                    var declaration = _ref3

                    this.checkDeclaration(declaration.id)
                  }
                }
              }
            }

            if (this.state.decorators.length) {
              var isClass =
                node.declaration &&
                (node.declaration.type === 'ClassDeclaration' ||
                  node.declaration.type === 'ClassExpression')
              if (!node.declaration || !isClass) {
                this.raise(
                  node.start,
                  'You can only use decorators on an export when exporting a class'
                )
              }
              this.takeDecorators(node.declaration)
            }
          }

          pp$1.checkDeclaration = function(node) {
            if (node.type === 'ObjectPattern') {
              for (
                var _iterator4 = node.properties,
                  _isArray4 = Array.isArray(_iterator4),
                  _i4 = 0,
                  _iterator4 = _isArray4
                    ? _iterator4
                    : _iterator4[Symbol.iterator]();
                ;

              ) {
                var _ref4

                if (_isArray4) {
                  if (_i4 >= _iterator4.length) break
                  _ref4 = _iterator4[_i4++]
                } else {
                  _i4 = _iterator4.next()
                  if (_i4.done) break
                  _ref4 = _i4.value
                }

                var prop = _ref4

                this.checkDeclaration(prop)
              }
            } else if (node.type === 'ArrayPattern') {
              for (
                var _iterator5 = node.elements,
                  _isArray5 = Array.isArray(_iterator5),
                  _i5 = 0,
                  _iterator5 = _isArray5
                    ? _iterator5
                    : _iterator5[Symbol.iterator]();
                ;

              ) {
                var _ref5

                if (_isArray5) {
                  if (_i5 >= _iterator5.length) break
                  _ref5 = _iterator5[_i5++]
                } else {
                  _i5 = _iterator5.next()
                  if (_i5.done) break
                  _ref5 = _i5.value
                }

                var elem = _ref5

                if (elem) {
                  this.checkDeclaration(elem)
                }
              }
            } else if (node.type === 'ObjectProperty') {
              this.checkDeclaration(node.value)
            } else if (
              node.type === 'RestElement' ||
              node.type === 'RestProperty'
            ) {
              this.checkDeclaration(node.argument)
            } else if (node.type === 'Identifier') {
              this.checkDuplicateExports(node, node.name)
            }
          }

          pp$1.checkDuplicateExports = function(node, name) {
            if (this.state.exportedIdentifiers.indexOf(name) > -1) {
              this.raiseDuplicateExportError(node, name)
            }
            this.state.exportedIdentifiers.push(name)
          }

          pp$1.raiseDuplicateExportError = function(node, name) {
            this.raise(
              node.start,
              name === 'default'
                ? 'Only one default export allowed per module.'
                : '`' +
                    name +
                    '` has already been exported. Exported identifiers must be unique.'
            )
          }

          // Parses a comma-separated list of module exports.

          pp$1.parseExportSpecifiers = function() {
            var nodes = []
            var first = true
            var needsFrom = void 0

            // export { x, y as z } [from '...']
            this.expect(types.braceL)

            while (!this.eat(types.braceR)) {
              if (first) {
                first = false
              } else {
                this.expect(types.comma)
                if (this.eat(types.braceR)) break
              }

              var isDefault = this.match(types._default)
              if (isDefault && !needsFrom) needsFrom = true

              var node = this.startNode()
              node.local = this.parseIdentifier(isDefault)
              node.exported = this.eatContextual('as')
                ? this.parseIdentifier(true)
                : node.local.__clone()
              nodes.push(this.finishNode(node, 'ExportSpecifier'))
            }

            // https://github.com/ember-cli/ember-cli/pull/3739
            if (needsFrom && !this.isContextual('from')) {
              this.unexpected()
            }

            return nodes
          }

          // Parses import declaration.

          pp$1.parseImport = function(node) {
            this.eat(types._import)

            // import '...'
            if (this.match(types.string)) {
              node.specifiers = []
              node.source = this.parseExprAtom()
            } else {
              node.specifiers = []
              this.parseImportSpecifiers(node)
              this.expectContextual('from')
              node.source = this.match(types.string)
                ? this.parseExprAtom()
                : this.unexpected()
            }
            this.semicolon()
            return this.finishNode(node, 'ImportDeclaration')
          }

          // Parses a comma-separated list of module imports.

          pp$1.parseImportSpecifiers = function(node) {
            var first = true
            if (this.match(types.name)) {
              // import defaultObj, { x, y as z } from '...'
              var startPos = this.state.start
              var startLoc = this.state.startLoc
              node.specifiers.push(
                this.parseImportSpecifierDefault(
                  this.parseIdentifier(),
                  startPos,
                  startLoc
                )
              )
              if (!this.eat(types.comma)) return
            }

            if (this.match(types.star)) {
              var specifier = this.startNode()
              this.next()
              this.expectContextual('as')
              specifier.local = this.parseIdentifier()
              this.checkLVal(
                specifier.local,
                true,
                undefined,
                'import namespace specifier'
              )
              node.specifiers.push(
                this.finishNode(specifier, 'ImportNamespaceSpecifier')
              )
              return
            }

            this.expect(types.braceL)
            while (!this.eat(types.braceR)) {
              if (first) {
                first = false
              } else {
                // Detect an attempt to deep destructure
                if (this.eat(types.colon)) {
                  this.unexpected(
                    null,
                    'ES2015 named imports do not destructure. Use another statement for destructuring after the import.'
                  )
                }

                this.expect(types.comma)
                if (this.eat(types.braceR)) break
              }

              this.parseImportSpecifier(node)
            }
          }

          pp$1.parseImportSpecifier = function(node) {
            var specifier = this.startNode()
            specifier.imported = this.parseIdentifier(true)
            if (this.eatContextual('as')) {
              specifier.local = this.parseIdentifier()
            } else {
              this.checkReservedWord(
                specifier.imported.name,
                specifier.start,
                true,
                true
              )
              specifier.local = specifier.imported.__clone()
            }
            this.checkLVal(specifier.local, true, undefined, 'import specifier')
            node.specifiers.push(this.finishNode(specifier, 'ImportSpecifier'))
          }

          pp$1.parseImportSpecifierDefault = function(id, startPos, startLoc) {
            var node = this.startNodeAt(startPos, startLoc)
            node.local = id
            this.checkLVal(
              node.local,
              true,
              undefined,
              'default import specifier'
            )
            return this.finishNode(node, 'ImportDefaultSpecifier')
          }

          var pp$2 = Parser.prototype

          // Convert existing expression atom to assignable pattern
          // if possible.

          pp$2.toAssignable = function(node, isBinding, contextDescription) {
            if (node) {
              switch (node.type) {
                case 'Identifier':
                case 'ObjectPattern':
                case 'ArrayPattern':
                case 'AssignmentPattern':
                  break

                case 'ObjectExpression':
                  node.type = 'ObjectPattern'
                  for (
                    var _iterator = node.properties,
                      _isArray = Array.isArray(_iterator),
                      _i = 0,
                      _iterator = _isArray
                        ? _iterator
                        : _iterator[Symbol.iterator]();
                    ;

                  ) {
                    var _ref

                    if (_isArray) {
                      if (_i >= _iterator.length) break
                      _ref = _iterator[_i++]
                    } else {
                      _i = _iterator.next()
                      if (_i.done) break
                      _ref = _i.value
                    }

                    var prop = _ref

                    if (prop.type === 'ObjectMethod') {
                      if (prop.kind === 'get' || prop.kind === 'set') {
                        this.raise(
                          prop.key.start,
                          "Object pattern can't contain getter or setter"
                        )
                      } else {
                        this.raise(
                          prop.key.start,
                          "Object pattern can't contain methods"
                        )
                      }
                    } else {
                      this.toAssignable(
                        prop,
                        isBinding,
                        'object destructuring pattern'
                      )
                    }
                  }
                  break

                case 'ObjectProperty':
                  this.toAssignable(node.value, isBinding, contextDescription)
                  break

                case 'SpreadProperty':
                  node.type = 'RestProperty'
                  break

                case 'ArrayExpression':
                  node.type = 'ArrayPattern'
                  this.toAssignableList(
                    node.elements,
                    isBinding,
                    contextDescription
                  )
                  break

                case 'AssignmentExpression':
                  if (node.operator === '=') {
                    node.type = 'AssignmentPattern'
                    delete node.operator
                  } else {
                    this.raise(
                      node.left.end,
                      "Only '=' operator can be used for specifying default value."
                    )
                  }
                  break

                case 'MemberExpression':
                  if (!isBinding) break

                default: {
                  var message =
                    'Invalid left-hand side' +
                    (contextDescription
                      ? ' in ' + contextDescription
                      : /* istanbul ignore next */ 'expression')
                  this.raise(node.start, message)
                }
              }
            }
            return node
          }

          // Convert list of expression atoms to binding list.

          pp$2.toAssignableList = function(
            exprList,
            isBinding,
            contextDescription
          ) {
            var end = exprList.length
            if (end) {
              var last = exprList[end - 1]
              if (last && last.type === 'RestElement') {
                --end
              } else if (last && last.type === 'SpreadElement') {
                last.type = 'RestElement'
                var arg = last.argument
                this.toAssignable(arg, isBinding, contextDescription)
                if (
                  arg.type !== 'Identifier' &&
                  arg.type !== 'MemberExpression' &&
                  arg.type !== 'ArrayPattern'
                ) {
                  this.unexpected(arg.start)
                }
                --end
              }
            }
            for (var i = 0; i < end; i++) {
              var elt = exprList[i]
              if (elt) this.toAssignable(elt, isBinding, contextDescription)
            }
            return exprList
          }

          // Convert list of expression atoms to a list of

          pp$2.toReferencedList = function(exprList) {
            return exprList
          }

          // Parses spread element.

          pp$2.parseSpread = function(refShorthandDefaultPos) {
            var node = this.startNode()
            this.next()
            node.argument = this.parseMaybeAssign(false, refShorthandDefaultPos)
            return this.finishNode(node, 'SpreadElement')
          }

          pp$2.parseRest = function() {
            var node = this.startNode()
            this.next()
            node.argument = this.parseBindingIdentifier()
            return this.finishNode(node, 'RestElement')
          }

          pp$2.shouldAllowYieldIdentifier = function() {
            return (
              this.match(types._yield) &&
              !this.state.strict &&
              !this.state.inGenerator
            )
          }

          pp$2.parseBindingIdentifier = function() {
            return this.parseIdentifier(this.shouldAllowYieldIdentifier())
          }

          // Parses lvalue (assignable) atom.

          pp$2.parseBindingAtom = function() {
            switch (this.state.type) {
              case types._yield:
                if (this.state.strict || this.state.inGenerator)
                  this.unexpected()
              // fall-through
              case types.name:
                return this.parseIdentifier(true)

              case types.bracketL:
                var node = this.startNode()
                this.next()
                node.elements = this.parseBindingList(types.bracketR, true)
                return this.finishNode(node, 'ArrayPattern')

              case types.braceL:
                return this.parseObj(true)

              default:
                this.unexpected()
            }
          }

          pp$2.parseBindingList = function(close, allowEmpty) {
            var elts = []
            var first = true
            while (!this.eat(close)) {
              if (first) {
                first = false
              } else {
                this.expect(types.comma)
              }
              if (allowEmpty && this.match(types.comma)) {
                elts.push(null)
              } else if (this.eat(close)) {
                break
              } else if (this.match(types.ellipsis)) {
                elts.push(this.parseAssignableListItemTypes(this.parseRest()))
                this.expect(close)
                break
              } else {
                var decorators = []
                while (this.match(types.at)) {
                  decorators.push(this.parseDecorator())
                }
                var left = this.parseMaybeDefault()
                if (decorators.length) {
                  left.decorators = decorators
                }
                this.parseAssignableListItemTypes(left)
                elts.push(
                  this.parseMaybeDefault(left.start, left.loc.start, left)
                )
              }
            }
            return elts
          }

          pp$2.parseAssignableListItemTypes = function(param) {
            return param
          }

          // Parses assignment pattern around given atom if possible.

          pp$2.parseMaybeDefault = function(startPos, startLoc, left) {
            startLoc = startLoc || this.state.startLoc
            startPos = startPos || this.state.start
            left = left || this.parseBindingAtom()
            if (!this.eat(types.eq)) return left

            var node = this.startNodeAt(startPos, startLoc)
            node.left = left
            node.right = this.parseMaybeAssign()
            return this.finishNode(node, 'AssignmentPattern')
          }

          // Verify that a node is an lval  something that can be assigned
          // to.

          pp$2.checkLVal = function(
            expr,
            isBinding,
            checkClashes,
            contextDescription
          ) {
            switch (expr.type) {
              case 'Identifier':
                this.checkReservedWord(expr.name, expr.start, false, true)

                if (checkClashes) {
                  // we need to prefix this with an underscore for the cases where we have a key of
                  // `__proto__`. there's a bug in old V8 where the following wouldn't work:
                  //
                  //   > var obj = Object.create(null);
                  //   undefined
                  //   > obj.__proto__
                  //   null
                  //   > obj.__proto__ = true;
                  //   true
                  //   > obj.__proto__
                  //   null
                  var key = '_' + expr.name

                  if (checkClashes[key]) {
                    this.raise(expr.start, 'Argument name clash in strict mode')
                  } else {
                    checkClashes[key] = true
                  }
                }
                break

              case 'MemberExpression':
                if (isBinding)
                  this.raise(
                    expr.start,
                    (isBinding ? 'Binding' : 'Assigning to') +
                      ' member expression'
                  )
                break

              case 'ObjectPattern':
                for (
                  var _iterator2 = expr.properties,
                    _isArray2 = Array.isArray(_iterator2),
                    _i2 = 0,
                    _iterator2 = _isArray2
                      ? _iterator2
                      : _iterator2[Symbol.iterator]();
                  ;

                ) {
                  var _ref2

                  if (_isArray2) {
                    if (_i2 >= _iterator2.length) break
                    _ref2 = _iterator2[_i2++]
                  } else {
                    _i2 = _iterator2.next()
                    if (_i2.done) break
                    _ref2 = _i2.value
                  }

                  var prop = _ref2

                  if (prop.type === 'ObjectProperty') prop = prop.value
                  this.checkLVal(
                    prop,
                    isBinding,
                    checkClashes,
                    'object destructuring pattern'
                  )
                }
                break

              case 'ArrayPattern':
                for (
                  var _iterator3 = expr.elements,
                    _isArray3 = Array.isArray(_iterator3),
                    _i3 = 0,
                    _iterator3 = _isArray3
                      ? _iterator3
                      : _iterator3[Symbol.iterator]();
                  ;

                ) {
                  var _ref3

                  if (_isArray3) {
                    if (_i3 >= _iterator3.length) break
                    _ref3 = _iterator3[_i3++]
                  } else {
                    _i3 = _iterator3.next()
                    if (_i3.done) break
                    _ref3 = _i3.value
                  }

                  var elem = _ref3

                  if (elem)
                    this.checkLVal(
                      elem,
                      isBinding,
                      checkClashes,
                      'array destructuring pattern'
                    )
                }
                break

              case 'AssignmentPattern':
                this.checkLVal(
                  expr.left,
                  isBinding,
                  checkClashes,
                  'assignment pattern'
                )
                break

              case 'RestProperty':
                this.checkLVal(
                  expr.argument,
                  isBinding,
                  checkClashes,
                  'rest property'
                )
                break

              case 'RestElement':
                this.checkLVal(
                  expr.argument,
                  isBinding,
                  checkClashes,
                  'rest element'
                )
                break

              default: {
                var message =
                  (isBinding
                    ? /* istanbul ignore next */ 'Binding invalid'
                    : 'Invalid') +
                  ' left-hand side' +
                  (contextDescription
                    ? ' in ' + contextDescription
                    : /* istanbul ignore next */ 'expression')
                this.raise(expr.start, message)
              }
            }
          }

          /* eslint max-len: 0 */

          // A recursive descent parser operates by defining functions for all
          // syntactic elements, and recursively calling those, each function
          // advancing the input stream and returning an AST node. Precedence
          // of constructs (for example, the fact that `!x[1]` means `!(x[1])`
          // instead of `(!x)[1]` is handled by the fact that the parser
          // function that parses unary prefix operators is called first, and
          // in turn calls the function that parses `[]` subscripts  that
          // way, it'll receive the node for `x[1]` already parsed, and wraps
          // *that* in the unary operator node.
          //
          // Acorn uses an [operator precedence parser][opp] to handle binary
          // operator precedence, because it is much more compact than using
          // the technique outlined above, which uses different, nesting
          // functions to specify precedence, for all of the ten binary
          // precedence levels that JavaScript defines.
          //
          // [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser

          var pp$3 = Parser.prototype

          // Check if property name clashes with already added.
          // Object/class getters and setters are not allowed to clash 
          // either with each other or with an init property  and in
          // strict mode, init properties are also not allowed to be repeated.

          pp$3.checkPropClash = function(prop, propHash) {
            if (prop.computed || prop.kind) return

            var key = prop.key
            // It is either an Identifier or a String/NumericLiteral
            var name = key.type === 'Identifier' ? key.name : String(key.value)

            if (name === '__proto__') {
              if (propHash.proto)
                this.raise(key.start, 'Redefinition of __proto__ property')
              propHash.proto = true
            }
          }

          // Convenience method to parse an Expression only
          pp$3.getExpression = function() {
            this.nextToken()
            var expr = this.parseExpression()
            if (!this.match(types.eof)) {
              this.unexpected()
            }
            return expr
          }

          // ### Expression parsing

          // These nest, from the most general expression type at the top to
          // 'atomic', nondivisible expression types at the bottom. Most of
          // the functions will simply let the function (s) below them parse,
          // and, *if* the syntactic construct they handle is present, wrap
          // the AST node that the inner parser gave them in another node.

          // Parse a full expression. The optional arguments are used to
          // forbid the `in` operator (in for loops initialization expressions)
          // and provide reference for storing '=' operator inside shorthand
          // property assignment in contexts where both object expression
          // and object pattern might appear (so it's possible to raise
          // delayed syntax error at correct position).

          pp$3.parseExpression = function(noIn, refShorthandDefaultPos) {
            var startPos = this.state.start
            var startLoc = this.state.startLoc
            var expr = this.parseMaybeAssign(noIn, refShorthandDefaultPos)
            if (this.match(types.comma)) {
              var node = this.startNodeAt(startPos, startLoc)
              node.expressions = [expr]
              while (this.eat(types.comma)) {
                node.expressions.push(
                  this.parseMaybeAssign(noIn, refShorthandDefaultPos)
                )
              }
              this.toReferencedList(node.expressions)
              return this.finishNode(node, 'SequenceExpression')
            }
            return expr
          }

          // Parse an assignment expression. This includes applications of
          // operators like `+=`.

          pp$3.parseMaybeAssign = function(
            noIn,
            refShorthandDefaultPos,
            afterLeftParse,
            refNeedsArrowPos
          ) {
            var startPos = this.state.start
            var startLoc = this.state.startLoc

            if (this.match(types._yield) && this.state.inGenerator) {
              var _left = this.parseYield()
              if (afterLeftParse)
                _left = afterLeftParse.call(this, _left, startPos, startLoc)
              return _left
            }

            var failOnShorthandAssign = void 0
            if (refShorthandDefaultPos) {
              failOnShorthandAssign = false
            } else {
              refShorthandDefaultPos = { start: 0 }
              failOnShorthandAssign = true
            }

            if (this.match(types.parenL) || this.match(types.name)) {
              this.state.potentialArrowAt = this.state.start
            }

            var left = this.parseMaybeConditional(
              noIn,
              refShorthandDefaultPos,
              refNeedsArrowPos
            )
            if (afterLeftParse)
              left = afterLeftParse.call(this, left, startPos, startLoc)
            if (this.state.type.isAssign) {
              var node = this.startNodeAt(startPos, startLoc)
              node.operator = this.state.value
              node.left = this.match(types.eq)
                ? this.toAssignable(left, undefined, 'assignment expression')
                : left
              refShorthandDefaultPos.start = 0 // reset because shorthand default was used correctly

              this.checkLVal(
                left,
                undefined,
                undefined,
                'assignment expression'
              )

              if (left.extra && left.extra.parenthesized) {
                var errorMsg = void 0
                if (left.type === 'ObjectPattern') {
                  errorMsg = '`({a}) = 0` use `({a} = 0)`'
                } else if (left.type === 'ArrayPattern') {
                  errorMsg = '`([a]) = 0` use `([a] = 0)`'
                }
                if (errorMsg) {
                  this.raise(
                    left.start,
                    "You're trying to assign to a parenthesized expression, eg. instead of " +
                      errorMsg
                  )
                }
              }

              this.next()
              node.right = this.parseMaybeAssign(noIn)
              return this.finishNode(node, 'AssignmentExpression')
            } else if (failOnShorthandAssign && refShorthandDefaultPos.start) {
              this.unexpected(refShorthandDefaultPos.start)
            }

            return left
          }

          // Parse a ternary conditional (`?:`) operator.

          pp$3.parseMaybeConditional = function(
            noIn,
            refShorthandDefaultPos,
            refNeedsArrowPos
          ) {
            var startPos = this.state.start
            var startLoc = this.state.startLoc
            var expr = this.parseExprOps(noIn, refShorthandDefaultPos)
            if (refShorthandDefaultPos && refShorthandDefaultPos.start)
              return expr

            return this.parseConditional(
              expr,
              noIn,
              startPos,
              startLoc,
              refNeedsArrowPos
            )
          }

          pp$3.parseConditional = function(expr, noIn, startPos, startLoc) {
            if (this.eat(types.question)) {
              var node = this.startNodeAt(startPos, startLoc)
              node.test = expr
              node.consequent = this.parseMaybeAssign()
              this.expect(types.colon)
              node.alternate = this.parseMaybeAssign(noIn)
              return this.finishNode(node, 'ConditionalExpression')
            }
            return expr
          }

          // Start the precedence parser.

          pp$3.parseExprOps = function(noIn, refShorthandDefaultPos) {
            var startPos = this.state.start
            var startLoc = this.state.startLoc
            var expr = this.parseMaybeUnary(refShorthandDefaultPos)
            if (refShorthandDefaultPos && refShorthandDefaultPos.start) {
              return expr
            } else {
              return this.parseExprOp(expr, startPos, startLoc, -1, noIn)
            }
          }

          // Parse binary operators with the operator precedence parsing
          // algorithm. `left` is the left-hand side of the operator.
          // `minPrec` provides context that allows the function to stop and
          // defer further parser to one of its callers when it encounters an
          // operator that has a lower precedence than the set it is parsing.

          pp$3.parseExprOp = function(
            left,
            leftStartPos,
            leftStartLoc,
            minPrec,
            noIn
          ) {
            var prec = this.state.type.binop
            if (prec != null && (!noIn || !this.match(types._in))) {
              if (prec > minPrec) {
                var node = this.startNodeAt(leftStartPos, leftStartLoc)
                node.left = left
                node.operator = this.state.value

                if (
                  node.operator === '**' &&
                  left.type === 'UnaryExpression' &&
                  left.extra &&
                  !left.extra.parenthesizedArgument &&
                  !left.extra.parenthesized
                ) {
                  this.raise(
                    left.argument.start,
                    'Illegal expression. Wrap left hand side or entire exponentiation in parentheses.'
                  )
                }

                var op = this.state.type
                this.next()

                var startPos = this.state.start
                var startLoc = this.state.startLoc
                node.right = this.parseExprOp(
                  this.parseMaybeUnary(),
                  startPos,
                  startLoc,
                  op.rightAssociative ? prec - 1 : prec,
                  noIn
                )

                this.finishNode(
                  node,
                  op === types.logicalOR || op === types.logicalAND
                    ? 'LogicalExpression'
                    : 'BinaryExpression'
                )
                return this.parseExprOp(
                  node,
                  leftStartPos,
                  leftStartLoc,
                  minPrec,
                  noIn
                )
              }
            }
            return left
          }

          // Parse unary operators, both prefix and postfix.

          pp$3.parseMaybeUnary = function(refShorthandDefaultPos) {
            if (this.state.type.prefix) {
              var node = this.startNode()
              var update = this.match(types.incDec)
              node.operator = this.state.value
              node.prefix = true
              this.next()

              var argType = this.state.type
              node.argument = this.parseMaybeUnary()

              this.addExtra(
                node,
                'parenthesizedArgument',
                argType === types.parenL &&
                  (!node.argument.extra || !node.argument.extra.parenthesized)
              )

              if (refShorthandDefaultPos && refShorthandDefaultPos.start) {
                this.unexpected(refShorthandDefaultPos.start)
              }

              if (update) {
                this.checkLVal(
                  node.argument,
                  undefined,
                  undefined,
                  'prefix operation'
                )
              } else if (
                this.state.strict &&
                node.operator === 'delete' &&
                node.argument.type === 'Identifier'
              ) {
                this.raise(node.start, 'Deleting local variable in strict mode')
              }

              return this.finishNode(
                node,
                update ? 'UpdateExpression' : 'UnaryExpression'
              )
            }

            var startPos = this.state.start
            var startLoc = this.state.startLoc
            var expr = this.parseExprSubscripts(refShorthandDefaultPos)
            if (refShorthandDefaultPos && refShorthandDefaultPos.start)
              return expr
            while (this.state.type.postfix && !this.canInsertSemicolon()) {
              var _node = this.startNodeAt(startPos, startLoc)
              _node.operator = this.state.value
              _node.prefix = false
              _node.argument = expr
              this.checkLVal(expr, undefined, undefined, 'postfix operation')
              this.next()
              expr = this.finishNode(_node, 'UpdateExpression')
            }
            return expr
          }

          // Parse call, dot, and `[]`-subscript expressions.

          pp$3.parseExprSubscripts = function(refShorthandDefaultPos) {
            var startPos = this.state.start
            var startLoc = this.state.startLoc
            var potentialArrowAt = this.state.potentialArrowAt
            var expr = this.parseExprAtom(refShorthandDefaultPos)

            if (
              expr.type === 'ArrowFunctionExpression' &&
              expr.start === potentialArrowAt
            ) {
              return expr
            }

            if (refShorthandDefaultPos && refShorthandDefaultPos.start) {
              return expr
            }

            return this.parseSubscripts(expr, startPos, startLoc)
          }

          pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {
            for (;;) {
              if (!noCalls && this.eat(types.doubleColon)) {
                var node = this.startNodeAt(startPos, startLoc)
                node.object = base
                node.callee = this.parseNoCallExpr()
                return this.parseSubscripts(
                  this.finishNode(node, 'BindExpression'),
                  startPos,
                  startLoc,
                  noCalls
                )
              } else if (this.eat(types.dot)) {
                var _node2 = this.startNodeAt(startPos, startLoc)
                _node2.object = base
                _node2.property = this.parseIdentifier(true)
                _node2.computed = false
                base = this.finishNode(_node2, 'MemberExpression')
              } else if (this.eat(types.bracketL)) {
                var _node3 = this.startNodeAt(startPos, startLoc)
                _node3.object = base
                _node3.property = this.parseExpression()
                _node3.computed = true
                this.expect(types.bracketR)
                base = this.finishNode(_node3, 'MemberExpression')
              } else if (!noCalls && this.match(types.parenL)) {
                var possibleAsync =
                  this.state.potentialArrowAt === base.start &&
                  base.type === 'Identifier' &&
                  base.name === 'async' &&
                  !this.canInsertSemicolon()
                this.next()

                var _node4 = this.startNodeAt(startPos, startLoc)
                _node4.callee = base
                _node4.arguments = this.parseCallExpressionArguments(
                  types.parenR,
                  possibleAsync
                )
                if (
                  _node4.callee.type === 'Import' &&
                  _node4.arguments.length !== 1
                ) {
                  this.raise(
                    _node4.start,
                    'import() requires exactly one argument'
                  )
                }
                base = this.finishNode(_node4, 'CallExpression')

                if (possibleAsync && this.shouldParseAsyncArrow()) {
                  return this.parseAsyncArrowFromCallExpression(
                    this.startNodeAt(startPos, startLoc),
                    _node4
                  )
                } else {
                  this.toReferencedList(_node4.arguments)
                }
              } else if (this.match(types.backQuote)) {
                var _node5 = this.startNodeAt(startPos, startLoc)
                _node5.tag = base
                _node5.quasi = this.parseTemplate(true)
                base = this.finishNode(_node5, 'TaggedTemplateExpression')
              } else {
                return base
              }
            }
          }

          pp$3.parseCallExpressionArguments = function(
            close,
            possibleAsyncArrow
          ) {
            var elts = []
            var innerParenStart = void 0
            var first = true

            while (!this.eat(close)) {
              if (first) {
                first = false
              } else {
                this.expect(types.comma)
                if (this.eat(close)) break
              }

              // we need to make sure that if this is an async arrow functions, that we don't allow inner parens inside the params
              if (this.match(types.parenL) && !innerParenStart) {
                innerParenStart = this.state.start
              }

              elts.push(
                this.parseExprListItem(
                  false,
                  possibleAsyncArrow ? { start: 0 } : undefined,
                  possibleAsyncArrow ? { start: 0 } : undefined
                )
              )
            }

            // we found an async arrow function so let's not allow any inner parens
            if (
              possibleAsyncArrow &&
              innerParenStart &&
              this.shouldParseAsyncArrow()
            ) {
              this.unexpected()
            }

            return elts
          }

          pp$3.shouldParseAsyncArrow = function() {
            return this.match(types.arrow)
          }

          pp$3.parseAsyncArrowFromCallExpression = function(node, call) {
            this.expect(types.arrow)
            return this.parseArrowExpression(node, call.arguments, true)
          }

          // Parse a no-call expression (like argument of `new` or `::` operators).

          pp$3.parseNoCallExpr = function() {
            var startPos = this.state.start
            var startLoc = this.state.startLoc
            return this.parseSubscripts(
              this.parseExprAtom(),
              startPos,
              startLoc,
              true
            )
          }

          // Parse an atomic expression  either a single token that is an
          // expression, an expression started by a keyword like `function` or
          // `new`, or an expression wrapped in punctuation like `()`, `[]`,
          // or `{}`.

          pp$3.parseExprAtom = function(refShorthandDefaultPos) {
            var canBeArrow = this.state.potentialArrowAt === this.state.start
            var node = void 0

            switch (this.state.type) {
              case types._super:
                if (
                  !this.state.inMethod &&
                  !this.options.allowSuperOutsideMethod
                ) {
                  this.raise(
                    this.state.start,
                    "'super' outside of function or class"
                  )
                }

                node = this.startNode()
                this.next()
                if (
                  !this.match(types.parenL) &&
                  !this.match(types.bracketL) &&
                  !this.match(types.dot)
                ) {
                  this.unexpected()
                }
                if (
                  this.match(types.parenL) &&
                  this.state.inMethod !== 'constructor' &&
                  !this.options.allowSuperOutsideMethod
                ) {
                  this.raise(node.start, 'super() outside of class constructor')
                }
                return this.finishNode(node, 'Super')

              case types._import:
                if (!this.hasPlugin('dynamicImport')) this.unexpected()

                node = this.startNode()
                this.next()
                if (!this.match(types.parenL)) {
                  this.unexpected(null, types.parenL)
                }
                return this.finishNode(node, 'Import')

              case types._this:
                node = this.startNode()
                this.next()
                return this.finishNode(node, 'ThisExpression')

              case types._yield:
                if (this.state.inGenerator) this.unexpected()

              case types.name:
                node = this.startNode()
                var allowAwait =
                  this.state.value === 'await' && this.state.inAsync
                var allowYield = this.shouldAllowYieldIdentifier()
                var id = this.parseIdentifier(allowAwait || allowYield)

                if (id.name === 'await') {
                  if (this.state.inAsync || this.inModule) {
                    return this.parseAwait(node)
                  }
                } else if (
                  id.name === 'async' &&
                  this.match(types._function) &&
                  !this.canInsertSemicolon()
                ) {
                  this.next()
                  return this.parseFunction(node, false, false, true)
                } else if (
                  canBeArrow &&
                  id.name === 'async' &&
                  this.match(types.name)
                ) {
                  var params = [this.parseIdentifier()]
                  this.expect(types.arrow)
                  // let foo = bar => {};
                  return this.parseArrowExpression(node, params, true)
                }

                if (
                  canBeArrow &&
                  !this.canInsertSemicolon() &&
                  this.eat(types.arrow)
                ) {
                  return this.parseArrowExpression(node, [id])
                }

                return id

              case types._do:
                if (this.hasPlugin('doExpressions')) {
                  var _node6 = this.startNode()
                  this.next()
                  var oldInFunction = this.state.inFunction
                  var oldLabels = this.state.labels
                  this.state.labels = []
                  this.state.inFunction = false
                  _node6.body = this.parseBlock(false, true)
                  this.state.inFunction = oldInFunction
                  this.state.labels = oldLabels
                  return this.finishNode(_node6, 'DoExpression')
                }

              case types.regexp:
                var value = this.state.value
                node = this.parseLiteral(value.value, 'RegExpLiteral')
                node.pattern = value.pattern
                node.flags = value.flags
                return node

              case types.num:
                return this.parseLiteral(this.state.value, 'NumericLiteral')

              case types.string:
                return this.parseLiteral(this.state.value, 'StringLiteral')

              case types._null:
                node = this.startNode()
                this.next()
                return this.finishNode(node, 'NullLiteral')

              case types._true:
              case types._false:
                node = this.startNode()
                node.value = this.match(types._true)
                this.next()
                return this.finishNode(node, 'BooleanLiteral')

              case types.parenL:
                return this.parseParenAndDistinguishExpression(
                  null,
                  null,
                  canBeArrow
                )

              case types.bracketL:
                node = this.startNode()
                this.next()
                node.elements = this.parseExprList(
                  types.bracketR,
                  true,
                  refShorthandDefaultPos
                )
                this.toReferencedList(node.elements)
                return this.finishNode(node, 'ArrayExpression')

              case types.braceL:
                return this.parseObj(false, refShorthandDefaultPos)

              case types._function:
                return this.parseFunctionExpression()

              case types.at:
                this.parseDecorators()

              case types._class:
                node = this.startNode()
                this.takeDecorators(node)
                return this.parseClass(node, false)

              case types._new:
                return this.parseNew()

              case types.backQuote:
                return this.parseTemplate(false)

              case types.doubleColon:
                node = this.startNode()
                this.next()
                node.object = null
                var callee = (node.callee = this.parseNoCallExpr())
                if (callee.type === 'MemberExpression') {
                  return this.finishNode(node, 'BindExpression')
                } else {
                  this.raise(
                    callee.start,
                    'Binding should be performed on object property.'
                  )
                }

              default:
                this.unexpected()
            }
          }

          pp$3.parseFunctionExpression = function() {
            var node = this.startNode()
            var meta = this.parseIdentifier(true)
            if (
              this.state.inGenerator &&
              this.eat(types.dot) &&
              this.hasPlugin('functionSent')
            ) {
              return this.parseMetaProperty(node, meta, 'sent')
            } else {
              return this.parseFunction(node, false)
            }
          }

          pp$3.parseMetaProperty = function(node, meta, propertyName) {
            node.meta = meta
            node.property = this.parseIdentifier(true)

            if (node.property.name !== propertyName) {
              this.raise(
                node.property.start,
                'The only valid meta property for new is ' +
                  meta.name +
                  '.' +
                  propertyName
              )
            }

            return this.finishNode(node, 'MetaProperty')
          }

          pp$3.parseLiteral = function(value, type, startPos, startLoc) {
            startPos = startPos || this.state.start
            startLoc = startLoc || this.state.startLoc

            var node = this.startNodeAt(startPos, startLoc)
            this.addExtra(node, 'rawValue', value)
            this.addExtra(
              node,
              'raw',
              this.input.slice(startPos, this.state.end)
            )
            node.value = value
            this.next()
            return this.finishNode(node, type)
          }

          pp$3.parseParenExpression = function() {
            this.expect(types.parenL)
            var val = this.parseExpression()
            this.expect(types.parenR)
            return val
          }

          pp$3.parseParenAndDistinguishExpression = function(
            startPos,
            startLoc,
            canBeArrow
          ) {
            startPos = startPos || this.state.start
            startLoc = startLoc || this.state.startLoc

            var val = void 0
            this.expect(types.parenL)

            var innerStartPos = this.state.start
            var innerStartLoc = this.state.startLoc
            var exprList = []
            var refShorthandDefaultPos = { start: 0 }
            var refNeedsArrowPos = { start: 0 }
            var first = true
            var spreadStart = void 0
            var optionalCommaStart = void 0

            while (!this.match(types.parenR)) {
              if (first) {
                first = false
              } else {
                this.expect(types.comma, refNeedsArrowPos.start || null)
                if (this.match(types.parenR)) {
                  optionalCommaStart = this.state.start
                  break
                }
              }

              if (this.match(types.ellipsis)) {
                var spreadNodeStartPos = this.state.start
                var spreadNodeStartLoc = this.state.startLoc
                spreadStart = this.state.start
                exprList.push(
                  this.parseParenItem(
                    this.parseRest(),
                    spreadNodeStartPos,
                    spreadNodeStartLoc
                  )
                )
                break
              } else {
                exprList.push(
                  this.parseMaybeAssign(
                    false,
                    refShorthandDefaultPos,
                    this.parseParenItem,
                    refNeedsArrowPos
                  )
                )
              }
            }

            var innerEndPos = this.state.start
            var innerEndLoc = this.state.startLoc
            this.expect(types.parenR)

            var arrowNode = this.startNodeAt(startPos, startLoc)
            if (
              canBeArrow &&
              this.shouldParseArrow() &&
              (arrowNode = this.parseArrow(arrowNode))
            ) {
              for (
                var _iterator = exprList,
                  _isArray = Array.isArray(_iterator),
                  _i = 0,
                  _iterator = _isArray
                    ? _iterator
                    : _iterator[Symbol.iterator]();
                ;

              ) {
                var _ref

                if (_isArray) {
                  if (_i >= _iterator.length) break
                  _ref = _iterator[_i++]
                } else {
                  _i = _iterator.next()
                  if (_i.done) break
                  _ref = _i.value
                }

                var param = _ref

                if (param.extra && param.extra.parenthesized)
                  this.unexpected(param.extra.parenStart)
              }

              return this.parseArrowExpression(arrowNode, exprList)
            }

            if (!exprList.length) {
              this.unexpected(this.state.lastTokStart)
            }
            if (optionalCommaStart) this.unexpected(optionalCommaStart)
            if (spreadStart) this.unexpected(spreadStart)
            if (refShorthandDefaultPos.start)
              this.unexpected(refShorthandDefaultPos.start)
            if (refNeedsArrowPos.start) this.unexpected(refNeedsArrowPos.start)

            if (exprList.length > 1) {
              val = this.startNodeAt(innerStartPos, innerStartLoc)
              val.expressions = exprList
              this.toReferencedList(val.expressions)
              this.finishNodeAt(
                val,
                'SequenceExpression',
                innerEndPos,
                innerEndLoc
              )
            } else {
              val = exprList[0]
            }

            this.addExtra(val, 'parenthesized', true)
            this.addExtra(val, 'parenStart', startPos)

            return val
          }

          pp$3.shouldParseArrow = function() {
            return !this.canInsertSemicolon()
          }

          pp$3.parseArrow = function(node) {
            if (this.eat(types.arrow)) {
              return node
            }
          }

          pp$3.parseParenItem = function(node) {
            return node
          }

          // New's precedence is slightly tricky. It must allow its argument
          // to be a `[]` or dot subscript expression, but not a call  at
          // least, not without wrapping it in parentheses. Thus, it uses the

          pp$3.parseNew = function() {
            var node = this.startNode()
            var meta = this.parseIdentifier(true)

            if (this.eat(types.dot)) {
              var metaProp = this.parseMetaProperty(node, meta, 'target')

              if (!this.state.inFunction) {
                this.raise(
                  metaProp.property.start,
                  'new.target can only be used in functions'
                )
              }

              return metaProp
            }

            node.callee = this.parseNoCallExpr()

            if (this.eat(types.parenL)) {
              node.arguments = this.parseExprList(types.parenR)
              this.toReferencedList(node.arguments)
            } else {
              node.arguments = []
            }

            return this.finishNode(node, 'NewExpression')
          }

          // Parse template expression.

          pp$3.parseTemplateElement = function(isTagged) {
            var elem = this.startNode()
            if (this.state.value === null) {
              if (!isTagged || !this.hasPlugin('templateInvalidEscapes')) {
                this.raise(
                  this.state.invalidTemplateEscapePosition,
                  'Invalid escape sequence in template'
                )
              } else {
                this.state.invalidTemplateEscapePosition = null
              }
            }
            elem.value = {
              raw: this.input
                .slice(this.state.start, this.state.end)
                .replace(/\r\n?/g, '\n'),
              cooked: this.state.value,
            }
            this.next()
            elem.tail = this.match(types.backQuote)
            return this.finishNode(elem, 'TemplateElement')
          }

          pp$3.parseTemplate = function(isTagged) {
            var node = this.startNode()
            this.next()
            node.expressions = []
            var curElt = this.parseTemplateElement(isTagged)
            node.quasis = [curElt]
            while (!curElt.tail) {
              this.expect(types.dollarBraceL)
              node.expressions.push(this.parseExpression())
              this.expect(types.braceR)
              node.quasis.push((curElt = this.parseTemplateElement(isTagged)))
            }
            this.next()
            return this.finishNode(node, 'TemplateLiteral')
          }

          // Parse an object literal or binding pattern.

          pp$3.parseObj = function(isPattern, refShorthandDefaultPos) {
            var decorators = []
            var propHash = Object.create(null)
            var first = true
            var node = this.startNode()

            node.properties = []
            this.next()

            var firstRestLocation = null

            while (!this.eat(types.braceR)) {
              if (first) {
                first = false
              } else {
                this.expect(types.comma)
                if (this.eat(types.braceR)) break
              }

              while (this.match(types.at)) {
                decorators.push(this.parseDecorator())
              }

              var prop = this.startNode(),
                isGenerator = false,
                isAsync = false,
                startPos = void 0,
                startLoc = void 0
              if (decorators.length) {
                prop.decorators = decorators
                decorators = []
              }

              if (
                this.hasPlugin('objectRestSpread') &&
                this.match(types.ellipsis)
              ) {
                prop = this.parseSpread(isPattern ? { start: 0 } : undefined)
                prop.type = isPattern ? 'RestProperty' : 'SpreadProperty'
                if (isPattern)
                  this.toAssignable(prop.argument, true, 'object pattern')
                node.properties.push(prop)
                if (isPattern) {
                  var position = this.state.start
                  if (firstRestLocation !== null) {
                    this.unexpected(
                      firstRestLocation,
                      'Cannot have multiple rest elements when destructuring'
                    )
                  } else if (this.eat(types.braceR)) {
                    break
                  } else if (
                    this.match(types.comma) &&
                    this.lookahead().type === types.braceR
                  ) {
                    // TODO: temporary rollback
                    // this.unexpected(position, "A trailing comma is not permitted after the rest element");
                    continue
                  } else {
                    firstRestLocation = position
                    continue
                  }
                } else {
                  continue
                }
              }

              prop.method = false
              prop.shorthand = false

              if (isPattern || refShorthandDefaultPos) {
                startPos = this.state.start
                startLoc = this.state.startLoc
              }

              if (!isPattern) {
                isGenerator = this.eat(types.star)
              }

              if (!isPattern && this.isContextual('async')) {
                if (isGenerator) this.unexpected()

                var asyncId = this.parseIdentifier()
                if (
                  this.match(types.colon) ||
                  this.match(types.parenL) ||
                  this.match(types.braceR) ||
                  this.match(types.eq) ||
                  this.match(types.comma)
                ) {
                  prop.key = asyncId
                  prop.computed = false
                } else {
                  isAsync = true
                  if (this.hasPlugin('asyncGenerators'))
                    isGenerator = this.eat(types.star)
                  this.parsePropertyName(prop)
                }
              } else {
                this.parsePropertyName(prop)
              }

              this.parseObjPropValue(
                prop,
                startPos,
                startLoc,
                isGenerator,
                isAsync,
                isPattern,
                refShorthandDefaultPos
              )
              this.checkPropClash(prop, propHash)

              if (prop.shorthand) {
                this.addExtra(prop, 'shorthand', true)
              }

              node.properties.push(prop)
            }

            if (firstRestLocation !== null) {
              this.unexpected(
                firstRestLocation,
                'The rest element has to be the last element when destructuring'
              )
            }

            if (decorators.length) {
              this.raise(
                this.state.start,
                'You have trailing decorators with no property'
              )
            }

            return this.finishNode(
              node,
              isPattern ? 'ObjectPattern' : 'ObjectExpression'
            )
          }

          pp$3.isGetterOrSetterMethod = function(prop, isPattern) {
            return (
              !isPattern &&
              !prop.computed &&
              prop.key.type === 'Identifier' &&
              (prop.key.name === 'get' || prop.key.name === 'set') &&
              (this.match(types.string) || // get "string"() {}
              this.match(types.num) || // get 1() {}
              this.match(types.bracketL) || // get ["string"]() {}
              this.match(types.name) || // get foo() {}
                this.state.type.keyword) // get debugger() {}
            )
          }

          // get methods aren't allowed to have any parameters
          // set methods must have exactly 1 parameter
          pp$3.checkGetterSetterParamCount = function(method) {
            var paramCount = method.kind === 'get' ? 0 : 1
            if (method.params.length !== paramCount) {
              var start = method.start
              if (method.kind === 'get') {
                this.raise(start, 'getter should have no params')
              } else {
                this.raise(start, 'setter should have exactly one param')
              }
            }
          }

          pp$3.parseObjectMethod = function(
            prop,
            isGenerator,
            isAsync,
            isPattern
          ) {
            if (isAsync || isGenerator || this.match(types.parenL)) {
              if (isPattern) this.unexpected()
              prop.kind = 'method'
              prop.method = true
              this.parseMethod(prop, isGenerator, isAsync)

              return this.finishNode(prop, 'ObjectMethod')
            }

            if (this.isGetterOrSetterMethod(prop, isPattern)) {
              if (isGenerator || isAsync) this.unexpected()
              prop.kind = prop.key.name
              this.parsePropertyName(prop)
              this.parseMethod(prop)
              this.checkGetterSetterParamCount(prop)

              return this.finishNode(prop, 'ObjectMethod')
            }
          }

          pp$3.parseObjectProperty = function(
            prop,
            startPos,
            startLoc,
            isPattern,
            refShorthandDefaultPos
          ) {
            if (this.eat(types.colon)) {
              prop.value = isPattern
                ? this.parseMaybeDefault(this.state.start, this.state.startLoc)
                : this.parseMaybeAssign(false, refShorthandDefaultPos)

              return this.finishNode(prop, 'ObjectProperty')
            }

            if (!prop.computed && prop.key.type === 'Identifier') {
              if (isPattern) {
                this.checkReservedWord(
                  prop.key.name,
                  prop.key.start,
                  true,
                  true
                )
                prop.value = this.parseMaybeDefault(
                  startPos,
                  startLoc,
                  prop.key.__clone()
                )
              } else if (this.match(types.eq) && refShorthandDefaultPos) {
                if (!refShorthandDefaultPos.start) {
                  refShorthandDefaultPos.start = this.state.start
                }
                prop.value = this.parseMaybeDefault(
                  startPos,
                  startLoc,
                  prop.key.__clone()
                )
              } else {
                prop.value = prop.key.__clone()
              }
              prop.shorthand = true

              return this.finishNode(prop, 'ObjectProperty')
            }
          }

          pp$3.parseObjPropValue = function(
            prop,
            startPos,
            startLoc,
            isGenerator,
            isAsync,
            isPattern,
            refShorthandDefaultPos
          ) {
            var node =
              this.parseObjectMethod(prop, isGenerator, isAsync, isPattern) ||
              this.parseObjectProperty(
                prop,
                startPos,
                startLoc,
                isPattern,
                refShorthandDefaultPos
              )

            if (!node) this.unexpected()

            return node
          }

          pp$3.parsePropertyName = function(prop) {
            if (this.eat(types.bracketL)) {
              prop.computed = true
              prop.key = this.parseMaybeAssign()
              this.expect(types.bracketR)
            } else {
              prop.computed = false
              var oldInPropertyName = this.state.inPropertyName
              this.state.inPropertyName = true
              prop.key = this.match(types.num) || this.match(types.string)
                ? this.parseExprAtom()
                : this.parseIdentifier(true)
              this.state.inPropertyName = oldInPropertyName
            }
            return prop.key
          }

          // Initialize empty function node.

          pp$3.initFunction = function(node, isAsync) {
            node.id = null
            node.generator = false
            node.expression = false
            node.async = !!isAsync
          }

          // Parse object or class method.

          pp$3.parseMethod = function(node, isGenerator, isAsync) {
            var oldInMethod = this.state.inMethod
            this.state.inMethod = node.kind || true
            this.initFunction(node, isAsync)
            this.expect(types.parenL)
            node.params = this.parseBindingList(types.parenR)
            node.generator = !!isGenerator
            this.parseFunctionBody(node)
            this.state.inMethod = oldInMethod
            return node
          }

          // Parse arrow function expression with given parameters.

          pp$3.parseArrowExpression = function(node, params, isAsync) {
            this.initFunction(node, isAsync)
            node.params = this.toAssignableList(
              params,
              true,
              'arrow function parameters'
            )
            this.parseFunctionBody(node, true)
            return this.finishNode(node, 'ArrowFunctionExpression')
          }

          pp$3.isStrictBody = function(node, isExpression) {
            if (!isExpression && node.body.directives.length) {
              for (
                var _iterator2 = node.body.directives,
                  _isArray2 = Array.isArray(_iterator2),
                  _i2 = 0,
                  _iterator2 = _isArray2
                    ? _iterator2
                    : _iterator2[Symbol.iterator]();
                ;

              ) {
                var _ref2

                if (_isArray2) {
                  if (_i2 >= _iterator2.length) break
                  _ref2 = _iterator2[_i2++]
                } else {
                  _i2 = _iterator2.next()
                  if (_i2.done) break
                  _ref2 = _i2.value
                }

                var directive = _ref2

                if (directive.value.value === 'use strict') {
                  return true
                }
              }
            }

            return false
          }

          // Parse function body and check parameters.
          pp$3.parseFunctionBody = function(node, allowExpression) {
            var isExpression = allowExpression && !this.match(types.braceL)

            var oldInAsync = this.state.inAsync
            this.state.inAsync = node.async
            if (isExpression) {
              node.body = this.parseMaybeAssign()
              node.expression = true
            } else {
              // Start a new scope with regard to labels and the `inFunction`
              // flag (restore them to their old value afterwards).
              var oldInFunc = this.state.inFunction
              var oldInGen = this.state.inGenerator
              var oldLabels = this.state.labels
              this.state.inFunction = true
              this.state.inGenerator = node.generator
              this.state.labels = []
              node.body = this.parseBlock(true)
              node.expression = false
              this.state.inFunction = oldInFunc
              this.state.inGenerator = oldInGen
              this.state.labels = oldLabels
            }
            this.state.inAsync = oldInAsync

            // If this is a strict mode function, verify that argument names
            // are not repeated, and it does not try to bind the words `eval`
            // or `arguments`.
            var isStrict = this.isStrictBody(node, isExpression)
            // Also check when allowExpression === true for arrow functions
            var checkLVal = this.state.strict || allowExpression || isStrict

            if (
              isStrict &&
              node.id &&
              node.id.type === 'Identifier' &&
              node.id.name === 'yield'
            ) {
              this.raise(node.id.start, 'Binding yield in strict mode')
            }

            if (checkLVal) {
              var nameHash = Object.create(null)
              var oldStrict = this.state.strict
              if (isStrict) this.state.strict = true
              if (node.id) {
                this.checkLVal(node.id, true, undefined, 'function name')
              }
              for (
                var _iterator3 = node.params,
                  _isArray3 = Array.isArray(_iterator3),
                  _i3 = 0,
                  _iterator3 = _isArray3
                    ? _iterator3
                    : _iterator3[Symbol.iterator]();
                ;

              ) {
                var _ref3

                if (_isArray3) {
                  if (_i3 >= _iterator3.length) break
                  _ref3 = _iterator3[_i3++]
                } else {
                  _i3 = _iterator3.next()
                  if (_i3.done) break
                  _ref3 = _i3.value
                }

                var param = _ref3

                if (isStrict && param.type !== 'Identifier') {
                  this.raise(param.start, 'Non-simple parameter in strict mode')
                }
                this.checkLVal(param, true, nameHash, 'function parameter list')
              }
              this.state.strict = oldStrict
            }
          }

          // Parses a comma-separated list of expressions, and returns them as
          // an array. `close` is the token type that ends the list, and
          // `allowEmpty` can be turned on to allow subsequent commas with
          // nothing in between them to be parsed as `null` (which is needed
          // for array literals).

          pp$3.parseExprList = function(
            close,
            allowEmpty,
            refShorthandDefaultPos
          ) {
            var elts = []
            var first = true

            while (!this.eat(close)) {
              if (first) {
                first = false
              } else {
                this.expect(types.comma)
                if (this.eat(close)) break
              }

              elts.push(
                this.parseExprListItem(allowEmpty, refShorthandDefaultPos)
              )
            }
            return elts
          }

          pp$3.parseExprListItem = function(
            allowEmpty,
            refShorthandDefaultPos,
            refNeedsArrowPos
          ) {
            var elt = void 0
            if (allowEmpty && this.match(types.comma)) {
              elt = null
            } else if (this.match(types.ellipsis)) {
              elt = this.parseSpread(refShorthandDefaultPos)
            } else {
              elt = this.parseMaybeAssign(
                false,
                refShorthandDefaultPos,
                this.parseParenItem,
                refNeedsArrowPos
              )
            }
            return elt
          }

          // Parse the next token as an identifier. If `liberal` is true (used
          // when parsing properties), it will also convert keywords into
          // identifiers.

          pp$3.parseIdentifier = function(liberal) {
            var node = this.startNode()
            if (!liberal) {
              this.checkReservedWord(
                this.state.value,
                this.state.start,
                !!this.state.type.keyword,
                false
              )
            }

            if (this.match(types.name)) {
              node.name = this.state.value
            } else if (this.state.type.keyword) {
              node.name = this.state.type.keyword
            } else {
              this.unexpected()
            }

            if (!liberal && node.name === 'await' && this.state.inAsync) {
              this.raise(
                node.start,
                'invalid use of await inside of an async function'
              )
            }

            node.loc.identifierName = node.name

            this.next()
            return this.finishNode(node, 'Identifier')
          }

          pp$3.checkReservedWord = function(
            word,
            startLoc,
            checkKeywords,
            isBinding
          ) {
            if (
              this.isReservedWord(word) ||
              (checkKeywords && this.isKeyword(word))
            ) {
              this.raise(startLoc, word + ' is a reserved word')
            }

            if (
              this.state.strict &&
              (reservedWords.strict(word) ||
                (isBinding && reservedWords.strictBind(word)))
            ) {
              this.raise(startLoc, word + ' is a reserved word in strict mode')
            }
          }

          // Parses await expression inside async function.

          pp$3.parseAwait = function(node) {
            // istanbul ignore next: this condition is checked at the call site so won't be hit here
            if (!this.state.inAsync) {
              this.unexpected()
            }
            if (this.match(types.star)) {
              this.raise(
                node.start,
                'await* has been removed from the async functions proposal. Use Promise.all() instead.'
              )
            }
            node.argument = this.parseMaybeUnary()
            return this.finishNode(node, 'AwaitExpression')
          }

          // Parses yield expression inside generator.

          pp$3.parseYield = function() {
            var node = this.startNode()
            this.next()
            if (
              this.match(types.semi) ||
              this.canInsertSemicolon() ||
              (!this.match(types.star) && !this.state.type.startsExpr)
            ) {
              node.delegate = false
              node.argument = null
            } else {
              node.delegate = this.eat(types.star)
              node.argument = this.parseMaybeAssign()
            }
            return this.finishNode(node, 'YieldExpression')
          }

          // Start an AST node, attaching a start offset.

          var pp$4 = Parser.prototype
          var commentKeys = [
            'leadingComments',
            'trailingComments',
            'innerComments',
          ]

          var Node = (function() {
            function Node(pos, loc, filename) {
              classCallCheck(this, Node)

              this.type = ''
              this.start = pos
              this.end = 0
              this.loc = new SourceLocation(loc)
              if (filename) this.loc.filename = filename
            }

            Node.prototype.__clone = function __clone() {
              var node2 = new Node()
              for (var key in this) {
                // Do not clone comments that are already attached to the node
                if (commentKeys.indexOf(key) < 0) {
                  node2[key] = this[key]
                }
              }

              return node2
            }

            return Node
          })()

          pp$4.startNode = function() {
            return new Node(
              this.state.start,
              this.state.startLoc,
              this.filename
            )
          }

          pp$4.startNodeAt = function(pos, loc) {
            return new Node(pos, loc, this.filename)
          }

          function finishNodeAt(node, type, pos, loc) {
            node.type = type
            node.end = pos
            node.loc.end = loc
            this.processComment(node)
            return node
          }

          // Finish an AST node, adding `type` and `end` properties.

          pp$4.finishNode = function(node, type) {
            return finishNodeAt.call(
              this,
              node,
              type,
              this.state.lastTokEnd,
              this.state.lastTokEndLoc
            )
          }

          // Finish node at given position

          pp$4.finishNodeAt = function(node, type, pos, loc) {
            return finishNodeAt.call(this, node, type, pos, loc)
          }

          var pp$5 = Parser.prototype

          // This function is used to raise exceptions on parse errors. It
          // takes an offset integer (into the current `input`) to indicate
          // the location of the error, attaches the position to the end
          // of the error message, and then raises a `SyntaxError` with that
          // message.

          pp$5.raise = function(pos, message) {
            var loc = getLineInfo(this.input, pos)
            message += ' (' + loc.line + ':' + loc.column + ')'
            var err = new SyntaxError(message)
            err.pos = pos
            err.loc = loc
            throw err
          }

          /* eslint max-len: 0 */

          /**
 * Based on the comment attachment algorithm used in espree and estraverse.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 * * Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in the
 *   documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

          function last(stack) {
            return stack[stack.length - 1]
          }

          var pp$6 = Parser.prototype

          pp$6.addComment = function(comment) {
            if (this.filename) comment.loc.filename = this.filename
            this.state.trailingComments.push(comment)
            this.state.leadingComments.push(comment)
          }

          pp$6.processComment = function(node) {
            if (node.type === 'Program' && node.body.length > 0) return

            var stack = this.state.commentStack

            var lastChild = void 0,
              trailingComments = void 0,
              i = void 0,
              j = void 0

            if (this.state.trailingComments.length > 0) {
              // If the first comment in trailingComments comes after the
              // current node, then we're good - all comments in the array will
              // come after the node and so it's safe to add them as official
              // trailingComments.
              if (this.state.trailingComments[0].start >= node.end) {
                trailingComments = this.state.trailingComments
                this.state.trailingComments = []
              } else {
                // Otherwise, if the first comment doesn't come after the
                // current node, that means we have a mix of leading and trailing
                // comments in the array and that leadingComments contains the
                // same items as trailingComments. Reset trailingComments to
                // zero items and we'll handle this by evaluating leadingComments
                // later.
                this.state.trailingComments.length = 0
              }
            } else {
              var lastInStack = last(stack)
              if (
                stack.length > 0 &&
                lastInStack.trailingComments &&
                lastInStack.trailingComments[0].start >= node.end
              ) {
                trailingComments = lastInStack.trailingComments
                lastInStack.trailingComments = null
              }
            }

            // Eating the stack.
            while (stack.length > 0 && last(stack).start >= node.start) {
              lastChild = stack.pop()
            }

            if (lastChild) {
              if (lastChild.leadingComments) {
                if (
                  lastChild !== node &&
                  last(lastChild.leadingComments).end <= node.start
                ) {
                  node.leadingComments = lastChild.leadingComments
                  lastChild.leadingComments = null
                } else {
                  // A leading comment for an anonymous class had been stolen by its first ClassMethod,
                  // so this takes back the leading comment.
                  // See also: https://github.com/eslint/espree/issues/158
                  for (i = lastChild.leadingComments.length - 2; i >= 0; --i) {
                    if (lastChild.leadingComments[i].end <= node.start) {
                      node.leadingComments = lastChild.leadingComments.splice(
                        0,
                        i + 1
                      )
                      break
                    }
                  }
                }
              }
            } else if (this.state.leadingComments.length > 0) {
              if (last(this.state.leadingComments).end <= node.start) {
                if (this.state.commentPreviousNode) {
                  for (j = 0; j < this.state.leadingComments.length; j++) {
                    if (
                      this.state.leadingComments[j].end <
                      this.state.commentPreviousNode.end
                    ) {
                      this.state.leadingComments.splice(j, 1)
                      j--
                    }
                  }
                }
                if (this.state.leadingComments.length > 0) {
                  node.leadingComments = this.state.leadingComments
                  this.state.leadingComments = []
                }
              } else {
                // https://github.com/eslint/espree/issues/2
                //
                // In special cases, such as return (without a value) and
                // debugger, all comments will end up as leadingComments and
                // will otherwise be eliminated. This step runs when the
                // commentStack is empty and there are comments left
                // in leadingComments.
                //
                // This loop figures out the stopping point between the actual
                // leading and trailing comments by finding the location of the
                // first comment that comes after the given node.
                for (i = 0; i < this.state.leadingComments.length; i++) {
                  if (this.state.leadingComments[i].end > node.start) {
                    break
                  }
                }

                // Split the array based on the location of the first comment
                // that comes after the node. Keep in mind that this could
                // result in an empty array, and if so, the array must be
                // deleted.
                node.leadingComments = this.state.leadingComments.slice(0, i)
                if (node.leadingComments.length === 0) {
                  node.leadingComments = null
                }

                // Similarly, trailing comments are attached later. The variable
                // must be reset to null if there are no trailing comments.
                trailingComments = this.state.leadingComments.slice(i)
                if (trailingComments.length === 0) {
                  trailingComments = null
                }
              }
            }

            this.state.commentPreviousNode = node

            if (trailingComments) {
              if (
                trailingComments.length &&
                trailingComments[0].start >= node.start &&
                last(trailingComments).end <= node.end
              ) {
                node.innerComments = trailingComments
              } else {
                node.trailingComments = trailingComments
              }
            }

            stack.push(node)
          }

          var pp$7 = Parser.prototype

          pp$7.estreeParseRegExpLiteral = function(_ref) {
            var pattern = _ref.pattern,
              flags = _ref.flags

            var regex = null
            try {
              regex = new RegExp(pattern, flags)
            } catch (e) {
              // In environments that don't support these flags value will
              // be null as the regex can't be represented natively.
            }
            var node = this.estreeParseLiteral(regex)
            node.regex = { pattern: pattern, flags: flags }

            return node
          }

          pp$7.estreeParseLiteral = function(value) {
            return this.parseLiteral(value, 'Literal')
          }

          pp$7.directiveToStmt = function(directive) {
            var directiveLiteral = directive.value

            var stmt = this.startNodeAt(directive.start, directive.loc.start)
            var expression = this.startNodeAt(
              directiveLiteral.start,
              directiveLiteral.loc.start
            )

            expression.value = directiveLiteral.value
            expression.raw = directiveLiteral.extra.raw

            stmt.expression = this.finishNodeAt(
              expression,
              'Literal',
              directiveLiteral.end,
              directiveLiteral.loc.end
            )
            stmt.directive = directiveLiteral.extra.raw.slice(1, -1)

            return this.finishNodeAt(
              stmt,
              'ExpressionStatement',
              directive.end,
              directive.loc.end
            )
          }

          function isSimpleProperty(node) {
            return (
              node &&
              node.type === 'Property' &&
              node.kind === 'init' &&
              node.method === false
            )
          }

          var estreePlugin = function(instance) {
            instance.extend('checkDeclaration', function(inner) {
              return function(node) {
                if (isSimpleProperty(node)) {
                  this.checkDeclaration(node.value)
                } else {
                  inner.call(this, node)
                }
              }
            })

            instance.extend('checkGetterSetterParamCount', function() {
              return function(prop) {
                var paramCount = prop.kind === 'get' ? 0 : 1
                if (prop.value.params.length !== paramCount) {
                  var start = prop.start
                  if (prop.kind === 'get') {
                    this.raise(start, 'getter should have no params')
                  } else {
                    this.raise(start, 'setter should have exactly one param')
                  }
                }
              }
            })

            instance.extend('checkLVal', function(inner) {
              return function(expr, isBinding, checkClashes) {
                var _this = this

                switch (expr.type) {
                  case 'ObjectPattern':
                    expr.properties.forEach(function(prop) {
                      _this.checkLVal(
                        prop.type === 'Property' ? prop.value : prop,
                        isBinding,
                        checkClashes,
                        'object destructuring pattern'
                      )
                    })
                    break
                  default:
                    for (
                      var _len = arguments.length,
                        args = Array(_len > 3 ? _len - 3 : 0),
                        _key = 3;
                      _key < _len;
                      _key++
                    ) {
                      args[_key - 3] = arguments[_key]
                    }

                    inner.call.apply(
                      inner,
                      [this, expr, isBinding, checkClashes].concat(args)
                    )
                }
              }
            })

            instance.extend('checkPropClash', function() {
              return function(prop, propHash) {
                if (prop.computed || !isSimpleProperty(prop)) return

                var key = prop.key
                // It is either an Identifier or a String/NumericLiteral
                var name = key.type === 'Identifier'
                  ? key.name
                  : String(key.value)

                if (name === '__proto__') {
                  if (propHash.proto)
                    this.raise(key.start, 'Redefinition of __proto__ property')
                  propHash.proto = true
                }
              }
            })

            instance.extend('isStrictBody', function() {
              return function(node, isExpression) {
                if (!isExpression && node.body.body.length > 0) {
                  for (
                    var _iterator = node.body.body,
                      _isArray = Array.isArray(_iterator),
                      _i = 0,
                      _iterator = _isArray
                        ? _iterator
                        : _iterator[Symbol.iterator]();
                    ;

                  ) {
                    var _ref2

                    if (_isArray) {
                      if (_i >= _iterator.length) break
                      _ref2 = _iterator[_i++]
                    } else {
                      _i = _iterator.next()
                      if (_i.done) break
                      _ref2 = _i.value
                    }

                    var directive = _ref2

                    if (
                      directive.type === 'ExpressionStatement' &&
                      directive.expression.type === 'Literal'
                    ) {
                      if (directive.expression.value === 'use strict')
                        return true
                    } else {
                      // Break for the first non literal expression
                      break
                    }
                  }
                }

                return false
              }
            })

            instance.extend('isValidDirective', function() {
              return function(stmt) {
                return (
                  stmt.type === 'ExpressionStatement' &&
                  stmt.expression.type === 'Literal' &&
                  typeof stmt.expression.value === 'string' &&
                  (!stmt.expression.extra ||
                    !stmt.expression.extra.parenthesized)
                )
              }
            })

            instance.extend('parseBlockBody', function(inner) {
              return function(node) {
                var _this2 = this

                for (
                  var _len2 = arguments.length,
                    args = Array(_len2 > 1 ? _len2 - 1 : 0),
                    _key2 = 1;
                  _key2 < _len2;
                  _key2++
                ) {
                  args[_key2 - 1] = arguments[_key2]
                }

                inner.call.apply(inner, [this, node].concat(args))

                node.directives.reverse().forEach(function(directive) {
                  node.body.unshift(_this2.directiveToStmt(directive))
                })
                delete node.directives
              }
            })

            instance.extend('parseClassMethod', function(inner) {
              return function(classBody) {
                for (
                  var _len3 = arguments.length,
                    args = Array(_len3 > 1 ? _len3 - 1 : 0),
                    _key3 = 1;
                  _key3 < _len3;
                  _key3++
                ) {
                  args[_key3 - 1] = arguments[_key3]
                }

                inner.call.apply(inner, [this, classBody].concat(args))

                var body = classBody.body
                body[body.length - 1].type = 'MethodDefinition'
              }
            })

            instance.extend('parseExprAtom', function(inner) {
              return function() {
                switch (this.state.type) {
                  case types.regexp:
                    return this.estreeParseRegExpLiteral(this.state.value)

                  case types.num:
                  case types.string:
                    return this.estreeParseLiteral(this.state.value)

                  case types._null:
                    return this.estreeParseLiteral(null)

                  case types._true:
                    return this.estreeParseLiteral(true)

                  case types._false:
                    return this.estreeParseLiteral(false)

                  default:
                    for (
                      var _len4 = arguments.length,
                        args = Array(_len4),
                        _key4 = 0;
                      _key4 < _len4;
                      _key4++
                    ) {
                      args[_key4] = arguments[_key4]
                    }

                    return inner.call.apply(inner, [this].concat(args))
                }
              }
            })

            instance.extend('parseLiteral', function(inner) {
              return function() {
                for (
                  var _len5 = arguments.length, args = Array(_len5), _key5 = 0;
                  _key5 < _len5;
                  _key5++
                ) {
                  args[_key5] = arguments[_key5]
                }

                var node = inner.call.apply(inner, [this].concat(args))
                node.raw = node.extra.raw
                delete node.extra

                return node
              }
            })

            instance.extend('parseMethod', function(inner) {
              return function(node) {
                var funcNode = this.startNode()
                funcNode.kind = node.kind // provide kind, so inner method correctly sets state

                for (
                  var _len6 = arguments.length,
                    args = Array(_len6 > 1 ? _len6 - 1 : 0),
                    _key6 = 1;
                  _key6 < _len6;
                  _key6++
                ) {
                  args[_key6 - 1] = arguments[_key6]
                }

                funcNode = inner.call.apply(
                  inner,
                  [this, funcNode].concat(args)
                )
                delete funcNode.kind
                node.value = this.finishNode(funcNode, 'FunctionExpression')

                return node
              }
            })

            instance.extend('parseObjectMethod', function(inner) {
              return function() {
                for (
                  var _len7 = arguments.length, args = Array(_len7), _key7 = 0;
                  _key7 < _len7;
                  _key7++
                ) {
                  args[_key7] = arguments[_key7]
                }

                var node = inner.call.apply(inner, [this].concat(args))

                if (node) {
                  if (node.kind === 'method') node.kind = 'init'
                  node.type = 'Property'
                }

                return node
              }
            })

            instance.extend('parseObjectProperty', function(inner) {
              return function() {
                for (
                  var _len8 = arguments.length, args = Array(_len8), _key8 = 0;
                  _key8 < _len8;
                  _key8++
                ) {
                  args[_key8] = arguments[_key8]
                }

                var node = inner.call.apply(inner, [this].concat(args))

                if (node) {
                  node.kind = 'init'
                  node.type = 'Property'
                }

                return node
              }
            })

            instance.extend('toAssignable', function(inner) {
              return function(node, isBinding) {
                for (
                  var _len9 = arguments.length,
                    args = Array(_len9 > 2 ? _len9 - 2 : 0),
                    _key9 = 2;
                  _key9 < _len9;
                  _key9++
                ) {
                  args[_key9 - 2] = arguments[_key9]
                }

                if (isSimpleProperty(node)) {
                  this.toAssignable.apply(
                    this,
                    [node.value, isBinding].concat(args)
                  )

                  return node
                } else if (node.type === 'ObjectExpression') {
                  node.type = 'ObjectPattern'
                  for (
                    var _iterator2 = node.properties,
                      _isArray2 = Array.isArray(_iterator2),
                      _i2 = 0,
                      _iterator2 = _isArray2
                        ? _iterator2
                        : _iterator2[Symbol.iterator]();
                    ;

                  ) {
                    var _ref3

                    if (_isArray2) {
                      if (_i2 >= _iterator2.length) break
                      _ref3 = _iterator2[_i2++]
                    } else {
                      _i2 = _iterator2.next()
                      if (_i2.done) break
                      _ref3 = _i2.value
                    }

                    var prop = _ref3

                    if (prop.kind === 'get' || prop.kind === 'set') {
                      this.raise(
                        prop.key.start,
                        "Object pattern can't contain getter or setter"
                      )
                    } else if (prop.method) {
                      this.raise(
                        prop.key.start,
                        "Object pattern can't contain methods"
                      )
                    } else {
                      this.toAssignable(
                        prop,
                        isBinding,
                        'object destructuring pattern'
                      )
                    }
                  }

                  return node
                }

                return inner.call.apply(
                  inner,
                  [this, node, isBinding].concat(args)
                )
              }
            })
          }

          /* eslint max-len: 0 */

          var primitiveTypes = [
            'any',
            'mixed',
            'empty',
            'bool',
            'boolean',
            'number',
            'string',
            'void',
            'null',
          ]

          var pp$8 = Parser.prototype

          pp$8.flowParseTypeInitialiser = function(tok) {
            var oldInType = this.state.inType
            this.state.inType = true
            this.expect(tok || types.colon)

            var type = this.flowParseType()
            this.state.inType = oldInType
            return type
          }

          pp$8.flowParsePredicate = function() {
            var node = this.startNode()
            var moduloLoc = this.state.startLoc
            var moduloPos = this.state.start
            this.expect(types.modulo)
            var checksLoc = this.state.startLoc
            this.expectContextual('checks')
            // Force '%' and 'checks' to be adjacent
            if (
              moduloLoc.line !== checksLoc.line ||
              moduloLoc.column !== checksLoc.column - 1
            ) {
              this.raise(
                moduloPos,
                'Spaces between % and checks are not allowed here.'
              )
            }
            if (this.eat(types.parenL)) {
              node.expression = this.parseExpression()
              this.expect(types.parenR)
              return this.finishNode(node, 'DeclaredPredicate')
            } else {
              return this.finishNode(node, 'InferredPredicate')
            }
          }

          pp$8.flowParseTypeAndPredicateInitialiser = function() {
            var oldInType = this.state.inType
            this.state.inType = true
            this.expect(types.colon)
            var type = null
            var predicate = null
            if (this.match(types.modulo)) {
              this.state.inType = oldInType
              predicate = this.flowParsePredicate()
            } else {
              type = this.flowParseType()
              this.state.inType = oldInType
              if (this.match(types.modulo)) {
                predicate = this.flowParsePredicate()
              }
            }
            return [type, predicate]
          }

          pp$8.flowParseDeclareClass = function(node) {
            this.next()
            this.flowParseInterfaceish(node, true)
            return this.finishNode(node, 'DeclareClass')
          }

          pp$8.flowParseDeclareFunction = function(node) {
            this.next()

            var id = (node.id = this.parseIdentifier())

            var typeNode = this.startNode()
            var typeContainer = this.startNode()

            if (this.isRelational('<')) {
              typeNode.typeParameters = this.flowParseTypeParameterDeclaration()
            } else {
              typeNode.typeParameters = null
            }

            this.expect(types.parenL)
            var tmp = this.flowParseFunctionTypeParams()
            typeNode.params = tmp.params
            typeNode.rest = tmp.rest
            this.expect(types.parenR)
            var predicate = null

            var _flowParseTypeAndPred = this.flowParseTypeAndPredicateInitialiser()

            typeNode.returnType = _flowParseTypeAndPred[0]
            predicate = _flowParseTypeAndPred[1]

            typeContainer.typeAnnotation = this.finishNode(
              typeNode,
              'FunctionTypeAnnotation'
            )
            typeContainer.predicate = predicate
            id.typeAnnotation = this.finishNode(typeContainer, 'TypeAnnotation')

            this.finishNode(id, id.type)

            this.semicolon()

            return this.finishNode(node, 'DeclareFunction')
          }

          pp$8.flowParseDeclare = function(node) {
            if (this.match(types._class)) {
              return this.flowParseDeclareClass(node)
            } else if (this.match(types._function)) {
              return this.flowParseDeclareFunction(node)
            } else if (this.match(types._var)) {
              return this.flowParseDeclareVariable(node)
            } else if (this.isContextual('module')) {
              if (this.lookahead().type === types.dot) {
                return this.flowParseDeclareModuleExports(node)
              } else {
                return this.flowParseDeclareModule(node)
              }
            } else if (this.isContextual('type')) {
              return this.flowParseDeclareTypeAlias(node)
            } else if (this.isContextual('interface')) {
              return this.flowParseDeclareInterface(node)
            } else {
              this.unexpected()
            }
          }

          pp$8.flowParseDeclareVariable = function(node) {
            this.next()
            node.id = this.flowParseTypeAnnotatableIdentifier()
            this.semicolon()
            return this.finishNode(node, 'DeclareVariable')
          }

          pp$8.flowParseDeclareModule = function(node) {
            this.next()

            if (this.match(types.string)) {
              node.id = this.parseExprAtom()
            } else {
              node.id = this.parseIdentifier()
            }

            var bodyNode = (node.body = this.startNode())
            var body = (bodyNode.body = [])
            this.expect(types.braceL)
            while (!this.match(types.braceR)) {
              var _bodyNode = this.startNode()

              if (this.match(types._import)) {
                var lookahead = this.lookahead()
                if (
                  lookahead.value !== 'type' &&
                  lookahead.value !== 'typeof'
                ) {
                  this.unexpected(
                    null,
                    'Imports within a `declare module` body must always be `import type` or `import typeof`'
                  )
                }

                this.parseImport(_bodyNode)
              } else {
                this.expectContextual(
                  'declare',
                  'Only declares and type imports are allowed inside declare module'
                )

                _bodyNode = this.flowParseDeclare(_bodyNode, true)
              }

              body.push(_bodyNode)
            }
            this.expect(types.braceR)

            this.finishNode(bodyNode, 'BlockStatement')
            return this.finishNode(node, 'DeclareModule')
          }

          pp$8.flowParseDeclareModuleExports = function(node) {
            this.expectContextual('module')
            this.expect(types.dot)
            this.expectContextual('exports')
            node.typeAnnotation = this.flowParseTypeAnnotation()
            this.semicolon()

            return this.finishNode(node, 'DeclareModuleExports')
          }

          pp$8.flowParseDeclareTypeAlias = function(node) {
            this.next()
            this.flowParseTypeAlias(node)
            return this.finishNode(node, 'DeclareTypeAlias')
          }

          pp$8.flowParseDeclareInterface = function(node) {
            this.next()
            this.flowParseInterfaceish(node)
            return this.finishNode(node, 'DeclareInterface')
          }

          // Interfaces

          pp$8.flowParseInterfaceish = function(node) {
            node.id = this.parseIdentifier()

            if (this.isRelational('<')) {
              node.typeParameters = this.flowParseTypeParameterDeclaration()
            } else {
              node.typeParameters = null
            }

            node.extends = []
            node.mixins = []

            if (this.eat(types._extends)) {
              do {
                node.extends.push(this.flowParseInterfaceExtends())
              } while (this.eat(types.comma))
            }

            if (this.isContextual('mixins')) {
              this.next()
              do {
                node.mixins.push(this.flowParseInterfaceExtends())
              } while (this.eat(types.comma))
            }

            node.body = this.flowParseObjectType(true, false, false)
          }

          pp$8.flowParseInterfaceExtends = function() {
            var node = this.startNode()

            node.id = this.flowParseQualifiedTypeIdentifier()
            if (this.isRelational('<')) {
              node.typeParameters = this.flowParseTypeParameterInstantiation()
            } else {
              node.typeParameters = null
            }

            return this.finishNode(node, 'InterfaceExtends')
          }

          pp$8.flowParseInterface = function(node) {
            this.flowParseInterfaceish(node, false)
            return this.finishNode(node, 'InterfaceDeclaration')
          }

          pp$8.flowParseRestrictedIdentifier = function(liberal) {
            if (primitiveTypes.indexOf(this.state.value) > -1) {
              this.raise(
                this.state.start,
                'Cannot overwrite primitive type ' + this.state.value
              )
            }

            return this.parseIdentifier(liberal)
          }

          // Type aliases

          pp$8.flowParseTypeAlias = function(node) {
            node.id = this.flowParseRestrictedIdentifier()

            if (this.isRelational('<')) {
              node.typeParameters = this.flowParseTypeParameterDeclaration()
            } else {
              node.typeParameters = null
            }

            node.right = this.flowParseTypeInitialiser(types.eq)
            this.semicolon()

            return this.finishNode(node, 'TypeAlias')
          }

          // Type annotations

          pp$8.flowParseTypeParameter = function() {
            var node = this.startNode()

            var variance = this.flowParseVariance()

            var ident = this.flowParseTypeAnnotatableIdentifier()
            node.name = ident.name
            node.variance = variance
            node.bound = ident.typeAnnotation

            if (this.match(types.eq)) {
              this.eat(types.eq)
              node.default = this.flowParseType()
            }

            return this.finishNode(node, 'TypeParameter')
          }

          pp$8.flowParseTypeParameterDeclaration = function() {
            var oldInType = this.state.inType
            var node = this.startNode()
            node.params = []

            this.state.inType = true

            // istanbul ignore else: this condition is already checked at all call sites
            if (this.isRelational('<') || this.match(types.jsxTagStart)) {
              this.next()
            } else {
              this.unexpected()
            }

            do {
              node.params.push(this.flowParseTypeParameter())
              if (!this.isRelational('>')) {
                this.expect(types.comma)
              }
            } while (!this.isRelational('>'))
            this.expectRelational('>')

            this.state.inType = oldInType

            return this.finishNode(node, 'TypeParameterDeclaration')
          }

          pp$8.flowParseTypeParameterInstantiation = function() {
            var node = this.startNode()
            var oldInType = this.state.inType
            node.params = []

            this.state.inType = true

            this.expectRelational('<')
            while (!this.isRelational('>')) {
              node.params.push(this.flowParseType())
              if (!this.isRelational('>')) {
                this.expect(types.comma)
              }
            }
            this.expectRelational('>')

            this.state.inType = oldInType

            return this.finishNode(node, 'TypeParameterInstantiation')
          }

          pp$8.flowParseObjectPropertyKey = function() {
            return this.match(types.num) || this.match(types.string)
              ? this.parseExprAtom()
              : this.parseIdentifier(true)
          }

          pp$8.flowParseObjectTypeIndexer = function(node, isStatic, variance) {
            node.static = isStatic

            this.expect(types.bracketL)
            if (this.lookahead().type === types.colon) {
              node.id = this.flowParseObjectPropertyKey()
              node.key = this.flowParseTypeInitialiser()
            } else {
              node.id = null
              node.key = this.flowParseType()
            }
            this.expect(types.bracketR)
            node.value = this.flowParseTypeInitialiser()
            node.variance = variance

            this.flowObjectTypeSemicolon()
            return this.finishNode(node, 'ObjectTypeIndexer')
          }

          pp$8.flowParseObjectTypeMethodish = function(node) {
            node.params = []
            node.rest = null
            node.typeParameters = null

            if (this.isRelational('<')) {
              node.typeParameters = this.flowParseTypeParameterDeclaration()
            }

            this.expect(types.parenL)
            while (this.match(types.name)) {
              node.params.push(this.flowParseFunctionTypeParam())
              if (!this.match(types.parenR)) {
                this.expect(types.comma)
              }
            }

            if (this.eat(types.ellipsis)) {
              node.rest = this.flowParseFunctionTypeParam()
            }
            this.expect(types.parenR)
            node.returnType = this.flowParseTypeInitialiser()

            return this.finishNode(node, 'FunctionTypeAnnotation')
          }

          pp$8.flowParseObjectTypeMethod = function(
            startPos,
            startLoc,
            isStatic,
            key
          ) {
            var node = this.startNodeAt(startPos, startLoc)
            node.value = this.flowParseObjectTypeMethodish(
              this.startNodeAt(startPos, startLoc)
            )
            node.static = isStatic
            node.key = key
            node.optional = false
            this.flowObjectTypeSemicolon()
            return this.finishNode(node, 'ObjectTypeProperty')
          }

          pp$8.flowParseObjectTypeCallProperty = function(node, isStatic) {
            var valueNode = this.startNode()
            node.static = isStatic
            node.value = this.flowParseObjectTypeMethodish(valueNode)
            this.flowObjectTypeSemicolon()
            return this.finishNode(node, 'ObjectTypeCallProperty')
          }

          pp$8.flowParseObjectType = function(
            allowStatic,
            allowExact,
            allowSpread
          ) {
            var oldInType = this.state.inType
            this.state.inType = true

            var nodeStart = this.startNode()
            var node = void 0
            var propertyKey = void 0
            var isStatic = false

            nodeStart.callProperties = []
            nodeStart.properties = []
            nodeStart.indexers = []

            var endDelim = void 0
            var exact = void 0
            if (allowExact && this.match(types.braceBarL)) {
              this.expect(types.braceBarL)
              endDelim = types.braceBarR
              exact = true
            } else {
              this.expect(types.braceL)
              endDelim = types.braceR
              exact = false
            }

            nodeStart.exact = exact

            while (!this.match(endDelim)) {
              var optional = false
              var startPos = this.state.start
              var startLoc = this.state.startLoc
              node = this.startNode()
              if (
                allowStatic &&
                this.isContextual('static') &&
                this.lookahead().type !== types.colon
              ) {
                this.next()
                isStatic = true
              }

              var variancePos = this.state.start
              var variance = this.flowParseVariance()

              if (this.match(types.bracketL)) {
                nodeStart.indexers.push(
                  this.flowParseObjectTypeIndexer(node, isStatic, variance)
                )
              } else if (this.match(types.parenL) || this.isRelational('<')) {
                if (variance) {
                  this.unexpected(variancePos)
                }
                nodeStart.callProperties.push(
                  this.flowParseObjectTypeCallProperty(node, isStatic)
                )
              } else {
                if (this.match(types.ellipsis)) {
                  if (!allowSpread) {
                    this.unexpected(
                      null,
                      'Spread operator cannnot appear in class or interface definitions'
                    )
                  }
                  if (variance) {
                    this.unexpected(
                      variance.start,
                      'Spread properties cannot have variance'
                    )
                  }
                  this.expect(types.ellipsis)
                  node.argument = this.flowParseType()
                  this.flowObjectTypeSemicolon()
                  nodeStart.properties.push(
                    this.finishNode(node, 'ObjectTypeSpreadProperty')
                  )
                } else {
                  propertyKey = this.flowParseObjectPropertyKey()
                  if (this.isRelational('<') || this.match(types.parenL)) {
                    // This is a method property
                    if (variance) {
                      this.unexpected(variance.start)
                    }
                    nodeStart.properties.push(
                      this.flowParseObjectTypeMethod(
                        startPos,
                        startLoc,
                        isStatic,
                        propertyKey
                      )
                    )
                  } else {
                    if (this.eat(types.question)) {
                      optional = true
                    }
                    node.key = propertyKey
                    node.value = this.flowParseTypeInitialiser()
                    node.optional = optional
                    node.static = isStatic
                    node.variance = variance
                    this.flowObjectTypeSemicolon()
                    nodeStart.properties.push(
                      this.finishNode(node, 'ObjectTypeProperty')
                    )
                  }
                }
              }

              isStatic = false
            }

            this.expect(endDelim)

            var out = this.finishNode(nodeStart, 'ObjectTypeAnnotation')

            this.state.inType = oldInType

            return out
          }

          pp$8.flowObjectTypeSemicolon = function() {
            if (
              !this.eat(types.semi) &&
              !this.eat(types.comma) &&
              !this.match(types.braceR) &&
              !this.match(types.braceBarR)
            ) {
              this.unexpected()
            }
          }

          pp$8.flowParseQualifiedTypeIdentifier = function(
            startPos,
            startLoc,
            id
          ) {
            startPos = startPos || this.state.start
            startLoc = startLoc || this.state.startLoc
            var node = id || this.parseIdentifier()

            while (this.eat(types.dot)) {
              var node2 = this.startNodeAt(startPos, startLoc)
              node2.qualification = node
              node2.id = this.parseIdentifier()
              node = this.finishNode(node2, 'QualifiedTypeIdentifier')
            }

            return node
          }

          pp$8.flowParseGenericType = function(startPos, startLoc, id) {
            var node = this.startNodeAt(startPos, startLoc)

            node.typeParameters = null
            node.id = this.flowParseQualifiedTypeIdentifier(
              startPos,
              startLoc,
              id
            )

            if (this.isRelational('<')) {
              node.typeParameters = this.flowParseTypeParameterInstantiation()
            }

            return this.finishNode(node, 'GenericTypeAnnotation')
          }

          pp$8.flowParseTypeofType = function() {
            var node = this.startNode()
            this.expect(types._typeof)
            node.argument = this.flowParsePrimaryType()
            return this.finishNode(node, 'TypeofTypeAnnotation')
          }

          pp$8.flowParseTupleType = function() {
            var node = this.startNode()
            node.types = []
            this.expect(types.bracketL)
            // We allow trailing commas
            while (
              this.state.pos < this.input.length &&
              !this.match(types.bracketR)
            ) {
              node.types.push(this.flowParseType())
              if (this.match(types.bracketR)) break
              this.expect(types.comma)
            }
            this.expect(types.bracketR)
            return this.finishNode(node, 'TupleTypeAnnotation')
          }

          pp$8.flowParseFunctionTypeParam = function() {
            var name = null
            var optional = false
            var typeAnnotation = null
            var node = this.startNode()
            var lh = this.lookahead()
            if (lh.type === types.colon || lh.type === types.question) {
              name = this.parseIdentifier()
              if (this.eat(types.question)) {
                optional = true
              }
              typeAnnotation = this.flowParseTypeInitialiser()
            } else {
              typeAnnotation = this.flowParseType()
            }
            node.name = name
            node.optional = optional
            node.typeAnnotation = typeAnnotation
            return this.finishNode(node, 'FunctionTypeParam')
          }

          pp$8.reinterpretTypeAsFunctionTypeParam = function(type) {
            var node = this.startNodeAt(type.start, type.loc)
            node.name = null
            node.optional = false
            node.typeAnnotation = type
            return this.finishNode(node, 'FunctionTypeParam')
          }

          pp$8.flowParseFunctionTypeParams = function() {
            var params = arguments.length > 0 && arguments[0] !== undefined
              ? arguments[0]
              : []

            var ret = { params: params, rest: null }
            while (!this.match(types.parenR) && !this.match(types.ellipsis)) {
              ret.params.push(this.flowParseFunctionTypeParam())
              if (!this.match(types.parenR)) {
                this.expect(types.comma)
              }
            }
            if (this.eat(types.ellipsis)) {
              ret.rest = this.flowParseFunctionTypeParam()
            }
            return ret
          }

          pp$8.flowIdentToTypeAnnotation = function(
            startPos,
            startLoc,
            node,
            id
          ) {
            switch (id.name) {
              case 'any':
                return this.finishNode(node, 'AnyTypeAnnotation')

              case 'void':
                return this.finishNode(node, 'VoidTypeAnnotation')

              case 'bool':
              case 'boolean':
                return this.finishNode(node, 'BooleanTypeAnnotation')

              case 'mixed':
                return this.finishNode(node, 'MixedTypeAnnotation')

              case 'empty':
                return this.finishNode(node, 'EmptyTypeAnnotation')

              case 'number':
                return this.finishNode(node, 'NumberTypeAnnotation')

              case 'string':
                return this.finishNode(node, 'StringTypeAnnotation')

              default:
                return this.flowParseGenericType(startPos, startLoc, id)
            }
          }

          // The parsing of types roughly parallels the parsing of expressions, and
          // primary types are kind of like primary expressions...they're the
          // primitives with which other types are constructed.
          pp$8.flowParsePrimaryType = function() {
            var startPos = this.state.start
            var startLoc = this.state.startLoc
            var node = this.startNode()
            var tmp = void 0
            var type = void 0
            var isGroupedType = false
            var oldNoAnonFunctionType = this.state.noAnonFunctionType

            switch (this.state.type) {
              case types.name:
                return this.flowIdentToTypeAnnotation(
                  startPos,
                  startLoc,
                  node,
                  this.parseIdentifier()
                )

              case types.braceL:
                return this.flowParseObjectType(false, false, true)

              case types.braceBarL:
                return this.flowParseObjectType(false, true, true)

              case types.bracketL:
                return this.flowParseTupleType()

              case types.relational:
                if (this.state.value === '<') {
                  node.typeParameters = this.flowParseTypeParameterDeclaration()
                  this.expect(types.parenL)
                  tmp = this.flowParseFunctionTypeParams()
                  node.params = tmp.params
                  node.rest = tmp.rest
                  this.expect(types.parenR)

                  this.expect(types.arrow)

                  node.returnType = this.flowParseType()

                  return this.finishNode(node, 'FunctionTypeAnnotation')
                }
                break

              case types.parenL:
                this.next()

                // Check to see if this is actually a grouped type
                if (!this.match(types.parenR) && !this.match(types.ellipsis)) {
                  if (this.match(types.name)) {
                    var token = this.lookahead().type
                    isGroupedType =
                      token !== types.question && token !== types.colon
                  } else {
                    isGroupedType = true
                  }
                }

                if (isGroupedType) {
                  this.state.noAnonFunctionType = false
                  type = this.flowParseType()
                  this.state.noAnonFunctionType = oldNoAnonFunctionType

                  // A `,` or a `) =>` means this is an anonymous function type
                  if (
                    this.state.noAnonFunctionType ||
                    !(
                      this.match(types.comma) ||
                      (this.match(types.parenR) &&
                        this.lookahead().type === types.arrow)
                    )
                  ) {
                    this.expect(types.parenR)
                    return type
                  } else {
                    // Eat a comma if there is one
                    this.eat(types.comma)
                  }
                }

                if (type) {
                  tmp = this.flowParseFunctionTypeParams([
                    this.reinterpretTypeAsFunctionTypeParam(type),
                  ])
                } else {
                  tmp = this.flowParseFunctionTypeParams()
                }

                node.params = tmp.params
                node.rest = tmp.rest

                this.expect(types.parenR)

                this.expect(types.arrow)

                node.returnType = this.flowParseType()

                node.typeParameters = null

                return this.finishNode(node, 'FunctionTypeAnnotation')

              case types.string:
                return this.parseLiteral(
                  this.state.value,
                  'StringLiteralTypeAnnotation'
                )

              case types._true:
              case types._false:
                node.value = this.match(types._true)
                this.next()
                return this.finishNode(node, 'BooleanLiteralTypeAnnotation')

              case types.plusMin:
                if (this.state.value === '-') {
                  this.next()
                  if (!this.match(types.num))
                    this.unexpected(null, 'Unexpected token, expected number')

                  return this.parseLiteral(
                    -this.state.value,
                    'NumericLiteralTypeAnnotation',
                    node.start,
                    node.loc.start
                  )
                }

                this.unexpected()
              case types.num:
                return this.parseLiteral(
                  this.state.value,
                  'NumericLiteralTypeAnnotation'
                )

              case types._null:
                node.value = this.match(types._null)
                this.next()
                return this.finishNode(node, 'NullLiteralTypeAnnotation')

              case types._this:
                node.value = this.match(types._this)
                this.next()
                return this.finishNode(node, 'ThisTypeAnnotation')

              case types.star:
                this.next()
                return this.finishNode(node, 'ExistentialTypeParam')

              default:
                if (this.state.type.keyword === 'typeof') {
                  return this.flowParseTypeofType()
                }
            }

            this.unexpected()
          }

          pp$8.flowParsePostfixType = function() {
            var startPos = this.state.start,
              startLoc = this.state.startLoc
            var type = this.flowParsePrimaryType()
            while (!this.canInsertSemicolon() && this.match(types.bracketL)) {
              var node = this.startNodeAt(startPos, startLoc)
              node.elementType = type
              this.expect(types.bracketL)
              this.expect(types.bracketR)
              type = this.finishNode(node, 'ArrayTypeAnnotation')
            }
            return type
          }

          pp$8.flowParsePrefixType = function() {
            var node = this.startNode()
            if (this.eat(types.question)) {
              node.typeAnnotation = this.flowParsePrefixType()
              return this.finishNode(node, 'NullableTypeAnnotation')
            } else {
              return this.flowParsePostfixType()
            }
          }

          pp$8.flowParseAnonFunctionWithoutParens = function() {
            var param = this.flowParsePrefixType()
            if (!this.state.noAnonFunctionType && this.eat(types.arrow)) {
              var node = this.startNodeAt(param.start, param.loc)
              node.params = [this.reinterpretTypeAsFunctionTypeParam(param)]
              node.rest = null
              node.returnType = this.flowParseType()
              node.typeParameters = null
              return this.finishNode(node, 'FunctionTypeAnnotation')
            }
            return param
          }

          pp$8.flowParseIntersectionType = function() {
            var node = this.startNode()
            this.eat(types.bitwiseAND)
            var type = this.flowParseAnonFunctionWithoutParens()
            node.types = [type]
            while (this.eat(types.bitwiseAND)) {
              node.types.push(this.flowParseAnonFunctionWithoutParens())
            }
            return node.types.length === 1
              ? type
              : this.finishNode(node, 'IntersectionTypeAnnotation')
          }

          pp$8.flowParseUnionType = function() {
            var node = this.startNode()
            this.eat(types.bitwiseOR)
            var type = this.flowParseIntersectionType()
            node.types = [type]
            while (this.eat(types.bitwiseOR)) {
              node.types.push(this.flowParseIntersectionType())
            }
            return node.types.length === 1
              ? type
              : this.finishNode(node, 'UnionTypeAnnotation')
          }

          pp$8.flowParseType = function() {
            var oldInType = this.state.inType
            this.state.inType = true
            var type = this.flowParseUnionType()
            this.state.inType = oldInType
            return type
          }

          pp$8.flowParseTypeAnnotation = function() {
            var node = this.startNode()
            node.typeAnnotation = this.flowParseTypeInitialiser()
            return this.finishNode(node, 'TypeAnnotation')
          }

          pp$8.flowParseTypeAndPredicateAnnotation = function() {
            var node = this.startNode()

            var _flowParseTypeAndPred2 = this.flowParseTypeAndPredicateInitialiser()

            node.typeAnnotation = _flowParseTypeAndPred2[0]
            node.predicate = _flowParseTypeAndPred2[1]

            return this.finishNode(node, 'TypeAnnotation')
          }

          pp$8.flowParseTypeAnnotatableIdentifier = function() {
            var ident = this.flowParseRestrictedIdentifier()
            if (this.match(types.colon)) {
              ident.typeAnnotation = this.flowParseTypeAnnotation()
              this.finishNode(ident, ident.type)
            }
            return ident
          }

          pp$8.typeCastToParameter = function(node) {
            node.expression.typeAnnotation = node.typeAnnotation

            return this.finishNodeAt(
              node.expression,
              node.expression.type,
              node.typeAnnotation.end,
              node.typeAnnotation.loc.end
            )
          }

          pp$8.flowParseVariance = function() {
            var variance = null
            if (this.match(types.plusMin)) {
              if (this.state.value === '+') {
                variance = 'plus'
              } else if (this.state.value === '-') {
                variance = 'minus'
              }
              this.next()
            }
            return variance
          }

          var flowPlugin = function(instance) {
            // plain function return types: function name(): string {}
            instance.extend('parseFunctionBody', function(inner) {
              return function(node, allowExpression) {
                if (this.match(types.colon) && !allowExpression) {
                  // if allowExpression is true then we're parsing an arrow function and if
                  // there's a return type then it's been handled elsewhere
                  node.returnType = this.flowParseTypeAndPredicateAnnotation()
                }

                return inner.call(this, node, allowExpression)
              }
            })

            // interfaces
            instance.extend('parseStatement', function(inner) {
              return function(declaration, topLevel) {
                // strict mode handling of `interface` since it's a reserved word
                if (
                  this.state.strict &&
                  this.match(types.name) &&
                  this.state.value === 'interface'
                ) {
                  var node = this.startNode()
                  this.next()
                  return this.flowParseInterface(node)
                } else {
                  return inner.call(this, declaration, topLevel)
                }
              }
            })

            // declares, interfaces and type aliases
            instance.extend('parseExpressionStatement', function(inner) {
              return function(node, expr) {
                if (expr.type === 'Identifier') {
                  if (expr.name === 'declare') {
                    if (
                      this.match(types._class) ||
                      this.match(types.name) ||
                      this.match(types._function) ||
                      this.match(types._var)
                    ) {
                      return this.flowParseDeclare(node)
                    }
                  } else if (this.match(types.name)) {
                    if (expr.name === 'interface') {
                      return this.flowParseInterface(node)
                    } else if (expr.name === 'type') {
                      return this.flowParseTypeAlias(node)
                    }
                  }
                }

                return inner.call(this, node, expr)
              }
            })

            // export type
            instance.extend('shouldParseExportDeclaration', function(inner) {
              return function() {
                return (
                  this.isContextual('type') ||
                  this.isContextual('interface') ||
                  inner.call(this)
                )
              }
            })

            instance.extend('parseConditional', function(inner) {
              return function(
                expr,
                noIn,
                startPos,
                startLoc,
                refNeedsArrowPos
              ) {
                // only do the expensive clone if there is a question mark
                // and if we come from inside parens
                if (refNeedsArrowPos && this.match(types.question)) {
                  var state = this.state.clone()
                  try {
                    return inner.call(this, expr, noIn, startPos, startLoc)
                  } catch (err) {
                    if (err instanceof SyntaxError) {
                      this.state = state
                      refNeedsArrowPos.start = err.pos || this.state.start
                      return expr
                    } else {
                      // istanbul ignore next: no such error is expected
                      throw err
                    }
                  }
                }

                return inner.call(this, expr, noIn, startPos, startLoc)
              }
            })

            instance.extend('parseParenItem', function(inner) {
              return function(node, startPos, startLoc) {
                node = inner.call(this, node, startPos, startLoc)
                if (this.eat(types.question)) {
                  node.optional = true
                }

                if (this.match(types.colon)) {
                  var typeCastNode = this.startNodeAt(startPos, startLoc)
                  typeCastNode.expression = node
                  typeCastNode.typeAnnotation = this.flowParseTypeAnnotation()

                  return this.finishNode(typeCastNode, 'TypeCastExpression')
                }

                return node
              }
            })

            instance.extend('parseExport', function(inner) {
              return function(node) {
                node = inner.call(this, node)
                if (node.type === 'ExportNamedDeclaration') {
                  node.exportKind = node.exportKind || 'value'
                }
                return node
              }
            })

            instance.extend('parseExportDeclaration', function(inner) {
              return function(node) {
                if (this.isContextual('type')) {
                  node.exportKind = 'type'

                  var declarationNode = this.startNode()
                  this.next()

                  if (this.match(types.braceL)) {
                    // export type { foo, bar };
                    node.specifiers = this.parseExportSpecifiers()
                    this.parseExportFrom(node)
                    return null
                  } else {
                    // export type Foo = Bar;
                    return this.flowParseTypeAlias(declarationNode)
                  }
                } else if (this.isContextual('interface')) {
                  node.exportKind = 'type'
                  var _declarationNode = this.startNode()
                  this.next()
                  return this.flowParseInterface(_declarationNode)
                } else {
                  return inner.call(this, node)
                }
              }
            })

            instance.extend('parseClassId', function(inner) {
              return function(node) {
                inner.apply(this, arguments)
                if (this.isRelational('<')) {
                  node.typeParameters = this.flowParseTypeParameterDeclaration()
                }
              }
            })

            // don't consider `void` to be a keyword as then it'll use the void token type
            // and set startExpr
            instance.extend('isKeyword', function(inner) {
              return function(name) {
                if (this.state.inType && name === 'void') {
                  return false
                } else {
                  return inner.call(this, name)
                }
              }
            })

            // ensure that inside flow types, we bypass the jsx parser plugin
            instance.extend('readToken', function(inner) {
              return function(code) {
                if (this.state.inType && (code === 62 || code === 60)) {
                  return this.finishOp(types.relational, 1)
                } else {
                  return inner.call(this, code)
                }
              }
            })

            // don't lex any token as a jsx one inside a flow type
            instance.extend('jsx_readToken', function(inner) {
              return function() {
                if (!this.state.inType) return inner.call(this)
              }
            })

            instance.extend('toAssignable', function(inner) {
              return function(node, isBinding, contextDescription) {
                if (node.type === 'TypeCastExpression') {
                  return inner.call(
                    this,
                    this.typeCastToParameter(node),
                    isBinding,
                    contextDescription
                  )
                } else {
                  return inner.call(this, node, isBinding, contextDescription)
                }
              }
            })

            // turn type casts that we found in function parameter head into type annotated params
            instance.extend('toAssignableList', function(inner) {
              return function(exprList, isBinding, contextDescription) {
                for (var i = 0; i < exprList.length; i++) {
                  var expr = exprList[i]
                  if (expr && expr.type === 'TypeCastExpression') {
                    exprList[i] = this.typeCastToParameter(expr)
                  }
                }
                return inner.call(this, exprList, isBinding, contextDescription)
              }
            })

            // this is a list of nodes, from something like a call expression, we need to filter the
            // type casts that we've found that are illegal in this context
            instance.extend('toReferencedList', function() {
              return function(exprList) {
                for (var i = 0; i < exprList.length; i++) {
                  var expr = exprList[i]
                  if (
                    expr &&
                    expr._exprListItem &&
                    expr.type === 'TypeCastExpression'
                  ) {
                    this.raise(expr.start, 'Unexpected type cast')
                  }
                }

                return exprList
              }
            })

            // parse an item inside a expression list eg. `(NODE, NODE)` where NODE represents
            // the position where this function is called
            instance.extend('parseExprListItem', function(inner) {
              return function() {
                var container = this.startNode()

                for (
                  var _len = arguments.length, args = Array(_len), _key = 0;
                  _key < _len;
                  _key++
                ) {
                  args[_key] = arguments[_key]
                }

                var node = inner.call.apply(inner, [this].concat(args))
                if (this.match(types.colon)) {
                  container._exprListItem = true
                  container.expression = node
                  container.typeAnnotation = this.flowParseTypeAnnotation()
                  return this.finishNode(container, 'TypeCastExpression')
                } else {
                  return node
                }
              }
            })

            instance.extend('checkLVal', function(inner) {
              return function(node) {
                if (node.type !== 'TypeCastExpression') {
                  return inner.apply(this, arguments)
                }
              }
            })

            // parse class property type annotations
            instance.extend('parseClassProperty', function(inner) {
              return function(node) {
                delete node.variancePos
                if (this.match(types.colon)) {
                  node.typeAnnotation = this.flowParseTypeAnnotation()
                }
                return inner.call(this, node)
              }
            })

            // determine whether or not we're currently in the position where a class method would appear
            instance.extend('isClassMethod', function(inner) {
              return function() {
                return this.isRelational('<') || inner.call(this)
              }
            })

            // determine whether or not we're currently in the position where a class property would appear
            instance.extend('isClassProperty', function(inner) {
              return function() {
                return this.match(types.colon) || inner.call(this)
              }
            })

            // parse type parameters for class methods
            instance.extend('parseClassMethod', function(inner) {
              return function(classBody, method) {
                if (method.variance) {
                  this.unexpected(method.variancePos)
                }
                delete method.variance
                delete method.variancePos
                if (this.isRelational('<')) {
                  method.typeParameters = this.flowParseTypeParameterDeclaration()
                }

                for (
                  var _len2 = arguments.length,
                    args = Array(_len2 > 2 ? _len2 - 2 : 0),
                    _key2 = 2;
                  _key2 < _len2;
                  _key2++
                ) {
                  args[_key2 - 2] = arguments[_key2]
                }

                inner.call.apply(inner, [this, classBody, method].concat(args))
              }
            })

            // parse a the super class type parameters and implements
            instance.extend('parseClassSuper', function(inner) {
              return function(node, isStatement) {
                inner.call(this, node, isStatement)
                if (node.superClass && this.isRelational('<')) {
                  node.superTypeParameters = this.flowParseTypeParameterInstantiation()
                }
                if (this.isContextual('implements')) {
                  this.next()
                  var implemented = (node.implements = [])
                  do {
                    var _node = this.startNode()
                    _node.id = this.parseIdentifier()
                    if (this.isRelational('<')) {
                      _node.typeParameters = this.flowParseTypeParameterInstantiation()
                    } else {
                      _node.typeParameters = null
                    }
                    implemented.push(this.finishNode(_node, 'ClassImplements'))
                  } while (this.eat(types.comma))
                }
              }
            })

            instance.extend('parsePropertyName', function(inner) {
              return function(node) {
                var variancePos = this.state.start
                var variance = this.flowParseVariance()
                var key = inner.call(this, node)
                node.variance = variance
                node.variancePos = variancePos
                return key
              }
            })

            // parse type parameters for object method shorthand
            instance.extend('parseObjPropValue', function(inner) {
              return function(prop) {
                if (prop.variance) {
                  this.unexpected(prop.variancePos)
                }
                delete prop.variance
                delete prop.variancePos

                var typeParameters = void 0

                // method shorthand
                if (this.isRelational('<')) {
                  typeParameters = this.flowParseTypeParameterDeclaration()
                  if (!this.match(types.parenL)) this.unexpected()
                }

                inner.apply(this, arguments)

                // add typeParameters if we found them
                if (typeParameters) {
                  ;(prop.value || prop).typeParameters = typeParameters
                }
              }
            })

            instance.extend('parseAssignableListItemTypes', function() {
              return function(param) {
                if (this.eat(types.question)) {
                  param.optional = true
                }
                if (this.match(types.colon)) {
                  param.typeAnnotation = this.flowParseTypeAnnotation()
                }
                this.finishNode(param, param.type)
                return param
              }
            })

            instance.extend('parseMaybeDefault', function(inner) {
              return function() {
                for (
                  var _len3 = arguments.length, args = Array(_len3), _key3 = 0;
                  _key3 < _len3;
                  _key3++
                ) {
                  args[_key3] = arguments[_key3]
                }

                var node = inner.apply(this, args)

                if (
                  node.type === 'AssignmentPattern' &&
                  node.typeAnnotation &&
                  node.right.start < node.typeAnnotation.start
                ) {
                  this.raise(
                    node.typeAnnotation.start,
                    'Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`'
                  )
                }

                return node
              }
            })

            // parse typeof and type imports
            instance.extend('parseImportSpecifiers', function(inner) {
              return function(node) {
                node.importKind = 'value'

                var kind = null
                if (this.match(types._typeof)) {
                  kind = 'typeof'
                } else if (this.isContextual('type')) {
                  kind = 'type'
                }
                if (kind) {
                  var lh = this.lookahead()
                  if (
                    (lh.type === types.name && lh.value !== 'from') ||
                    lh.type === types.braceL ||
                    lh.type === types.star
                  ) {
                    this.next()
                    node.importKind = kind
                  }
                }

                inner.call(this, node)
              }
            })

            // parse import-type/typeof shorthand
            instance.extend('parseImportSpecifier', function() {
              return function(node) {
                var specifier = this.startNode()
                var firstIdentLoc = this.state.start
                var firstIdent = this.parseIdentifier(true)

                var specifierTypeKind = null
                if (firstIdent.name === 'type') {
                  specifierTypeKind = 'type'
                } else if (firstIdent.name === 'typeof') {
                  specifierTypeKind = 'typeof'
                }

                var isBinding = false
                if (this.isContextual('as')) {
                  var as_ident = this.parseIdentifier(true)
                  if (
                    specifierTypeKind !== null &&
                    !this.match(types.name) &&
                    !this.state.type.keyword
                  ) {
                    // `import {type as ,` or `import {type as }`
                    specifier.imported = as_ident
                    specifier.importKind = specifierTypeKind
                    specifier.local = as_ident.__clone()
                  } else {
                    // `import {type as foo`
                    specifier.imported = firstIdent
                    specifier.importKind = null
                    specifier.local = this.parseIdentifier()
                  }
                } else if (
                  specifierTypeKind !== null &&
                  (this.match(types.name) || this.state.type.keyword)
                ) {
                  // `import {type foo`
                  specifier.imported = this.parseIdentifier(true)
                  specifier.importKind = specifierTypeKind
                  if (this.eatContextual('as')) {
                    specifier.local = this.parseIdentifier()
                  } else {
                    isBinding = true
                    specifier.local = specifier.imported.__clone()
                  }
                } else {
                  isBinding = true
                  specifier.imported = firstIdent
                  specifier.importKind = null
                  specifier.local = specifier.imported.__clone()
                }

                if (
                  (node.importKind === 'type' ||
                    node.importKind === 'typeof') &&
                  (specifier.importKind === 'type' ||
                    specifier.importKind === 'typeof')
                ) {
                  this.raise(
                    firstIdentLoc,
                    '`The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements`'
                  )
                }

                if (isBinding)
                  this.checkReservedWord(
                    specifier.local.name,
                    specifier.start,
                    true,
                    true
                  )

                this.checkLVal(
                  specifier.local,
                  true,
                  undefined,
                  'import specifier'
                )
                node.specifiers.push(
                  this.finishNode(specifier, 'ImportSpecifier')
                )
              }
            })

            // parse function type parameters - function foo<T>() {}
            instance.extend('parseFunctionParams', function(inner) {
              return function(node) {
                if (this.isRelational('<')) {
                  node.typeParameters = this.flowParseTypeParameterDeclaration()
                }
                inner.call(this, node)
              }
            })

            // parse flow type annotations on variable declarator heads - let foo: string = bar
            instance.extend('parseVarHead', function(inner) {
              return function(decl) {
                inner.call(this, decl)
                if (this.match(types.colon)) {
                  decl.id.typeAnnotation = this.flowParseTypeAnnotation()
                  this.finishNode(decl.id, decl.id.type)
                }
              }
            })

            // parse the return type of an async arrow function - let foo = (async (): number => {});
            instance.extend('parseAsyncArrowFromCallExpression', function(
              inner
            ) {
              return function(node, call) {
                if (this.match(types.colon)) {
                  var oldNoAnonFunctionType = this.state.noAnonFunctionType
                  this.state.noAnonFunctionType = true
                  node.returnType = this.flowParseTypeAnnotation()
                  this.state.noAnonFunctionType = oldNoAnonFunctionType
                }

                return inner.call(this, node, call)
              }
            })

            // todo description
            instance.extend('shouldParseAsyncArrow', function(inner) {
              return function() {
                return this.match(types.colon) || inner.call(this)
              }
            })

            // We need to support type parameter declarations for arrow functions. This
            // is tricky. There are three situations we need to handle
            //
            // 1. This is either JSX or an arrow function. We'll try JSX first. If that
            //    fails, we'll try an arrow function. If that fails, we'll throw the JSX
            //    error.
            // 2. This is an arrow function. We'll parse the type parameter declaration,
            //    parse the rest, make sure the rest is an arrow function, and go from
            //    there
            // 3. This is neither. Just call the inner function
            instance.extend('parseMaybeAssign', function(inner) {
              return function() {
                var jsxError = null

                for (
                  var _len4 = arguments.length, args = Array(_len4), _key4 = 0;
                  _key4 < _len4;
                  _key4++
                ) {
                  args[_key4] = arguments[_key4]
                }

                if (types.jsxTagStart && this.match(types.jsxTagStart)) {
                  var state = this.state.clone()
                  try {
                    return inner.apply(this, args)
                  } catch (err) {
                    if (err instanceof SyntaxError) {
                      this.state = state
                      jsxError = err
                    } else {
                      // istanbul ignore next: no such error is expected
                      throw err
                    }
                  }
                }

                // Need to push something onto the context to stop
                // the JSX plugin from messing with the tokens
                this.state.context.push(types$1.parenExpression)
                if (jsxError != null || this.isRelational('<')) {
                  var arrowExpression = void 0
                  var typeParameters = void 0
                  try {
                    typeParameters = this.flowParseTypeParameterDeclaration()

                    arrowExpression = inner.apply(this, args)
                    arrowExpression.typeParameters = typeParameters
                    arrowExpression.start = typeParameters.start
                    arrowExpression.loc.start = typeParameters.loc.start
                  } catch (err) {
                    throw jsxError || err
                  }

                  if (arrowExpression.type === 'ArrowFunctionExpression') {
                    return arrowExpression
                  } else if (jsxError != null) {
                    throw jsxError
                  } else {
                    this.raise(
                      typeParameters.start,
                      'Expected an arrow function after this type parameter declaration'
                    )
                  }
                }
                this.state.context.pop()

                return inner.apply(this, args)
              }
            })

            // handle return types for arrow functions
            instance.extend('parseArrow', function(inner) {
              return function(node) {
                if (this.match(types.colon)) {
                  var state = this.state.clone()
                  try {
                    var oldNoAnonFunctionType = this.state.noAnonFunctionType
                    this.state.noAnonFunctionType = true
                    var returnType = this.flowParseTypeAndPredicateAnnotation()
                    this.state.noAnonFunctionType = oldNoAnonFunctionType

                    if (this.canInsertSemicolon()) this.unexpected()
                    if (!this.match(types.arrow)) this.unexpected()
                    // assign after it is clear it is an arrow
                    node.returnType = returnType
                  } catch (err) {
                    if (err instanceof SyntaxError) {
                      this.state = state
                    } else {
                      // istanbul ignore next: no such error is expected
                      throw err
                    }
                  }
                }

                return inner.call(this, node)
              }
            })

            instance.extend('shouldParseArrow', function(inner) {
              return function() {
                return this.match(types.colon) || inner.call(this)
              }
            })
          }

          // Adapted from String.fromcodepoint to export the function without modifying String
          /*! https://mths.be/fromcodepoint v0.2.1 by @mathias */

          // The MIT License (MIT)
          // Copyright (c) Mathias Bynens
          //
          // Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
          // associated documentation files (the "Software"), to deal in the Software without restriction,
          // including without limitation the rights to use, copy, modify, merge, publish, distribute,
          // sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
          // furnished to do so, subject to the following conditions:
          //
          // The above copyright notice and this permission notice shall be included in all copies or
          // substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
          // NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
          // NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
          // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

          var fromCodePoint = String.fromCodePoint

          if (!fromCodePoint) {
            var stringFromCharCode = String.fromCharCode
            var floor = Math.floor
            fromCodePoint = function fromCodePoint() {
              var MAX_SIZE = 0x4000
              var codeUnits = []
              var highSurrogate = void 0
              var lowSurrogate = void 0
              var index = -1
              var length = arguments.length
              if (!length) {
                return ''
              }
              var result = ''
              while (++index < length) {
                var codePoint = Number(arguments[index])
                if (
                  !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
                  codePoint < 0 || // not a valid Unicode code point
                  codePoint > 0x10ffff || // not a valid Unicode code point
                  floor(codePoint) != codePoint // not an integer
                ) {
                  throw RangeError('Invalid code point: ' + codePoint)
                }
                if (codePoint <= 0xffff) {
                  // BMP code point
                  codeUnits.push(codePoint)
                } else {
                  // Astral code point; split in surrogate halves
                  // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
                  codePoint -= 0x10000
                  highSurrogate = (codePoint >> 10) + 0xd800
                  lowSurrogate = codePoint % 0x400 + 0xdc00
                  codeUnits.push(highSurrogate, lowSurrogate)
                }
                if (index + 1 == length || codeUnits.length > MAX_SIZE) {
                  result += stringFromCharCode.apply(null, codeUnits)
                  codeUnits.length = 0
                }
              }
              return result
            }
          }

          var fromCodePoint$1 = fromCodePoint

          var XHTMLEntities = {
            quot: '"',
            amp: '&',
            apos: "'",
            lt: '<',
            gt: '>',
            nbsp: '\xA0',
            iexcl: '\xA1',
            cent: '\xA2',
            pound: '\xA3',
            curren: '\xA4',
            yen: '\xA5',
            brvbar: '\xA6',
            sect: '\xA7',
            uml: '\xA8',
            copy: '\xA9',
            ordf: '\xAA',
            laquo: '\xAB',
            not: '\xAC',
            shy: '\xAD',
            reg: '\xAE',
            macr: '\xAF',
            deg: '\xB0',
            plusmn: '\xB1',
            sup2: '\xB2',
            sup3: '\xB3',
            acute: '\xB4',
            micro: '\xB5',
            para: '\xB6',
            middot: '\xB7',
            cedil: '\xB8',
            sup1: '\xB9',
            ordm: '\xBA',
            raquo: '\xBB',
            frac14: '\xBC',
            frac12: '\xBD',
            frac34: '\xBE',
            iquest: '\xBF',
            Agrave: '\xC0',
            Aacute: '\xC1',
            Acirc: '\xC2',
            Atilde: '\xC3',
            Auml: '\xC4',
            Aring: '\xC5',
            AElig: '\xC6',
            Ccedil: '\xC7',
            Egrave: '\xC8',
            Eacute: '\xC9',
            Ecirc: '\xCA',
            Euml: '\xCB',
            Igrave: '\xCC',
            Iacute: '\xCD',
            Icirc: '\xCE',
            Iuml: '\xCF',
            ETH: '\xD0',
            Ntilde: '\xD1',
            Ograve: '\xD2',
            Oacute: '\xD3',
            Ocirc: '\xD4',
            Otilde: '\xD5',
            Ouml: '\xD6',
            times: '\xD7',
            Oslash: '\xD8',
            Ugrave: '\xD9',
            Uacute: '\xDA',
            Ucirc: '\xDB',
            Uuml: '\xDC',
            Yacute: '\xDD',
            THORN: '\xDE',
            szlig: '\xDF',
            agrave: '\xE0',
            aacute: '\xE1',
            acirc: '\xE2',
            atilde: '\xE3',
            auml: '\xE4',
            aring: '\xE5',
            aelig: '\xE6',
            ccedil: '\xE7',
            egrave: '\xE8',
            eacute: '\xE9',
            ecirc: '\xEA',
            euml: '\xEB',
            igrave: '\xEC',
            iacute: '\xED',
            icirc: '\xEE',
            iuml: '\xEF',
            eth: '\xF0',
            ntilde: '\xF1',
            ograve: '\xF2',
            oacute: '\xF3',
            ocirc: '\xF4',
            otilde: '\xF5',
            ouml: '\xF6',
            divide: '\xF7',
            oslash: '\xF8',
            ugrave: '\xF9',
            uacute: '\xFA',
            ucirc: '\xFB',
            uuml: '\xFC',
            yacute: '\xFD',
            thorn: '\xFE',
            yuml: '\xFF',
            OElig: '\u0152',
            oelig: '\u0153',
            Scaron: '\u0160',
            scaron: '\u0161',
            Yuml: '\u0178',
            fnof: '\u0192',
            circ: '\u02C6',
            tilde: '\u02DC',
            Alpha: '\u0391',
            Beta: '\u0392',
            Gamma: '\u0393',
            Delta: '\u0394',
            Epsilon: '\u0395',
            Zeta: '\u0396',
            Eta: '\u0397',
            Theta: '\u0398',
            Iota: '\u0399',
            Kappa: '\u039A',
            Lambda: '\u039B',
            Mu: '\u039C',
            Nu: '\u039D',
            Xi: '\u039E',
            Omicron: '\u039F',
            Pi: '\u03A0',
            Rho: '\u03A1',
            Sigma: '\u03A3',
            Tau: '\u03A4',
            Upsilon: '\u03A5',
            Phi: '\u03A6',
            Chi: '\u03A7',
            Psi: '\u03A8',
            Omega: '\u03A9',
            alpha: '\u03B1',
            beta: '\u03B2',
            gamma: '\u03B3',
            delta: '\u03B4',
            epsilon: '\u03B5',
            zeta: '\u03B6',
            eta: '\u03B7',
            theta: '\u03B8',
            iota: '\u03B9',
            kappa: '\u03BA',
            lambda: '\u03BB',
            mu: '\u03BC',
            nu: '\u03BD',
            xi: '\u03BE',
            omicron: '\u03BF',
            pi: '\u03C0',
            rho: '\u03C1',
            sigmaf: '\u03C2',
            sigma: '\u03C3',
            tau: '\u03C4',
            upsilon: '\u03C5',
            phi: '\u03C6',
            chi: '\u03C7',
            psi: '\u03C8',
            omega: '\u03C9',
            thetasym: '\u03D1',
            upsih: '\u03D2',
            piv: '\u03D6',
            ensp: '\u2002',
            emsp: '\u2003',
            thinsp: '\u2009',
            zwnj: '\u200C',
            zwj: '\u200D',
            lrm: '\u200E',
            rlm: '\u200F',
            ndash: '\u2013',
            mdash: '\u2014',
            lsquo: '\u2018',
            rsquo: '\u2019',
            sbquo: '\u201A',
            ldquo: '\u201C',
            rdquo: '\u201D',
            bdquo: '\u201E',
            dagger: '\u2020',
            Dagger: '\u2021',
            bull: '\u2022',
            hellip: '\u2026',
            permil: '\u2030',
            prime: '\u2032',
            Prime: '\u2033',
            lsaquo: '\u2039',
            rsaquo: '\u203A',
            oline: '\u203E',
            frasl: '\u2044',
            euro: '\u20AC',
            image: '\u2111',
            weierp: '\u2118',
            real: '\u211C',
            trade: '\u2122',
            alefsym: '\u2135',
            larr: '\u2190',
            uarr: '\u2191',
            rarr: '\u2192',
            darr: '\u2193',
            harr: '\u2194',
            crarr: '\u21B5',
            lArr: '\u21D0',
            uArr: '\u21D1',
            rArr: '\u21D2',
            dArr: '\u21D3',
            hArr: '\u21D4',
            forall: '\u2200',
            part: '\u2202',
            exist: '\u2203',
            empty: '\u2205',
            nabla: '\u2207',
            isin: '\u2208',
            notin: '\u2209',
            ni: '\u220B',
            prod: '\u220F',
            sum: '\u2211',
            minus: '\u2212',
            lowast: '\u2217',
            radic: '\u221A',
            prop: '\u221D',
            infin: '\u221E',
            ang: '\u2220',
            and: '\u2227',
            or: '\u2228',
            cap: '\u2229',
            cup: '\u222A',
            int: '\u222B',
            there4: '\u2234',
            sim: '\u223C',
            cong: '\u2245',
            asymp: '\u2248',
            ne: '\u2260',
            equiv: '\u2261',
            le: '\u2264',
            ge: '\u2265',
            sub: '\u2282',
            sup: '\u2283',
            nsub: '\u2284',
            sube: '\u2286',
            supe: '\u2287',
            oplus: '\u2295',
            otimes: '\u2297',
            perp: '\u22A5',
            sdot: '\u22C5',
            lceil: '\u2308',
            rceil: '\u2309',
            lfloor: '\u230A',
            rfloor: '\u230B',
            lang: '\u2329',
            rang: '\u232A',
            loz: '\u25CA',
            spades: '\u2660',
            clubs: '\u2663',
            hearts: '\u2665',
            diams: '\u2666',
          }

          var HEX_NUMBER = /^[\da-fA-F]+$/
          var DECIMAL_NUMBER = /^\d+$/

          types$1.j_oTag = new TokContext('<tag', false)
          types$1.j_cTag = new TokContext('</tag', false)
          types$1.j_expr = new TokContext('<tag>...</tag>', true, true)

          types.jsxName = new TokenType('jsxName')
          types.jsxText = new TokenType('jsxText', { beforeExpr: true })
          types.jsxTagStart = new TokenType('jsxTagStart', { startsExpr: true })
          types.jsxTagEnd = new TokenType('jsxTagEnd')

          types.jsxTagStart.updateContext = function() {
            this.state.context.push(types$1.j_expr) // treat as beginning of JSX expression
            this.state.context.push(types$1.j_oTag) // start opening tag context
            this.state.exprAllowed = false
          }

          types.jsxTagEnd.updateContext = function(prevType) {
            var out = this.state.context.pop()
            if (
              (out === types$1.j_oTag && prevType === types.slash) ||
              out === types$1.j_cTag
            ) {
              this.state.context.pop()
              this.state.exprAllowed = this.curContext() === types$1.j_expr
            } else {
              this.state.exprAllowed = true
            }
          }

          var pp$9 = Parser.prototype

          // Reads inline JSX contents token.

          pp$9.jsxReadToken = function() {
            var out = ''
            var chunkStart = this.state.pos
            for (;;) {
              if (this.state.pos >= this.input.length) {
                this.raise(this.state.start, 'Unterminated JSX contents')
              }

              var ch = this.input.charCodeAt(this.state.pos)

              switch (ch) {
                case 60: // "<"
                case 123:
                  // "{"
                  if (this.state.pos === this.state.start) {
                    if (ch === 60 && this.state.exprAllowed) {
                      ++this.state.pos
                      return this.finishToken(types.jsxTagStart)
                    }
                    return this.getTokenFromCode(ch)
                  }
                  out += this.input.slice(chunkStart, this.state.pos)
                  return this.finishToken(types.jsxText, out)

                case 38:
                  // "&"
                  out += this.input.slice(chunkStart, this.state.pos)
                  out += this.jsxReadEntity()
                  chunkStart = this.state.pos
                  break

                default:
                  if (isNewLine(ch)) {
                    out += this.input.slice(chunkStart, this.state.pos)
                    out += this.jsxReadNewLine(true)
                    chunkStart = this.state.pos
                  } else {
                    ++this.state.pos
                  }
              }
            }
          }

          pp$9.jsxReadNewLine = function(normalizeCRLF) {
            var ch = this.input.charCodeAt(this.state.pos)
            var out = void 0
            ++this.state.pos
            if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
              ++this.state.pos
              out = normalizeCRLF ? '\n' : '\r\n'
            } else {
              out = String.fromCharCode(ch)
            }
            ++this.state.curLine
            this.state.lineStart = this.state.pos

            return out
          }

          pp$9.jsxReadString = function(quote) {
            var out = ''
            var chunkStart = ++this.state.pos
            for (;;) {
              if (this.state.pos >= this.input.length) {
                this.raise(this.state.start, 'Unterminated string constant')
              }

              var ch = this.input.charCodeAt(this.state.pos)
              if (ch === quote) break
              if (ch === 38) {
                // "&"
                out += this.input.slice(chunkStart, this.state.pos)
                out += this.jsxReadEntity()
                chunkStart = this.state.pos
              } else if (isNewLine(ch)) {
                out += this.input.slice(chunkStart, this.state.pos)
                out += this.jsxReadNewLine(false)
                chunkStart = this.state.pos
              } else {
                ++this.state.pos
              }
            }
            out += this.input.slice(chunkStart, this.state.pos++)
            return this.finishToken(types.string, out)
          }

          pp$9.jsxReadEntity = function() {
            var str = ''
            var count = 0
            var entity = void 0
            var ch = this.input[this.state.pos]

            var startPos = ++this.state.pos
            while (this.state.pos < this.input.length && count++ < 10) {
              ch = this.input[this.state.pos++]
              if (ch === ';') {
                if (str[0] === '#') {
                  if (str[1] === 'x') {
                    str = str.substr(2)
                    if (HEX_NUMBER.test(str))
                      entity = fromCodePoint$1(parseInt(str, 16))
                  } else {
                    str = str.substr(1)
                    if (DECIMAL_NUMBER.test(str))
                      entity = fromCodePoint$1(parseInt(str, 10))
                  }
                } else {
                  entity = XHTMLEntities[str]
                }
                break
              }
              str += ch
            }
            if (!entity) {
              this.state.pos = startPos
              return '&'
            }
            return entity
          }

          // Read a JSX identifier (valid tag or attribute name).
          //
          // Optimized version since JSX identifiers can"t contain
          // escape characters and so can be read as single slice.
          // Also assumes that first character was already checked
          // by isIdentifierStart in readToken.

          pp$9.jsxReadWord = function() {
            var ch = void 0
            var start = this.state.pos
            do {
              ch = this.input.charCodeAt(++this.state.pos)
            } while (isIdentifierChar(ch) || ch === 45) // "-"
            return this.finishToken(
              types.jsxName,
              this.input.slice(start, this.state.pos)
            )
          }

          // Transforms JSX element name to string.

          function getQualifiedJSXName(object) {
            if (object.type === 'JSXIdentifier') {
              return object.name
            }

            if (object.type === 'JSXNamespacedName') {
              return object.namespace.name + ':' + object.name.name
            }

            if (object.type === 'JSXMemberExpression') {
              return (
                getQualifiedJSXName(object.object) +
                '.' +
                getQualifiedJSXName(object.property)
              )
            }
          }

          // Parse next token as JSX identifier

          pp$9.jsxParseIdentifier = function() {
            var node = this.startNode()
            if (this.match(types.jsxName)) {
              node.name = this.state.value
            } else if (this.state.type.keyword) {
              node.name = this.state.type.keyword
            } else {
              this.unexpected()
            }
            this.next()
            return this.finishNode(node, 'JSXIdentifier')
          }

          // Parse namespaced identifier.

          pp$9.jsxParseNamespacedName = function() {
            var startPos = this.state.start
            var startLoc = this.state.startLoc
            var name = this.jsxParseIdentifier()
            if (!this.eat(types.colon)) return name

            var node = this.startNodeAt(startPos, startLoc)
            node.namespace = name
            node.name = this.jsxParseIdentifier()
            return this.finishNode(node, 'JSXNamespacedName')
          }

          // Parses element name in any form - namespaced, member
          // or single identifier.

          pp$9.jsxParseElementName = function() {
            var startPos = this.state.start
            var startLoc = this.state.startLoc
            var node = this.jsxParseNamespacedName()
            while (this.eat(types.dot)) {
              var newNode = this.startNodeAt(startPos, startLoc)
              newNode.object = node
              newNode.property = this.jsxParseIdentifier()
              node = this.finishNode(newNode, 'JSXMemberExpression')
            }
            return node
          }

          // Parses any type of JSX attribute value.

          pp$9.jsxParseAttributeValue = function() {
            var node = void 0
            switch (this.state.type) {
              case types.braceL:
                node = this.jsxParseExpressionContainer()
                if (node.expression.type === 'JSXEmptyExpression') {
                  this.raise(
                    node.start,
                    'JSX attributes must only be assigned a non-empty expression'
                  )
                } else {
                  return node
                }

              case types.jsxTagStart:
              case types.string:
                node = this.parseExprAtom()
                node.extra = null
                return node

              default:
                this.raise(
                  this.state.start,
                  'JSX value should be either an expression or a quoted JSX text'
                )
            }
          }

          // JSXEmptyExpression is unique type since it doesn't actually parse anything,
          // and so it should start at the end of last read token (left brace) and finish
          // at the beginning of the next one (right brace).

          pp$9.jsxParseEmptyExpression = function() {
            var node = this.startNodeAt(
              this.state.lastTokEnd,
              this.state.lastTokEndLoc
            )
            return this.finishNodeAt(
              node,
              'JSXEmptyExpression',
              this.state.start,
              this.state.startLoc
            )
          }

          // Parse JSX spread child

          pp$9.jsxParseSpreadChild = function() {
            var node = this.startNode()
            this.expect(types.braceL)
            this.expect(types.ellipsis)
            node.expression = this.parseExpression()
            this.expect(types.braceR)

            return this.finishNode(node, 'JSXSpreadChild')
          }

          // Parses JSX expression enclosed into curly brackets.

          pp$9.jsxParseExpressionContainer = function() {
            var node = this.startNode()
            this.next()
            if (this.match(types.braceR)) {
              node.expression = this.jsxParseEmptyExpression()
            } else {
              node.expression = this.parseExpression()
            }
            this.expect(types.braceR)
            return this.finishNode(node, 'JSXExpressionContainer')
          }

          // Parses following JSX attribute name-value pair.

          pp$9.jsxParseAttribute = function() {
            var node = this.startNode()
            if (this.eat(types.braceL)) {
              this.expect(types.ellipsis)
              node.argument = this.parseMaybeAssign()
              this.expect(types.braceR)
              return this.finishNode(node, 'JSXSpreadAttribute')
            }
            node.name = this.jsxParseNamespacedName()
            node.value = this.eat(types.eq)
              ? this.jsxParseAttributeValue()
              : null
            return this.finishNode(node, 'JSXAttribute')
          }

          // Parses JSX opening tag starting after "<".

          pp$9.jsxParseOpeningElementAt = function(startPos, startLoc) {
            var node = this.startNodeAt(startPos, startLoc)
            node.attributes = []
            node.name = this.jsxParseElementName()
            while (!this.match(types.slash) && !this.match(types.jsxTagEnd)) {
              node.attributes.push(this.jsxParseAttribute())
            }
            node.selfClosing = this.eat(types.slash)
            this.expect(types.jsxTagEnd)
            return this.finishNode(node, 'JSXOpeningElement')
          }

          // Parses JSX closing tag starting after "</".

          pp$9.jsxParseClosingElementAt = function(startPos, startLoc) {
            var node = this.startNodeAt(startPos, startLoc)
            node.name = this.jsxParseElementName()
            this.expect(types.jsxTagEnd)
            return this.finishNode(node, 'JSXClosingElement')
          }

          // Parses entire JSX element, including it"s opening tag
          // (starting after "<"), attributes, contents and closing tag.

          pp$9.jsxParseElementAt = function(startPos, startLoc) {
            var node = this.startNodeAt(startPos, startLoc)
            var children = []
            var openingElement = this.jsxParseOpeningElementAt(
              startPos,
              startLoc
            )
            var closingElement = null

            if (!openingElement.selfClosing) {
              contents: for (;;) {
                switch (this.state.type) {
                  case types.jsxTagStart:
                    startPos = this.state.start
                    startLoc = this.state.startLoc
                    this.next()
                    if (this.eat(types.slash)) {
                      closingElement = this.jsxParseClosingElementAt(
                        startPos,
                        startLoc
                      )
                      break contents
                    }
                    children.push(this.jsxParseElementAt(startPos, startLoc))
                    break

                  case types.jsxText:
                    children.push(this.parseExprAtom())
                    break

                  case types.braceL:
                    if (this.lookahead().type === types.ellipsis) {
                      children.push(this.jsxParseSpreadChild())
                    } else {
                      children.push(this.jsxParseExpressionContainer())
                    }

                    break

                  // istanbul ignore next - should never happen
                  default:
                    this.unexpected()
                }
              }

              if (
                getQualifiedJSXName(closingElement.name) !==
                getQualifiedJSXName(openingElement.name)
              ) {
                this.raise(
                  closingElement.start,
                  'Expected corresponding JSX closing tag for <' +
                    getQualifiedJSXName(openingElement.name) +
                    '>'
                )
              }
            }

            node.openingElement = openingElement
            node.closingElement = closingElement
            node.children = children
            if (this.match(types.relational) && this.state.value === '<') {
              this.raise(
                this.state.start,
                'Adjacent JSX elements must be wrapped in an enclosing tag'
              )
            }
            return this.finishNode(node, 'JSXElement')
          }

          // Parses entire JSX element from current position.

          pp$9.jsxParseElement = function() {
            var startPos = this.state.start
            var startLoc = this.state.startLoc
            this.next()
            return this.jsxParseElementAt(startPos, startLoc)
          }

          var jsxPlugin = function(instance) {
            instance.extend('parseExprAtom', function(inner) {
              return function(refShortHandDefaultPos) {
                if (this.match(types.jsxText)) {
                  var node = this.parseLiteral(this.state.value, 'JSXText')
                  // https://github.com/babel/babel/issues/2078
                  node.extra = null
                  return node
                } else if (this.match(types.jsxTagStart)) {
                  return this.jsxParseElement()
                } else {
                  return inner.call(this, refShortHandDefaultPos)
                }
              }
            })

            instance.extend('readToken', function(inner) {
              return function(code) {
                if (this.state.inPropertyName) return inner.call(this, code)

                var context = this.curContext()

                if (context === types$1.j_expr) {
                  return this.jsxReadToken()
                }

                if (context === types$1.j_oTag || context === types$1.j_cTag) {
                  if (isIdentifierStart(code)) {
                    return this.jsxReadWord()
                  }

                  if (code === 62) {
                    ++this.state.pos
                    return this.finishToken(types.jsxTagEnd)
                  }

                  if (
                    (code === 34 || code === 39) &&
                    context === types$1.j_oTag
                  ) {
                    return this.jsxReadString(code)
                  }
                }

                if (code === 60 && this.state.exprAllowed) {
                  ++this.state.pos
                  return this.finishToken(types.jsxTagStart)
                }

                return inner.call(this, code)
              }
            })

            instance.extend('updateContext', function(inner) {
              return function(prevType) {
                if (this.match(types.braceL)) {
                  var curContext = this.curContext()
                  if (curContext === types$1.j_oTag) {
                    this.state.context.push(types$1.braceExpression)
                  } else if (curContext === types$1.j_expr) {
                    this.state.context.push(types$1.templateQuasi)
                  } else {
                    inner.call(this, prevType)
                  }
                  this.state.exprAllowed = true
                } else if (
                  this.match(types.slash) &&
                  prevType === types.jsxTagStart
                ) {
                  this.state.context.length -= 2 // do not consider JSX expr -> JSX open tag -> ... anymore
                  this.state.context.push(types$1.j_cTag) // reconsider as closing tag context
                  this.state.exprAllowed = false
                } else {
                  return inner.call(this, prevType)
                }
              }
            })
          }

          plugins.estree = estreePlugin
          plugins.flow = flowPlugin
          plugins.jsx = jsxPlugin

          function parse(input, options) {
            return new Parser(options, input).parse()
          }

          function parseExpression(input, options) {
            var parser = new Parser(options, input)
            if (parser.options.strictMode) {
              parser.state.strict = true
            }
            return parser.getExpression()
          }

          exports.parse = parse
          exports.parseExpression = parseExpression
          exports.tokTypes = types
        },
        {},
      ],
      115: [
        function(require, module, exports) {
          module.exports = balanced
          function balanced(a, b, str) {
            if (a instanceof RegExp) a = maybeMatch(a, str)
            if (b instanceof RegExp) b = maybeMatch(b, str)

            var r = range(a, b, str)

            return (
              r && {
                start: r[0],
                end: r[1],
                pre: str.slice(0, r[0]),
                body: str.slice(r[0] + a.length, r[1]),
                post: str.slice(r[1] + b.length),
              }
            )
          }

          function maybeMatch(reg, str) {
            var m = str.match(reg)
            return m ? m[0] : null
          }

          balanced.range = range
          function range(a, b, str) {
            var begs, beg, left, right, result
            var ai = str.indexOf(a)
            var bi = str.indexOf(b, ai + 1)
            var i = ai

            if (ai >= 0 && bi > 0) {
              begs = []
              left = str.length

              while (i >= 0 && !result) {
                if (i == ai) {
                  begs.push(i)
                  ai = str.indexOf(a, i + 1)
                } else if (begs.length == 1) {
                  result = [begs.pop(), bi]
                } else {
                  beg = begs.pop()
                  if (beg < left) {
                    left = beg
                    right = bi
                  }

                  bi = str.indexOf(b, i + 1)
                }

                i = ai < bi && ai >= 0 ? ai : bi
              }

              if (begs.length) {
                result = [left, right]
              }
            }

            return result
          }
        },
        {},
      ],
      116: [
        function(require, module, exports) {
          'use strict'
          exports.byteLength = byteLength
          exports.toByteArray = toByteArray
          exports.fromByteArray = fromByteArray

          var lookup = []
          var revLookup = []
          var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

          var code =
            'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
          for (var i = 0, len = code.length; i < len; ++i) {
            lookup[i] = code[i]
            revLookup[code.charCodeAt(i)] = i
          }

          revLookup['-'.charCodeAt(0)] = 62
          revLookup['_'.charCodeAt(0)] = 63

          function placeHoldersCount(b64) {
            var len = b64.length
            if (len % 4 > 0) {
              throw new Error('Invalid string. Length must be a multiple of 4')
            }

            // the number of equal signs (place holders)
            // if there are two placeholders, than the two characters before it
            // represent one byte
            // if there is only one, then the three characters before it represent 2 bytes
            // this is just a cheap hack to not do indexOf twice
            return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
          }

          function byteLength(b64) {
            // base64 is 4/3 + up to two characters of the original data
            return b64.length * 3 / 4 - placeHoldersCount(b64)
          }

          function toByteArray(b64) {
            var i, j, l, tmp, placeHolders, arr
            var len = b64.length
            placeHolders = placeHoldersCount(b64)

            arr = new Arr(len * 3 / 4 - placeHolders)

            // if there are placeholders, only get up to the last complete 4 chars
            l = placeHolders > 0 ? len - 4 : len

            var L = 0

            for (i = 0, j = 0; i < l; i += 4, j += 3) {
              tmp =
                (revLookup[b64.charCodeAt(i)] << 18) |
                (revLookup[b64.charCodeAt(i + 1)] << 12) |
                (revLookup[b64.charCodeAt(i + 2)] << 6) |
                revLookup[b64.charCodeAt(i + 3)]
              arr[L++] = (tmp >> 16) & 0xff
              arr[L++] = (tmp >> 8) & 0xff
              arr[L++] = tmp & 0xff
            }

            if (placeHolders === 2) {
              tmp =
                (revLookup[b64.charCodeAt(i)] << 2) |
                (revLookup[b64.charCodeAt(i + 1)] >> 4)
              arr[L++] = tmp & 0xff
            } else if (placeHolders === 1) {
              tmp =
                (revLookup[b64.charCodeAt(i)] << 10) |
                (revLookup[b64.charCodeAt(i + 1)] << 4) |
                (revLookup[b64.charCodeAt(i + 2)] >> 2)
              arr[L++] = (tmp >> 8) & 0xff
              arr[L++] = tmp & 0xff
            }

            return arr
          }

          function tripletToBase64(num) {
            return (
              lookup[(num >> 18) & 0x3f] +
              lookup[(num >> 12) & 0x3f] +
              lookup[(num >> 6) & 0x3f] +
              lookup[num & 0x3f]
            )
          }

          function encodeChunk(uint8, start, end) {
            var tmp
            var output = []
            for (var i = start; i < end; i += 3) {
              tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2]
              output.push(tripletToBase64(tmp))
            }
            return output.join('')
          }

          function fromByteArray(uint8) {
            var tmp
            var len = uint8.length
            var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
            var output = ''
            var parts = []
            var maxChunkLength = 16383 // must be multiple of 3

            // go through the array every three bytes, we'll deal with trailing stuff later
            for (
              var i = 0, len2 = len - extraBytes;
              i < len2;
              i += maxChunkLength
            ) {
              parts.push(
                encodeChunk(
                  uint8,
                  i,
                  i + maxChunkLength > len2 ? len2 : i + maxChunkLength
                )
              )
            }

            // pad the end with zeros, but make sure to not forget the extra bytes
            if (extraBytes === 1) {
              tmp = uint8[len - 1]
              output += lookup[tmp >> 2]
              output += lookup[(tmp << 4) & 0x3f]
              output += '=='
            } else if (extraBytes === 2) {
              tmp = (uint8[len - 2] << 8) + uint8[len - 1]
              output += lookup[tmp >> 10]
              output += lookup[(tmp >> 4) & 0x3f]
              output += lookup[(tmp << 2) & 0x3f]
              output += '='
            }

            parts.push(output)

            return parts.join('')
          }
        },
        {},
      ],
      117: [
        function(require, module, exports) {
          var concatMap = require('concat-map')
          var balanced = require('balanced-match')

          module.exports = expandTop

          var escSlash = '\0SLASH' + Math.random() + '\0'
          var escOpen = '\0OPEN' + Math.random() + '\0'
          var escClose = '\0CLOSE' + Math.random() + '\0'
          var escComma = '\0COMMA' + Math.random() + '\0'
          var escPeriod = '\0PERIOD' + Math.random() + '\0'

          function numeric(str) {
            return parseInt(str, 10) == str
              ? parseInt(str, 10)
              : str.charCodeAt(0)
          }

          function escapeBraces(str) {
            return str
              .split('\\\\')
              .join(escSlash)
              .split('\\{')
              .join(escOpen)
              .split('\\}')
              .join(escClose)
              .split('\\,')
              .join(escComma)
              .split('\\.')
              .join(escPeriod)
          }

          function unescapeBraces(str) {
            return str
              .split(escSlash)
              .join('\\')
              .split(escOpen)
              .join('{')
              .split(escClose)
              .join('}')
              .split(escComma)
              .join(',')
              .split(escPeriod)
              .join('.')
          }

          // Basically just str.split(","), but handling cases
          // where we have nested braced sections, which should be
          // treated as individual members, like {a,{b,c},d}
          function parseCommaParts(str) {
            if (!str) return ['']

            var parts = []
            var m = balanced('{', '}', str)

            if (!m) return str.split(',')

            var pre = m.pre
            var body = m.body
            var post = m.post
            var p = pre.split(',')

            p[p.length - 1] += '{' + body + '}'
            var postParts = parseCommaParts(post)
            if (post.length) {
              p[p.length - 1] += postParts.shift()
              p.push.apply(p, postParts)
            }

            parts.push.apply(parts, p)

            return parts
          }

          function expandTop(str) {
            if (!str) return []

            // I don't know why Bash 4.3 does this, but it does.
            // Anything starting with {} will have the first two bytes preserved
            // but *only* at the top level, so {},a}b will not expand to anything,
            // but a{},b}c will be expanded to [a}c,abc].
            // One could argue that this is a bug in Bash, but since the goal of
            // this module is to match Bash's rules, we escape a leading {}
            if (str.substr(0, 2) === '{}') {
              str = '\\{\\}' + str.substr(2)
            }

            return expand(escapeBraces(str), true).map(unescapeBraces)
          }

          function identity(e) {
            return e
          }

          function embrace(str) {
            return '{' + str + '}'
          }
          function isPadded(el) {
            return /^-?0\d/.test(el)
          }

          function lte(i, y) {
            return i <= y
          }
          function gte(i, y) {
            return i >= y
          }

          function expand(str, isTop) {
            var expansions = []

            var m = balanced('{', '}', str)
            if (!m || /\$$/.test(m.pre)) return [str]

            var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(
              m.body
            )
            var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(
              m.body
            )
            var isSequence = isNumericSequence || isAlphaSequence
            var isOptions = m.body.indexOf(',') >= 0
            if (!isSequence && !isOptions) {
              // {a},b}
              if (m.post.match(/,.*\}/)) {
                str = m.pre + '{' + m.body + escClose + m.post
                return expand(str)
              }
              return [str]
            }

            var n
            if (isSequence) {
              n = m.body.split(/\.\./)
            } else {
              n = parseCommaParts(m.body)
              if (n.length === 1) {
                // x{{a,b}}y ==> x{a}y x{b}y
                n = expand(n[0], false).map(embrace)
                if (n.length === 1) {
                  var post = m.post.length ? expand(m.post, false) : ['']
                  return post.map(function(p) {
                    return m.pre + n[0] + p
                  })
                }
              }
            }

            // at this point, n is the parts, and we know it's not a comma set
            // with a single entry.

            // no need to expand pre, since it is guaranteed to be free of brace-sets
            var pre = m.pre
            var post = m.post.length ? expand(m.post, false) : ['']

            var N

            if (isSequence) {
              var x = numeric(n[0])
              var y = numeric(n[1])
              var width = Math.max(n[0].length, n[1].length)
              var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1
              var test = lte
              var reverse = y < x
              if (reverse) {
                incr *= -1
                test = gte
              }
              var pad = n.some(isPadded)

              N = []

              for (var i = x; test(i, y); i += incr) {
                var c
                if (isAlphaSequence) {
                  c = String.fromCharCode(i)
                  if (c === '\\') c = ''
                } else {
                  c = String(i)
                  if (pad) {
                    var need = width - c.length
                    if (need > 0) {
                      var z = new Array(need + 1).join('0')
                      if (i < 0) c = '-' + z + c.slice(1)
                      else c = z + c
                    }
                  }
                }
                N.push(c)
              }
            } else {
              N = concatMap(n, function(el) {
                return expand(el, false)
              })
            }

            for (var j = 0; j < N.length; j++) {
              for (var k = 0; k < post.length; k++) {
                var expansion = pre + N[j] + post[k]
                if (!isTop || isSequence || expansion)
                  expansions.push(expansion)
              }
            }

            return expansions
          }
        },
        { 'balanced-match': 115, 'concat-map': 130 },
      ],
      118: [function(require, module, exports) {}, {}],
      119: [
        function(require, module, exports) {
          ;(function(global) {
            ;(function(global, factory) {
              typeof exports === 'object' && typeof module !== 'undefined'
                ? factory(
                    exports,
                    require('acorn/dist/acorn.js'),
                    require('magic-string')
                  )
                : typeof define === 'function' && define.amd
                  ? define(
                      ['exports', 'acorn/dist/acorn.js', 'magic-string'],
                      factory
                    )
                  : factory(
                      (global.buble = global.buble || {}),
                      global.acorn,
                      global.MagicString
                    )
            })(this, function(exports, acorn, MagicString) {
              'use strict'
              acorn = 'default' in acorn ? acorn['default'] : acorn
              MagicString = 'default' in MagicString
                ? MagicString['default']
                : MagicString

              var __commonjs_global = typeof window !== 'undefined'
                ? window
                : typeof global !== 'undefined' ? global : this
              function __commonjs(fn, module) {
                return (module = {
                  exports: {},
                }), fn(module, module.exports, __commonjs_global), module.exports
              }

              var xhtml = __commonjs(function(module) {
                module.exports = {
                  quot: '\u0022',
                  amp: '&',
                  apos: '\u0027',
                  lt: '<',
                  gt: '>',
                  nbsp: '\u00A0',
                  iexcl: '\u00A1',
                  cent: '\u00A2',
                  pound: '\u00A3',
                  curren: '\u00A4',
                  yen: '\u00A5',
                  brvbar: '\u00A6',
                  sect: '\u00A7',
                  uml: '\u00A8',
                  copy: '\u00A9',
                  ordf: '\u00AA',
                  laquo: '\u00AB',
                  not: '\u00AC',
                  shy: '\u00AD',
                  reg: '\u00AE',
                  macr: '\u00AF',
                  deg: '\u00B0',
                  plusmn: '\u00B1',
                  sup2: '\u00B2',
                  sup3: '\u00B3',
                  acute: '\u00B4',
                  micro: '\u00B5',
                  para: '\u00B6',
                  middot: '\u00B7',
                  cedil: '\u00B8',
                  sup1: '\u00B9',
                  ordm: '\u00BA',
                  raquo: '\u00BB',
                  frac14: '\u00BC',
                  frac12: '\u00BD',
                  frac34: '\u00BE',
                  iquest: '\u00BF',
                  Agrave: '\u00C0',
                  Aacute: '\u00C1',
                  Acirc: '\u00C2',
                  Atilde: '\u00C3',
                  Auml: '\u00C4',
                  Aring: '\u00C5',
                  AElig: '\u00C6',
                  Ccedil: '\u00C7',
                  Egrave: '\u00C8',
                  Eacute: '\u00C9',
                  Ecirc: '\u00CA',
                  Euml: '\u00CB',
                  Igrave: '\u00CC',
                  Iacute: '\u00CD',
                  Icirc: '\u00CE',
                  Iuml: '\u00CF',
                  ETH: '\u00D0',
                  Ntilde: '\u00D1',
                  Ograve: '\u00D2',
                  Oacute: '\u00D3',
                  Ocirc: '\u00D4',
                  Otilde: '\u00D5',
                  Ouml: '\u00D6',
                  times: '\u00D7',
                  Oslash: '\u00D8',
                  Ugrave: '\u00D9',
                  Uacute: '\u00DA',
                  Ucirc: '\u00DB',
                  Uuml: '\u00DC',
                  Yacute: '\u00DD',
                  THORN: '\u00DE',
                  szlig: '\u00DF',
                  agrave: '\u00E0',
                  aacute: '\u00E1',
                  acirc: '\u00E2',
                  atilde: '\u00E3',
                  auml: '\u00E4',
                  aring: '\u00E5',
                  aelig: '\u00E6',
                  ccedil: '\u00E7',
                  egrave: '\u00E8',
                  eacute: '\u00E9',
                  ecirc: '\u00EA',
                  euml: '\u00EB',
                  igrave: '\u00EC',
                  iacute: '\u00ED',
                  icirc: '\u00EE',
                  iuml: '\u00EF',
                  eth: '\u00F0',
                  ntilde: '\u00F1',
                  ograve: '\u00F2',
                  oacute: '\u00F3',
                  ocirc: '\u00F4',
                  otilde: '\u00F5',
                  ouml: '\u00F6',
                  divide: '\u00F7',
                  oslash: '\u00F8',
                  ugrave: '\u00F9',
                  uacute: '\u00FA',
                  ucirc: '\u00FB',
                  uuml: '\u00FC',
                  yacute: '\u00FD',
                  thorn: '\u00FE',
                  yuml: '\u00FF',
                  OElig: '\u0152',
                  oelig: '\u0153',
                  Scaron: '\u0160',
                  scaron: '\u0161',
                  Yuml: '\u0178',
                  fnof: '\u0192',
                  circ: '\u02C6',
                  tilde: '\u02DC',
                  Alpha: '\u0391',
                  Beta: '\u0392',
                  Gamma: '\u0393',
                  Delta: '\u0394',
                  Epsilon: '\u0395',
                  Zeta: '\u0396',
                  Eta: '\u0397',
                  Theta: '\u0398',
                  Iota: '\u0399',
                  Kappa: '\u039A',
                  Lambda: '\u039B',
                  Mu: '\u039C',
                  Nu: '\u039D',
                  Xi: '\u039E',
                  Omicron: '\u039F',
                  Pi: '\u03A0',
                  Rho: '\u03A1',
                  Sigma: '\u03A3',
                  Tau: '\u03A4',
                  Upsilon: '\u03A5',
                  Phi: '\u03A6',
                  Chi: '\u03A7',
                  Psi: '\u03A8',
                  Omega: '\u03A9',
                  alpha: '\u03B1',
                  beta: '\u03B2',
                  gamma: '\u03B3',
                  delta: '\u03B4',
                  epsilon: '\u03B5',
                  zeta: '\u03B6',
                  eta: '\u03B7',
                  theta: '\u03B8',
                  iota: '\u03B9',
                  kappa: '\u03BA',
                  lambda: '\u03BB',
                  mu: '\u03BC',
                  nu: '\u03BD',
                  xi: '\u03BE',
                  omicron: '\u03BF',
                  pi: '\u03C0',
                  rho: '\u03C1',
                  sigmaf: '\u03C2',
                  sigma: '\u03C3',
                  tau: '\u03C4',
                  upsilon: '\u03C5',
                  phi: '\u03C6',
                  chi: '\u03C7',
                  psi: '\u03C8',
                  omega: '\u03C9',
                  thetasym: '\u03D1',
                  upsih: '\u03D2',
                  piv: '\u03D6',
                  ensp: '\u2002',
                  emsp: '\u2003',
                  thinsp: '\u2009',
                  zwnj: '\u200C',
                  zwj: '\u200D',
                  lrm: '\u200E',
                  rlm: '\u200F',
                  ndash: '\u2013',
                  mdash: '\u2014',
                  lsquo: '\u2018',
                  rsquo: '\u2019',
                  sbquo: '\u201A',
                  ldquo: '\u201C',
                  rdquo: '\u201D',
                  bdquo: '\u201E',
                  dagger: '\u2020',
                  Dagger: '\u2021',
                  bull: '\u2022',
                  hellip: '\u2026',
                  permil: '\u2030',
                  prime: '\u2032',
                  Prime: '\u2033',
                  lsaquo: '\u2039',
                  rsaquo: '\u203A',
                  oline: '\u203E',
                  frasl: '\u2044',
                  euro: '\u20AC',
                  image: '\u2111',
                  weierp: '\u2118',
                  real: '\u211C',
                  trade: '\u2122',
                  alefsym: '\u2135',
                  larr: '\u2190',
                  uarr: '\u2191',
                  rarr: '\u2192',
                  darr: '\u2193',
                  harr: '\u2194',
                  crarr: '\u21B5',
                  lArr: '\u21D0',
                  uArr: '\u21D1',
                  rArr: '\u21D2',
                  dArr: '\u21D3',
                  hArr: '\u21D4',
                  forall: '\u2200',
                  part: '\u2202',
                  exist: '\u2203',
                  empty: '\u2205',
                  nabla: '\u2207',
                  isin: '\u2208',
                  notin: '\u2209',
                  ni: '\u220B',
                  prod: '\u220F',
                  sum: '\u2211',
                  minus: '\u2212',
                  lowast: '\u2217',
                  radic: '\u221A',
                  prop: '\u221D',
                  infin: '\u221E',
                  ang: '\u2220',
                  and: '\u2227',
                  or: '\u2228',
                  cap: '\u2229',
                  cup: '\u222A',
                  int: '\u222B',
                  there4: '\u2234',
                  sim: '\u223C',
                  cong: '\u2245',
                  asymp: '\u2248',
                  ne: '\u2260',
                  equiv: '\u2261',
                  le: '\u2264',
                  ge: '\u2265',
                  sub: '\u2282',
                  sup: '\u2283',
                  nsub: '\u2284',
                  sube: '\u2286',
                  supe: '\u2287',
                  oplus: '\u2295',
                  otimes: '\u2297',
                  perp: '\u22A5',
                  sdot: '\u22C5',
                  lceil: '\u2308',
                  rceil: '\u2309',
                  lfloor: '\u230A',
                  rfloor: '\u230B',
                  lang: '\u2329',
                  rang: '\u232A',
                  loz: '\u25CA',
                  spades: '\u2660',
                  clubs: '\u2663',
                  hearts: '\u2665',
                  diams: '\u2666',
                }
              })

              var require$$0 = xhtml &&
                typeof xhtml === 'object' &&
                'default' in xhtml
                ? xhtml['default']
                : xhtml

              var inject = __commonjs(function(module) {
                'use strict'
                var XHTMLEntities = require$$0

                var hexNumber = /^[\da-fA-F]+$/
                var decimalNumber = /^\d+$/

                module.exports = function(acorn) {
                  var tt = acorn.tokTypes
                  var tc = acorn.tokContexts

                  tc.j_oTag = new acorn.TokContext('<tag', false)
                  tc.j_cTag = new acorn.TokContext('</tag', false)
                  tc.j_expr = new acorn.TokContext('<tag>...</tag>', true, true)

                  tt.jsxName = new acorn.TokenType('jsxName')
                  tt.jsxText = new acorn.TokenType('jsxText', {
                    beforeExpr: true,
                  })
                  tt.jsxTagStart = new acorn.TokenType('jsxTagStart')
                  tt.jsxTagEnd = new acorn.TokenType('jsxTagEnd')

                  tt.jsxTagStart.updateContext = function() {
                    this.context.push(tc.j_expr) // treat as beginning of JSX expression
                    this.context.push(tc.j_oTag) // start opening tag context
                    this.exprAllowed = false
                  }
                  tt.jsxTagEnd.updateContext = function(prevType) {
                    var out = this.context.pop()
                    if (
                      (out === tc.j_oTag && prevType === tt.slash) ||
                      out === tc.j_cTag
                    ) {
                      this.context.pop()
                      this.exprAllowed = this.curContext() === tc.j_expr
                    } else {
                      this.exprAllowed = true
                    }
                  }

                  var pp = acorn.Parser.prototype

                  // Reads inline JSX contents token.

                  pp.jsx_readToken = function() {
                    var out = '',
                      chunkStart = this.pos
                    for (;;) {
                      if (this.pos >= this.input.length)
                        this.raise(this.start, 'Unterminated JSX contents')
                      var ch = this.input.charCodeAt(this.pos)

                      switch (ch) {
                        case 60: // '<'
                        case 123: // '{'
                          if (this.pos === this.start) {
                            if (ch === 60 && this.exprAllowed) {
                              ++this.pos
                              return this.finishToken(tt.jsxTagStart)
                            }
                            return this.getTokenFromCode(ch)
                          }
                          out += this.input.slice(chunkStart, this.pos)
                          return this.finishToken(tt.jsxText, out)

                        case 38: // '&'
                          out += this.input.slice(chunkStart, this.pos)
                          out += this.jsx_readEntity()
                          chunkStart = this.pos
                          break

                        default:
                          if (acorn.isNewLine(ch)) {
                            out += this.input.slice(chunkStart, this.pos)
                            out += this.jsx_readNewLine(true)
                            chunkStart = this.pos
                          } else {
                            ++this.pos
                          }
                      }
                    }
                  }

                  pp.jsx_readNewLine = function(normalizeCRLF) {
                    var ch = this.input.charCodeAt(this.pos)
                    var out
                    ++this.pos
                    if (ch === 13 && this.input.charCodeAt(this.pos) === 10) {
                      ++this.pos
                      out = normalizeCRLF ? '\n' : '\r\n'
                    } else {
                      out = String.fromCharCode(ch)
                    }
                    if (this.options.locations) {
                      ++this.curLine
                      this.lineStart = this.pos
                    }

                    return out
                  }

                  pp.jsx_readString = function(quote) {
                    var out = '',
                      chunkStart = ++this.pos
                    for (;;) {
                      if (this.pos >= this.input.length)
                        this.raise(this.start, 'Unterminated string constant')
                      var ch = this.input.charCodeAt(this.pos)
                      if (ch === quote) break
                      if (ch === 38) {
                        // '&'
                        out += this.input.slice(chunkStart, this.pos)
                        out += this.jsx_readEntity()
                        chunkStart = this.pos
                      } else if (acorn.isNewLine(ch)) {
                        out += this.input.slice(chunkStart, this.pos)
                        out += this.jsx_readNewLine(false)
                        chunkStart = this.pos
                      } else {
                        ++this.pos
                      }
                    }
                    out += this.input.slice(chunkStart, this.pos++)
                    return this.finishToken(tt.string, out)
                  }

                  pp.jsx_readEntity = function() {
                    var str = '',
                      count = 0,
                      entity
                    var ch = this.input[this.pos]
                    if (ch !== '&')
                      this.raise(
                        this.pos,
                        'Entity must start with an ampersand'
                      )
                    var startPos = ++this.pos
                    while (this.pos < this.input.length && count++ < 10) {
                      ch = this.input[this.pos++]
                      if (ch === ';') {
                        if (str[0] === '#') {
                          if (str[1] === 'x') {
                            str = str.substr(2)
                            if (hexNumber.test(str))
                              entity = String.fromCharCode(parseInt(str, 16))
                          } else {
                            str = str.substr(1)
                            if (decimalNumber.test(str))
                              entity = String.fromCharCode(parseInt(str, 10))
                          }
                        } else {
                          entity = XHTMLEntities[str]
                        }
                        break
                      }
                      str += ch
                    }
                    if (!entity) {
                      this.pos = startPos
                      return '&'
                    }
                    return entity
                  }

                  // Read a JSX identifier (valid tag or attribute name).
                  //
                  // Optimized version since JSX identifiers can't contain
                  // escape characters and so can be read as single slice.
                  // Also assumes that first character was already checked
                  // by isIdentifierStart in readToken.

                  pp.jsx_readWord = function() {
                    var ch,
                      start = this.pos
                    do {
                      ch = this.input.charCodeAt(++this.pos)
                    } while (acorn.isIdentifierChar(ch) || ch === 45) // '-'
                    return this.finishToken(
                      tt.jsxName,
                      this.input.slice(start, this.pos)
                    )
                  }

                  // Transforms JSX element name to string.

                  function getQualifiedJSXName(object) {
                    if (object.type === 'JSXIdentifier') return object.name

                    if (object.type === 'JSXNamespacedName')
                      return object.namespace.name + ':' + object.name.name

                    if (object.type === 'JSXMemberExpression')
                      return (
                        getQualifiedJSXName(object.object) +
                        '.' +
                        getQualifiedJSXName(object.property)
                      )
                  }

                  // Parse next token as JSX identifier

                  pp.jsx_parseIdentifier = function() {
                    var node = this.startNode()
                    if (this.type === tt.jsxName) node.name = this.value
                    else if (this.type.keyword) node.name = this.type.keyword
                    else this.unexpected()
                    this.next()
                    return this.finishNode(node, 'JSXIdentifier')
                  }

                  // Parse namespaced identifier.

                  pp.jsx_parseNamespacedName = function() {
                    var startPos = this.start,
                      startLoc = this.startLoc
                    var name = this.jsx_parseIdentifier()
                    if (
                      !this.options.plugins.jsx.allowNamespaces ||
                      !this.eat(tt.colon)
                    )
                      return name
                    var node = this.startNodeAt(startPos, startLoc)
                    node.namespace = name
                    node.name = this.jsx_parseIdentifier()
                    return this.finishNode(node, 'JSXNamespacedName')
                  }

                  // Parses element name in any form - namespaced, member
                  // or single identifier.

                  pp.jsx_parseElementName = function() {
                    var startPos = this.start,
                      startLoc = this.startLoc
                    var node = this.jsx_parseNamespacedName()
                    if (
                      this.type === tt.dot &&
                      node.type === 'JSXNamespacedName' &&
                      !this.options.plugins.jsx.allowNamespacedObjects
                    ) {
                      this.unexpected()
                    }
                    while (this.eat(tt.dot)) {
                      var newNode = this.startNodeAt(startPos, startLoc)
                      newNode.object = node
                      newNode.property = this.jsx_parseIdentifier()
                      node = this.finishNode(newNode, 'JSXMemberExpression')
                    }
                    return node
                  }

                  // Parses any type of JSX attribute value.

                  pp.jsx_parseAttributeValue = function() {
                    switch (this.type) {
                      case tt.braceL:
                        var node = this.jsx_parseExpressionContainer()
                        if (node.expression.type === 'JSXEmptyExpression')
                          this.raise(
                            node.start,
                            'JSX attributes must only be assigned a non-empty expression'
                          )
                        return node

                      case tt.jsxTagStart:
                      case tt.string:
                        return this.parseExprAtom()

                      default:
                        this.raise(
                          this.start,
                          'JSX value should be either an expression or a quoted JSX text'
                        )
                    }
                  }

                  // JSXEmptyExpression is unique type since it doesn't actually parse anything,
                  // and so it should start at the end of last read token (left brace) and finish
                  // at the beginning of the next one (right brace).

                  pp.jsx_parseEmptyExpression = function() {
                    var node = this.startNodeAt(
                      this.lastTokEnd,
                      this.lastTokEndLoc
                    )
                    return this.finishNodeAt(
                      node,
                      'JSXEmptyExpression',
                      this.start,
                      this.startLoc
                    )
                  }

                  // Parses JSX expression enclosed into curly brackets.

                  pp.jsx_parseExpressionContainer = function() {
                    var node = this.startNode()
                    this.next()
                    node.expression = this.type === tt.braceR
                      ? this.jsx_parseEmptyExpression()
                      : this.parseExpression()
                    this.expect(tt.braceR)
                    return this.finishNode(node, 'JSXExpressionContainer')
                  }

                  // Parses following JSX attribute name-value pair.

                  pp.jsx_parseAttribute = function() {
                    var node = this.startNode()
                    if (this.eat(tt.braceL)) {
                      this.expect(tt.ellipsis)
                      node.argument = this.parseMaybeAssign()
                      this.expect(tt.braceR)
                      return this.finishNode(node, 'JSXSpreadAttribute')
                    }
                    node.name = this.jsx_parseNamespacedName()
                    node.value = this.eat(tt.eq)
                      ? this.jsx_parseAttributeValue()
                      : null
                    return this.finishNode(node, 'JSXAttribute')
                  }

                  // Parses JSX opening tag starting after '<'.

                  pp.jsx_parseOpeningElementAt = function(startPos, startLoc) {
                    var node = this.startNodeAt(startPos, startLoc)
                    node.attributes = []
                    node.name = this.jsx_parseElementName()
                    while (this.type !== tt.slash && this.type !== tt.jsxTagEnd)
                      node.attributes.push(this.jsx_parseAttribute())
                    node.selfClosing = this.eat(tt.slash)
                    this.expect(tt.jsxTagEnd)
                    return this.finishNode(node, 'JSXOpeningElement')
                  }

                  // Parses JSX closing tag starting after '</'.

                  pp.jsx_parseClosingElementAt = function(startPos, startLoc) {
                    var node = this.startNodeAt(startPos, startLoc)
                    node.name = this.jsx_parseElementName()
                    this.expect(tt.jsxTagEnd)
                    return this.finishNode(node, 'JSXClosingElement')
                  }

                  // Parses entire JSX element, including it's opening tag
                  // (starting after '<'), attributes, contents and closing tag.

                  pp.jsx_parseElementAt = function(startPos, startLoc) {
                    var node = this.startNodeAt(startPos, startLoc)
                    var children = []
                    var openingElement = this.jsx_parseOpeningElementAt(
                      startPos,
                      startLoc
                    )
                    var closingElement = null

                    if (!openingElement.selfClosing) {
                      contents: for (;;) {
                        switch (this.type) {
                          case tt.jsxTagStart:
                            startPos = this.start
                            startLoc = this.startLoc
                            this.next()
                            if (this.eat(tt.slash)) {
                              closingElement = this.jsx_parseClosingElementAt(
                                startPos,
                                startLoc
                              )
                              break contents
                            }
                            children.push(
                              this.jsx_parseElementAt(startPos, startLoc)
                            )
                            break

                          case tt.jsxText:
                            children.push(this.parseExprAtom())
                            break

                          case tt.braceL:
                            children.push(this.jsx_parseExpressionContainer())
                            break

                          default:
                            this.unexpected()
                        }
                      }
                      if (
                        getQualifiedJSXName(closingElement.name) !==
                        getQualifiedJSXName(openingElement.name)
                      ) {
                        this.raise(
                          closingElement.start,
                          'Expected corresponding JSX closing tag for <' +
                            getQualifiedJSXName(openingElement.name) +
                            '>'
                        )
                      }
                    }

                    node.openingElement = openingElement
                    node.closingElement = closingElement
                    node.children = children
                    if (this.type === tt.relational && this.value === '<') {
                      this.raise(
                        this.start,
                        'Adjacent JSX elements must be wrapped in an enclosing tag'
                      )
                    }
                    return this.finishNode(node, 'JSXElement')
                  }

                  // Parses entire JSX element from current position.

                  pp.jsx_parseElement = function() {
                    var startPos = this.start,
                      startLoc = this.startLoc
                    this.next()
                    return this.jsx_parseElementAt(startPos, startLoc)
                  }

                  acorn.plugins.jsx = function(instance, opts) {
                    if (!opts) {
                      return
                    }

                    if (typeof opts !== 'object') {
                      opts = {}
                    }

                    instance.options.plugins.jsx = {
                      allowNamespaces: opts.allowNamespaces !== false,
                      allowNamespacedObjects: !!opts.allowNamespacedObjects,
                    }

                    instance.extend('parseExprAtom', function(inner) {
                      return function(refShortHandDefaultPos) {
                        if (this.type === tt.jsxText)
                          return this.parseLiteral(this.value)
                        else if (this.type === tt.jsxTagStart)
                          return this.jsx_parseElement()
                        else return inner.call(this, refShortHandDefaultPos)
                      }
                    })

                    instance.extend('readToken', function(inner) {
                      return function(code) {
                        var context = this.curContext()

                        if (context === tc.j_expr) return this.jsx_readToken()

                        if (context === tc.j_oTag || context === tc.j_cTag) {
                          if (acorn.isIdentifierStart(code))
                            return this.jsx_readWord()

                          if (code == 62) {
                            ++this.pos
                            return this.finishToken(tt.jsxTagEnd)
                          }

                          if (
                            (code === 34 || code === 39) &&
                            context == tc.j_oTag
                          )
                            return this.jsx_readString(code)
                        }

                        if (code === 60 && this.exprAllowed) {
                          ++this.pos
                          return this.finishToken(tt.jsxTagStart)
                        }
                        return inner.call(this, code)
                      }
                    })

                    instance.extend('updateContext', function(inner) {
                      return function(prevType) {
                        if (this.type == tt.braceL) {
                          var curContext = this.curContext()
                          if (curContext == tc.j_oTag)
                            this.context.push(tc.b_expr)
                          else if (curContext == tc.j_expr)
                            this.context.push(tc.b_tmpl)
                          else inner.call(this, prevType)
                          this.exprAllowed = true
                        } else if (
                          this.type === tt.slash &&
                          prevType === tt.jsxTagStart
                        ) {
                          this.context.length -= 2 // do not consider JSX expr -> JSX open tag -> ... anymore
                          this.context.push(tc.j_cTag) // reconsider as closing tag context
                          this.exprAllowed = false
                        } else {
                          return inner.call(this, prevType)
                        }
                      }
                    })
                  }

                  return acorn
                }
              })

              var acornJsx = inject &&
                typeof inject === 'object' &&
                'default' in inject
                ? inject['default']
                : inject

              var inject$1 = __commonjs(function(module) {
                'use strict'
                module.exports = function(acorn) {
                  var tt = acorn.tokTypes
                  var pp = acorn.Parser.prototype

                  // this is the same parseObj that acorn has with...
                  function parseObj(isPattern, refDestructuringErrors) {
                    var this$1 = this

                    var node = this.startNode(),
                      first = true,
                      propHash = {}
                    node.properties = []
                    this.next()
                    while (!this$1.eat(tt.braceR)) {
                      if (!first) {
                        this$1.expect(tt.comma)
                        if (this$1.afterTrailingComma(tt.braceR)) break
                      } else first = false

                      var prop = this$1.startNode(),
                        isGenerator,
                        startPos,
                        startLoc
                      if (this$1.options.ecmaVersion >= 6) {
                        // ...the spread logic borrowed from babylon :)
                        if (this$1.type === tt.ellipsis) {
                          prop = this$1.parseSpread()
                          prop.type = isPattern
                            ? 'RestProperty'
                            : 'SpreadProperty'
                          node.properties.push(prop)
                          continue
                        }

                        prop.method = false
                        prop.shorthand = false
                        if (isPattern || refDestructuringErrors) {
                          startPos = this$1.start
                          startLoc = this$1.startLoc
                        }
                        if (!isPattern) isGenerator = this$1.eat(tt.star)
                      }
                      this$1.parsePropertyName(prop)
                      this$1.parsePropertyValue(
                        prop,
                        isPattern,
                        isGenerator,
                        startPos,
                        startLoc,
                        refDestructuringErrors
                      )
                      this$1.checkPropClash(prop, propHash)
                      node.properties.push(this$1.finishNode(prop, 'Property'))
                    }
                    return this.finishNode(
                      node,
                      isPattern ? 'ObjectPattern' : 'ObjectExpression'
                    )
                  }

                  acorn.plugins.objectSpread = function objectSpreadPlugin(
                    instance
                  ) {
                    pp.parseObj = parseObj
                  }

                  return acorn
                }
              })

              var acornObjectSpread = inject$1 &&
                typeof inject$1 === 'object' &&
                'default' in inject$1
                ? inject$1['default']
                : inject$1

              var keys = {
                Program: ['body'],
                Literal: [],
              }

              // used for debugging, without the noise created by
              // circular references
              function toJSON(node) {
                var obj = {}

                Object.keys(node).forEach(function(key) {
                  if (
                    key === 'parent' ||
                    key === 'program' ||
                    key === 'keys' ||
                    key === '__wrapped'
                  )
                    return

                  if (Array.isArray(node[key])) {
                    obj[key] = node[key].map(toJSON)
                  } else if (node[key] && node[key].toJSON) {
                    obj[key] = node[key].toJSON()
                  } else {
                    obj[key] = node[key]
                  }
                })

                return obj
              }

              var Node = function Node(raw, parent) {
                raw.parent = parent
                raw.program = parent.program || parent
                raw.depth = parent.depth + 1
                raw.keys = keys[raw.type]
                raw.indentation = undefined

                for (
                  var i = 0, list = keys[raw.type];
                  i < list.length;
                  i += 1
                ) {
                  var key = list[i]

                  wrap(raw[key], raw)
                }

                raw.program.magicString.addSourcemapLocation(raw.start)
                raw.program.magicString.addSourcemapLocation(raw.end)
              }

              Node.prototype.ancestor = function ancestor(level) {
                var node = this
                while (level--) {
                  node = node.parent
                  if (!node) return null
                }

                return node
              }

              Node.prototype.contains = function contains(node) {
                var this$1 = this

                while (node) {
                  if (node === this$1) return true
                  node = node.parent
                }

                return false
              }

              Node.prototype.findLexicalBoundary = function findLexicalBoundary() {
                return this.parent.findLexicalBoundary()
              }

              Node.prototype.findNearest = function findNearest(type) {
                if (typeof type === 'string')
                  type = new RegExp('^' + type + '$')
                if (type.test(this.type)) return this
                return this.parent.findNearest(type)
              }

              Node.prototype.unparenthesizedParent = function unparenthesizedParent() {
                var node = this.parent
                while (node && node.type === 'ParenthesizedExpression') {
                  node = node.parent
                }
                return node
              }

              Node.prototype.unparenthesize = function unparenthesize() {
                var node = this
                while (node.type === 'ParenthesizedExpression') {
                  node = node.expression
                }
                return node
              }

              Node.prototype.findScope = function findScope(functionScope) {
                return this.parent.findScope(functionScope)
              }

              Node.prototype.getIndentation = function getIndentation() {
                return this.parent.getIndentation()
              }

              Node.prototype.initialise = function initialise(transforms) {
                for (var i = 0, list = this.keys; i < list.length; i += 1) {
                  var key = list[i]

                  var value = this[key]

                  if (Array.isArray(value)) {
                    value.forEach(function(node) {
                      return node && node.initialise(transforms)
                    })
                  } else if (value && typeof value === 'object') {
                    value.initialise(transforms)
                  }
                }
              }

              Node.prototype.toJSON = function toJSON$1() {
                return toJSON(this)
              }

              Node.prototype.toString = function toString() {
                return this.program.magicString.original.slice(
                  this.start,
                  this.end
                )
              }

              Node.prototype.transpile = function transpile(code, transforms) {
                for (var i = 0, list = this.keys; i < list.length; i += 1) {
                  var key = list[i]

                  var value = this[key]

                  if (Array.isArray(value)) {
                    value.forEach(function(node) {
                      return node && node.transpile(code, transforms)
                    })
                  } else if (value && typeof value === 'object') {
                    value.transpile(code, transforms)
                  }
                }
              }

              function isArguments(node) {
                return node.type === 'Identifier' && node.name === 'arguments'
              }

              function spread(
                code,
                elements,
                start,
                argumentsArrayAlias,
                isNew
              ) {
                var i = elements.length
                var firstSpreadIndex = -1

                while (i--) {
                  var element$1 = elements[i]
                  if (element$1 && element$1.type === 'SpreadElement') {
                    if (isArguments(element$1.argument)) {
                      code.overwrite(
                        element$1.argument.start,
                        element$1.argument.end,
                        argumentsArrayAlias
                      )
                    }

                    firstSpreadIndex = i
                  }
                }

                if (firstSpreadIndex === -1) return false // false indicates no spread elements

                if (isNew) {
                  for (i = 0; i < elements.length; i += 1) {
                    var element$2 = elements[i]
                    if (element$2.type === 'SpreadElement') {
                      code.remove(element$2.start, element$2.argument.start)
                    } else {
                      code.insertRight(element$2.start, '[')
                      code.insertRight(element$2.end, ']')
                    }
                  }

                  return true // true indicates some spread elements
                }

                var element = elements[firstSpreadIndex]
                var previousElement = elements[firstSpreadIndex - 1]

                if (!previousElement) {
                  code.remove(start, element.start)
                  code.overwrite(element.end, elements[1].start, '.concat( ')
                } else {
                  code.overwrite(
                    previousElement.end,
                    element.start,
                    ' ].concat( '
                  )
                }

                for (i = firstSpreadIndex; i < elements.length; i += 1) {
                  element = elements[i]

                  if (element) {
                    if (element.type === 'SpreadElement') {
                      code.remove(element.start, element.argument.start)
                    } else {
                      code.insertLeft(element.start, '[')
                      code.insertLeft(element.end, ']')
                    }
                  }
                }

                return true // true indicates some spread elements
              }

              var ArrayExpression = (function(Node) {
                function ArrayExpression() {
                  Node.apply(this, arguments)
                }

                if (Node) ArrayExpression.__proto__ = Node
                ArrayExpression.prototype = Object.create(
                  Node && Node.prototype
                )
                ArrayExpression.prototype.constructor = ArrayExpression

                ArrayExpression.prototype.initialise = function initialise(
                  transforms
                ) {
                  var this$1 = this

                  if (transforms.spreadRest && this.elements.length) {
                    var lexicalBoundary = this.findLexicalBoundary()

                    var i = this.elements.length
                    while (i--) {
                      var element = this$1.elements[i]
                      if (
                        element &&
                        element.type === 'SpreadElement' &&
                        isArguments(element.argument)
                      ) {
                        this$1.argumentsArrayAlias = lexicalBoundary.getArgumentsArrayAlias()
                      }
                    }
                  }

                  Node.prototype.initialise.call(this, transforms)
                }

                ArrayExpression.prototype.transpile = function transpile(
                  code,
                  transforms
                ) {
                  if (transforms.spreadRest) {
                    // erase trailing comma after last array element if not an array hole
                    if (this.elements.length) {
                      var lastElement = this.elements[this.elements.length - 1]
                      if (
                        lastElement &&
                        /\s*,/.test(
                          code.original.slice(lastElement.end, this.end)
                        )
                      ) {
                        code.overwrite(lastElement.end, this.end - 1, ' ')
                      }
                    }

                    if (this.elements.length === 1) {
                      var element = this.elements[0]

                      if (element && element.type === 'SpreadElement') {
                        // special case  [ ...arguments ]
                        if (isArguments(element.argument)) {
                          code.overwrite(
                            this.start,
                            this.end,
                            '[].concat( ' + this.argumentsArrayAlias + ' )'
                          ) // TODO if this is the only use of argsArray, don't bother concating
                        } else {
                          code.overwrite(
                            this.start,
                            element.argument.start,
                            '[].concat( '
                          )
                          code.overwrite(element.end, this.end, ' )')
                        }
                      }
                    } else {
                      var hasSpreadElements = spread(
                        code,
                        this.elements,
                        this.start,
                        this.argumentsArrayAlias
                      )

                      if (hasSpreadElements) {
                        code.overwrite(this.end - 1, this.end, ')')
                      }
                    }
                  }

                  Node.prototype.transpile.call(this, code, transforms)
                }

                return ArrayExpression
              })(Node)

              var ArrowFunctionExpression = (function(Node) {
                function ArrowFunctionExpression() {
                  Node.apply(this, arguments)
                }

                if (Node) ArrowFunctionExpression.__proto__ = Node
                ArrowFunctionExpression.prototype = Object.create(
                  Node && Node.prototype
                )
                ArrowFunctionExpression.prototype.constructor = ArrowFunctionExpression

                ArrowFunctionExpression.prototype.initialise = function initialise(
                  transforms
                ) {
                  this.body.createScope()
                  Node.prototype.initialise.call(this, transforms)
                }

                ArrowFunctionExpression.prototype.transpile = function transpile(
                  code,
                  transforms
                ) {
                  if (transforms.arrow) {
                    // remove arrow
                    var charIndex = this.body.start
                    while (code.original[charIndex] !== '=') {
                      charIndex -= 1
                    }
                    code.remove(charIndex, this.body.start)

                    // wrap naked parameter
                    if (
                      this.params.length === 1 &&
                      this.start === this.params[0].start
                    ) {
                      code.insertRight(this.params[0].start, '(')
                      code.insertLeft(this.params[0].end, ')')
                    }

                    // add function
                    if (
                      this.parent &&
                      this.parent.type === 'ExpressionStatement'
                    ) {
                      // standalone expression statement
                      code.insertRight(this.start, '(function')
                      code.insertRight(this.end, ')')
                    } else {
                      code.insertRight(this.start, 'function ')
                    }
                  }

                  Node.prototype.transpile.call(this, code, transforms)
                }

                return ArrowFunctionExpression
              })(Node)

              function locate(source, index) {
                var lines = source.split('\n')
                var len = lines.length

                var lineStart = 0
                var i

                for (i = 0; i < len; i += 1) {
                  var line = lines[i]
                  var lineEnd = lineStart + line.length + 1 // +1 for newline

                  if (lineEnd > index) {
                    return { line: i + 1, column: index - lineStart, char: i }
                  }

                  lineStart = lineEnd
                }

                throw new Error('Could not determine location of character')
              }

              function pad(num, len) {
                var result = String(num)
                return result + repeat(' ', len - result.length)
              }

              function repeat(str, times) {
                var result = ''
                while (times--) result += str
                return result
              }

              function getSnippet(source, loc, length) {
                if (length === void 0) length = 1

                var first = Math.max(loc.line - 5, 0)
                var last = loc.line

                var numDigits = String(last).length

                var lines = source.split('\n').slice(first, last)

                var lastLine = lines[lines.length - 1]
                var offset = lastLine.slice(0, loc.column).replace(/\t/g, '  ')
                  .length

                var snippet = lines
                  .map(function(line, i) {
                    return (
                      pad(i + first + 1, numDigits) +
                      ' : ' +
                      line.replace(/\t/g, '  ')
                    )
                  })
                  .join('\n')

                snippet +=
                  '\n' +
                  repeat(' ', numDigits + 3 + offset) +
                  repeat('^', length)

                return snippet
              }

              var CompileError = (function(Error) {
                function CompileError(node, message) {
                  Error.call(this)

                  var source = node.program.magicString.original
                  var loc = locate(source, node.start)

                  this.name = 'CompileError'
                  this.message =
                    message + ' (' + loc.line + ':' + loc.column + ')'

                  this.stack = new Error().stack.replace(
                    new RegExp('.+new ' + this.name + '.+\\n', 'm'),
                    ''
                  )

                  this.loc = loc
                  this.snippet = getSnippet(source, loc, node.end - node.start)
                }

                if (Error) CompileError.__proto__ = Error
                CompileError.prototype = Object.create(Error && Error.prototype)
                CompileError.prototype.constructor = CompileError

                CompileError.prototype.toString = function toString() {
                  return this.name + ': ' + this.message + '\n' + this.snippet
                }

                return CompileError
              })(Error)

              var AssignmentExpression = (function(Node) {
                function AssignmentExpression() {
                  Node.apply(this, arguments)
                }

                if (Node) AssignmentExpression.__proto__ = Node
                AssignmentExpression.prototype = Object.create(
                  Node && Node.prototype
                )
                AssignmentExpression.prototype.constructor = AssignmentExpression

                AssignmentExpression.prototype.initialise = function initialise(
                  transforms
                ) {
                  if (this.left.type === 'Identifier') {
                    var declaration = this.findScope(false).findDeclaration(
                      this.left.name
                    )
                    if (declaration && declaration.kind === 'const') {
                      throw new CompileError(
                        this.left,
                        this.left.name + ' is read-only'
                      )
                    }

                    // special case  https://gitlab.com/Rich-Harris/buble/issues/11
                    var statement = declaration && declaration.node.ancestor(3)
                    if (
                      statement &&
                      statement.type === 'ForStatement' &&
                      statement.body.contains(this)
                    ) {
                      statement.reassigned[this.left.name] = true
                    }
                  }

                  Node.prototype.initialise.call(this, transforms)
                }

                AssignmentExpression.prototype.transpile = function transpile(
                  code,
                  transforms
                ) {
                  if (this.operator === '**=' && transforms.exponentiation) {
                    this.transpileExponentiation(code, transforms)
                  } else if (
                    /Pattern/.test(this.left.type) &&
                    transforms.destructuring
                  ) {
                    this.transpileDestructuring(code, transforms)
                  }

                  Node.prototype.transpile.call(this, code, transforms)
                }

                AssignmentExpression.prototype.transpileDestructuring = function transpileDestructuring(
                  code
                ) {
                  var scope = this.findScope(true)
                  var assign = scope.createIdentifier('assign')
                  var temporaries = [assign]

                  var start = this.start

                  // We need to pick out some elements from the original code,
                  // interleaved with generated code. These helpers are used to
                  // easily do that while keeping the order of the output
                  // predictable.
                  var text = ''
                  function use(node) {
                    code.insertRight(node.start, text)
                    code.move(node.start, node.end, start)
                    text = ''
                  }
                  function write(string) {
                    text += string
                  }

                  write('(' + assign + ' = ')
                  use(this.right)

                  // Walk `pattern`, generating code that assigns the value in
                  // `ref` to it. When `mayDuplicate` is false, the function
                  // must take care to only output `ref` once.
                  function destructure(pattern, ref, mayDuplicate) {
                    if (
                      pattern.type === 'Identifier' ||
                      pattern.type === 'MemberExpression'
                    ) {
                      write(', ')
                      use(pattern)
                      write(' = ' + ref)
                    } else if (pattern.type === 'AssignmentPattern') {
                      if (pattern.left.type === 'Identifier') {
                        var target = pattern.left.name
                        var source = ref
                        if (!mayDuplicate) {
                          write(', ' + target + ' = ' + ref)
                          source = target
                        }
                        write(', ' + target + ' = ' + source + ' === void 0 ? ')
                        use(pattern.right)
                        write(' : ' + source)
                      } else {
                        var target$1 = scope.createIdentifier('temp')
                        var source$1 = ref
                        temporaries.push(target$1)
                        if (!mayDuplicate) {
                          write(', ' + target$1 + ' = ' + ref)
                          source$1 = target$1
                        }
                        write(
                          ', ' + target$1 + ' = ' + source$1 + ' === void 0 ? '
                        )
                        use(pattern.right)
                        write(' : ' + source$1)
                        destructure(pattern.left, target$1, true)
                      }
                    } else if (pattern.type === 'ArrayPattern') {
                      var elements = pattern.elements
                      if (elements.length === 1) {
                        destructure(elements[0], ref + '[0]', false)
                      } else {
                        if (!mayDuplicate) {
                          var temp = scope.createIdentifier('array')
                          temporaries.push(temp)
                          write(', ' + temp + ' = ' + ref)
                          ref = temp
                        }
                        elements.forEach(function(element, i) {
                          if (element) {
                            if (element.type === 'RestElement') {
                              destructure(
                                element.argument,
                                ref + '.slice(' + i + ')',
                                false
                              )
                            } else {
                              destructure(element, ref + '[' + i + ']', false)
                            }
                          }
                        })
                      }
                    } else if (pattern.type === 'ObjectPattern') {
                      var props = pattern.properties
                      if (props.length == 1) {
                        var prop = props[0]
                        var value = prop.computed ||
                          prop.key.type !== 'Identifier'
                          ? ref +
                              '[' +
                              code.slice(prop.key.start, prop.key.end) +
                              ']'
                          : ref + '.' + prop.key.name
                        destructure(prop.value, value, false)
                      } else {
                        if (!mayDuplicate) {
                          var temp$1 = scope.createIdentifier('obj')
                          temporaries.push(temp$1)
                          write(', ' + temp$1 + ' = ' + ref)
                          ref = temp$1
                        }
                        props.forEach(function(prop) {
                          var value = prop.computed ||
                            prop.key.type !== 'Identifier'
                            ? ref +
                                '[' +
                                code.slice(prop.key.start, prop.key.end) +
                                ']'
                            : ref + '.' + prop.key.name
                          destructure(prop.value, value, false)
                        })
                      }
                    } else {
                      throw new Error(
                        'Unexpected node type in destructuring assignment (' +
                          pattern.type +
                          ')'
                      )
                    }
                  }
                  destructure(this.left, assign, true)

                  if (
                    this.unparenthesizedParent().type === 'ExpressionStatement'
                  ) {
                    // no rvalue needed for expression statement
                    code.insertRight(start, text + ')')
                  } else {
                    // destructuring is part of an expression - need an rvalue
                    code.insertRight(start, text + ', ' + assign + ')')
                  }

                  code.remove(start, this.right.start)

                  var statement = this.findNearest(/(?:Statement|Declaration)$/)
                  code.insertLeft(
                    statement.start,
                    'var ' +
                      temporaries.join(', ') +
                      ';\n' +
                      statement.getIndentation()
                  )
                }

                AssignmentExpression.prototype.transpileExponentiation = function transpileExponentiation(
                  code
                ) {
                  var scope = this.findScope(false)
                  var getAlias = function(name) {
                    var declaration = scope.findDeclaration(name)
                    return declaration ? declaration.name : name
                  }

                  // first, the easy part  `**=` -> `=`
                  var charIndex = this.left.end
                  while (code.original[charIndex] !== '*') charIndex += 1
                  code.remove(charIndex, charIndex + 2)

                  // how we do the next part depends on a number of factors  whether
                  // this is a top-level statement, and whether we're updating a
                  // simple or complex reference
                  var base

                  var left = this.left.unparenthesize()

                  if (left.type === 'Identifier') {
                    base = getAlias(left.name)
                  } else if (left.type === 'MemberExpression') {
                    var object
                    var needsObjectVar = false
                    var property
                    var needsPropertyVar = false

                    var statement = this.findNearest(
                      /(?:Statement|Declaration)$/
                    )
                    var i0 = statement.getIndentation()

                    if (left.property.type === 'Identifier') {
                      property = left.computed
                        ? getAlias(left.property.name)
                        : left.property.name
                    } else {
                      property = scope.createIdentifier('property')
                      needsPropertyVar = true
                    }

                    if (left.object.type === 'Identifier') {
                      object = getAlias(left.object.name)
                    } else {
                      object = scope.createIdentifier('object')
                      needsObjectVar = true
                    }

                    if (left.start === statement.start) {
                      if (needsObjectVar && needsPropertyVar) {
                        code.insertRight(
                          statement.start,
                          'var ' + object + ' = '
                        )
                        code.overwrite(
                          left.object.end,
                          left.property.start,
                          ';\n' + i0 + 'var ' + property + ' = '
                        )
                        code.overwrite(
                          left.property.end,
                          left.end,
                          ';\n' + i0 + object + '[' + property + ']'
                        )
                      } else if (needsObjectVar) {
                        code.insertRight(
                          statement.start,
                          'var ' + object + ' = '
                        )
                        code.insertLeft(left.object.end, ';\n' + i0)
                        code.insertLeft(left.object.end, object)
                      } else if (needsPropertyVar) {
                        code.insertRight(
                          left.property.start,
                          'var ' + property + ' = '
                        )
                        code.insertLeft(left.property.end, ';\n' + i0)
                        code.move(
                          left.property.start,
                          left.property.end,
                          this.start
                        )

                        code.insertLeft(left.object.end, '[' + property + ']')
                        code.remove(left.object.end, left.property.start)
                        code.remove(left.property.end, left.end)
                      }
                    } else {
                      var declarators = []
                      if (needsObjectVar) declarators.push(object)
                      if (needsPropertyVar) declarators.push(property)

                      if (declarators.length) {
                        code.insertRight(
                          statement.start,
                          'var ' + declarators.join(', ') + ';\n' + i0
                        )
                      }

                      if (needsObjectVar && needsPropertyVar) {
                        code.insertRight(left.start, '( ' + object + ' = ')
                        code.overwrite(
                          left.object.end,
                          left.property.start,
                          ', ' + property + ' = '
                        )
                        code.overwrite(
                          left.property.end,
                          left.end,
                          ', ' + object + '[' + property + ']'
                        )
                      } else if (needsObjectVar) {
                        code.insertRight(left.start, '( ' + object + ' = ')
                        code.insertLeft(left.object.end, ', ' + object)
                      } else if (needsPropertyVar) {
                        code.insertRight(
                          left.property.start,
                          '( ' + property + ' = '
                        )
                        code.insertLeft(left.property.end, ', ')
                        code.move(
                          left.property.start,
                          left.property.end,
                          left.start
                        )

                        code.overwrite(
                          left.object.end,
                          left.property.start,
                          '[' + property + ']'
                        )
                        code.remove(left.property.end, left.end)
                      }

                      if (needsPropertyVar) {
                        code.insertLeft(this.end, ' )')
                      }
                    }

                    base =
                      object +
                      (left.computed || needsPropertyVar
                        ? '[' + property + ']'
                        : '.' + property)
                  }

                  code.insertRight(this.right.start, 'Math.pow( ' + base + ', ')
                  code.insertLeft(this.right.end, ' )')
                }

                return AssignmentExpression
              })(Node)

              var BinaryExpression = (function(Node) {
                function BinaryExpression() {
                  Node.apply(this, arguments)
                }

                if (Node) BinaryExpression.__proto__ = Node
                BinaryExpression.prototype = Object.create(
                  Node && Node.prototype
                )
                BinaryExpression.prototype.constructor = BinaryExpression

                BinaryExpression.prototype.transpile = function transpile(
                  code,
                  transforms
                ) {
                  if (this.operator === '**' && transforms.exponentiation) {
                    code.insertRight(this.start, 'Math.pow( ')
                    code.overwrite(this.left.end, this.right.start, ', ')
                    code.insertLeft(this.end, ' )')
                  }
                  Node.prototype.transpile.call(this, code, transforms)
                }

                return BinaryExpression
              })(Node)

              var loopStatement = /(?:For(?:In|Of)?|While)Statement/

              var BreakStatement = (function(Node) {
                function BreakStatement() {
                  Node.apply(this, arguments)
                }

                if (Node) BreakStatement.__proto__ = Node
                BreakStatement.prototype = Object.create(Node && Node.prototype)
                BreakStatement.prototype.constructor = BreakStatement

                BreakStatement.prototype.initialise = function initialise() {
                  var loop = this.findNearest(loopStatement)
                  var switchCase = this.findNearest('SwitchCase')

                  if (loop && (!switchCase || loop.depth > switchCase.depth)) {
                    loop.canBreak = true
                    this.loop = loop
                  }
                }

                BreakStatement.prototype.transpile = function transpile(code) {
                  if (this.loop && this.loop.shouldRewriteAsFunction) {
                    if (this.label)
                      throw new CompileError(
                        this,
                        'Labels are not currently supported in a loop with locally-scoped variables'
                      )
                    code.overwrite(this.start, this.start + 5, "return 'break'")
                  }
                }

                return BreakStatement
              })(Node)

              var CallExpression = (function(Node) {
                function CallExpression() {
                  Node.apply(this, arguments)
                }

                if (Node) CallExpression.__proto__ = Node
                CallExpression.prototype = Object.create(Node && Node.prototype)
                CallExpression.prototype.constructor = CallExpression

                CallExpression.prototype.initialise = function initialise(
                  transforms
                ) {
                  var this$1 = this

                  if (transforms.spreadRest && this.arguments.length > 1) {
                    var lexicalBoundary = this.findLexicalBoundary()

                    var i = this.arguments.length
                    while (i--) {
                      var arg = this$1.arguments[i]
                      if (
                        arg.type === 'SpreadElement' &&
                        isArguments(arg.argument)
                      ) {
                        this$1.argumentsArrayAlias = lexicalBoundary.getArgumentsArrayAlias()
                      }
                    }
                  }

                  Node.prototype.initialise.call(this, transforms)
                }

                CallExpression.prototype.transpile = function transpile(
                  code,
                  transforms
                ) {
                  if (transforms.spreadRest && this.arguments.length) {
                    var hasSpreadElements = false
                    var context

                    var firstArgument = this.arguments[0]

                    if (this.arguments.length === 1) {
                      if (firstArgument.type === 'SpreadElement') {
                        code.remove(
                          firstArgument.start,
                          firstArgument.argument.start
                        )
                        hasSpreadElements = true
                      }
                    } else {
                      hasSpreadElements = spread(
                        code,
                        this.arguments,
                        firstArgument.start,
                        this.argumentsArrayAlias
                      )
                    }

                    if (hasSpreadElements) {
                      // we need to handle super() and super.method() differently
                      // due to its instance
                      var _super = null
                      if (this.callee.type === 'Super') {
                        _super = this.callee
                      } else if (
                        this.callee.type === 'MemberExpression' &&
                        this.callee.object.type === 'Super'
                      ) {
                        _super = this.callee.object
                      }

                      if (!_super && this.callee.type === 'MemberExpression') {
                        if (this.callee.object.type === 'Identifier') {
                          context = this.callee.object.name
                        } else {
                          context = this.findScope(true).createIdentifier('ref')
                          var callExpression = this.callee.object
                          var enclosure = callExpression.findNearest(/Function/)
                          var block = enclosure
                            ? enclosure.body.body
                            : callExpression.findNearest(/^Program$/).body
                          var lastStatementInBlock = block[block.length - 1]
                          var i0 = lastStatementInBlock.getIndentation()
                          code.insertRight(
                            callExpression.start,
                            '(' + context + ' = '
                          )
                          code.insertLeft(callExpression.end, ')')
                          code.insertLeft(
                            lastStatementInBlock.end,
                            '\n' + i0 + 'var ' + context + ';'
                          )
                        }
                      } else {
                        context = 'void 0'
                      }

                      code.insertLeft(this.callee.end, '.apply')

                      if (_super) {
                        _super.noCall = true // bit hacky...

                        if (this.arguments.length > 1) {
                          if (firstArgument.type !== 'SpreadElement') {
                            code.insertRight(firstArgument.start, '[ ')
                          }

                          code.insertLeft(
                            this.arguments[this.arguments.length - 1].end,
                            ' )'
                          )
                        }
                      } else if (this.arguments.length === 1) {
                        code.insertRight(firstArgument.start, context + ', ')
                      } else {
                        if (firstArgument.type === 'SpreadElement') {
                          code.insertLeft(firstArgument.start, context + ', ')
                        } else {
                          code.insertLeft(firstArgument.start, context + ', [ ')
                        }

                        code.insertLeft(
                          this.arguments[this.arguments.length - 1].end,
                          ' )'
                        )
                      }
                    }
                  }

                  Node.prototype.transpile.call(this, code, transforms)
                }

                return CallExpression
              })(Node)

              function findIndex(array, fn) {
                for (var i = 0; i < array.length; i += 1) {
                  if (fn(array[i], i)) return i
                }

                return -1
              }

              var reserved = Object.create(null)
              'do if in for let new try var case else enum eval null this true void with await break catch class const false super throw while yield delete export import public return static switch typeof default extends finally package private continue debugger function arguments interface protected implements instanceof'
                .split(' ')
                .forEach(function(word) {
                  return (reserved[word] = true)
                })

              // TODO this code is pretty wild, tidy it up
              var ClassBody = (function(Node) {
                function ClassBody() {
                  Node.apply(this, arguments)
                }

                if (Node) ClassBody.__proto__ = Node
                ClassBody.prototype = Object.create(Node && Node.prototype)
                ClassBody.prototype.constructor = ClassBody

                ClassBody.prototype.transpile = function transpile(
                  code,
                  transforms,
                  inFunctionExpression,
                  superName
                ) {
                  var this$1 = this

                  if (transforms.classes) {
                    var name = this.parent.name

                    var indentStr = code.getIndentString()
                    var i0 =
                      this.getIndentation() +
                      (inFunctionExpression ? indentStr : '')
                    var i1 = i0 + indentStr

                    var constructorIndex = findIndex(this.body, function(node) {
                      return node.kind === 'constructor'
                    })
                    var constructor = this.body[constructorIndex]

                    var introBlock = ''
                    var outroBlock = ''

                    if (this.body.length) {
                      code.remove(this.start, this.body[0].start)
                      code.remove(this.body[this.body.length - 1].end, this.end)
                    } else {
                      code.remove(this.start, this.end)
                    }

                    if (constructor) {
                      constructor.value.body.isConstructorBody = true

                      var previousMethod = this.body[constructorIndex - 1]
                      var nextMethod = this.body[constructorIndex + 1]

                      // ensure constructor is first
                      if (constructorIndex > 0) {
                        code.remove(previousMethod.end, constructor.start)
                        code.move(
                          constructor.start,
                          nextMethod ? nextMethod.start : this.end - 1,
                          this.body[0].start
                        )
                      }

                      if (!inFunctionExpression)
                        code.insertLeft(constructor.end, ';')
                    }

                    var namedFunctions =
                      this.program.options.namedFunctionExpressions !== false
                    var namedConstructor =
                      namedFunctions ||
                      this.parent.superClass ||
                      this.parent.type !== 'ClassDeclaration'
                    if (this.parent.superClass) {
                      var inheritanceBlock =
                        'if ( ' +
                        superName +
                        ' ) ' +
                        name +
                        '.__proto__ = ' +
                        superName +
                        ';\n' +
                        i0 +
                        name +
                        '.prototype = Object.create( ' +
                        superName +
                        ' && ' +
                        superName +
                        '.prototype );\n' +
                        i0 +
                        name +
                        '.prototype.constructor = ' +
                        name +
                        ';'

                      if (constructor) {
                        introBlock += '\n\n' + i0 + inheritanceBlock
                      } else {
                        var fn =
                          'function ' +
                          name +
                          ' () {' +
                          (superName
                            ? '\n' +
                                i1 +
                                superName +
                                '.apply(this, arguments);\n' +
                                i0 +
                                '}'
                            : '}') +
                          (inFunctionExpression ? '' : ';') +
                          (this.body.length ? '\n\n' + i0 : '')

                        inheritanceBlock = fn + inheritanceBlock
                        introBlock += inheritanceBlock + '\n\n' + i0
                      }
                    } else if (!constructor) {
                      var fn$1 =
                        'function ' +
                        (namedConstructor ? name + ' ' : '') +
                        '() {}'
                      if (this.parent.type === 'ClassDeclaration') fn$1 += ';'
                      if (this.body.length) fn$1 += '\n\n' + i0

                      introBlock += fn$1
                    }

                    var scope = this.findScope(false)

                    var prototypeGettersAndSetters = []
                    var staticGettersAndSetters = []
                    var prototypeAccessors
                    var staticAccessors

                    this.body.forEach(function(method, i) {
                      if (method.kind === 'constructor') {
                        var constructorName = namedConstructor ? ' ' + name : ''
                        code.overwrite(
                          method.key.start,
                          method.key.end,
                          'function' + constructorName
                        )
                        return
                      }

                      if (method.static) {
                        var len = code.original[method.start + 6] == ' ' ? 7 : 6
                        code.remove(method.start, method.start + len)
                      }

                      var isAccessor = method.kind !== 'method'
                      var lhs

                      var methodName = method.key.name
                      if (
                        reserved[methodName] ||
                        method.value.body.scope.references[methodName]
                      ) {
                        methodName = scope.createIdentifier(methodName)
                      }

                      // when method name is a string or a number let's pretend it's a computed method

                      var fake_computed = false
                      if (!method.computed && method.key.type === 'Literal') {
                        fake_computed = true
                        method.computed = true
                      }

                      if (isAccessor) {
                        if (method.computed) {
                          throw new Error(
                            'Computed accessor properties are not currently supported'
                          )
                        }

                        code.remove(method.start, method.key.start)

                        if (method.static) {
                          if (
                            !~staticGettersAndSetters.indexOf(method.key.name)
                          )
                            staticGettersAndSetters.push(method.key.name)
                          if (!staticAccessors)
                            staticAccessors = scope.createIdentifier(
                              'staticAccessors'
                            )

                          lhs = '' + staticAccessors
                        } else {
                          if (
                            !~prototypeGettersAndSetters.indexOf(
                              method.key.name
                            )
                          )
                            prototypeGettersAndSetters.push(method.key.name)
                          if (!prototypeAccessors)
                            prototypeAccessors = scope.createIdentifier(
                              'prototypeAccessors'
                            )

                          lhs = '' + prototypeAccessors
                        }
                      } else {
                        lhs = method.static ? '' + name : name + '.prototype'
                      }

                      if (!method.computed) lhs += '.'

                      var insertNewlines =
                        (constructorIndex > 0 && i === constructorIndex + 1) ||
                        (i === 0 && constructorIndex === this$1.body.length - 1)

                      if (insertNewlines) lhs = '\n\n' + i0 + lhs

                      var c = method.key.end
                      if (method.computed) {
                        if (fake_computed) {
                          code.insertRight(method.key.start, '[')
                          code.insertLeft(method.key.end, ']')
                        } else {
                          while (code.original[c] !== ']') c += 1
                          c += 1
                        }
                      }

                      code.insertRight(method.start, lhs)

                      var funcName = method.computed ||
                        isAccessor ||
                        !namedFunctions
                        ? ''
                        : methodName + ' '
                      var rhs =
                        (isAccessor ? '.' + method.kind : '') +
                        ' = function' +
                        (method.value.generator ? '* ' : ' ') +
                        funcName
                      code.remove(c, method.value.start)
                      code.insertRight(method.value.start, rhs)
                      code.insertLeft(method.end, ';')

                      if (method.value.generator)
                        code.remove(method.start, method.key.start)
                    })

                    if (
                      prototypeGettersAndSetters.length ||
                      staticGettersAndSetters.length
                    ) {
                      var intro = []
                      var outro = []

                      if (prototypeGettersAndSetters.length) {
                        intro.push(
                          'var ' +
                            prototypeAccessors +
                            ' = { ' +
                            prototypeGettersAndSetters
                              .map(function(name) {
                                return name + ': {}'
                              })
                              .join(',') +
                            ' };'
                        )
                        outro.push(
                          'Object.defineProperties( ' +
                            name +
                            '.prototype, ' +
                            prototypeAccessors +
                            ' );'
                        )
                      }

                      if (staticGettersAndSetters.length) {
                        intro.push(
                          'var ' +
                            staticAccessors +
                            ' = { ' +
                            staticGettersAndSetters
                              .map(function(name) {
                                return name + ': {}'
                              })
                              .join(',') +
                            ' };'
                        )
                        outro.push(
                          'Object.defineProperties( ' +
                            name +
                            ', ' +
                            staticAccessors +
                            ' );'
                        )
                      }

                      if (constructor) introBlock += '\n\n' + i0
                      introBlock += intro.join('\n' + i0)
                      if (!constructor) introBlock += '\n\n' + i0

                      outroBlock += '\n\n' + i0 + outro.join('\n' + i0)
                    }

                    if (constructor) {
                      code.insertLeft(constructor.end, introBlock)
                    } else {
                      code.insertRight(this.start, introBlock)
                    }

                    code.insertLeft(this.end, outroBlock)
                  }

                  Node.prototype.transpile.call(this, code, transforms)
                }

                return ClassBody
              })(Node)

              // TODO this function is slightly flawed  it works on the original string,
              // not its current edited state.
              // That's not a problem for the way that it's currently used, but it could
              // be in future...
              function deindent(node, code) {
                var start = node.start
                var end = node.end

                var indentStr = code.getIndentString()
                var indentStrLen = indentStr.length
                var indentStart = start - indentStrLen

                if (
                  !node.program.indentExclusions[indentStart] &&
                  code.original.slice(indentStart, start) === indentStr
                ) {
                  code.remove(indentStart, start)
                }

                var pattern = new RegExp(indentStr + '\\S', 'g')
                var slice = code.original.slice(start, end)
                var match

                while ((match = pattern.exec(slice))) {
                  var removeStart = start + match.index
                  if (!node.program.indentExclusions[removeStart]) {
                    code.remove(removeStart, removeStart + indentStrLen)
                  }
                }
              }

              var ClassDeclaration = (function(Node) {
                function ClassDeclaration() {
                  Node.apply(this, arguments)
                }

                if (Node) ClassDeclaration.__proto__ = Node
                ClassDeclaration.prototype = Object.create(
                  Node && Node.prototype
                )
                ClassDeclaration.prototype.constructor = ClassDeclaration

                ClassDeclaration.prototype.initialise = function initialise(
                  transforms
                ) {
                  this.name = this.id.name
                  this.findScope(true).addDeclaration(this.id, 'class')

                  Node.prototype.initialise.call(this, transforms)
                }

                ClassDeclaration.prototype.transpile = function transpile(
                  code,
                  transforms
                ) {
                  if (transforms.classes) {
                    if (!this.superClass) deindent(this.body, code)

                    var superName =
                      this.superClass && (this.superClass.name || 'superclass')

                    var i0 = this.getIndentation()
                    var i1 = i0 + code.getIndentString()

                    // if this is an export default statement, we have to move the export to
                    // after the declaration, because `export default var Foo = ...` is illegal
                    var syntheticDefaultExport = this.parent.type ===
                      'ExportDefaultDeclaration'
                      ? '\n\n' + i0 + 'export default ' + this.id.name + ';'
                      : ''

                    if (syntheticDefaultExport)
                      code.remove(this.parent.start, this.start)

                    code.overwrite(this.start, this.id.start, 'var ')

                    if (this.superClass) {
                      if (this.superClass.end === this.body.start) {
                        code.remove(this.id.end, this.superClass.start)
                        code.insertLeft(
                          this.id.end,
                          ' = (function (' + superName + ') {\n' + i1
                        )
                      } else {
                        code.overwrite(
                          this.id.end,
                          this.superClass.start,
                          ' = '
                        )
                        code.overwrite(
                          this.superClass.end,
                          this.body.start,
                          '(function (' + superName + ') {\n' + i1
                        )
                      }
                    } else {
                      if (this.id.end === this.body.start) {
                        code.insertLeft(this.id.end, ' = ')
                      } else {
                        code.overwrite(this.id.end, this.body.start, ' = ')
                      }
                    }

                    this.body.transpile(
                      code,
                      transforms,
                      !!this.superClass,
                      superName
                    )

                    if (this.superClass) {
                      code.insertLeft(
                        this.end,
                        '\n\n' + i1 + 'return ' + this.name + ';\n' + i0 + '}('
                      )
                      code.move(
                        this.superClass.start,
                        this.superClass.end,
                        this.end
                      )
                      code.insertRight(this.end, '));' + syntheticDefaultExport)
                    } else if (syntheticDefaultExport) {
                      code.insertRight(this.end, syntheticDefaultExport)
                    }
                  } else {
                    this.body.transpile(code, transforms, false, null)
                  }
                }

                return ClassDeclaration
              })(Node)

              var ClassExpression = (function(Node) {
                function ClassExpression() {
                  Node.apply(this, arguments)
                }

                if (Node) ClassExpression.__proto__ = Node
                ClassExpression.prototype = Object.create(
                  Node && Node.prototype
                )
                ClassExpression.prototype.constructor = ClassExpression

                ClassExpression.prototype.initialise = function initialise(
                  transforms
                ) {
                  this.name = this.id
                    ? this.id.name
                    : this.parent.type === 'VariableDeclarator'
                      ? this.parent.id.name
                      : this.parent.type === 'AssignmentExpression'
                        ? this.parent.left.name
                        : this.findScope(true).createIdentifier('anonymous')

                  Node.prototype.initialise.call(this, transforms)
                }

                ClassExpression.prototype.transpile = function transpile(
                  code,
                  transforms
                ) {
                  if (transforms.classes) {
                    var superName =
                      this.superClass && (this.superClass.name || 'superclass')

                    var i0 = this.getIndentation()
                    var i1 = i0 + code.getIndentString()

                    if (this.superClass) {
                      code.remove(this.start, this.superClass.start)
                      code.remove(this.superClass.end, this.body.start)
                      code.insertLeft(
                        this.start,
                        '(function (' + superName + ') {\n' + i1
                      )
                    } else {
                      code.overwrite(
                        this.start,
                        this.body.start,
                        '(function () {\n' + i1
                      )
                    }

                    this.body.transpile(code, transforms, true, superName)

                    var outro =
                      '\n\n' + i1 + 'return ' + this.name + ';\n' + i0 + '}('

                    if (this.superClass) {
                      code.insertLeft(this.end, outro)
                      code.move(
                        this.superClass.start,
                        this.superClass.end,
                        this.end
                      )
                      code.insertRight(this.end, '))')
                    } else {
                      code.insertLeft(
                        this.end,
                        '\n\n' +
                          i1 +
                          'return ' +
                          this.name +
                          ';\n' +
                          i0 +
                          '}())'
                      )
                    }
                  } else {
                    this.body.transpile(code, transforms, false)
                  }
                }

                return ClassExpression
              })(Node)

              var ContinueStatement = (function(Node) {
                function ContinueStatement() {
                  Node.apply(this, arguments)
                }

                if (Node) ContinueStatement.__proto__ = Node
                ContinueStatement.prototype = Object.create(
                  Node && Node.prototype
                )
                ContinueStatement.prototype.constructor = ContinueStatement

                ContinueStatement.prototype.transpile = function transpile(
                  code
                ) {
                  var loop = this.findNearest(loopStatement)
                  if (loop.shouldRewriteAsFunction) {
                    if (this.label)
                      throw new CompileError(
                        this,
                        'Labels are not currently supported in a loop with locally-scoped variables'
                      )
                    code.overwrite(this.start, this.start + 8, 'return')
                  }
                }

                return ContinueStatement
              })(Node)

              var ExportDefaultDeclaration = (function(Node) {
                function ExportDefaultDeclaration() {
                  Node.apply(this, arguments)
                }

                if (Node) ExportDefaultDeclaration.__proto__ = Node
                ExportDefaultDeclaration.prototype = Object.create(
                  Node && Node.prototype
                )
                ExportDefaultDeclaration.prototype.constructor = ExportDefaultDeclaration

                ExportDefaultDeclaration.prototype.initialise = function initialise(
                  transforms
                ) {
                  if (transforms.moduleExport)
                    throw new CompileError(this, 'export is not supported')
                  Node.prototype.initialise.call(this, transforms)
                }

                return ExportDefaultDeclaration
              })(Node)

              var ExportNamedDeclaration = (function(Node) {
                function ExportNamedDeclaration() {
                  Node.apply(this, arguments)
                }

                if (Node) ExportNamedDeclaration.__proto__ = Node
                ExportNamedDeclaration.prototype = Object.create(
                  Node && Node.prototype
                )
                ExportNamedDeclaration.prototype.constructor = ExportNamedDeclaration

                ExportNamedDeclaration.prototype.initialise = function initialise(
                  transforms
                ) {
                  if (transforms.moduleExport)
                    throw new CompileError(this, 'export is not supported')
                  Node.prototype.initialise.call(this, transforms)
                }

                return ExportNamedDeclaration
              })(Node)

              var LoopStatement = (function(Node) {
                function LoopStatement() {
                  Node.apply(this, arguments)
                }

                if (Node) LoopStatement.__proto__ = Node
                LoopStatement.prototype = Object.create(Node && Node.prototype)
                LoopStatement.prototype.constructor = LoopStatement

                LoopStatement.prototype.findScope = function findScope(
                  functionScope
                ) {
                  return functionScope || !this.createdScope
                    ? this.parent.findScope(functionScope)
                    : this.body.scope
                }

                LoopStatement.prototype.initialise = function initialise(
                  transforms
                ) {
                  var this$1 = this

                  this.body.createScope()
                  this.createdScope = true

                  // this is populated as and when reassignments occur
                  this.reassigned = Object.create(null)
                  this.aliases = Object.create(null)

                  Node.prototype.initialise.call(this, transforms)

                  if (transforms.letConst) {
                    // see if any block-scoped declarations are referenced
                    // inside function expressions
                    var names = Object.keys(this.body.scope.declarations)

                    var i = names.length
                    while (i--) {
                      var name = names[i]
                      var declaration = this$1.body.scope.declarations[name]

                      var j = declaration.instances.length
                      while (j--) {
                        var instance = declaration.instances[j]
                        var nearestFunctionExpression = instance.findNearest(
                          /Function/
                        )

                        if (
                          nearestFunctionExpression &&
                          nearestFunctionExpression.depth > this$1.depth
                        ) {
                          this$1.shouldRewriteAsFunction = true
                          break
                        }
                      }

                      if (this$1.shouldRewriteAsFunction) break
                    }
                  }
                }

                LoopStatement.prototype.transpile = function transpile(
                  code,
                  transforms
                ) {
                  var needsBlock =
                    this.type != 'ForOfStatement' &&
                    (this.body.type !== 'BlockStatement' ||
                      (this.body.type === 'BlockStatement' &&
                        this.body.synthetic))

                  if (this.shouldRewriteAsFunction) {
                    var i0 = this.getIndentation()
                    var i1 = i0 + code.getIndentString()

                    var argString = this.args
                      ? ' ' + this.args.join(', ') + ' '
                      : ''
                    var paramString = this.params
                      ? ' ' + this.params.join(', ') + ' '
                      : ''

                    var functionScope = this.findScope(true)
                    var loop = functionScope.createIdentifier('loop')

                    var before =
                      'var ' +
                      loop +
                      ' = function (' +
                      paramString +
                      ') ' +
                      (this.body.synthetic
                        ? '{\n' + i0 + code.getIndentString()
                        : '')
                    var after =
                      (this.body.synthetic ? '\n' + i0 + '}' : '') +
                      ';\n\n' +
                      i0

                    code.insertRight(this.body.start, before)
                    code.insertLeft(this.body.end, after)
                    code.move(this.start, this.body.start, this.body.end)

                    if (this.canBreak || this.canReturn) {
                      var returned = functionScope.createIdentifier('returned')

                      var insert =
                        '{\n' +
                        i1 +
                        'var ' +
                        returned +
                        ' = ' +
                        loop +
                        '(' +
                        argString +
                        ');\n'
                      if (this.canBreak)
                        insert +=
                          '\n' +
                          i1 +
                          'if ( ' +
                          returned +
                          " === 'break' ) break;"
                      if (this.canReturn)
                        insert +=
                          '\n' +
                          i1 +
                          'if ( ' +
                          returned +
                          ' ) return ' +
                          returned +
                          '.v;'
                      insert += '\n' + i0 + '}'

                      code.insertRight(this.body.end, insert)
                    } else {
                      var callExpression = loop + '(' + argString + ');'

                      if (this.type === 'DoWhileStatement') {
                        code.overwrite(
                          this.start,
                          this.body.start,
                          'do {\n' + i1 + callExpression + '\n' + i0 + '}'
                        )
                      } else {
                        code.insertRight(this.body.end, callExpression)
                      }
                    }
                  } else if (needsBlock) {
                    code.insertLeft(this.body.start, '{ ')
                    code.insertRight(this.body.end, ' }')
                  }

                  Node.prototype.transpile.call(this, code, transforms)
                }

                return LoopStatement
              })(Node)

              function extractNames(node) {
                var names = []
                extractors[node.type](names, node)
                return names
              }

              var extractors = {
                Identifier: function Identifier(names, node) {
                  names.push(node)
                },

                ObjectPattern: function ObjectPattern(names, node) {
                  for (
                    var i = 0, list = node.properties;
                    i < list.length;
                    i += 1
                  ) {
                    var prop = list[i]

                    extractors[prop.value.type](names, prop.value)
                  }
                },

                ArrayPattern: function ArrayPattern(names, node) {
                  for (
                    var i = 0, list = node.elements;
                    i < list.length;
                    i += 1
                  ) {
                    var element = list[i]

                    if (element) extractors[element.type](names, element)
                  }
                },

                RestElement: function RestElement(names, node) {
                  extractors[node.argument.type](names, node.argument)
                },

                AssignmentPattern: function AssignmentPattern(names, node) {
                  extractors[node.left.type](names, node.left)
                },
              }

              var ForStatement = (function(LoopStatement) {
                function ForStatement() {
                  LoopStatement.apply(this, arguments)
                }

                if (LoopStatement) ForStatement.__proto__ = LoopStatement
                ForStatement.prototype = Object.create(
                  LoopStatement && LoopStatement.prototype
                )
                ForStatement.prototype.constructor = ForStatement

                ForStatement.prototype.findScope = function findScope(
                  functionScope
                ) {
                  return functionScope || !this.createdScope
                    ? this.parent.findScope(functionScope)
                    : this.body.scope
                }

                ForStatement.prototype.transpile = function transpile(
                  code,
                  transforms
                ) {
                  var this$1 = this

                  var i1 = this.getIndentation() + code.getIndentString()

                  if (this.shouldRewriteAsFunction) {
                    // which variables are declared in the init statement?
                    var names = this.init.type === 'VariableDeclaration'
                      ? [].concat.apply(
                          [],
                          this.init.declarations.map(function(declarator) {
                            return extractNames(declarator.id)
                          })
                        )
                      : []

                    var aliases = this.aliases

                    this.args = names.map(function(name) {
                      return name in this$1.aliases
                        ? this$1.aliases[name].outer
                        : name
                    })
                    this.params = names.map(function(name) {
                      return name in this$1.aliases
                        ? this$1.aliases[name].inner
                        : name
                    })

                    var updates = Object.keys(this.reassigned).map(function(
                      name
                    ) {
                      return (
                        aliases[name].outer + ' = ' + aliases[name].inner + ';'
                      )
                    })

                    if (updates.length) {
                      if (this.body.synthetic) {
                        code.insertLeft(
                          this.body.body[0].end,
                          '; ' + updates.join(' ')
                        )
                      } else {
                        var lastStatement = this.body.body[
                          this.body.body.length - 1
                        ]
                        code.insertLeft(
                          lastStatement.end,
                          '\n\n' + i1 + updates.join('\n' + i1)
                        )
                      }
                    }
                  }

                  LoopStatement.prototype.transpile.call(this, code, transforms)
                }

                return ForStatement
              })(LoopStatement)

              var ForInStatement = (function(LoopStatement) {
                function ForInStatement() {
                  LoopStatement.apply(this, arguments)
                }

                if (LoopStatement) ForInStatement.__proto__ = LoopStatement
                ForInStatement.prototype = Object.create(
                  LoopStatement && LoopStatement.prototype
                )
                ForInStatement.prototype.constructor = ForInStatement

                ForInStatement.prototype.findScope = function findScope(
                  functionScope
                ) {
                  return functionScope || !this.createdScope
                    ? this.parent.findScope(functionScope)
                    : this.body.scope
                }

                ForInStatement.prototype.transpile = function transpile(
                  code,
                  transforms
                ) {
                  var this$1 = this

                  if (this.shouldRewriteAsFunction) {
                    // which variables are declared in the init statement?
                    var names = this.left.type === 'VariableDeclaration'
                      ? [].concat.apply(
                          [],
                          this.left.declarations.map(function(declarator) {
                            return extractNames(declarator.id)
                          })
                        )
                      : []

                    this.args = names.map(function(name) {
                      return name in this$1.aliases
                        ? this$1.aliases[name].outer
                        : name
                    })
                    this.params = names.map(function(name) {
                      return name in this$1.aliases
                        ? this$1.aliases[name].inner
                        : name
                    })
                  }

                  LoopStatement.prototype.transpile.call(this, code, transforms)
                }

                return ForInStatement
              })(LoopStatement)

              var handlers = {
                Identifier: destructureIdentifier,
                AssignmentPattern: destructureAssignmentPattern,
                ArrayPattern: destructureArrayPattern,
                ObjectPattern: destructureObjectPattern,
              }

              function destructure(
                code,
                scope,
                node,
                ref,
                inline,
                statementGenerators
              ) {
                handlers[node.type](
                  code,
                  scope,
                  node,
                  ref,
                  inline,
                  statementGenerators
                )
              }

              function destructureIdentifier(
                code,
                scope,
                node,
                ref,
                inline,
                statementGenerators
              ) {
                statementGenerators.push(function(start, prefix, suffix) {
                  code.insertRight(
                    node.start,
                    inline ? prefix : prefix + 'var '
                  )
                  code.insertLeft(node.end, ' = ' + ref + suffix)
                  code.move(node.start, node.end, start)
                })
              }

              function destructureAssignmentPattern(
                code,
                scope,
                node,
                ref,
                inline,
                statementGenerators
              ) {
                var isIdentifier = node.left.type === 'Identifier'
                var name = isIdentifier ? node.left.name : ref

                if (!inline) {
                  statementGenerators.push(function(start, prefix, suffix) {
                    code.insertRight(
                      node.left.end,
                      prefix + 'if ( ' + name + ' === void 0 ) ' + name
                    )
                    code.move(node.left.end, node.right.end, start)
                    code.insertLeft(node.right.end, suffix)
                  })
                }

                if (!isIdentifier) {
                  destructure(
                    code,
                    scope,
                    node.left,
                    ref,
                    inline,
                    statementGenerators
                  )
                }
              }

              function destructureArrayPattern(
                code,
                scope,
                node,
                ref,
                inline,
                statementGenerators
              ) {
                var c = node.start

                node.elements.forEach(function(element, i) {
                  if (!element) return

                  if (element.type === 'RestElement') {
                    handleProperty(
                      code,
                      scope,
                      c,
                      element.argument,
                      ref + '.slice(' + i + ')',
                      inline,
                      statementGenerators
                    )
                  } else {
                    handleProperty(
                      code,
                      scope,
                      c,
                      element,
                      ref + '[' + i + ']',
                      inline,
                      statementGenerators
                    )
                  }
                  c = element.end
                })

                code.remove(c, node.end)
              }

              function destructureObjectPattern(
                code,
                scope,
                node,
                ref,
                inline,
                statementGenerators
              ) {
                var c = node.start

                node.properties.forEach(function(prop) {
                  var value = prop.computed || prop.key.type !== 'Identifier'
                    ? ref + '[' + code.slice(prop.key.start, prop.key.end) + ']'
                    : ref + '.' + prop.key.name
                  handleProperty(
                    code,
                    scope,
                    c,
                    prop.value,
                    value,
                    inline,
                    statementGenerators
                  )
                  c = prop.end
                })

                code.remove(c, node.end)
              }

              function handleProperty(
                code,
                scope,
                c,
                node,
                value,
                inline,
                statementGenerators
              ) {
                switch (node.type) {
                  case 'Identifier': {
                    code.remove(c, node.start)
                    destructureIdentifier(
                      code,
                      scope,
                      node,
                      value,
                      inline,
                      statementGenerators
                    )
                    break
                  }

                  case 'AssignmentPattern': {
                    var name

                    var isIdentifier = node.left.type === 'Identifier'

                    if (isIdentifier) {
                      name = node.left.name
                      var declaration = scope.findDeclaration(name)
                      if (declaration) name = declaration.name
                    } else {
                      name = scope.createIdentifier(value)
                    }

                    statementGenerators.push(function(start, prefix, suffix) {
                      if (inline) {
                        code.insertRight(
                          node.right.start,
                          name + ' = ' + value + ' === undefined ? '
                        )
                        code.insertLeft(node.right.end, ' : ' + value)
                      } else {
                        code.insertRight(
                          node.right.start,
                          prefix +
                            'var ' +
                            name +
                            ' = ' +
                            value +
                            '; if ( ' +
                            name +
                            ' === void 0 ) ' +
                            name +
                            ' = '
                        )
                        code.insertLeft(node.right.end, suffix)
                      }

                      code.move(node.right.start, node.right.end, start)
                    })

                    if (isIdentifier) {
                      code.remove(c, node.right.start)
                    } else {
                      code.remove(c, node.left.start)
                      code.remove(node.left.end, node.right.start)
                      handleProperty(
                        code,
                        scope,
                        c,
                        node.left,
                        name,
                        inline,
                        statementGenerators
                      )
                    }

                    break
                  }

                  case 'ObjectPattern': {
                    code.remove(c, (c = node.start))

                    if (node.properties.length > 1) {
                      var ref = scope.createIdentifier(value)

                      statementGenerators.push(function(start, prefix, suffix) {
                        // this feels a tiny bit hacky, but we can't do a
                        // straightforward insertLeft and keep correct order...
                        code.insertRight(
                          node.start,
                          prefix + 'var ' + ref + ' = '
                        )
                        code.overwrite(node.start, (c = node.start + 1), value)
                        code.insertLeft(c, suffix)

                        code.move(node.start, c, start)
                      })

                      node.properties.forEach(function(prop) {
                        var value = prop.computed ||
                          prop.key.type !== 'Identifier'
                          ? ref +
                              '[' +
                              code.slice(prop.key.start, prop.key.end) +
                              ']'
                          : ref + '.' + prop.key.name
                        handleProperty(
                          code,
                          scope,
                          c,
                          prop.value,
                          value,
                          inline,
                          statementGenerators
                        )
                        c = prop.end
                      })
                    } else {
                      var prop = node.properties[0]
                      var value_suffix = prop.computed ||
                        prop.key.type !== 'Identifier'
                        ? '[' + code.slice(prop.key.start, prop.key.end) + ']'
                        : '.' + prop.key.name
                      handleProperty(
                        code,
                        scope,
                        c,
                        prop.value,
                        '' + value + value_suffix,
                        inline,
                        statementGenerators
                      )
                      c = prop.end
                    }

                    code.remove(c, node.end)
                    break
                  }

                  case 'ArrayPattern': {
                    code.remove(c, (c = node.start))

                    if (node.elements.filter(Boolean).length > 1) {
                      var ref$1 = scope.createIdentifier(value)

                      statementGenerators.push(function(start, prefix, suffix) {
                        code.insertRight(
                          node.start,
                          prefix + 'var ' + ref$1 + ' = '
                        )
                        code.overwrite(node.start, (c = node.start + 1), value)
                        code.insertLeft(c, suffix)

                        code.move(node.start, c, start)
                      })

                      node.elements.forEach(function(element, i) {
                        if (!element) return

                        if (element.type === 'RestElement') {
                          handleProperty(
                            code,
                            scope,
                            c,
                            element.argument,
                            ref$1 + '.slice(' + i + ')',
                            inline,
                            statementGenerators
                          )
                        } else {
                          handleProperty(
                            code,
                            scope,
                            c,
                            element,
                            ref$1 + '[' + i + ']',
                            inline,
                            statementGenerators
                          )
                        }
                        c = element.end
                      })
                    } else {
                      var index = findIndex(node.elements, Boolean)
                      var element = node.elements[index]
                      if (element.type === 'RestElement') {
                        handleProperty(
                          code,
                          scope,
                          c,
                          element.argument,
                          value + '.slice(' + index + ')',
                          inline,
                          statementGenerators
                        )
                      } else {
                        handleProperty(
                          code,
                          scope,
                          c,
                          element,
                          value + '[' + index + ']',
                          inline,
                          statementGenerators
                        )
                      }
                      c = element.end
                    }

                    code.remove(c, node.end)
                    break
                  }

                  default: {
                    throw new Error(
                      'Unexpected node type in destructuring (' +
                        node.type +
                        ')'
                    )
                  }
                }
              }

              var ForOfStatement = (function(LoopStatement) {
                function ForOfStatement() {
                  LoopStatement.apply(this, arguments)
                }

                if (LoopStatement) ForOfStatement.__proto__ = LoopStatement
                ForOfStatement.prototype = Object.create(
                  LoopStatement && LoopStatement.prototype
                )
                ForOfStatement.prototype.constructor = ForOfStatement

                ForOfStatement.prototype.initialise = function initialise(
                  transforms
                ) {
                  if (transforms.forOf && !transforms.dangerousForOf)
                    throw new CompileError(
                      this,
                      "for...of statements are not supported. Use `transforms: { forOf: false }` to skip transformation and disable this error, or `transforms: { dangerousForOf: true }` if you know what you're doing"
                    )
                  LoopStatement.prototype.initialise.call(this, transforms)
                }

                ForOfStatement.prototype.transpile = function transpile(
                  code,
                  transforms
                ) {
                  if (!transforms.dangerousForOf) {
                    LoopStatement.prototype.transpile.call(
                      this,
                      code,
                      transforms
                    )
                    return
                  }

                  // edge case (#80)
                  if (!this.body.body[0]) {
                    if (
                      this.left.type === 'VariableDeclaration' &&
                      this.left.kind === 'var'
                    ) {
                      code.remove(this.start, this.left.start)
                      code.insertLeft(this.left.end, ';')
                      code.remove(this.left.end, this.end)
                    } else {
                      code.remove(this.start, this.end)
                    }

                    return
                  }

                  var scope = this.findScope(true)
                  var i0 = this.getIndentation()
                  var i1 = i0 + code.getIndentString()

                  var key = scope.createIdentifier('i')
                  var list = scope.createIdentifier('list')

                  if (this.body.synthetic) {
                    code.insertRight(this.left.start, '{\n' + i1)
                    code.insertLeft(this.body.body[0].end, '\n' + i0 + '}')
                  }

                  var bodyStart = this.body.body[0].start

                  code.remove(this.left.end, this.right.start)
                  code.move(this.left.start, this.left.end, bodyStart)

                  code.insertRight(
                    this.right.start,
                    'var ' + key + ' = 0, ' + list + ' = '
                  )
                  code.insertLeft(
                    this.right.end,
                    '; ' + key + ' < ' + list + '.length; ' + key + ' += 1'
                  )

                  // destructuring. TODO non declaration destructuring
                  var declarator =
                    this.left.type === 'VariableDeclaration' &&
                    this.left.declarations[0]
                  if (declarator && declarator.id.type !== 'Identifier') {
                    var statementGenerators = []
                    var ref = scope.createIdentifier('ref')
                    destructure(
                      code,
                      scope,
                      declarator.id,
                      ref,
                      false,
                      statementGenerators
                    )

                    var suffix = ';\n' + i1
                    statementGenerators.forEach(function(fn, i) {
                      if (i === statementGenerators.length - 1) {
                        suffix = ';\n\n' + i1
                      }

                      fn(bodyStart, '', suffix)
                    })

                    code.insertLeft(
                      this.left.start + this.left.kind.length + 1,
                      ref
                    )
                    code.insertLeft(
                      this.left.end,
                      ' = ' + list + '[' + key + '];\n' + i1
                    )
                  } else {
                    code.insertLeft(
                      this.left.end,
                      ' = ' + list + '[' + key + '];\n\n' + i1
                    )
                  }

                  LoopStatement.prototype.transpile.call(this, code, transforms)
                }

                return ForOfStatement
              })(LoopStatement)

              var FunctionDeclaration = (function(Node) {
                function FunctionDeclaration() {
                  Node.apply(this, arguments)
                }

                if (Node) FunctionDeclaration.__proto__ = Node
                FunctionDeclaration.prototype = Object.create(
                  Node && Node.prototype
                )
                FunctionDeclaration.prototype.constructor = FunctionDeclaration

                FunctionDeclaration.prototype.initialise = function initialise(
                  transforms
                ) {
                  if (this.generator && transforms.generator) {
                    throw new CompileError(this, 'Generators are not supported')
                  }

                  this.body.createScope()

                  this.findScope(true).addDeclaration(this.id, 'function')
                  Node.prototype.initialise.call(this, transforms)
                }

                return FunctionDeclaration
              })(Node)

              var FunctionExpression = (function(Node) {
                function FunctionExpression() {
                  Node.apply(this, arguments)
                }

                if (Node) FunctionExpression.__proto__ = Node
                FunctionExpression.prototype = Object.create(
                  Node && Node.prototype
                )
                FunctionExpression.prototype.constructor = FunctionExpression

                FunctionExpression.prototype.initialise = function initialise(
                  transforms
                ) {
                  if (this.generator && transforms.generator) {
                    throw new CompileError(this, 'Generators are not supported')
                  }

                  this.body.createScope()

                  if (this.id) {
                    // function expression IDs belong to the child scope...
                    this.body.scope.addDeclaration(this.id, 'function')
                  }

                  Node.prototype.initialise.call(this, transforms)

                  var parent = this.parent
                  var methodName

                  if (
                    transforms.conciseMethodProperty &&
                    parent.type === 'Property' &&
                    parent.kind === 'init' &&
                    parent.method &&
                    parent.key.type === 'Identifier'
                  ) {
                    // object literal concise method
                    methodName = parent.key.name
                  } else if (
                    transforms.classes &&
                    parent.type === 'MethodDefinition' &&
                    parent.kind === 'method' &&
                    parent.key.type === 'Identifier'
                  ) {
                    // method definition in a class
                    methodName = parent.key.name
                  } else if (this.id && this.id.type === 'Identifier') {
                    // naked function expression
                    methodName = this.id.alias || this.id.name
                  }

                  if (methodName) {
                    for (
                      var i = 0, list = this.params;
                      i < list.length;
                      i += 1
                    ) {
                      var param = list[i]

                      if (
                        param.type === 'Identifier' &&
                        methodName === param.name
                      ) {
                        // workaround for Safari 9/WebKit bug:
                        // https://gitlab.com/Rich-Harris/buble/issues/154
                        // change parameter name when same as method name

                        var scope = this.body.scope
                        var declaration = scope.declarations[methodName]

                        var alias = scope.createIdentifier(methodName)
                        param.alias = alias

                        for (
                          var i$1 = 0, list$1 = declaration.instances;
                          i$1 < list$1.length;
                          i$1 += 1
                        ) {
                          var identifier = list$1[i$1]

                          identifier.alias = alias
                        }

                        break
                      }
                    }
                  }
                }

                return FunctionExpression
              })(Node)

              function isReference(node, parent) {
                if (node.type === 'MemberExpression') {
                  return !node.computed && isReference(node.object, node)
                }

                if (node.type === 'Identifier') {
                  // the only time we could have an identifier node without a parent is
                  // if it's the entire body of a function without a block statement 
                  // i.e. an arrow function expression like `a => a`
                  if (!parent) return true

                  if (/(Function|Class)Expression/.test(parent.type))
                    return false

                  if (parent.type === 'VariableDeclarator')
                    return node === parent.init

                  // TODO is this right?
                  if (
                    parent.type === 'MemberExpression' ||
                    parent.type === 'MethodDefinition'
                  ) {
                    return parent.computed || node === parent.object
                  }

                  if (parent.type === 'ArrayPattern') return false

                  // disregard the `bar` in `{ bar: foo }`, but keep it in `{ [bar]: foo }`
                  if (parent.type === 'Property') {
                    if (parent.parent.type === 'ObjectPattern') return false
                    return parent.computed || node === parent.value
                  }

                  // disregard the `bar` in `class Foo { bar () {...} }`
                  if (parent.type === 'MethodDefinition') return false

                  // disregard the `bar` in `export { foo as bar }`
                  if (
                    parent.type === 'ExportSpecifier' &&
                    node !== parent.local
                  )
                    return false

                  return true
                }
              }

              var Identifier = (function(Node) {
                function Identifier() {
                  Node.apply(this, arguments)
                }

                if (Node) Identifier.__proto__ = Node
                Identifier.prototype = Object.create(Node && Node.prototype)
                Identifier.prototype.constructor = Identifier

                Identifier.prototype.findScope = function findScope(
                  functionScope
                ) {
                  if (this.parent.params && ~this.parent.params.indexOf(this)) {
                    return this.parent.body.scope
                  }

                  if (
                    this.parent.type === 'FunctionExpression' &&
                    this === this.parent.id
                  ) {
                    return this.parent.body.scope
                  }

                  return this.parent.findScope(functionScope)
                }

                Identifier.prototype.initialise = function initialise(
                  transforms
                ) {
                  if (transforms.arrow && isReference(this, this.parent)) {
                    if (
                      this.name === 'arguments' &&
                      !this.findScope(false).contains(this.name)
                    ) {
                      var lexicalBoundary = this.findLexicalBoundary()
                      var arrowFunction = this.findNearest(
                        'ArrowFunctionExpression'
                      )
                      var loop = this.findNearest(loopStatement)

                      if (
                        arrowFunction &&
                        arrowFunction.depth > lexicalBoundary.depth
                      ) {
                        this.alias = lexicalBoundary.getArgumentsAlias()
                      }

                      if (
                        loop &&
                        loop.body.contains(this) &&
                        loop.depth > lexicalBoundary.depth
                      ) {
                        this.alias = lexicalBoundary.getArgumentsAlias()
                      }
                    }

                    this.findScope(false).addReference(this)
                  }
                }

                Identifier.prototype.transpile = function transpile(code) {
                  if (this.alias) {
                    code.overwrite(this.start, this.end, this.alias, true)
                  }
                }

                return Identifier
              })(Node)

              var IfStatement = (function(Node) {
                function IfStatement() {
                  Node.apply(this, arguments)
                }

                if (Node) IfStatement.__proto__ = Node
                IfStatement.prototype = Object.create(Node && Node.prototype)
                IfStatement.prototype.constructor = IfStatement

                IfStatement.prototype.initialise = function initialise(
                  transforms
                ) {
                  Node.prototype.initialise.call(this, transforms)
                }

                IfStatement.prototype.transpile = function transpile(
                  code,
                  transforms
                ) {
                  if (
                    this.consequent.type !== 'BlockStatement' ||
                    (this.consequent.type === 'BlockStatement' &&
                      this.consequent.synthetic)
                  ) {
                    code.insertLeft(this.consequent.start, '{ ')
                    code.insertRight(this.consequent.end, ' }')
                  }

                  if (
                    this.alternate &&
                    this.alternate.type !== 'IfStatement' &&
                    (this.alternate.type !== 'BlockStatement' ||
                      (this.alternate.type === 'BlockStatement' &&
                        this.alternate.synthetic))
                  ) {
                    code.insertLeft(this.alternate.start, '{ ')
                    code.insertRight(this.alternate.end, ' }')
                  }

                  Node.prototype.transpile.call(this, code, transforms)
                }

                return IfStatement
              })(Node)

              var ImportDeclaration = (function(Node) {
                function ImportDeclaration() {
                  Node.apply(this, arguments)
                }

                if (Node) ImportDeclaration.__proto__ = Node
                ImportDeclaration.prototype = Object.create(
                  Node && Node.prototype
                )
                ImportDeclaration.prototype.constructor = ImportDeclaration

                ImportDeclaration.prototype.initialise = function initialise(
                  transforms
                ) {
                  if (transforms.moduleImport)
                    throw new CompileError(this, 'import is not supported')
                  Node.prototype.initialise.call(this, transforms)
                }

                return ImportDeclaration
              })(Node)

              var ImportDefaultSpecifier = (function(Node) {
                function ImportDefaultSpecifier() {
                  Node.apply(this, arguments)
                }

                if (Node) ImportDefaultSpecifier.__proto__ = Node
                ImportDefaultSpecifier.prototype = Object.create(
                  Node && Node.prototype
                )
                ImportDefaultSpecifier.prototype.constructor = ImportDefaultSpecifier

                ImportDefaultSpecifier.prototype.initialise = function initialise(
                  transforms
                ) {
                  this.findScope(true).addDeclaration(this.local, 'import')
                  Node.prototype.initialise.call(this, transforms)
                }

                return ImportDefaultSpecifier
              })(Node)

              var ImportSpecifier = (function(Node) {
                function ImportSpecifier() {
                  Node.apply(this, arguments)
                }

                if (Node) ImportSpecifier.__proto__ = Node
                ImportSpecifier.prototype = Object.create(
                  Node && Node.prototype
                )
                ImportSpecifier.prototype.constructor = ImportSpecifier

                ImportSpecifier.prototype.initialise = function initialise(
                  transforms
                ) {
                  this.findScope(true).addDeclaration(this.local, 'import')
                  Node.prototype.initialise.call(this, transforms)
                }

                return ImportSpecifier
              })(Node)

              var IS_DATA_ATTRIBUTE = /-/

              var JSXAttribute = (function(Node) {
                function JSXAttribute() {
                  Node.apply(this, arguments)
                }

                if (Node) JSXAttribute.__proto__ = Node
                JSXAttribute.prototype = Object.create(Node && Node.prototype)
                JSXAttribute.prototype.constructor = JSXAttribute

                JSXAttribute.prototype.transpile = function transpile(
                  code,
                  transforms
                ) {
                  if (this.value) {
                    code.overwrite(this.name.end, this.value.start, ': ')
                  } else {
                    // tag without value
                    code.overwrite(
                      this.name.start,
                      this.name.end,
                      this.name.name + ': true'
                    )
                  }

                  if (IS_DATA_ATTRIBUTE.test(this.name.name)) {
                    code.overwrite(
                      this.name.start,
                      this.name.end,
                      "'" + this.name.name + "'"
                    )
                  }

                  Node.prototype.transpile.call(this, code, transforms)
                }

                return JSXAttribute
              })(Node)

              function containsNewLine(node) {
                return (
                  node.type === 'Literal' &&
                  !/\S/.test(node.value) &&
                  /\n/.test(node.value)
                )
              }

              var JSXClosingElement = (function(Node) {
                function JSXClosingElement() {
                  Node.apply(this, arguments)
                }

                if (Node) JSXClosingElement.__proto__ = Node
                JSXClosingElement.prototype = Object.create(
                  Node && Node.prototype
                )
                JSXClosingElement.prototype.constructor = JSXClosingElement

                JSXClosingElement.prototype.transpile = function transpile(
                  code
                ) {
                  var spaceBeforeParen = true

                  var lastChild = this.parent.children[
                    this.parent.children.length - 1
                  ]

                  // omit space before closing paren if
                  //   a) this is on a separate line, or
                  //   b) there are no children but there are attributes
                  if (
                    (lastChild && containsNewLine(lastChild)) ||
                    this.parent.openingElement.attributes.length
                  ) {
                    spaceBeforeParen = false
                  }

                  code.overwrite(
                    this.start,
                    this.end,
                    spaceBeforeParen ? ' )' : ')'
                  )
                }

                return JSXClosingElement
              })(Node)

              function normalise(str, removeTrailingWhitespace) {
                if (removeTrailingWhitespace && /\n/.test(str)) {
                  str = str.replace(/\s+$/, '')
                }

                str = str
                  .replace(/^\n\r?\s+/, '') // remove leading newline + space
                  .replace(/\s*\n\r?\s*/gm, ' ') // replace newlines with spaces

                // TODO prefer single quotes?
                return JSON.stringify(str)
              }

              var JSXElement = (function(Node) {
                function JSXElement() {
                  Node.apply(this, arguments)
                }

                if (Node) JSXElement.__proto__ = Node
                JSXElement.prototype = Object.create(Node && Node.prototype)
                JSXElement.prototype.constructor = JSXElement

                JSXElement.prototype.transpile = function transpile(
                  code,
                  transforms
                ) {
                  Node.prototype.transpile.call(this, code, transforms)

                  var children = this.children.filter(function(child) {
                    if (child.type !== 'Literal') return true

                    // remove whitespace-only literals, unless on a single line
                    return /\S/.test(child.value) || !/\n/.test(child.value)
                  })

                  if (children.length) {
                    var c = this.openingElement.end

                    var i
                    for (i = 0; i < children.length; i += 1) {
                      var child = children[i]

                      if (
                        child.type === 'JSXExpressionContainer' &&
                        child.expression.type === 'JSXEmptyExpression'
                      ) {
                        // empty block is a no op
                      } else {
                        var tail = code.original[c] === '\n' &&
                          child.type !== 'Literal'
                          ? ''
                          : ' '
                        code.insertLeft(c, ',' + tail)
                      }

                      if (child.type === 'Literal') {
                        var str = normalise(
                          child.value,
                          i === children.length - 1
                        )
                        code.overwrite(child.start, child.end, str)
                      }

                      c = child.end
                    }
                  }
                }

                return JSXElement
              })(Node)

              var JSXExpressionContainer = (function(Node) {
                function JSXExpressionContainer() {
                  Node.apply(this, arguments)
                }

                if (Node) JSXExpressionContainer.__proto__ = Node
                JSXExpressionContainer.prototype = Object.create(
                  Node && Node.prototype
                )
                JSXExpressionContainer.prototype.constructor = JSXExpressionContainer

                JSXExpressionContainer.prototype.transpile = function transpile(
                  code,
                  transforms
                ) {
                  code.remove(this.start, this.expression.start)
                  code.remove(this.expression.end, this.end)

                  Node.prototype.transpile.call(this, code, transforms)
                }

                return JSXExpressionContainer
              })(Node)

              var JSXOpeningElement = (function(Node) {
                function JSXOpeningElement() {
                  Node.apply(this, arguments)
                }

                if (Node) JSXOpeningElement.__proto__ = Node
                JSXOpeningElement.prototype = Object.create(
                  Node && Node.prototype
                )
                JSXOpeningElement.prototype.constructor = JSXOpeningElement

                JSXOpeningElement.prototype.transpile = function transpile(
                  code,
                  transforms
                ) {
                  var this$1 = this

                  code.overwrite(
                    this.start,
                    this.name.start,
                    this.program.jsx + '( '
                  )

                  var html =
                    this.name.type === 'JSXIdentifier' &&
                    this.name.name[0] === this.name.name[0].toLowerCase()
                  if (html) code.insertRight(this.name.start, "'")

                  var len = this.attributes.length
                  var c = this.name.end

                  if (len) {
                    var i

                    var hasSpread = false
                    for (i = 0; i < len; i += 1) {
                      if (this$1.attributes[i].type === 'JSXSpreadAttribute') {
                        hasSpread = true
                        break
                      }
                    }

                    c = this.attributes[0].end

                    for (i = 0; i < len; i += 1) {
                      var attr = this$1.attributes[i]

                      if (i > 0) {
                        code.overwrite(c, attr.start, ', ')
                      }

                      if (hasSpread && attr.type !== 'JSXSpreadAttribute') {
                        var lastAttr = this$1.attributes[i - 1]
                        var nextAttr = this$1.attributes[i + 1]

                        if (
                          !lastAttr ||
                          lastAttr.type === 'JSXSpreadAttribute'
                        ) {
                          code.insertRight(attr.start, '{ ')
                        }

                        if (
                          !nextAttr ||
                          nextAttr.type === 'JSXSpreadAttribute'
                        ) {
                          code.insertLeft(attr.end, ' }')
                        }
                      }

                      c = attr.end
                    }

                    var after
                    var before
                    if (hasSpread) {
                      if (len === 1) {
                        before = html ? "'," : ','
                      } else {
                        if (!this.program.options.objectAssign) {
                          throw new CompileError(
                            this,
                            "Mixed JSX attributes ending in spread requires specified objectAssign option with 'Object.assign' or polyfill helper."
                          )
                        }
                        before = html
                          ? "', " + this.program.options.objectAssign + '({},'
                          : ', ' + this.program.options.objectAssign + '({},'
                        after = ')'
                      }
                    } else {
                      before = html ? "', {" : ', {'
                      after = ' }'
                    }

                    code.insertRight(this.name.end, before)

                    if (after) {
                      code.insertLeft(this.attributes[len - 1].end, after)
                    }
                  } else {
                    code.insertLeft(this.name.end, html ? "', null" : ', null')
                    c = this.name.end
                  }

                  Node.prototype.transpile.call(this, code, transforms)

                  if (this.selfClosing) {
                    code.overwrite(
                      c,
                      this.end,
                      this.attributes.length ? ')' : ' )'
                    )
                  } else {
                    code.remove(c, this.end)
                  }
                }

                return JSXOpeningElement
              })(Node)

              var JSXSpreadAttribute = (function(Node) {
                function JSXSpreadAttribute() {
                  Node.apply(this, arguments)
                }

                if (Node) JSXSpreadAttribute.__proto__ = Node
                JSXSpreadAttribute.prototype = Object.create(
                  Node && Node.prototype
                )
                JSXSpreadAttribute.prototype.constructor = JSXSpreadAttribute

                JSXSpreadAttribute.prototype.transpile = function transpile(
                  code,
                  transforms
                ) {
                  code.remove(this.start, this.argument.start)
                  code.remove(this.argument.end, this.end)

                  Node.prototype.transpile.call(this, code, transforms)
                }

                return JSXSpreadAttribute
              })(Node)

              var regenerate = __commonjs(function(module, exports, global) {
                /*! https://mths.be/regenerate v1.3.1 by @mathias | MIT license */
                ;(function(root) {
                  // Detect free variables `exports`.
                  var freeExports = typeof exports == 'object' && exports

                  // Detect free variable `module`.
                  var freeModule =
                    typeof module == 'object' &&
                    module &&
                    module.exports == freeExports &&
                    module

                  // Detect free variable `global`, from Node.js/io.js or Browserified code,
                  // and use it as `root`.
                  var freeGlobal = typeof global == 'object' && global
                  if (
                    freeGlobal.global === freeGlobal ||
                    freeGlobal.window === freeGlobal
                  ) {
                    root = freeGlobal
                  }

                  /*--------------------------------------------------------------------------*/

                  var ERRORS = {
                    rangeOrder:
                      'A range\u2019s `stop` value must be greater than or equal ' +
                        'to the `start` value.',
                    codePointRange:
                      'Invalid code point value. Code points range from ' +
                        'U+000000 to U+10FFFF.',
                  }

                  // https://mathiasbynens.be/notes/javascript-encoding#surrogate-pairs
                  var HIGH_SURROGATE_MIN = 0xd800
                  var HIGH_SURROGATE_MAX = 0xdbff
                  var LOW_SURROGATE_MIN = 0xdc00
                  var LOW_SURROGATE_MAX = 0xdfff

                  // In Regenerate output, `\0` is never preceded by `\` because we sort by
                  // code point value, so lets keep this regular expression simple.
                  var regexNull = /\\x00([^0123456789]|$)/g

                  var object = {}
                  var hasOwnProperty = object.hasOwnProperty
                  var extend = function(destination, source) {
                    var key
                    for (key in source) {
                      if (hasOwnProperty.call(source, key)) {
                        destination[key] = source[key]
                      }
                    }
                    return destination
                  }

                  var forEach = function(array, callback) {
                    var index = -1
                    var length = array.length
                    while (++index < length) {
                      callback(array[index], index)
                    }
                  }

                  var toString = object.toString
                  var isArray = function(value) {
                    return toString.call(value) == '[object Array]'
                  }
                  var isNumber = function(value) {
                    return (
                      typeof value == 'number' ||
                      toString.call(value) == '[object Number]'
                    )
                  }

                  // This assumes that `number` is a positive integer that `toString()`s nicely
                  // (which is the case for all code point values).
                  var zeroes = '0000'
                  var pad = function(number, totalCharacters) {
                    var string = String(number)
                    return string.length < totalCharacters
                      ? (zeroes + string).slice(-totalCharacters)
                      : string
                  }

                  var hex = function(number) {
                    return Number(number).toString(16).toUpperCase()
                  }

                  var slice = [].slice

                  /*--------------------------------------------------------------------------*/

                  var dataFromCodePoints = function(codePoints) {
                    var index = -1
                    var length = codePoints.length
                    var max = length - 1
                    var result = []
                    var isStart = true
                    var tmp
                    var previous = 0
                    while (++index < length) {
                      tmp = codePoints[index]
                      if (isStart) {
                        result.push(tmp)
                        previous = tmp
                        isStart = false
                      } else {
                        if (tmp == previous + 1) {
                          if (index != max) {
                            previous = tmp
                            continue
                          } else {
                            isStart = true
                            result.push(tmp + 1)
                          }
                        } else {
                          // End the previous range and start a new one.
                          result.push(previous + 1, tmp)
                          previous = tmp
                        }
                      }
                    }
                    if (!isStart) {
                      result.push(tmp + 1)
                    }
                    return result
                  }

                  var dataRemove = function(data, codePoint) {
                    // Iterate over the data per `(start, end)` pair.
                    var index = 0
                    var start
                    var end
                    var length = data.length
                    while (index < length) {
                      start = data[index]
                      end = data[index + 1]
                      if (codePoint >= start && codePoint < end) {
                        // Modify this pair.
                        if (codePoint == start) {
                          if (end == start + 1) {
                            // Just remove `start` and `end`.
                            data.splice(index, 2)
                            return data
                          } else {
                            // Just replace `start` with a new value.
                            data[index] = codePoint + 1
                            return data
                          }
                        } else if (codePoint == end - 1) {
                          // Just replace `end` with a new value.
                          data[index + 1] = codePoint
                          return data
                        } else {
                          // Replace `[start, end]` with `[startA, endA, startB, endB]`.
                          data.splice(
                            index,
                            2,
                            start,
                            codePoint,
                            codePoint + 1,
                            end
                          )
                          return data
                        }
                      }
                      index += 2
                    }
                    return data
                  }

                  var dataRemoveRange = function(data, rangeStart, rangeEnd) {
                    if (rangeEnd < rangeStart) {
                      throw Error(ERRORS.rangeOrder)
                    }
                    // Iterate over the data per `(start, end)` pair.
                    var index = 0
                    var start
                    var end
                    while (index < data.length) {
                      start = data[index]
                      end = data[index + 1] - 1 // Note: the `- 1` makes `end` inclusive.

                      // Exit as soon as no more matching pairs can be found.
                      if (start > rangeEnd) {
                        return data
                      }

                      // Check if this range pair is equal to, or forms a subset of, the range
                      // to be removed.
                      // E.g. we have `[0, 11, 40, 51]` and want to remove 0-10  `[40, 51]`.
                      // E.g. we have `[40, 51]` and want to remove 0-100  `[]`.
                      if (rangeStart <= start && rangeEnd >= end) {
                        // Remove this pair.
                        data.splice(index, 2)
                        continue
                      }

                      // Check if both `rangeStart` and `rangeEnd` are within the bounds of
                      // this pair.
                      // E.g. we have `[0, 11]` and want to remove 4-6  `[0, 4, 7, 11]`.
                      if (rangeStart >= start && rangeEnd < end) {
                        if (rangeStart == start) {
                          // Replace `[start, end]` with `[startB, endB]`.
                          data[index] = rangeEnd + 1
                          data[index + 1] = end + 1
                          return data
                        }
                        // Replace `[start, end]` with `[startA, endA, startB, endB]`.
                        data.splice(
                          index,
                          2,
                          start,
                          rangeStart,
                          rangeEnd + 1,
                          end + 1
                        )
                        return data
                      }

                      // Check if only `rangeStart` is within the bounds of this pair.
                      // E.g. we have `[0, 11]` and want to remove 4-20  `[0, 4]`.
                      if (rangeStart >= start && rangeStart <= end) {
                        // Replace `end` with `rangeStart`.
                        data[index + 1] = rangeStart
                        // Note: we cannot `return` just yet, in case any following pairs still
                        // contain matching code points.
                        // E.g. we have `[0, 11, 14, 31]` and want to remove 4-20
                        //  `[0, 4, 21, 31]`.
                      } else if (rangeEnd >= start && rangeEnd <= end) {
                        // Check if only `rangeEnd` is within the bounds of this pair.
                        // E.g. we have `[14, 31]` and want to remove 4-20  `[21, 31]`.
                        // Just replace `start`.
                        data[index] = rangeEnd + 1
                        return data
                      }

                      index += 2
                    }
                    return data
                  }

                  var dataAdd = function(data, codePoint) {
                    // Iterate over the data per `(start, end)` pair.
                    var index = 0
                    var start
                    var end
                    var lastIndex = null
                    var length = data.length
                    if (codePoint < 0x0 || codePoint > 0x10ffff) {
                      throw RangeError(ERRORS.codePointRange)
                    }
                    while (index < length) {
                      start = data[index]
                      end = data[index + 1]

                      // Check if the code point is already in the set.
                      if (codePoint >= start && codePoint < end) {
                        return data
                      }

                      if (codePoint == start - 1) {
                        // Just replace `start` with a new value.
                        data[index] = codePoint
                        return data
                      }

                      // At this point, if `start` is `greater` than `codePoint`, insert a new
                      // `[start, end]` pair before the current pair, or after the current pair
                      // if there is a known `lastIndex`.
                      if (start > codePoint) {
                        data.splice(
                          lastIndex != null ? lastIndex + 2 : 0,
                          0,
                          codePoint,
                          codePoint + 1
                        )
                        return data
                      }

                      if (codePoint == end) {
                        // Check if adding this code point causes two separate ranges to become
                        // a single range, e.g. `dataAdd([0, 4, 5, 10], 4)`  `[0, 10]`.
                        if (codePoint + 1 == data[index + 2]) {
                          data.splice(index, 4, start, data[index + 3])
                          return data
                        }
                        // Else, just replace `end` with a new value.
                        data[index + 1] = codePoint + 1
                        return data
                      }
                      lastIndex = index
                      index += 2
                    }
                    // The loop has finished; add the new pair to the end of the data set.
                    data.push(codePoint, codePoint + 1)
                    return data
                  }

                  var dataAddData = function(dataA, dataB) {
                    // Iterate over the data per `(start, end)` pair.
                    var index = 0
                    var start
                    var end
                    var data = dataA.slice()
                    var length = dataB.length
                    while (index < length) {
                      start = dataB[index]
                      end = dataB[index + 1] - 1
                      if (start == end) {
                        data = dataAdd(data, start)
                      } else {
                        data = dataAddRange(data, start, end)
                      }
                      index += 2
                    }
                    return data
                  }

                  var dataRemoveData = function(dataA, dataB) {
                    // Iterate over the data per `(start, end)` pair.
                    var index = 0
                    var start
                    var end
                    var data = dataA.slice()
                    var length = dataB.length
                    while (index < length) {
                      start = dataB[index]
                      end = dataB[index + 1] - 1
                      if (start == end) {
                        data = dataRemove(data, start)
                      } else {
                        data = dataRemoveRange(data, start, end)
                      }
                      index += 2
                    }
                    return data
                  }

                  var dataAddRange = function(data, rangeStart, rangeEnd) {
                    if (rangeEnd < rangeStart) {
                      throw Error(ERRORS.rangeOrder)
                    }
                    if (
                      rangeStart < 0x0 ||
                      rangeStart > 0x10ffff ||
                      rangeEnd < 0x0 ||
                      rangeEnd > 0x10ffff
                    ) {
                      throw RangeError(ERRORS.codePointRange)
                    }
                    // Iterate over the data per `(start, end)` pair.
                    var index = 0
                    var start
                    var end
                    var added = false
                    var length = data.length
                    while (index < length) {
                      start = data[index]
                      end = data[index + 1]

                      if (added) {
                        // The range has already been added to the set; at this point, we just
                        // need to get rid of the following ranges in case they overlap.

                        // Check if this range can be combined with the previous range.
                        if (start == rangeEnd + 1) {
                          data.splice(index - 1, 2)
                          return data
                        }

                        // Exit as soon as no more possibly overlapping pairs can be found.
                        if (start > rangeEnd) {
                          return data
                        }

                        // E.g. `[0, 11, 12, 16]` and weve added 5-15, so we now have
                        // `[0, 16, 12, 16]`. Remove the `12,16` part, as it lies within the
                        // `0,16` range that was previously added.
                        if (start >= rangeStart && start <= rangeEnd) {
                          // `start` lies within the range that was previously added.

                          if (end > rangeStart && end - 1 <= rangeEnd) {
                            // `end` lies within the range that was previously added as well,
                            // so remove this pair.
                            data.splice(index, 2)
                            index -= 2
                            // Note: we cannot `return` just yet, as there may still be other
                            // overlapping pairs.
                          } else {
                            // `start` lies within the range that was previously added, but
                            // `end` doesnt. E.g. `[0, 11, 12, 31]` and weve added 5-15, so
                            // now we have `[0, 16, 12, 31]`. This must be written as `[0, 31]`.
                            // Remove the previously added `end` and the current `start`.
                            data.splice(index - 1, 2)
                            index -= 2
                          }

                          // Note: we cannot return yet.
                        }
                      } else if (start == rangeEnd + 1) {
                        data[index] = rangeStart
                        return data
                      } else if (start > rangeEnd) {
                        // Check if a new pair must be inserted *before* the current one.
                        data.splice(index, 0, rangeStart, rangeEnd + 1)
                        return data
                      } else if (
                        rangeStart >= start &&
                        rangeStart < end &&
                        rangeEnd + 1 <= end
                      ) {
                        // The new range lies entirely within an existing range pair. No action
                        // needed.
                        return data
                      } else if (
                        // E.g. `[0, 11]` and you add 5-15  `[0, 16]`.
                        (rangeStart >= start && rangeStart < end) ||
                        // E.g. `[0, 3]` and you add 3-6  `[0, 7]`.
                        end == rangeStart
                      ) {
                        // Replace `end` with the new value.
                        data[index + 1] = rangeEnd + 1
                        // Make sure the next range pair doesnt overlap, e.g. `[0, 11, 12, 14]`
                        // and you add 5-15  `[0, 16]`, i.e. remove the `12,14` part.
                        added = true
                        // Note: we cannot `return` just yet.
                      } else if (rangeStart <= start && rangeEnd + 1 >= end) {
                        // The new range is a superset of the old range.
                        data[index] = rangeStart
                        data[index + 1] = rangeEnd + 1
                        added = true
                      }

                      index += 2
                    }
                    // The loop has finished without doing anything; add the new pair to the end
                    // of the data set.
                    if (!added) {
                      data.push(rangeStart, rangeEnd + 1)
                    }
                    return data
                  }

                  var dataContains = function(data, codePoint) {
                    var index = 0
                    var length = data.length
                    // Exit early if `codePoint` is not within `data`s overall range.
                    var start = data[index]
                    var end = data[length - 1]
                    if (length >= 2) {
                      if (codePoint < start || codePoint > end) {
                        return false
                      }
                    }
                    // Iterate over the data per `(start, end)` pair.
                    while (index < length) {
                      start = data[index]
                      end = data[index + 1]
                      if (codePoint >= start && codePoint < end) {
                        return true
                      }
                      index += 2
                    }
                    return false
                  }

                  var dataIntersection = function(data, codePoints) {
                    var index = 0
                    var length = codePoints.length
                    var codePoint
                    var result = []
                    while (index < length) {
                      codePoint = codePoints[index]
                      if (dataContains(data, codePoint)) {
                        result.push(codePoint)
                      }
                      ++index
                    }
                    return dataFromCodePoints(result)
                  }

                  var dataIsEmpty = function(data) {
                    return !data.length
                  }

                  var dataIsSingleton = function(data) {
                    // Check if the set only represents a single code point.
                    return data.length == 2 && data[0] + 1 == data[1]
                  }

                  var dataToArray = function(data) {
                    // Iterate over the data per `(start, end)` pair.
                    var index = 0
                    var start
                    var end
                    var result = []
                    var length = data.length
                    while (index < length) {
                      start = data[index]
                      end = data[index + 1]
                      while (start < end) {
                        result.push(start)
                        ++start
                      }
                      index += 2
                    }
                    return result
                  }

                  /*--------------------------------------------------------------------------*/

                  // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
                  var floor = Math.floor
                  var highSurrogate = function(codePoint) {
                    return parseInt(
                      floor((codePoint - 0x10000) / 0x400) + HIGH_SURROGATE_MIN,
                      10
                    )
                  }

                  var lowSurrogate = function(codePoint) {
                    return parseInt(
                      (codePoint - 0x10000) % 0x400 + LOW_SURROGATE_MIN,
                      10
                    )
                  }

                  var stringFromCharCode = String.fromCharCode
                  var codePointToString = function(codePoint) {
                    var string
                    // https://mathiasbynens.be/notes/javascript-escapes#single
                    // Note: the `\b` escape sequence for U+0008 BACKSPACE in strings has a
                    // different meaning in regular expressions (word boundary), so it cannot
                    // be used here.
                    if (codePoint == 0x09) {
                      string = '\\t'
                    } else if (codePoint == 0x0a) {
                      // Note: IE < 9 treats `'\v'` as `'v'`, so avoid using it.
                      // else if (codePoint == 0x0B) {
                      // 	string = '\\v';
                      // }
                      string = '\\n'
                    } else if (codePoint == 0x0c) {
                      string = '\\f'
                    } else if (codePoint == 0x0d) {
                      string = '\\r'
                    } else if (codePoint == 0x5c) {
                      string = '\\\\'
                    } else if (
                      codePoint == 0x24 ||
                      (codePoint >= 0x28 && codePoint <= 0x2b) ||
                      codePoint == 0x2d ||
                      codePoint == 0x2e ||
                      codePoint == 0x3f ||
                      (codePoint >= 0x5b && codePoint <= 0x5e) ||
                      (codePoint >= 0x7b && codePoint <= 0x7d)
                    ) {
                      // The code point maps to an unsafe printable ASCII character;
                      // backslash-escape it. Heres the list of those symbols:
                      //
                      //     $()*+-.?[\]^{|}
                      //
                      // See #7 for more info.
                      string = '\\' + stringFromCharCode(codePoint)
                    } else if (codePoint >= 0x20 && codePoint <= 0x7e) {
                      // The code point maps to one of these printable ASCII symbols
                      // (including the space character):
                      //
                      //      !"#%&',/0123456789:;<=>@ABCDEFGHIJKLMNO
                      //     PQRSTUVWXYZ_`abcdefghijklmnopqrstuvwxyz~
                      //
                      // These can safely be used directly.
                      string = stringFromCharCode(codePoint)
                    } else if (codePoint <= 0xff) {
                      // https://mathiasbynens.be/notes/javascript-escapes#hexadecimal
                      string = '\\x' + pad(hex(codePoint), 2)
                    } else {
                      // `codePoint <= 0xFFFF` holds true.
                      // https://mathiasbynens.be/notes/javascript-escapes#unicode
                      string = '\\u' + pad(hex(codePoint), 4)
                    }

                    // Theres no need to account for astral symbols / surrogate pairs here,
                    // since `codePointToString` is private and only used for BMP code points.
                    // But if thats what you need, just add an `else` block with this code:
                    //
                    //     string = '\\u' + pad(hex(highSurrogate(codePoint)), 4)
                    //     	+ '\\u' + pad(hex(lowSurrogate(codePoint)), 4);

                    return string
                  }

                  var codePointToStringUnicode = function(codePoint) {
                    if (codePoint <= 0xffff) {
                      return codePointToString(codePoint)
                    }
                    return '\\u{' + codePoint.toString(16).toUpperCase() + '}'
                  }

                  var symbolToCodePoint = function(symbol) {
                    var length = symbol.length
                    var first = symbol.charCodeAt(0)
                    var second
                    if (
                      first >= HIGH_SURROGATE_MIN &&
                      first <= HIGH_SURROGATE_MAX &&
                      length > 1 // There is a next code unit.
                    ) {
                      // `first` is a high surrogate, and there is a next character. Assume
                      // its a low surrogate (else its invalid usage of Regenerate anyway).
                      second = symbol.charCodeAt(1)
                      // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
                      return (
                        (first - HIGH_SURROGATE_MIN) * 0x400 +
                        second -
                        LOW_SURROGATE_MIN +
                        0x10000
                      )
                    }
                    return first
                  }

                  var createBMPCharacterClasses = function(data) {
                    // Iterate over the data per `(start, end)` pair.
                    var result = ''
                    var index = 0
                    var start
                    var end
                    var length = data.length
                    if (dataIsSingleton(data)) {
                      return codePointToString(data[0])
                    }
                    while (index < length) {
                      start = data[index]
                      end = data[index + 1] - 1 // Note: the `- 1` makes `end` inclusive.
                      if (start == end) {
                        result += codePointToString(start)
                      } else if (start + 1 == end) {
                        result +=
                          codePointToString(start) + codePointToString(end)
                      } else {
                        result +=
                          codePointToString(start) +
                          '-' +
                          codePointToString(end)
                      }
                      index += 2
                    }
                    return '[' + result + ']'
                  }

                  var createUnicodeCharacterClasses = function(data) {
                    // Iterate over the data per `(start, end)` pair.
                    var result = ''
                    var index = 0
                    var start
                    var end
                    var length = data.length
                    if (dataIsSingleton(data)) {
                      return codePointToStringUnicode(data[0])
                    }
                    while (index < length) {
                      start = data[index]
                      end = data[index + 1] - 1 // Note: the `- 1` makes `end` inclusive.
                      if (start == end) {
                        result += codePointToStringUnicode(start)
                      } else if (start + 1 == end) {
                        result +=
                          codePointToStringUnicode(start) +
                          codePointToStringUnicode(end)
                      } else {
                        result +=
                          codePointToStringUnicode(start) +
                          '-' +
                          codePointToStringUnicode(end)
                      }
                      index += 2
                    }
                    return '[' + result + ']'
                  }

                  var splitAtBMP = function(data) {
                    // Iterate over the data per `(start, end)` pair.
                    var loneHighSurrogates = []
                    var loneLowSurrogates = []
                    var bmp = []
                    var astral = []
                    var index = 0
                    var start
                    var end
                    var length = data.length
                    while (index < length) {
                      start = data[index]
                      end = data[index + 1] - 1 // Note: the `- 1` makes `end` inclusive.

                      if (start < HIGH_SURROGATE_MIN) {
                        // The range starts and ends before the high surrogate range.
                        // E.g. (0, 0x10).
                        if (end < HIGH_SURROGATE_MIN) {
                          bmp.push(start, end + 1)
                        }

                        // The range starts before the high surrogate range and ends within it.
                        // E.g. (0, 0xD855).
                        if (
                          end >= HIGH_SURROGATE_MIN &&
                          end <= HIGH_SURROGATE_MAX
                        ) {
                          bmp.push(start, HIGH_SURROGATE_MIN)
                          loneHighSurrogates.push(HIGH_SURROGATE_MIN, end + 1)
                        }

                        // The range starts before the high surrogate range and ends in the low
                        // surrogate range. E.g. (0, 0xDCFF).
                        if (
                          end >= LOW_SURROGATE_MIN &&
                          end <= LOW_SURROGATE_MAX
                        ) {
                          bmp.push(start, HIGH_SURROGATE_MIN)
                          loneHighSurrogates.push(
                            HIGH_SURROGATE_MIN,
                            HIGH_SURROGATE_MAX + 1
                          )
                          loneLowSurrogates.push(LOW_SURROGATE_MIN, end + 1)
                        }

                        // The range starts before the high surrogate range and ends after the
                        // low surrogate range. E.g. (0, 0x10FFFF).
                        if (end > LOW_SURROGATE_MAX) {
                          bmp.push(start, HIGH_SURROGATE_MIN)
                          loneHighSurrogates.push(
                            HIGH_SURROGATE_MIN,
                            HIGH_SURROGATE_MAX + 1
                          )
                          loneLowSurrogates.push(
                            LOW_SURROGATE_MIN,
                            LOW_SURROGATE_MAX + 1
                          )
                          if (end <= 0xffff) {
                            bmp.push(LOW_SURROGATE_MAX + 1, end + 1)
                          } else {
                            bmp.push(LOW_SURROGATE_MAX + 1, 0xffff + 1)
                            astral.push(0xffff + 1, end + 1)
                          }
                        }
                      } else if (
                        start >= HIGH_SURROGATE_MIN &&
                        start <= HIGH_SURROGATE_MAX
                      ) {
                        // The range starts and ends in the high surrogate range.
                        // E.g. (0xD855, 0xD866).
                        if (
                          end >= HIGH_SURROGATE_MIN &&
                          end <= HIGH_SURROGATE_MAX
                        ) {
                          loneHighSurrogates.push(start, end + 1)
                        }

                        // The range starts in the high surrogate range and ends in the low
                        // surrogate range. E.g. (0xD855, 0xDCFF).
                        if (
                          end >= LOW_SURROGATE_MIN &&
                          end <= LOW_SURROGATE_MAX
                        ) {
                          loneHighSurrogates.push(start, HIGH_SURROGATE_MAX + 1)
                          loneLowSurrogates.push(LOW_SURROGATE_MIN, end + 1)
                        }

                        // The range starts in the high surrogate range and ends after the low
                        // surrogate range. E.g. (0xD855, 0x10FFFF).
                        if (end > LOW_SURROGATE_MAX) {
                          loneHighSurrogates.push(start, HIGH_SURROGATE_MAX + 1)
                          loneLowSurrogates.push(
                            LOW_SURROGATE_MIN,
                            LOW_SURROGATE_MAX + 1
                          )
                          if (end <= 0xffff) {
                            bmp.push(LOW_SURROGATE_MAX + 1, end + 1)
                          } else {
                            bmp.push(LOW_SURROGATE_MAX + 1, 0xffff + 1)
                            astral.push(0xffff + 1, end + 1)
                          }
                        }
                      } else if (
                        start >= LOW_SURROGATE_MIN &&
                        start <= LOW_SURROGATE_MAX
                      ) {
                        // The range starts and ends in the low surrogate range.
                        // E.g. (0xDCFF, 0xDDFF).
                        if (
                          end >= LOW_SURROGATE_MIN &&
                          end <= LOW_SURROGATE_MAX
                        ) {
                          loneLowSurrogates.push(start, end + 1)
                        }

                        // The range starts in the low surrogate range and ends after the low
                        // surrogate range. E.g. (0xDCFF, 0x10FFFF).
                        if (end > LOW_SURROGATE_MAX) {
                          loneLowSurrogates.push(start, LOW_SURROGATE_MAX + 1)
                          if (end <= 0xffff) {
                            bmp.push(LOW_SURROGATE_MAX + 1, end + 1)
                          } else {
                            bmp.push(LOW_SURROGATE_MAX + 1, 0xffff + 1)
                            astral.push(0xffff + 1, end + 1)
                          }
                        }
                      } else if (start > LOW_SURROGATE_MAX && start <= 0xffff) {
                        // The range starts and ends after the low surrogate range.
                        // E.g. (0xFFAA, 0x10FFFF).
                        if (end <= 0xffff) {
                          bmp.push(start, end + 1)
                        } else {
                          bmp.push(start, 0xffff + 1)
                          astral.push(0xffff + 1, end + 1)
                        }
                      } else {
                        // The range starts and ends in the astral range.
                        astral.push(start, end + 1)
                      }

                      index += 2
                    }
                    return {
                      loneHighSurrogates: loneHighSurrogates,
                      loneLowSurrogates: loneLowSurrogates,
                      bmp: bmp,
                      astral: astral,
                    }
                  }

                  var optimizeSurrogateMappings = function(surrogateMappings) {
                    var result = []
                    var tmpLow = []
                    var addLow = false
                    var mapping
                    var nextMapping
                    var highSurrogates
                    var lowSurrogates
                    var nextHighSurrogates
                    var nextLowSurrogates
                    var index = -1
                    var length = surrogateMappings.length
                    while (++index < length) {
                      mapping = surrogateMappings[index]
                      nextMapping = surrogateMappings[index + 1]
                      if (!nextMapping) {
                        result.push(mapping)
                        continue
                      }
                      highSurrogates = mapping[0]
                      lowSurrogates = mapping[1]
                      nextHighSurrogates = nextMapping[0]
                      nextLowSurrogates = nextMapping[1]

                      // Check for identical high surrogate ranges.
                      tmpLow = lowSurrogates
                      while (
                        nextHighSurrogates &&
                        highSurrogates[0] == nextHighSurrogates[0] &&
                        highSurrogates[1] == nextHighSurrogates[1]
                      ) {
                        // Merge with the next item.
                        if (dataIsSingleton(nextLowSurrogates)) {
                          tmpLow = dataAdd(tmpLow, nextLowSurrogates[0])
                        } else {
                          tmpLow = dataAddRange(
                            tmpLow,
                            nextLowSurrogates[0],
                            nextLowSurrogates[1] - 1
                          )
                        }
                        ++index
                        mapping = surrogateMappings[index]
                        highSurrogates = mapping[0]
                        lowSurrogates = mapping[1]
                        nextMapping = surrogateMappings[index + 1]
                        nextHighSurrogates = nextMapping && nextMapping[0]
                        nextLowSurrogates = nextMapping && nextMapping[1]
                        addLow = true
                      }
                      result.push([
                        highSurrogates,
                        addLow ? tmpLow : lowSurrogates,
                      ])
                      addLow = false
                    }
                    return optimizeByLowSurrogates(result)
                  }

                  var optimizeByLowSurrogates = function(surrogateMappings) {
                    if (surrogateMappings.length == 1) {
                      return surrogateMappings
                    }
                    var index = -1
                    var innerIndex = -1
                    while (++index < surrogateMappings.length) {
                      var mapping = surrogateMappings[index]
                      var lowSurrogates = mapping[1]
                      var lowSurrogateStart = lowSurrogates[0]
                      var lowSurrogateEnd = lowSurrogates[1]
                      innerIndex = index // Note: the loop starts at the next index.
                      while (++innerIndex < surrogateMappings.length) {
                        var otherMapping = surrogateMappings[innerIndex]
                        var otherLowSurrogates = otherMapping[1]
                        var otherLowSurrogateStart = otherLowSurrogates[0]
                        var otherLowSurrogateEnd = otherLowSurrogates[1]
                        if (
                          lowSurrogateStart == otherLowSurrogateStart &&
                          lowSurrogateEnd == otherLowSurrogateEnd
                        ) {
                          // Add the code points in the other item to this one.
                          if (dataIsSingleton(otherMapping[0])) {
                            mapping[0] = dataAdd(mapping[0], otherMapping[0][0])
                          } else {
                            mapping[0] = dataAddRange(
                              mapping[0],
                              otherMapping[0][0],
                              otherMapping[0][1] - 1
                            )
                          }
                          // Remove the other, now redundant, item.
                          surrogateMappings.splice(innerIndex, 1)
                          --innerIndex
                        }
                      }
                    }
                    return surrogateMappings
                  }

                  var surrogateSet = function(data) {
                    // Exit early if `data` is an empty set.
                    if (!data.length) {
                      return []
                    }

                    // Iterate over the data per `(start, end)` pair.
                    var index = 0
                    var start
                    var end
                    var startHigh
                    var startLow
                    var prevStartHigh = 0
                    var prevEndHigh = 0
                    var tmpLow = []
                    var endHigh
                    var endLow
                    var surrogateMappings = []
                    var length = data.length
                    var dataHigh = []
                    while (index < length) {
                      start = data[index]
                      end = data[index + 1] - 1

                      startHigh = highSurrogate(start)
                      startLow = lowSurrogate(start)
                      endHigh = highSurrogate(end)
                      endLow = lowSurrogate(end)

                      var startsWithLowestLowSurrogate =
                        startLow == LOW_SURROGATE_MIN
                      var endsWithHighestLowSurrogate =
                        endLow == LOW_SURROGATE_MAX
                      var complete = false

                      // Append the previous high-surrogate-to-low-surrogate mappings.
                      // Step 1: `(startHigh, startLow)` to `(startHigh, LOW_SURROGATE_MAX)`.
                      if (
                        startHigh == endHigh ||
                        (startsWithLowestLowSurrogate &&
                          endsWithHighestLowSurrogate)
                      ) {
                        surrogateMappings.push([
                          [startHigh, endHigh + 1],
                          [startLow, endLow + 1],
                        ])
                        complete = true
                      } else {
                        surrogateMappings.push([
                          [startHigh, startHigh + 1],
                          [startLow, LOW_SURROGATE_MAX + 1],
                        ])
                      }

                      // Step 2: `(startHigh + 1, LOW_SURROGATE_MIN)` to
                      // `(endHigh - 1, LOW_SURROGATE_MAX)`.
                      if (!complete && startHigh + 1 < endHigh) {
                        if (endsWithHighestLowSurrogate) {
                          // Combine step 2 and step 3.
                          surrogateMappings.push([
                            [startHigh + 1, endHigh + 1],
                            [LOW_SURROGATE_MIN, endLow + 1],
                          ])
                          complete = true
                        } else {
                          surrogateMappings.push([
                            [startHigh + 1, endHigh],
                            [LOW_SURROGATE_MIN, LOW_SURROGATE_MAX + 1],
                          ])
                        }
                      }

                      // Step 3. `(endHigh, LOW_SURROGATE_MIN)` to `(endHigh, endLow)`.
                      if (!complete) {
                        surrogateMappings.push([
                          [endHigh, endHigh + 1],
                          [LOW_SURROGATE_MIN, endLow + 1],
                        ])
                      }

                      prevStartHigh = startHigh
                      prevEndHigh = endHigh

                      index += 2
                    }

                    // The format of `surrogateMappings` is as follows:
                    //
                    //     [ surrogateMapping1, surrogateMapping2 ]
                    //
                    // i.e.:
                    //
                    //     [
                    //       [ highSurrogates1, lowSurrogates1 ],
                    //       [ highSurrogates2, lowSurrogates2 ]
                    //     ]
                    return optimizeSurrogateMappings(surrogateMappings)
                  }

                  var createSurrogateCharacterClasses = function(
                    surrogateMappings
                  ) {
                    var result = []
                    forEach(surrogateMappings, function(surrogateMapping) {
                      var highSurrogates = surrogateMapping[0]
                      var lowSurrogates = surrogateMapping[1]
                      result.push(
                        createBMPCharacterClasses(highSurrogates) +
                          createBMPCharacterClasses(lowSurrogates)
                      )
                    })
                    return result.join('|')
                  }

                  var createCharacterClassesFromData = function(
                    data,
                    bmpOnly,
                    hasUnicodeFlag
                  ) {
                    if (hasUnicodeFlag) {
                      return createUnicodeCharacterClasses(data)
                    }
                    var result = []

                    var parts = splitAtBMP(data)
                    var loneHighSurrogates = parts.loneHighSurrogates
                    var loneLowSurrogates = parts.loneLowSurrogates
                    var bmp = parts.bmp
                    var astral = parts.astral
                    var hasAstral = !dataIsEmpty(parts.astral)
                    var hasLoneHighSurrogates = !dataIsEmpty(loneHighSurrogates)
                    var hasLoneLowSurrogates = !dataIsEmpty(loneLowSurrogates)

                    var surrogateMappings = surrogateSet(astral)

                    if (bmpOnly) {
                      bmp = dataAddData(bmp, loneHighSurrogates)
                      hasLoneHighSurrogates = false
                      bmp = dataAddData(bmp, loneLowSurrogates)
                      hasLoneLowSurrogates = false
                    }

                    if (!dataIsEmpty(bmp)) {
                      // The data set contains BMP code points that are not high surrogates
                      // needed for astral code points in the set.
                      result.push(createBMPCharacterClasses(bmp))
                    }
                    if (surrogateMappings.length) {
                      // The data set contains astral code points; append character classes
                      // based on their surrogate pairs.
                      result.push(
                        createSurrogateCharacterClasses(surrogateMappings)
                      )
                    }
                    // https://gist.github.com/mathiasbynens/bbe7f870208abcfec860
                    if (hasLoneHighSurrogates) {
                      result.push(
                        createBMPCharacterClasses(loneHighSurrogates) +
                          // Make sure the high surrogates arent part of a surrogate pair.
                          '(?![\\uDC00-\\uDFFF])'
                      )
                    }
                    if (hasLoneLowSurrogates) {
                      result.push(
                        // It is not possible to accurately assert the low surrogates arent
                        // part of a surrogate pair, since JavaScript regular expressions do
                        // not support lookbehind.
                        '(?:[^\\uD800-\\uDBFF]|^)' +
                          createBMPCharacterClasses(loneLowSurrogates)
                      )
                    }
                    return result.join('|')
                  }

                  /*--------------------------------------------------------------------------*/

                  // `regenerate` can be used as a constructor (and new methods can be added to
                  // its prototype) but also as a regular function, the latter of which is the
                  // documented and most common usage. For that reason, its not capitalized.
                  var regenerate = function(value) {
                    if (arguments.length > 1) {
                      value = slice.call(arguments)
                    }
                    if (this instanceof regenerate) {
                      this.data = []
                      return value ? this.add(value) : this
                    }
                    return new regenerate().add(value)
                  }

                  regenerate.version = '1.3.1'

                  var proto = regenerate.prototype
                  extend(proto, {
                    add: function(value) {
                      var $this = this
                      if (value == null) {
                        return $this
                      }
                      if (value instanceof regenerate) {
                        // Allow passing other Regenerate instances.
                        $this.data = dataAddData($this.data, value.data)
                        return $this
                      }
                      if (arguments.length > 1) {
                        value = slice.call(arguments)
                      }
                      if (isArray(value)) {
                        forEach(value, function(item) {
                          $this.add(item)
                        })
                        return $this
                      }
                      $this.data = dataAdd(
                        $this.data,
                        isNumber(value) ? value : symbolToCodePoint(value)
                      )
                      return $this
                    },
                    remove: function(value) {
                      var $this = this
                      if (value == null) {
                        return $this
                      }
                      if (value instanceof regenerate) {
                        // Allow passing other Regenerate instances.
                        $this.data = dataRemoveData($this.data, value.data)
                        return $this
                      }
                      if (arguments.length > 1) {
                        value = slice.call(arguments)
                      }
                      if (isArray(value)) {
                        forEach(value, function(item) {
                          $this.remove(item)
                        })
                        return $this
                      }
                      $this.data = dataRemove(
                        $this.data,
                        isNumber(value) ? value : symbolToCodePoint(value)
                      )
                      return $this
                    },
                    addRange: function(start, end) {
                      var $this = this
                      $this.data = dataAddRange(
                        $this.data,
                        isNumber(start) ? start : symbolToCodePoint(start),
                        isNumber(end) ? end : symbolToCodePoint(end)
                      )
                      return $this
                    },
                    removeRange: function(start, end) {
                      var $this = this
                      var startCodePoint = isNumber(start)
                        ? start
                        : symbolToCodePoint(start)
                      var endCodePoint = isNumber(end)
                        ? end
                        : symbolToCodePoint(end)
                      $this.data = dataRemoveRange(
                        $this.data,
                        startCodePoint,
                        endCodePoint
                      )
                      return $this
                    },
                    intersection: function(argument) {
                      var $this = this
                      // Allow passing other Regenerate instances.
                      // TODO: Optimize this by writing and using `dataIntersectionData()`.
                      var array = argument instanceof regenerate
                        ? dataToArray(argument.data)
                        : argument
                      $this.data = dataIntersection($this.data, array)
                      return $this
                    },
                    contains: function(codePoint) {
                      return dataContains(
                        this.data,
                        isNumber(codePoint)
                          ? codePoint
                          : symbolToCodePoint(codePoint)
                      )
                    },
                    clone: function() {
                      var set = new regenerate()
                      set.data = this.data.slice(0)
                      return set
                    },
                    toString: function(options) {
                      var result = createCharacterClassesFromData(
                        this.data,
                        options ? options.bmpOnly : false,
                        options ? options.hasUnicodeFlag : false
                      )
                      if (!result) {
                        // For an empty set, return something that can be inserted `/here/` to
                        // form a valid regular expression. Avoid `(?:)` since that matches the
                        // empty string.
                        return '[]'
                      }
                      // Use `\0` instead of `\x00` where possible.
                      return result.replace(regexNull, '\\0$1')
                    },
                    toRegExp: function(flags) {
                      var pattern = this.toString(
                        flags && flags.indexOf('u') != -1
                          ? { hasUnicodeFlag: true }
                          : null
                      )
                      return RegExp(pattern, flags || '')
                    },
                    valueOf: function() {
                      // Note: `valueOf` is aliased as `toArray`.
                      return dataToArray(this.data)
                    },
                  })

                  proto.toArray = proto.valueOf

                  // Some AMD build optimizers, like r.js, check for specific condition patterns
                  // like the following:
                  if (
                    typeof define == 'function' &&
                    typeof define.amd == 'object' &&
                    define.amd
                  ) {
                    define(function() {
                      return regenerate
                    })
                  } else if (freeExports && !freeExports.nodeType) {
                    if (freeModule) {
                      // in Node.js, io.js, or RingoJS v0.8.0+
                      freeModule.exports = regenerate
                    } else {
                      // in Narwhal or RingoJS v0.7.0-
                      freeExports.regenerate = regenerate
                    }
                  } else {
                    // in Rhino or a web browser
                    root.regenerate = regenerate
                  }
                })(__commonjs_global)
              })

              var require$$0$2 = regenerate &&
                typeof regenerate === 'object' &&
                'default' in regenerate
                ? regenerate['default']
                : regenerate

              var characterClassEscapeSets = __commonjs(function(
                module,
                exports
              ) {
                // Generated by `/scripts/character-class-escape-sets.js`. Do not edit.
                var regenerate = require$$0$2

                exports.REGULAR = {
                  d: regenerate().addRange(0x30, 0x39),
                  D: regenerate().addRange(0x0, 0x2f).addRange(0x3a, 0xffff),
                  s: regenerate(
                    0x20,
                    0xa0,
                    0x1680,
                    0x202f,
                    0x205f,
                    0x3000,
                    0xfeff
                  )
                    .addRange(0x9, 0xd)
                    .addRange(0x2000, 0x200a)
                    .addRange(0x2028, 0x2029),
                  S: regenerate()
                    .addRange(0x0, 0x8)
                    .addRange(0xe, 0x1f)
                    .addRange(0x21, 0x9f)
                    .addRange(0xa1, 0x167f)
                    .addRange(0x1681, 0x1fff)
                    .addRange(0x200b, 0x2027)
                    .addRange(0x202a, 0x202e)
                    .addRange(0x2030, 0x205e)
                    .addRange(0x2060, 0x2fff)
                    .addRange(0x3001, 0xfefe)
                    .addRange(0xff00, 0xffff),
                  w: regenerate(0x5f)
                    .addRange(0x30, 0x39)
                    .addRange(0x41, 0x5a)
                    .addRange(0x61, 0x7a),
                  W: regenerate(0x60)
                    .addRange(0x0, 0x2f)
                    .addRange(0x3a, 0x40)
                    .addRange(0x5b, 0x5e)
                    .addRange(0x7b, 0xffff),
                }

                exports.UNICODE = {
                  d: regenerate().addRange(0x30, 0x39),
                  D: regenerate().addRange(0x0, 0x2f).addRange(0x3a, 0x10ffff),
                  s: regenerate(
                    0x20,
                    0xa0,
                    0x1680,
                    0x202f,
                    0x205f,
                    0x3000,
                    0xfeff
                  )
                    .addRange(0x9, 0xd)
                    .addRange(0x2000, 0x200a)
                    .addRange(0x2028, 0x2029),
                  S: regenerate()
                    .addRange(0x0, 0x8)
                    .addRange(0xe, 0x1f)
                    .addRange(0x21, 0x9f)
                    .addRange(0xa1, 0x167f)
                    .addRange(0x1681, 0x1fff)
                    .addRange(0x200b, 0x2027)
                    .addRange(0x202a, 0x202e)
                    .addRange(0x2030, 0x205e)
                    .addRange(0x2060, 0x2fff)
                    .addRange(0x3001, 0xfefe)
                    .addRange(0xff00, 0x10ffff),
                  w: regenerate(0x5f)
                    .addRange(0x30, 0x39)
                    .addRange(0x41, 0x5a)
                    .addRange(0x61, 0x7a),
                  W: regenerate(0x60)
                    .addRange(0x0, 0x2f)
                    .addRange(0x3a, 0x40)
                    .addRange(0x5b, 0x5e)
                    .addRange(0x7b, 0x10ffff),
                }

                exports.UNICODE_IGNORE_CASE = {
                  d: regenerate().addRange(0x30, 0x39),
                  D: regenerate().addRange(0x0, 0x2f).addRange(0x3a, 0x10ffff),
                  s: regenerate(
                    0x20,
                    0xa0,
                    0x1680,
                    0x202f,
                    0x205f,
                    0x3000,
                    0xfeff
                  )
                    .addRange(0x9, 0xd)
                    .addRange(0x2000, 0x200a)
                    .addRange(0x2028, 0x2029),
                  S: regenerate()
                    .addRange(0x0, 0x8)
                    .addRange(0xe, 0x1f)
                    .addRange(0x21, 0x9f)
                    .addRange(0xa1, 0x167f)
                    .addRange(0x1681, 0x1fff)
                    .addRange(0x200b, 0x2027)
                    .addRange(0x202a, 0x202e)
                    .addRange(0x2030, 0x205e)
                    .addRange(0x2060, 0x2fff)
                    .addRange(0x3001, 0xfefe)
                    .addRange(0xff00, 0x10ffff),
                  w: regenerate(0x5f, 0x17f, 0x212a)
                    .addRange(0x30, 0x39)
                    .addRange(0x41, 0x5a)
                    .addRange(0x61, 0x7a),
                  W: regenerate(0x4b, 0x53, 0x60)
                    .addRange(0x0, 0x2f)
                    .addRange(0x3a, 0x40)
                    .addRange(0x5b, 0x5e)
                    .addRange(0x7b, 0x10ffff),
                }
              })

              var require$$0$1 = characterClassEscapeSets &&
                typeof characterClassEscapeSets === 'object' &&
                'default' in characterClassEscapeSets
                ? characterClassEscapeSets['default']
                : characterClassEscapeSets

              var require$$1 = {
                '75': 8490,
                '83': 383,
                '107': 8490,
                '115': 383,
                '181': 924,
                '197': 8491,
                '383': 83,
                '452': 453,
                '453': 452,
                '455': 456,
                '456': 455,
                '458': 459,
                '459': 458,
                '497': 498,
                '498': 497,
                '837': 8126,
                '914': 976,
                '917': 1013,
                '920': 1012,
                '921': 8126,
                '922': 1008,
                '924': 181,
                '928': 982,
                '929': 1009,
                '931': 962,
                '934': 981,
                '937': 8486,
                '962': 931,
                '976': 914,
                '977': 1012,
                '981': 934,
                '982': 928,
                '1008': 922,
                '1009': 929,
                '1012': [920, 977],
                '1013': 917,
                '7776': 7835,
                '7835': 7776,
                '8126': [837, 921],
                '8486': 937,
                '8490': 75,
                '8491': 197,
                '66560': 66600,
                '66561': 66601,
                '66562': 66602,
                '66563': 66603,
                '66564': 66604,
                '66565': 66605,
                '66566': 66606,
                '66567': 66607,
                '66568': 66608,
                '66569': 66609,
                '66570': 66610,
                '66571': 66611,
                '66572': 66612,
                '66573': 66613,
                '66574': 66614,
                '66575': 66615,
                '66576': 66616,
                '66577': 66617,
                '66578': 66618,
                '66579': 66619,
                '66580': 66620,
                '66581': 66621,
                '66582': 66622,
                '66583': 66623,
                '66584': 66624,
                '66585': 66625,
                '66586': 66626,
                '66587': 66627,
                '66588': 66628,
                '66589': 66629,
                '66590': 66630,
                '66591': 66631,
                '66592': 66632,
                '66593': 66633,
                '66594': 66634,
                '66595': 66635,
                '66596': 66636,
                '66597': 66637,
                '66598': 66638,
                '66599': 66639,
                '66600': 66560,
                '66601': 66561,
                '66602': 66562,
                '66603': 66563,
                '66604': 66564,
                '66605': 66565,
                '66606': 66566,
                '66607': 66567,
                '66608': 66568,
                '66609': 66569,
                '66610': 66570,
                '66611': 66571,
                '66612': 66572,
                '66613': 66573,
                '66614': 66574,
                '66615': 66575,
                '66616': 66576,
                '66617': 66577,
                '66618': 66578,
                '66619': 66579,
                '66620': 66580,
                '66621': 66581,
                '66622': 66582,
                '66623': 66583,
                '66624': 66584,
                '66625': 66585,
                '66626': 66586,
                '66627': 66587,
                '66628': 66588,
                '66629': 66589,
                '66630': 66590,
                '66631': 66591,
                '66632': 66592,
                '66633': 66593,
                '66634': 66594,
                '66635': 66595,
                '66636': 66596,
                '66637': 66597,
                '66638': 66598,
                '66639': 66599,
                '68736': 68800,
                '68737': 68801,
                '68738': 68802,
                '68739': 68803,
                '68740': 68804,
                '68741': 68805,
                '68742': 68806,
                '68743': 68807,
                '68744': 68808,
                '68745': 68809,
                '68746': 68810,
                '68747': 68811,
                '68748': 68812,
                '68749': 68813,
                '68750': 68814,
                '68751': 68815,
                '68752': 68816,
                '68753': 68817,
                '68754': 68818,
                '68755': 68819,
                '68756': 68820,
                '68757': 68821,
                '68758': 68822,
                '68759': 68823,
                '68760': 68824,
                '68761': 68825,
                '68762': 68826,
                '68763': 68827,
                '68764': 68828,
                '68765': 68829,
                '68766': 68830,
                '68767': 68831,
                '68768': 68832,
                '68769': 68833,
                '68770': 68834,
                '68771': 68835,
                '68772': 68836,
                '68773': 68837,
                '68774': 68838,
                '68775': 68839,
                '68776': 68840,
                '68777': 68841,
                '68778': 68842,
                '68779': 68843,
                '68780': 68844,
                '68781': 68845,
                '68782': 68846,
                '68783': 68847,
                '68784': 68848,
                '68785': 68849,
                '68786': 68850,
                '68800': 68736,
                '68801': 68737,
                '68802': 68738,
                '68803': 68739,
                '68804': 68740,
                '68805': 68741,
                '68806': 68742,
                '68807': 68743,
                '68808': 68744,
                '68809': 68745,
                '68810': 68746,
                '68811': 68747,
                '68812': 68748,
                '68813': 68749,
                '68814': 68750,
                '68815': 68751,
                '68816': 68752,
                '68817': 68753,
                '68818': 68754,
                '68819': 68755,
                '68820': 68756,
                '68821': 68757,
                '68822': 68758,
                '68823': 68759,
                '68824': 68760,
                '68825': 68761,
                '68826': 68762,
                '68827': 68763,
                '68828': 68764,
                '68829': 68765,
                '68830': 68766,
                '68831': 68767,
                '68832': 68768,
                '68833': 68769,
                '68834': 68770,
                '68835': 68771,
                '68836': 68772,
                '68837': 68773,
                '68838': 68774,
                '68839': 68775,
                '68840': 68776,
                '68841': 68777,
                '68842': 68778,
                '68843': 68779,
                '68844': 68780,
                '68845': 68781,
                '68846': 68782,
                '68847': 68783,
                '68848': 68784,
                '68849': 68785,
                '68850': 68786,
                '71840': 71872,
                '71841': 71873,
                '71842': 71874,
                '71843': 71875,
                '71844': 71876,
                '71845': 71877,
                '71846': 71878,
                '71847': 71879,
                '71848': 71880,
                '71849': 71881,
                '71850': 71882,
                '71851': 71883,
                '71852': 71884,
                '71853': 71885,
                '71854': 71886,
                '71855': 71887,
                '71856': 71888,
                '71857': 71889,
                '71858': 71890,
                '71859': 71891,
                '71860': 71892,
                '71861': 71893,
                '71862': 71894,
                '71863': 71895,
                '71864': 71896,
                '71865': 71897,
                '71866': 71898,
                '71867': 71899,
                '71868': 71900,
                '71869': 71901,
                '71870': 71902,
                '71871': 71903,
                '71872': 71840,
                '71873': 71841,
                '71874': 71842,
                '71875': 71843,
                '71876': 71844,
                '71877': 71845,
                '71878': 71846,
                '71879': 71847,
                '71880': 71848,
                '71881': 71849,
                '71882': 71850,
                '71883': 71851,
                '71884': 71852,
                '71885': 71853,
                '71886': 71854,
                '71887': 71855,
                '71888': 71856,
                '71889': 71857,
                '71890': 71858,
                '71891': 71859,
                '71892': 71860,
                '71893': 71861,
                '71894': 71862,
                '71895': 71863,
                '71896': 71864,
                '71897': 71865,
                '71898': 71866,
                '71899': 71867,
                '71900': 71868,
                '71901': 71869,
                '71902': 71870,
                '71903': 71871,
              }

              var parser = __commonjs(function(module) {
                // regjsparser
                //
                // ==================================================================
                //
                // See ECMA-262 Standard: 15.10.1
                //
                // NOTE: The ECMA-262 standard uses the term "Assertion" for /^/. Here the
                //   term "Anchor" is used.
                //
                // Pattern ::
                //      Disjunction
                //
                // Disjunction ::
                //      Alternative
                //      Alternative | Disjunction
                //
                // Alternative ::
                //      [empty]
                //      Alternative Term
                //
                // Term ::
                //      Anchor
                //      Atom
                //      Atom Quantifier
                //
                // Anchor ::
                //      ^
                //      $
                //      \ b
                //      \ B
                //      ( ? = Disjunction )
                //      ( ? ! Disjunction )
                //
                // Quantifier ::
                //      QuantifierPrefix
                //      QuantifierPrefix ?
                //
                // QuantifierPrefix ::
                //      *
                //      +
                //      ?
                //      { DecimalDigits }
                //      { DecimalDigits , }
                //      { DecimalDigits , DecimalDigits }
                //
                // Atom ::
                //      PatternCharacter
                //      .
                //      \ AtomEscape
                //      CharacterClass
                //      ( Disjunction )
                //      ( ? : Disjunction )
                //
                // PatternCharacter ::
                //      SourceCharacter but not any of: ^ $ \ . * + ? ( ) [ ] { } |
                //
                // AtomEscape ::
                //      DecimalEscape
                //      CharacterEscape
                //      CharacterClassEscape
                //
                // CharacterEscape[U] ::
                //      ControlEscape
                //      c ControlLetter
                //      HexEscapeSequence
                //      RegExpUnicodeEscapeSequence[?U] (ES6)
                //      IdentityEscape[?U]
                //
                // ControlEscape ::
                //      one of f n r t v
                // ControlLetter ::
                //      one of
                //          a b c d e f g h i j k l m n o p q r s t u v w x y z
                //          A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
                //
                // IdentityEscape ::
                //      SourceCharacter but not IdentifierPart
                //      <ZWJ>
                //      <ZWNJ>
                //
                // DecimalEscape ::
                //      DecimalIntegerLiteral [lookahead  DecimalDigit]
                //
                // CharacterClassEscape ::
                //      one of d D s S w W
                //
                // CharacterClass ::
                //      [ [lookahead  {^}] ClassRanges ]
                //      [ ^ ClassRanges ]
                //
                // ClassRanges ::
                //      [empty]
                //      NonemptyClassRanges
                //
                // NonemptyClassRanges ::
                //      ClassAtom
                //      ClassAtom NonemptyClassRangesNoDash
                //      ClassAtom - ClassAtom ClassRanges
                //
                // NonemptyClassRangesNoDash ::
                //      ClassAtom
                //      ClassAtomNoDash NonemptyClassRangesNoDash
                //      ClassAtomNoDash - ClassAtom ClassRanges
                //
                // ClassAtom ::
                //      -
                //      ClassAtomNoDash
                //
                // ClassAtomNoDash ::
                //      SourceCharacter but not one of \ or ] or -
                //      \ ClassEscape
                //
                // ClassEscape ::
                //      DecimalEscape
                //      b
                //      CharacterEscape
                //      CharacterClassEscape

                ;(function() {
                  function parse(str, flags) {
                    function addRaw(node) {
                      node.raw = str.substring(node.range[0], node.range[1])
                      return node
                    }

                    function updateRawStart(node, start) {
                      node.range[0] = start
                      return addRaw(node)
                    }

                    function createAnchor(kind, rawLength) {
                      return addRaw({
                        type: 'anchor',
                        kind: kind,
                        range: [pos - rawLength, pos],
                      })
                    }

                    function createValue(kind, codePoint, from, to) {
                      return addRaw({
                        type: 'value',
                        kind: kind,
                        codePoint: codePoint,
                        range: [from, to],
                      })
                    }

                    function createEscaped(kind, codePoint, value, fromOffset) {
                      fromOffset = fromOffset || 0
                      return createValue(
                        kind,
                        codePoint,
                        pos - (value.length + fromOffset),
                        pos
                      )
                    }

                    function createCharacter(matches) {
                      var _char = matches[0]
                      var first = _char.charCodeAt(0)
                      if (hasUnicodeFlag) {
                        var second
                        if (
                          _char.length === 1 &&
                          first >= 0xd800 &&
                          first <= 0xdbff
                        ) {
                          second = lookahead().charCodeAt(0)
                          if (second >= 0xdc00 && second <= 0xdfff) {
                            // Unicode surrogate pair
                            pos++
                            return createValue(
                              'symbol',
                              (first - 0xd800) * 0x400 +
                                second -
                                0xdc00 +
                                0x10000,
                              pos - 2,
                              pos
                            )
                          }
                        }
                      }
                      return createValue('symbol', first, pos - 1, pos)
                    }

                    function createDisjunction(alternatives, from, to) {
                      return addRaw({
                        type: 'disjunction',
                        body: alternatives,
                        range: [from, to],
                      })
                    }

                    function createDot() {
                      return addRaw({
                        type: 'dot',
                        range: [pos - 1, pos],
                      })
                    }

                    function createCharacterClassEscape(value) {
                      return addRaw({
                        type: 'characterClassEscape',
                        value: value,
                        range: [pos - 2, pos],
                      })
                    }

                    function createReference(matchIndex) {
                      return addRaw({
                        type: 'reference',
                        matchIndex: parseInt(matchIndex, 10),
                        range: [pos - 1 - matchIndex.length, pos],
                      })
                    }

                    function createGroup(behavior, disjunction, from, to) {
                      return addRaw({
                        type: 'group',
                        behavior: behavior,
                        body: disjunction,
                        range: [from, to],
                      })
                    }

                    function createQuantifier(min, max, from, to) {
                      if (to == null) {
                        from = pos - 1
                        to = pos
                      }

                      return addRaw({
                        type: 'quantifier',
                        min: min,
                        max: max,
                        greedy: true,
                        body: null, // set later on
                        range: [from, to],
                      })
                    }

                    function createAlternative(terms, from, to) {
                      return addRaw({
                        type: 'alternative',
                        body: terms,
                        range: [from, to],
                      })
                    }

                    function createCharacterClass(
                      classRanges,
                      negative,
                      from,
                      to
                    ) {
                      return addRaw({
                        type: 'characterClass',
                        body: classRanges,
                        negative: negative,
                        range: [from, to],
                      })
                    }

                    function createClassRange(min, max, from, to) {
                      // See 15.10.2.15:
                      if (min.codePoint > max.codePoint) {
                        bail(
                          'invalid range in character class',
                          min.raw + '-' + max.raw,
                          from,
                          to
                        )
                      }

                      return addRaw({
                        type: 'characterClassRange',
                        min: min,
                        max: max,
                        range: [from, to],
                      })
                    }

                    function flattenBody(body) {
                      if (body.type === 'alternative') {
                        return body.body
                      } else {
                        return [body]
                      }
                    }

                    function isEmpty(obj) {
                      return obj.type === 'empty'
                    }

                    function incr(amount) {
                      amount = amount || 1
                      var res = str.substring(pos, pos + amount)
                      pos += amount || 1
                      return res
                    }

                    function skip(value) {
                      if (!match(value)) {
                        bail('character', value)
                      }
                    }

                    function match(value) {
                      if (str.indexOf(value, pos) === pos) {
                        return incr(value.length)
                      }
                    }

                    function lookahead() {
                      return str[pos]
                    }

                    function current(value) {
                      return str.indexOf(value, pos) === pos
                    }

                    function next(value) {
                      return str[pos + 1] === value
                    }

                    function matchReg(regExp) {
                      var subStr = str.substring(pos)
                      var res = subStr.match(regExp)
                      if (res) {
                        res.range = []
                        res.range[0] = pos
                        incr(res[0].length)
                        res.range[1] = pos
                      }
                      return res
                    }

                    function parseDisjunction() {
                      // Disjunction ::
                      //      Alternative
                      //      Alternative | Disjunction
                      var res = [],
                        from = pos
                      res.push(parseAlternative())

                      while (match('|')) {
                        res.push(parseAlternative())
                      }

                      if (res.length === 1) {
                        return res[0]
                      }

                      return createDisjunction(res, from, pos)
                    }

                    function parseAlternative() {
                      var res = [],
                        from = pos
                      var term

                      // Alternative ::
                      //      [empty]
                      //      Alternative Term
                      while ((term = parseTerm())) {
                        res.push(term)
                      }

                      if (res.length === 1) {
                        return res[0]
                      }

                      return createAlternative(res, from, pos)
                    }

                    function parseTerm() {
                      // Term ::
                      //      Anchor
                      //      Atom
                      //      Atom Quantifier

                      if (pos >= str.length || current('|') || current(')')) {
                        return null /* Means: The term is empty */
                      }

                      var anchor = parseAnchor()

                      if (anchor) {
                        return anchor
                      }

                      var atom = parseAtom()
                      if (!atom) {
                        bail('Expected atom')
                      }
                      var quantifier = parseQuantifier() || false
                      if (quantifier) {
                        quantifier.body = flattenBody(atom)
                        // The quantifier contains the atom. Therefore, the beginning of the
                        // quantifier range is given by the beginning of the atom.
                        updateRawStart(quantifier, atom.range[0])
                        return quantifier
                      }
                      return atom
                    }

                    function parseGroup(matchA, typeA, matchB, typeB) {
                      var type = null,
                        from = pos

                      if (match(matchA)) {
                        type = typeA
                      } else if (match(matchB)) {
                        type = typeB
                      } else {
                        return false
                      }

                      var body = parseDisjunction()
                      if (!body) {
                        bail('Expected disjunction')
                      }
                      skip(')')
                      var group = createGroup(
                        type,
                        flattenBody(body),
                        from,
                        pos
                      )

                      if (type == 'normal') {
                        // Keep track of the number of closed groups. This is required for
                        // parseDecimalEscape(). In case the string is parsed a second time the
                        // value already holds the total count and no incrementation is required.
                        if (firstIteration) {
                          closedCaptureCounter++
                        }
                      }
                      return group
                    }

                    function parseAnchor() {
                      // Anchor ::
                      //      ^
                      //      $
                      //      \ b
                      //      \ B
                      //      ( ? = Disjunction )
                      //      ( ? ! Disjunction )
                      var res,
                        from = pos

                      if (match('^')) {
                        return createAnchor('start', 1 /* rawLength */)
                      } else if (match('$')) {
                        return createAnchor('end', 1 /* rawLength */)
                      } else if (match('\\b')) {
                        return createAnchor('boundary', 2 /* rawLength */)
                      } else if (match('\\B')) {
                        return createAnchor('not-boundary', 2 /* rawLength */)
                      } else {
                        return parseGroup(
                          '(?=',
                          'lookahead',
                          '(?!',
                          'negativeLookahead'
                        )
                      }
                    }

                    function parseQuantifier() {
                      // Quantifier ::
                      //      QuantifierPrefix
                      //      QuantifierPrefix ?
                      //
                      // QuantifierPrefix ::
                      //      *
                      //      +
                      //      ?
                      //      { DecimalDigits }
                      //      { DecimalDigits , }
                      //      { DecimalDigits , DecimalDigits }

                      var res,
                        from = pos
                      var quantifier
                      var min, max

                      if (match('*')) {
                        quantifier = createQuantifier(0)
                      } else if (match('+')) {
                        quantifier = createQuantifier(1)
                      } else if (match('?')) {
                        quantifier = createQuantifier(0, 1)
                      } else if ((res = matchReg(/^\{([0-9]+)\}/))) {
                        min = parseInt(res[1], 10)
                        quantifier = createQuantifier(
                          min,
                          min,
                          res.range[0],
                          res.range[1]
                        )
                      } else if ((res = matchReg(/^\{([0-9]+),\}/))) {
                        min = parseInt(res[1], 10)
                        quantifier = createQuantifier(
                          min,
                          undefined,
                          res.range[0],
                          res.range[1]
                        )
                      } else if ((res = matchReg(/^\{([0-9]+),([0-9]+)\}/))) {
                        min = parseInt(res[1], 10)
                        max = parseInt(res[2], 10)
                        if (min > max) {
                          bail(
                            'numbers out of order in {} quantifier',
                            '',
                            from,
                            pos
                          )
                        }
                        quantifier = createQuantifier(
                          min,
                          max,
                          res.range[0],
                          res.range[1]
                        )
                      }

                      if (quantifier) {
                        if (match('?')) {
                          quantifier.greedy = false
                          quantifier.range[1] += 1
                        }
                      }

                      return quantifier
                    }

                    function parseAtom() {
                      // Atom ::
                      //      PatternCharacter
                      //      .
                      //      \ AtomEscape
                      //      CharacterClass
                      //      ( Disjunction )
                      //      ( ? : Disjunction )

                      var res

                      // jviereck: allow ']', '}' here as well to be compatible with browser's
                      //   implementations: ']'.match(/]/);
                      // if (res = matchReg(/^[^^$\\.*+?()[\]{}|]/)) {
                      if ((res = matchReg(/^[^^$\\.*+?(){[|]/))) {
                        //      PatternCharacter
                        return createCharacter(res)
                      } else if (match('.')) {
                        //      .
                        return createDot()
                      } else if (match('\\')) {
                        //      \ AtomEscape
                        res = parseAtomEscape()
                        if (!res) {
                          bail('atomEscape')
                        }
                        return res
                      } else if ((res = parseCharacterClass())) {
                        return res
                      } else {
                        //      ( Disjunction )
                        //      ( ? : Disjunction )
                        return parseGroup('(?:', 'ignore', '(', 'normal')
                      }
                    }

                    function parseUnicodeSurrogatePairEscape(firstEscape) {
                      if (hasUnicodeFlag) {
                        var first, second
                        if (
                          firstEscape.kind == 'unicodeEscape' &&
                          (first = firstEscape.codePoint) >= 0xd800 &&
                          first <= 0xdbff &&
                          current('\\') &&
                          next('u')
                        ) {
                          var prevPos = pos
                          pos++
                          var secondEscape = parseClassEscape()
                          if (
                            secondEscape.kind == 'unicodeEscape' &&
                            (second = secondEscape.codePoint) >= 0xdc00 &&
                            second <= 0xdfff
                          ) {
                            // Unicode surrogate pair
                            firstEscape.range[1] = secondEscape.range[1]
                            firstEscape.codePoint =
                              (first - 0xd800) * 0x400 +
                              second -
                              0xdc00 +
                              0x10000
                            firstEscape.type = 'value'
                            firstEscape.kind = 'unicodeCodePointEscape'
                            addRaw(firstEscape)
                          } else {
                            pos = prevPos
                          }
                        }
                      }
                      return firstEscape
                    }

                    function parseClassEscape() {
                      return parseAtomEscape(true)
                    }

                    function parseAtomEscape(insideCharacterClass) {
                      // AtomEscape ::
                      //      DecimalEscape
                      //      CharacterEscape
                      //      CharacterClassEscape

                      var res,
                        from = pos

                      res = parseDecimalEscape()
                      if (res) {
                        return res
                      }

                      // For ClassEscape
                      if (insideCharacterClass) {
                        if (match('b')) {
                          // 15.10.2.19
                          // The production ClassEscape :: b evaluates by returning the
                          // CharSet containing the one character <BS> (Unicode value 0008).
                          return createEscaped('singleEscape', 0x0008, '\\b')
                        } else if (match('B')) {
                          bail(
                            '\\B not possible inside of CharacterClass',
                            '',
                            from
                          )
                        }
                      }

                      res = parseCharacterEscape()

                      return res
                    }

                    function parseDecimalEscape() {
                      // DecimalEscape ::
                      //      DecimalIntegerLiteral [lookahead  DecimalDigit]
                      //      CharacterClassEscape :: one of d D s S w W

                      var res, match

                      if ((res = matchReg(/^(?!0)\d+/))) {
                        match = res[0]
                        var refIdx = parseInt(res[0], 10)
                        if (refIdx <= closedCaptureCounter) {
                          // If the number is smaller than the normal-groups found so
                          // far, then it is a reference...
                          return createReference(res[0])
                        } else {
                          // ... otherwise it needs to be interpreted as a octal (if the
                          // number is in an octal format). If it is NOT octal format,
                          // then the slash is ignored and the number is matched later
                          // as normal characters.

                          // Recall the negative decision to decide if the input must be parsed
                          // a second time with the total normal-groups.
                          backrefDenied.push(refIdx)

                          // Reset the position again, as maybe only parts of the previous
                          // matched numbers are actual octal numbers. E.g. in '019' only
                          // the '01' should be matched.
                          incr(-res[0].length)
                          if ((res = matchReg(/^[0-7]{1,3}/))) {
                            return createEscaped(
                              'octal',
                              parseInt(res[0], 8),
                              res[0],
                              1
                            )
                          } else {
                            // If we end up here, we have a case like /\91/. Then the
                            // first slash is to be ignored and the 9 & 1 to be treated
                            // like ordinary characters. Create a character for the
                            // first number only here - other number-characters
                            // (if available) will be matched later.
                            res = createCharacter(matchReg(/^[89]/))
                            return updateRawStart(res, res.range[0] - 1)
                          }
                        }
                      } else if ((res = matchReg(/^[0-7]{1,3}/))) {
                        // Only allow octal numbers in the following. All matched numbers start
                        // with a zero (if the do not, the previous if-branch is executed).
                        // If the number is not octal format and starts with zero (e.g. `091`)
                        // then only the zeros `0` is treated here and the `91` are ordinary
                        // characters.
                        // Example:
                        //   /\091/.exec('\091')[0].length === 3
                        match = res[0]
                        if (/^0{1,3}$/.test(match)) {
                          // If they are all zeros, then only take the first one.
                          return createEscaped(
                            'null',
                            0x0000,
                            '0',
                            match.length + 1
                          )
                        } else {
                          return createEscaped(
                            'octal',
                            parseInt(match, 8),
                            match,
                            1
                          )
                        }
                      } else if ((res = matchReg(/^[dDsSwW]/))) {
                        return createCharacterClassEscape(res[0])
                      }
                      return false
                    }

                    function parseCharacterEscape() {
                      // CharacterEscape ::
                      //      ControlEscape
                      //      c ControlLetter
                      //      HexEscapeSequence
                      //      UnicodeEscapeSequence
                      //      IdentityEscape

                      var res
                      if ((res = matchReg(/^[fnrtv]/))) {
                        // ControlEscape
                        var codePoint = 0
                        switch (res[0]) {
                          case 't':
                            codePoint = 0x009
                            break
                          case 'n':
                            codePoint = 0x00a
                            break
                          case 'v':
                            codePoint = 0x00b
                            break
                          case 'f':
                            codePoint = 0x00c
                            break
                          case 'r':
                            codePoint = 0x00d
                            break
                        }
                        return createEscaped(
                          'singleEscape',
                          codePoint,
                          '\\' + res[0]
                        )
                      } else if ((res = matchReg(/^c([a-zA-Z])/))) {
                        // c ControlLetter
                        return createEscaped(
                          'controlLetter',
                          res[1].charCodeAt(0) % 32,
                          res[1],
                          2
                        )
                      } else if ((res = matchReg(/^x([0-9a-fA-F]{2})/))) {
                        // HexEscapeSequence
                        return createEscaped(
                          'hexadecimalEscape',
                          parseInt(res[1], 16),
                          res[1],
                          2
                        )
                      } else if ((res = matchReg(/^u([0-9a-fA-F]{4})/))) {
                        // UnicodeEscapeSequence
                        return parseUnicodeSurrogatePairEscape(
                          createEscaped(
                            'unicodeEscape',
                            parseInt(res[1], 16),
                            res[1],
                            2
                          )
                        )
                      } else if (
                        hasUnicodeFlag &&
                        (res = matchReg(/^u\{([0-9a-fA-F]+)\}/))
                      ) {
                        // RegExpUnicodeEscapeSequence (ES6 Unicode code point escape)
                        return createEscaped(
                          'unicodeCodePointEscape',
                          parseInt(res[1], 16),
                          res[1],
                          4
                        )
                      } else {
                        // IdentityEscape
                        return parseIdentityEscape()
                      }
                    }

                    // Taken from the Esprima parser.
                    function isIdentifierPart(ch) {
                      // Generated by `tools/generate-identifier-regex.js`.
                      var NonAsciiIdentifierPart = new RegExp(
                        '[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]'
                      )

                      return (
                        ch === 36 ||
                        ch === 95 || // $ (dollar) and _ (underscore)
                        (ch >= 65 && ch <= 90) || // A..Z
                        (ch >= 97 && ch <= 122) || // a..z
                        (ch >= 48 && ch <= 57) || // 0..9
                        ch === 92 || // \ (backslash)
                        (ch >= 0x80 &&
                          NonAsciiIdentifierPart.test(String.fromCharCode(ch)))
                      )
                    }

                    function parseIdentityEscape() {
                      // IdentityEscape ::
                      //      SourceCharacter but not IdentifierPart
                      //      <ZWJ>
                      //      <ZWNJ>

                      var ZWJ = '\u200C'
                      var ZWNJ = '\u200D'

                      var tmp

                      if (!isIdentifierPart(lookahead())) {
                        tmp = incr()
                        return createEscaped(
                          'identifier',
                          tmp.charCodeAt(0),
                          tmp,
                          1
                        )
                      }

                      if (match(ZWJ)) {
                        // <ZWJ>
                        return createEscaped('identifier', 0x200c, ZWJ)
                      } else if (match(ZWNJ)) {
                        // <ZWNJ>
                        return createEscaped('identifier', 0x200d, ZWNJ)
                      }

                      return null
                    }

                    function parseCharacterClass() {
                      // CharacterClass ::
                      //      [ [lookahead  {^}] ClassRanges ]
                      //      [ ^ ClassRanges ]

                      var res,
                        from = pos
                      if ((res = matchReg(/^\[\^/))) {
                        res = parseClassRanges()
                        skip(']')
                        return createCharacterClass(res, true, from, pos)
                      } else if (match('[')) {
                        res = parseClassRanges()
                        skip(']')
                        return createCharacterClass(res, false, from, pos)
                      }

                      return null
                    }

                    function parseClassRanges() {
                      // ClassRanges ::
                      //      [empty]
                      //      NonemptyClassRanges

                      var res
                      if (current(']')) {
                        // Empty array means nothing insinde of the ClassRange.
                        return []
                      } else {
                        res = parseNonemptyClassRanges()
                        if (!res) {
                          bail('nonEmptyClassRanges')
                        }
                        return res
                      }
                    }

                    function parseHelperClassRanges(atom) {
                      var from, to, res
                      if (current('-') && !next(']')) {
                        // ClassAtom - ClassAtom ClassRanges
                        skip('-')

                        res = parseClassAtom()
                        if (!res) {
                          bail('classAtom')
                        }
                        to = pos
                        var classRanges = parseClassRanges()
                        if (!classRanges) {
                          bail('classRanges')
                        }
                        from = atom.range[0]
                        if (classRanges.type === 'empty') {
                          return [createClassRange(atom, res, from, to)]
                        }
                        return [createClassRange(atom, res, from, to)].concat(
                          classRanges
                        )
                      }

                      res = parseNonemptyClassRangesNoDash()
                      if (!res) {
                        bail('nonEmptyClassRangesNoDash')
                      }

                      return [atom].concat(res)
                    }

                    function parseNonemptyClassRanges() {
                      // NonemptyClassRanges ::
                      //      ClassAtom
                      //      ClassAtom NonemptyClassRangesNoDash
                      //      ClassAtom - ClassAtom ClassRanges

                      var atom = parseClassAtom()
                      if (!atom) {
                        bail('classAtom')
                      }

                      if (current(']')) {
                        // ClassAtom
                        return [atom]
                      }

                      // ClassAtom NonemptyClassRangesNoDash
                      // ClassAtom - ClassAtom ClassRanges
                      return parseHelperClassRanges(atom)
                    }

                    function parseNonemptyClassRangesNoDash() {
                      // NonemptyClassRangesNoDash ::
                      //      ClassAtom
                      //      ClassAtomNoDash NonemptyClassRangesNoDash
                      //      ClassAtomNoDash - ClassAtom ClassRanges

                      var res = parseClassAtom()
                      if (!res) {
                        bail('classAtom')
                      }
                      if (current(']')) {
                        //      ClassAtom
                        return res
                      }

                      // ClassAtomNoDash NonemptyClassRangesNoDash
                      // ClassAtomNoDash - ClassAtom ClassRanges
                      return parseHelperClassRanges(res)
                    }

                    function parseClassAtom() {
                      // ClassAtom ::
                      //      -
                      //      ClassAtomNoDash
                      if (match('-')) {
                        return createCharacter('-')
                      } else {
                        return parseClassAtomNoDash()
                      }
                    }

                    function parseClassAtomNoDash() {
                      // ClassAtomNoDash ::
                      //      SourceCharacter but not one of \ or ] or -
                      //      \ ClassEscape

                      var res
                      if ((res = matchReg(/^[^\\\]-]/))) {
                        return createCharacter(res[0])
                      } else if (match('\\')) {
                        res = parseClassEscape()
                        if (!res) {
                          bail('classEscape')
                        }

                        return parseUnicodeSurrogatePairEscape(res)
                      }
                    }

                    function bail(message, details, from, to) {
                      from = from == null ? pos : from
                      to = to == null ? from : to

                      var contextStart = Math.max(0, from - 10)
                      var contextEnd = Math.min(to + 10, str.length)

                      // Output a bit of context and a line pointing to where our error is.
                      //
                      // We are assuming that there are no actual newlines in the content as this is a regular expression.
                      var context =
                        '    ' + str.substring(contextStart, contextEnd)
                      var pointer =
                        '    ' +
                        new Array(from - contextStart + 1).join(' ') +
                        '^'

                      throw SyntaxError(
                        message +
                          ' at position ' +
                          from +
                          (details ? ': ' + details : '') +
                          '\n' +
                          context +
                          '\n' +
                          pointer
                      )
                    }

                    var backrefDenied = []
                    var closedCaptureCounter = 0
                    var firstIteration = true
                    var hasUnicodeFlag = (flags || '').indexOf('u') !== -1
                    var pos = 0

                    // Convert the input to a string and treat the empty string special.
                    str = String(str)
                    if (str === '') {
                      str = '(?:)'
                    }

                    var result = parseDisjunction()

                    if (result.range[1] !== str.length) {
                      bail(
                        'Could not parse entire input - got stuck',
                        '',
                        result.range[1]
                      )
                    }

                    // The spec requires to interpret the `\2` in `/\2()()/` as backreference.
                    // As the parser collects the number of capture groups as the string is
                    // parsed it is impossible to make these decisions at the point when the
                    // `\2` is handled. In case the local decision turns out to be wrong after
                    // the parsing has finished, the input string is parsed a second time with
                    // the total number of capture groups set.
                    //
                    // SEE: https://github.com/jviereck/regjsparser/issues/70
                    for (var i = 0; i < backrefDenied.length; i++) {
                      if (backrefDenied[i] <= closedCaptureCounter) {
                        // Parse the input a second time.
                        pos = 0
                        firstIteration = false
                        return parseDisjunction()
                      }
                    }

                    return result
                  }

                  var regjsparser = {
                    parse: parse,
                  }

                  if (typeof module !== 'undefined' && module.exports) {
                    module.exports = regjsparser
                  } else {
                    window.regjsparser = regjsparser
                  }
                })()
              })

              var require$$3 = parser &&
                typeof parser === 'object' &&
                'default' in parser
                ? parser['default']
                : parser

              var regjsgen = __commonjs(function(module, exports, global) {
                /*!
   * RegJSGen
   * Copyright 2014 Benjamin Tan <https://d10.github.io/>
   * Available under MIT license <http://d10.mit-license.org/>
   */
                ;(function() {
                  'use strict'
                  /** Used to determine if values are of the language type `Object` */
                  var objectTypes = {
                    function: true,
                    object: true,
                  }

                  /** Used as a reference to the global object */
                  var root = (objectTypes[typeof window] && window) || this

                  /** Backup possible global object */
                  var oldRoot = root

                  /** Detect free variable `exports` */
                  var freeExports = objectTypes[typeof exports] && exports

                  /** Detect free variable `module` */
                  var freeModule =
                    objectTypes[typeof module] &&
                    module &&
                    !module.nodeType &&
                    module

                  /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */
                  var freeGlobal =
                    freeExports &&
                    freeModule &&
                    typeof global == 'object' &&
                    global
                  if (
                    freeGlobal &&
                    (freeGlobal.global === freeGlobal ||
                      freeGlobal.window === freeGlobal ||
                      freeGlobal.self === freeGlobal)
                  ) {
                    root = freeGlobal
                  }

                  /*--------------------------------------------------------------------------*/

                  /*! Based on https://mths.be/fromcodepoint v0.2.0 by @mathias */

                  var stringFromCharCode = String.fromCharCode
                  var floor = Math.floor
                  function fromCodePoint() {
                    var MAX_SIZE = 0x4000
                    var codeUnits = []
                    var highSurrogate
                    var lowSurrogate
                    var index = -1
                    var length = arguments.length
                    if (!length) {
                      return ''
                    }
                    var result = ''
                    while (++index < length) {
                      var codePoint = Number(arguments[index])
                      if (
                        !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
                        codePoint < 0 || // not a valid Unicode code point
                        codePoint > 0x10ffff || // not a valid Unicode code point
                        floor(codePoint) != codePoint // not an integer
                      ) {
                        throw RangeError('Invalid code point: ' + codePoint)
                      }
                      if (codePoint <= 0xffff) {
                        // BMP code point
                        codeUnits.push(codePoint)
                      } else {
                        // Astral code point; split in surrogate halves
                        // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
                        codePoint -= 0x10000
                        highSurrogate = (codePoint >> 10) + 0xd800
                        lowSurrogate = codePoint % 0x400 + 0xdc00
                        codeUnits.push(highSurrogate, lowSurrogate)
                      }
                      if (index + 1 == length || codeUnits.length > MAX_SIZE) {
                        result += stringFromCharCode.apply(null, codeUnits)
                        codeUnits.length = 0
                      }
                    }
                    return result
                  }

                  function assertType(type, expected) {
                    if (expected.indexOf('|') == -1) {
                      if (type == expected) {
                        return
                      }

                      throw Error('Invalid node type: ' + type)
                    }

                    expected = assertType.hasOwnProperty(expected)
                      ? assertType[expected]
                      : (assertType[expected] = RegExp(
                          '^(?:' + expected + ')$'
                        ))

                    if (expected.test(type)) {
                      return
                    }

                    throw Error('Invalid node type: ' + type)
                  }

                  /*--------------------------------------------------------------------------*/

                  function generate(node) {
                    var type = node.type

                    if (
                      generate.hasOwnProperty(type) &&
                      typeof generate[type] == 'function'
                    ) {
                      return generate[type](node)
                    }

                    throw Error('Invalid node type: ' + type)
                  }

                  /*--------------------------------------------------------------------------*/

                  function generateAlternative(node) {
                    assertType(node.type, 'alternative')

                    var terms = node.body,
                      length = terms ? terms.length : 0

                    if (length == 1) {
                      return generateTerm(terms[0])
                    } else {
                      var i = -1,
                        result = ''

                      while (++i < length) {
                        result += generateTerm(terms[i])
                      }

                      return result
                    }
                  }

                  function generateAnchor(node) {
                    assertType(node.type, 'anchor')

                    switch (node.kind) {
                      case 'start':
                        return '^'
                      case 'end':
                        return '$'
                      case 'boundary':
                        return '\\b'
                      case 'not-boundary':
                        return '\\B'
                      default:
                        throw Error('Invalid assertion')
                    }
                  }

                  function generateAtom(node) {
                    assertType(
                      node.type,
                      'anchor|characterClass|characterClassEscape|dot|group|reference|value'
                    )

                    return generate(node)
                  }

                  function generateCharacterClass(node) {
                    assertType(node.type, 'characterClass')

                    var classRanges = node.body,
                      length = classRanges ? classRanges.length : 0

                    var i = -1,
                      result = '['

                    if (node.negative) {
                      result += '^'
                    }

                    while (++i < length) {
                      result += generateClassAtom(classRanges[i])
                    }

                    result += ']'

                    return result
                  }

                  function generateCharacterClassEscape(node) {
                    assertType(node.type, 'characterClassEscape')

                    return '\\' + node.value
                  }

                  function generateCharacterClassRange(node) {
                    assertType(node.type, 'characterClassRange')

                    var min = node.min,
                      max = node.max

                    if (
                      min.type == 'characterClassRange' ||
                      max.type == 'characterClassRange'
                    ) {
                      throw Error('Invalid character class range')
                    }

                    return generateClassAtom(min) + '-' + generateClassAtom(max)
                  }

                  function generateClassAtom(node) {
                    assertType(
                      node.type,
                      'anchor|characterClassEscape|characterClassRange|dot|value'
                    )

                    return generate(node)
                  }

                  function generateDisjunction(node) {
                    assertType(node.type, 'disjunction')

                    var body = node.body,
                      length = body ? body.length : 0

                    if (length == 0) {
                      throw Error('No body')
                    } else if (length == 1) {
                      return generate(body[0])
                    } else {
                      var i = -1,
                        result = ''

                      while (++i < length) {
                        if (i != 0) {
                          result += '|'
                        }
                        result += generate(body[i])
                      }

                      return result
                    }
                  }

                  function generateDot(node) {
                    assertType(node.type, 'dot')

                    return '.'
                  }

                  function generateGroup(node) {
                    assertType(node.type, 'group')

                    var result = '('

                    switch (node.behavior) {
                      case 'normal':
                        break
                      case 'ignore':
                        result += '?:'
                        break
                      case 'lookahead':
                        result += '?='
                        break
                      case 'negativeLookahead':
                        result += '?!'
                        break
                      default:
                        throw Error('Invalid behaviour: ' + node.behaviour)
                    }

                    var body = node.body,
                      length = body ? body.length : 0

                    if (length == 1) {
                      result += generate(body[0])
                    } else {
                      var i = -1

                      while (++i < length) {
                        result += generate(body[i])
                      }
                    }

                    result += ')'

                    return result
                  }

                  function generateQuantifier(node) {
                    assertType(node.type, 'quantifier')

                    var quantifier = '',
                      min = node.min,
                      max = node.max

                    switch (max) {
                      case undefined:
                      case null:
                        switch (min) {
                          case 0:
                            quantifier = '*'
                            break
                          case 1:
                            quantifier = '+'
                            break
                          default:
                            quantifier = '{' + min + ',}'
                            break
                        }
                        break
                      default:
                        if (min == max) {
                          quantifier = '{' + min + '}'
                        } else if (min == 0 && max == 1) {
                          quantifier = '?'
                        } else {
                          quantifier = '{' + min + ',' + max + '}'
                        }
                        break
                    }

                    if (!node.greedy) {
                      quantifier += '?'
                    }

                    return generateAtom(node.body[0]) + quantifier
                  }

                  function generateReference(node) {
                    assertType(node.type, 'reference')

                    return '\\' + node.matchIndex
                  }

                  function generateTerm(node) {
                    assertType(
                      node.type,
                      'anchor|characterClass|characterClassEscape|empty|group|quantifier|reference|value'
                    )

                    return generate(node)
                  }

                  function generateValue(node) {
                    assertType(node.type, 'value')

                    var kind = node.kind,
                      codePoint = node.codePoint

                    switch (kind) {
                      case 'controlLetter':
                        return '\\c' + fromCodePoint(codePoint + 64)
                      case 'hexadecimalEscape':
                        return (
                          '\\x' +
                          ('00' + codePoint.toString(16).toUpperCase()).slice(
                            -2
                          )
                        )
                      case 'identifier':
                        return '\\' + fromCodePoint(codePoint)
                      case 'null':
                        return '\\' + codePoint
                      case 'octal':
                        return '\\' + codePoint.toString(8)
                      case 'singleEscape':
                        switch (codePoint) {
                          case 0x0008:
                            return '\\b'
                          case 0x009:
                            return '\\t'
                          case 0x00a:
                            return '\\n'
                          case 0x00b:
                            return '\\v'
                          case 0x00c:
                            return '\\f'
                          case 0x00d:
                            return '\\r'
                          default:
                            throw Error('Invalid codepoint: ' + codePoint)
                        }
                      case 'symbol':
                        return fromCodePoint(codePoint)
                      case 'unicodeEscape':
                        return (
                          '\\u' +
                          ('0000' + codePoint.toString(16).toUpperCase()).slice(
                            -4
                          )
                        )
                      case 'unicodeCodePointEscape':
                        return (
                          '\\u{' + codePoint.toString(16).toUpperCase() + '}'
                        )
                      default:
                        throw Error('Unsupported node kind: ' + kind)
                    }
                  }

                  /*--------------------------------------------------------------------------*/

                  generate.alternative = generateAlternative
                  generate.anchor = generateAnchor
                  generate.characterClass = generateCharacterClass
                  generate.characterClassEscape = generateCharacterClassEscape
                  generate.characterClassRange = generateCharacterClassRange
                  generate.disjunction = generateDisjunction
                  generate.dot = generateDot
                  generate.group = generateGroup
                  generate.quantifier = generateQuantifier
                  generate.reference = generateReference
                  generate.value = generateValue

                  /*--------------------------------------------------------------------------*/

                  // export regjsgen
                  // some AMD build optimizers, like r.js, check for condition patterns like the following:
                  if (
                    typeof define == 'function' &&
                    typeof define.amd == 'object' &&
                    define.amd
                  ) {
                    // define as an anonymous module so, through path mapping, it can be aliased
                    define(function() {
                      return {
                        generate: generate,
                      }
                    })
                  } else if (freeExports && freeModule) {
                    // check for `exports` after `define` in case a build optimizer adds an `exports` object
                    // in Narwhal, Node.js, Rhino -require, or RingoJS
                    freeExports.generate = generate
                  } else {
                    // in a browser or Rhino
                    root.regjsgen = {
                      generate: generate,
                    }
                  }
                }.call(__commonjs_global))
              })

              var require$$4 = regjsgen &&
                typeof regjsgen === 'object' &&
                'default' in regjsgen
                ? regjsgen['default']
                : regjsgen

              var rewritePattern = __commonjs(function(module) {
                var generate = require$$4.generate
                var parse = require$$3.parse
                var regenerate = require$$0$2
                var iuMappings = require$$1
                var ESCAPE_SETS = require$$0$1

                function getCharacterClassEscapeSet(character) {
                  if (unicode) {
                    if (ignoreCase) {
                      return ESCAPE_SETS.UNICODE_IGNORE_CASE[character]
                    }
                    return ESCAPE_SETS.UNICODE[character]
                  }
                  return ESCAPE_SETS.REGULAR[character]
                }

                var object = {}
                var hasOwnProperty = object.hasOwnProperty
                function has(object, property) {
                  return hasOwnProperty.call(object, property)
                }

                // Prepare a Regenerate set containing all code points, used for negative
                // character classes (if any).
                var UNICODE_SET = regenerate().addRange(0x0, 0x10ffff)
                // Without the `u` flag, the range stops at 0xFFFF.
                // https://mths.be/es6#sec-pattern-semantics
                var BMP_SET = regenerate().addRange(0x0, 0xffff)

                // Prepare a Regenerate set containing all code points that are supposed to be
                // matched by `/./u`. https://mths.be/es6#sec-atom
                var DOT_SET_UNICODE = UNICODE_SET.clone() // all Unicode code points
                  .remove(
                    // minus `LineTerminator`s (https://mths.be/es6#sec-line-terminators):
                    0x000a, // Line Feed <LF>
                    0x000d, // Carriage Return <CR>
                    0x2028, // Line Separator <LS>
                    0x2029 // Paragraph Separator <PS>
                  )
                // Prepare a Regenerate set containing all code points that are supposed to be
                // matched by `/./` (only BMP code points).
                var DOT_SET = DOT_SET_UNICODE.clone().intersection(BMP_SET)

                // Add a range of code points + any case-folded code points in that range to a
                // set.
                regenerate.prototype.iuAddRange = function(min, max) {
                  var $this = this
                  do {
                    var folded = caseFold(min)
                    if (folded) {
                      $this.add(folded)
                    }
                  } while (++min <= max)
                  return $this
                }

                function assign(target, source) {
                  for (var key in source) {
                    // Note: `hasOwnProperty` is not needed here.
                    target[key] = source[key]
                  }
                }

                function update(item, pattern) {
                  // TODO: Test if memoizing `pattern` here is worth the effort.
                  if (!pattern) {
                    return
                  }
                  var tree = parse(pattern, '')
                  switch (tree.type) {
                    case 'characterClass':
                    case 'group':
                    case 'value':
                      // No wrapping needed.
                      break
                    default:
                      // Wrap the pattern in a non-capturing group.
                      tree = wrap(tree, pattern)
                  }
                  assign(item, tree)
                }

                function wrap(tree, pattern) {
                  // Wrap the pattern in a non-capturing group.
                  return {
                    type: 'group',
                    behavior: 'ignore',
                    body: [tree],
                    raw: '(?:' + pattern + ')',
                  }
                }

                function caseFold(codePoint) {
                  return has(iuMappings, codePoint)
                    ? iuMappings[codePoint]
                    : false
                }

                var ignoreCase = false
                var unicode = false
                function processCharacterClass(characterClassItem) {
                  var set = regenerate()
                  var body = characterClassItem.body.forEach(function(item) {
                    switch (item.type) {
                      case 'value':
                        set.add(item.codePoint)
                        if (ignoreCase && unicode) {
                          var folded = caseFold(item.codePoint)
                          if (folded) {
                            set.add(folded)
                          }
                        }
                        break
                      case 'characterClassRange':
                        var min = item.min.codePoint
                        var max = item.max.codePoint
                        set.addRange(min, max)
                        if (ignoreCase && unicode) {
                          set.iuAddRange(min, max)
                        }
                        break
                      case 'characterClassEscape':
                        set.add(getCharacterClassEscapeSet(item.value))
                        break
                      // The `default` clause is only here as a safeguard; it should never be
                      // reached. Code coverage tools should ignore it.
                      /* istanbul ignore next */
                      default:
                        throw Error('Unknown term type: ' + item.type)
                    }
                  })
                  if (characterClassItem.negative) {
                    set = (unicode ? UNICODE_SET : BMP_SET).clone().remove(set)
                  }
                  update(characterClassItem, set.toString())
                  return characterClassItem
                }

                function processTerm(item) {
                  switch (item.type) {
                    case 'dot':
                      update(
                        item,
                        (unicode ? DOT_SET_UNICODE : DOT_SET).toString()
                      )
                      break
                    case 'characterClass':
                      item = processCharacterClass(item)
                      break
                    case 'characterClassEscape':
                      update(
                        item,
                        getCharacterClassEscapeSet(item.value).toString()
                      )
                      break
                    case 'alternative':
                    case 'disjunction':
                    case 'group':
                    case 'quantifier':
                      item.body = item.body.map(processTerm)
                      break
                    case 'value':
                      var codePoint = item.codePoint
                      var set = regenerate(codePoint)
                      if (ignoreCase && unicode) {
                        var folded = caseFold(codePoint)
                        if (folded) {
                          set.add(folded)
                        }
                      }
                      update(item, set.toString())
                      break
                    case 'anchor':
                    case 'empty':
                    case 'group':
                    case 'reference':
                      // Nothing to do here.
                      break
                    // The `default` clause is only here as a safeguard; it should never be
                    // reached. Code coverage tools should ignore it.
                    /* istanbul ignore next */
                    default:
                      throw Error('Unknown term type: ' + item.type)
                  }
                  return item
                }

                module.exports = function(pattern, flags) {
                  var tree = parse(pattern, flags)
                  ignoreCase = flags ? flags.indexOf('i') > -1 : false
                  unicode = flags ? flags.indexOf('u') > -1 : false
                  assign(tree, processTerm(tree))
                  return generate(tree)
                }
              })

              var rewritePattern$1 = rewritePattern &&
                typeof rewritePattern === 'object' &&
                'default' in rewritePattern
                ? rewritePattern['default']
                : rewritePattern

              var Literal = (function(Node) {
                function Literal() {
                  Node.apply(this, arguments)
                }

                if (Node) Literal.__proto__ = Node
                Literal.prototype = Object.create(Node && Node.prototype)
                Literal.prototype.constructor = Literal

                Literal.prototype.initialise = function initialise() {
                  if (typeof this.value === 'string') {
                    this.program.indentExclusionElements.push(this)
                  }
                }

                Literal.prototype.transpile = function transpile(
                  code,
                  transforms
                ) {
                  if (transforms.numericLiteral) {
                    var leading = this.raw.slice(0, 2)
                    if (leading === '0b' || leading === '0o') {
                      code.overwrite(
                        this.start,
                        this.end,
                        String(this.value),
                        true
                      )
                    }
                  }

                  if (this.regex) {
                    var ref = this.regex
                    var pattern = ref.pattern
                    var flags = ref.flags

                    if (transforms.stickyRegExp && /y/.test(flags))
                      throw new CompileError(
                        this,
                        'Regular expression sticky flag is not supported'
                      )
                    if (transforms.unicodeRegExp && /u/.test(flags)) {
                      code.overwrite(
                        this.start,
                        this.end,
                        '/' +
                          rewritePattern$1(pattern, flags) +
                          '/' +
                          flags.replace('u', '')
                      )
                    }
                  }
                }

                return Literal
              })(Node)

              var MemberExpression = (function(Node) {
                function MemberExpression() {
                  Node.apply(this, arguments)
                }

                if (Node) MemberExpression.__proto__ = Node
                MemberExpression.prototype = Object.create(
                  Node && Node.prototype
                )
                MemberExpression.prototype.constructor = MemberExpression

                MemberExpression.prototype.transpile = function transpile(
                  code,
                  transforms
                ) {
                  if (
                    transforms.reservedProperties &&
                    reserved[this.property.name]
                  ) {
                    code.overwrite(this.object.end, this.property.start, "['")
                    code.insertLeft(this.property.end, "']")
                  }

                  Node.prototype.transpile.call(this, code, transforms)
                }

                return MemberExpression
              })(Node)

              var NewExpression = (function(Node) {
                function NewExpression() {
                  Node.apply(this, arguments)
                }

                if (Node) NewExpression.__proto__ = Node
                NewExpression.prototype = Object.create(Node && Node.prototype)
                NewExpression.prototype.constructor = NewExpression

                NewExpression.prototype.initialise = function initialise(
                  transforms
                ) {
                  var this$1 = this

                  if (transforms.spreadRest && this.arguments.length) {
                    var lexicalBoundary = this.findLexicalBoundary()

                    var i = this.arguments.length
                    while (i--) {
                      var arg = this$1.arguments[i]
                      if (
                        arg.type === 'SpreadElement' &&
                        isArguments(arg.argument)
                      ) {
                        this$1.argumentsArrayAlias = lexicalBoundary.getArgumentsArrayAlias()
                        break
                      }
                    }
                  }

                  Node.prototype.initialise.call(this, transforms)
                }

                NewExpression.prototype.transpile = function transpile(
                  code,
                  transforms
                ) {
                  if (transforms.spreadRest && this.arguments.length) {
                    var firstArgument = this.arguments[0]
                    var isNew = true
                    var hasSpreadElements = spread(
                      code,
                      this.arguments,
                      firstArgument.start,
                      this.argumentsArrayAlias,
                      isNew
                    )

                    if (hasSpreadElements) {
                      code.insertRight(
                        this.start + 'new'.length,
                        ' (Function.prototype.bind.apply('
                      )
                      code.overwrite(
                        this.callee.end,
                        firstArgument.start,
                        ', [ null ].concat( '
                      )
                      code.insertLeft(this.end, ' ))')
                    }
                  }

                  Node.prototype.transpile.call(this, code, transforms)
                }

                return NewExpression
              })(Node)

              var ObjectExpression = (function(Node) {
                function ObjectExpression() {
                  Node.apply(this, arguments)
                }

                if (Node) ObjectExpression.__proto__ = Node
                ObjectExpression.prototype = Object.create(
                  Node && Node.prototype
                )
                ObjectExpression.prototype.constructor = ObjectExpression

                ObjectExpression.prototype.transpile = function transpile(
                  code,
                  transforms
                ) {
                  var this$1 = this

                  Node.prototype.transpile.call(this, code, transforms)

                  var firstPropertyStart = this.start + 1
                  var regularPropertyCount = 0
                  var spreadPropertyCount = 0
                  var computedPropertyCount = 0

                  for (
                    var i$2 = 0, list = this.properties;
                    i$2 < list.length;
                    i$2 += 1
                  ) {
                    var prop = list[i$2]

                    if (prop.type === 'SpreadProperty') {
                      spreadPropertyCount += 1
                    } else if (prop.computed) {
                      computedPropertyCount += 1
                    } else if (prop.type === 'Property') {
                      regularPropertyCount += 1
                    }
                  }

                  if (spreadPropertyCount) {
                    if (!this.program.options.objectAssign) {
                      throw new CompileError(
                        this,
                        "Object spread operator requires specified objectAssign option with 'Object.assign' or polyfill helper."
                      )
                    }
                    // enclose run of non-spread properties in curlies
                    var i = this.properties.length
                    if (regularPropertyCount) {
                      while (i--) {
                        var prop$1 = this$1.properties[i]

                        if (prop$1.type === 'Property' && !prop$1.computed) {
                          var lastProp = this$1.properties[i - 1]
                          var nextProp = this$1.properties[i + 1]

                          if (
                            !lastProp ||
                            lastProp.type !== 'Property' ||
                            lastProp.computed
                          ) {
                            code.insertRight(prop$1.start, '{')
                          }

                          if (
                            !nextProp ||
                            nextProp.type !== 'Property' ||
                            nextProp.computed
                          ) {
                            code.insertLeft(prop$1.end, '}')
                          }
                        }
                      }
                    }

                    // wrap the whole thing in Object.assign
                    firstPropertyStart = this.properties[0].start
                    code.overwrite(
                      this.start,
                      firstPropertyStart,
                      this.program.options.objectAssign + '({}, '
                    )
                    code.overwrite(
                      this.properties[this.properties.length - 1].end,
                      this.end,
                      ')'
                    )
                  }

                  if (computedPropertyCount && transforms.computedProperty) {
                    var i0 = this.getIndentation()

                    var isSimpleAssignment
                    var name

                    if (
                      this.parent.type === 'VariableDeclarator' &&
                      this.parent.parent.declarations.length === 1
                    ) {
                      isSimpleAssignment = true
                      name = this.parent.id.alias || this.parent.id.name // TODO is this right?
                    } else if (
                      this.parent.type === 'AssignmentExpression' &&
                      this.parent.parent.type === 'ExpressionStatement' &&
                      this.parent.left.type === 'Identifier'
                    ) {
                      isSimpleAssignment = true
                      name = this.parent.left.alias || this.parent.left.name // TODO is this right?
                    } else if (
                      this.parent.type === 'AssignmentPattern' &&
                      this.parent.left.type === 'Identifier'
                    ) {
                      isSimpleAssignment = true
                      name = this.parent.left.alias || this.parent.left.name // TODO is this right?
                    }

                    // handle block scoping
                    var declaration = this.findScope(false).findDeclaration(
                      name
                    )
                    if (declaration) name = declaration.name

                    var start = firstPropertyStart
                    var end = this.end

                    if (isSimpleAssignment) {
                      // ???
                    } else {
                      name = this.findScope(true).createIdentifier('obj')

                      var statement = this.findNearest(
                        /(?:Statement|Declaration)$/
                      )
                      code.insertLeft(
                        statement.end,
                        '\n' + i0 + 'var ' + name + ';'
                      )

                      code.insertRight(this.start, '( ' + name + ' = ')
                    }

                    var len = this.properties.length
                    var lastComputedProp
                    var sawNonComputedProperty = false

                    for (var i$1 = 0; i$1 < len; i$1 += 1) {
                      var prop$2 = this$1.properties[i$1]

                      if (prop$2.computed) {
                        lastComputedProp = prop$2
                        var moveStart = i$1 > 0
                          ? this$1.properties[i$1 - 1].end
                          : start

                        var propId = isSimpleAssignment
                          ? ';\n' + i0 + name
                          : ', ' + name

                        if (moveStart < prop$2.start) {
                          code.overwrite(moveStart, prop$2.start, propId)
                        } else {
                          code.insertRight(prop$2.start, propId)
                        }

                        var c = prop$2.key.end
                        while (code.original[c] !== ']') c += 1
                        c += 1

                        if (prop$2.value.start > c)
                          code.remove(c, prop$2.value.start)
                        code.insertLeft(c, ' = ')
                        code.move(moveStart, prop$2.end, end)

                        if (i$1 < len - 1 && !sawNonComputedProperty) {
                          // remove trailing comma
                          c = prop$2.end
                          while (code.original[c] !== ',') c += 1

                          code.remove(prop$2.end, c + 1)
                        }

                        if (prop$2.method && transforms.conciseMethodProperty) {
                          code.insertRight(prop$2.value.start, 'function ')
                        }
                      } else {
                        sawNonComputedProperty = true
                      }
                    }

                    // special case
                    if (computedPropertyCount === len) {
                      code.remove(this.properties[len - 1].end, this.end - 1)
                    }

                    if (!isSimpleAssignment) {
                      code.insertLeft(lastComputedProp.end, ', ' + name + ' )')
                    }
                  }
                }

                return ObjectExpression
              })(Node)

              var Property = (function(Node) {
                function Property() {
                  Node.apply(this, arguments)
                }

                if (Node) Property.__proto__ = Node
                Property.prototype = Object.create(Node && Node.prototype)
                Property.prototype.constructor = Property

                Property.prototype.transpile = function transpile(
                  code,
                  transforms
                ) {
                  if (
                    transforms.conciseMethodProperty &&
                    !this.computed &&
                    this.parent.type !== 'ObjectPattern'
                  ) {
                    if (this.shorthand) {
                      code.insertRight(this.start, this.key.name + ': ')
                    } else if (this.method) {
                      var name = ''
                      if (
                        this.program.options.namedFunctionExpressions !== false
                      ) {
                        if (
                          this.key.type === 'Literal' &&
                          typeof this.key.value === 'number'
                        ) {
                          name = ''
                        } else if (this.key.type === 'Identifier') {
                          if (
                            reserved[this.key.name] ||
                            !/^[a-z_$][a-z0-9_$]*$/i.test(this.key.name) ||
                            this.value.body.scope.references[this.key.name]
                          ) {
                            name = this.findScope(true).createIdentifier(
                              this.key.name
                            )
                          } else {
                            name = this.key.name
                          }
                        } else {
                          name = this.findScope(true).createIdentifier(
                            this.key.value
                          )
                        }
                        name = ' ' + name
                      }

                      if (this.value.generator)
                        code.remove(this.start, this.key.start)
                      code.insertLeft(
                        this.key.end,
                        ': function' + (this.value.generator ? '*' : '') + name
                      )
                    }
                  }

                  if (
                    transforms.reservedProperties &&
                    reserved[this.key.name]
                  ) {
                    code.insertRight(this.key.start, "'")
                    code.insertLeft(this.key.end, "'")
                  }

                  Node.prototype.transpile.call(this, code, transforms)
                }

                return Property
              })(Node)

              var ReturnStatement = (function(Node) {
                function ReturnStatement() {
                  Node.apply(this, arguments)
                }

                if (Node) ReturnStatement.__proto__ = Node
                ReturnStatement.prototype = Object.create(
                  Node && Node.prototype
                )
                ReturnStatement.prototype.constructor = ReturnStatement

                ReturnStatement.prototype.initialise = function initialise(
                  transforms
                ) {
                  this.loop = this.findNearest(loopStatement)
                  this.nearestFunction = this.findNearest(/Function/)

                  if (
                    this.loop &&
                    (!this.nearestFunction ||
                      this.loop.depth > this.nearestFunction.depth)
                  ) {
                    this.loop.canReturn = true
                    this.shouldWrap = true
                  }

                  if (this.argument) this.argument.initialise(transforms)
                }

                ReturnStatement.prototype.transpile = function transpile(
                  code,
                  transforms
                ) {
                  var shouldWrap =
                    this.shouldWrap &&
                    this.loop &&
                    this.loop.shouldRewriteAsFunction

                  if (this.argument) {
                    if (shouldWrap)
                      code.insertRight(this.argument.start, '{ v: ')
                    this.argument.transpile(code, transforms)
                    if (shouldWrap) code.insertLeft(this.argument.end, ' }')
                  } else if (shouldWrap) {
                    code.insertLeft(this.start + 6, ' {}')
                  }
                }

                return ReturnStatement
              })(Node)

              var SpreadProperty = (function(Node) {
                function SpreadProperty() {
                  Node.apply(this, arguments)
                }

                if (Node) SpreadProperty.__proto__ = Node
                SpreadProperty.prototype = Object.create(Node && Node.prototype)
                SpreadProperty.prototype.constructor = SpreadProperty

                SpreadProperty.prototype.transpile = function transpile(
                  code,
                  transforms
                ) {
                  code.remove(this.start, this.argument.start)
                  code.remove(this.argument.end, this.end)

                  Node.prototype.transpile.call(this, code, transforms)
                }

                return SpreadProperty
              })(Node)

              var Super = (function(Node) {
                function Super() {
                  Node.apply(this, arguments)
                }

                if (Node) Super.__proto__ = Node
                Super.prototype = Object.create(Node && Node.prototype)
                Super.prototype.constructor = Super

                Super.prototype.initialise = function initialise(transforms) {
                  if (transforms.classes) {
                    this.method = this.findNearest('MethodDefinition')
                    if (!this.method)
                      throw new CompileError(
                        this,
                        'use of super outside class method'
                      )

                    var parentClass = this.findNearest('ClassBody').parent
                    this.superClassName =
                      parentClass.superClass &&
                      (parentClass.superClass.name || 'superclass')

                    if (!this.superClassName)
                      throw new CompileError(this, 'super used in base class')

                    this.isCalled =
                      this.parent.type === 'CallExpression' &&
                      this === this.parent.callee

                    if (this.method.kind !== 'constructor' && this.isCalled) {
                      throw new CompileError(
                        this,
                        'super() not allowed outside class constructor'
                      )
                    }

                    this.isMember = this.parent.type === 'MemberExpression'

                    if (!this.isCalled && !this.isMember) {
                      throw new CompileError(
                        this,
                        'Unexpected use of `super` (expected `super(...)` or `super.*`)'
                      )
                    }
                  }

                  if (transforms.arrow) {
                    var lexicalBoundary = this.findLexicalBoundary()
                    var arrowFunction = this.findNearest(
                      'ArrowFunctionExpression'
                    )
                    var loop = this.findNearest(loopStatement)

                    if (
                      arrowFunction &&
                      arrowFunction.depth > lexicalBoundary.depth
                    ) {
                      this.thisAlias = lexicalBoundary.getThisAlias()
                    }

                    if (
                      loop &&
                      loop.body.contains(this) &&
                      loop.depth > lexicalBoundary.depth
                    ) {
                      this.thisAlias = lexicalBoundary.getThisAlias()
                    }
                  }
                }

                Super.prototype.transpile = function transpile(
                  code,
                  transforms
                ) {
                  if (transforms.classes) {
                    var expression = this.isCalled || this.method.static
                      ? this.superClassName
                      : this.superClassName + '.prototype'

                    code.overwrite(this.start, this.end, expression, true)

                    var callExpression = this.isCalled
                      ? this.parent
                      : this.parent.parent

                    if (
                      callExpression &&
                      callExpression.type === 'CallExpression'
                    ) {
                      if (!this.noCall) {
                        // special case  `super( ...args )`
                        code.insertLeft(callExpression.callee.end, '.call')
                      }

                      var thisAlias = this.thisAlias || 'this'

                      if (callExpression.arguments.length) {
                        code.insertLeft(
                          callExpression.arguments[0].start,
                          thisAlias + ', '
                        )
                      } else {
                        code.insertLeft(callExpression.end - 1, '' + thisAlias)
                      }
                    }
                  }
                }

                return Super
              })(Node)

              var TaggedTemplateExpression = (function(Node) {
                function TaggedTemplateExpression() {
                  Node.apply(this, arguments)
                }

                if (Node) TaggedTemplateExpression.__proto__ = Node
                TaggedTemplateExpression.prototype = Object.create(
                  Node && Node.prototype
                )
                TaggedTemplateExpression.prototype.constructor = TaggedTemplateExpression

                TaggedTemplateExpression.prototype.initialise = function initialise(
                  transforms
                ) {
                  if (
                    transforms.templateString &&
                    !transforms.dangerousTaggedTemplateString
                  ) {
                    throw new CompileError(
                      this,
                      "Tagged template strings are not supported. Use `transforms: { templateString: false }` to skip transformation and disable this error, or `transforms: { dangerousTaggedTemplateString: true }` if you know what you're doing"
                    )
                  }

                  Node.prototype.initialise.call(this, transforms)
                }

                TaggedTemplateExpression.prototype.transpile = function transpile(
                  code,
                  transforms
                ) {
                  if (
                    transforms.templateString &&
                    transforms.dangerousTaggedTemplateString
                  ) {
                    var ordered = this.quasi.expressions
                      .concat(this.quasi.quasis)
                      .sort(function(a, b) {
                        return a.start - b.start
                      })

                    // insert strings at start
                    var templateStrings = this.quasi.quasis.map(function(
                      quasi
                    ) {
                      return JSON.stringify(quasi.value.cooked)
                    })
                    code.overwrite(
                      this.tag.end,
                      ordered[0].start,
                      '([' + templateStrings.join(', ') + ']'
                    )

                    var lastIndex = ordered[0].start
                    ordered.forEach(function(node) {
                      if (node.type === 'TemplateElement') {
                        code.remove(lastIndex, node.end)
                      } else {
                        code.overwrite(lastIndex, node.start, ', ')
                      }

                      lastIndex = node.end
                    })

                    code.overwrite(lastIndex, this.end, ')')
                  }

                  Node.prototype.transpile.call(this, code, transforms)
                }

                return TaggedTemplateExpression
              })(Node)

              var TemplateElement = (function(Node) {
                function TemplateElement() {
                  Node.apply(this, arguments)
                }

                if (Node) TemplateElement.__proto__ = Node
                TemplateElement.prototype = Object.create(
                  Node && Node.prototype
                )
                TemplateElement.prototype.constructor = TemplateElement

                TemplateElement.prototype.initialise = function initialise() {
                  this.program.indentExclusionElements.push(this)
                }

                return TemplateElement
              })(Node)

              var TemplateLiteral = (function(Node) {
                function TemplateLiteral() {
                  Node.apply(this, arguments)
                }

                if (Node) TemplateLiteral.__proto__ = Node
                TemplateLiteral.prototype = Object.create(
                  Node && Node.prototype
                )
                TemplateLiteral.prototype.constructor = TemplateLiteral

                TemplateLiteral.prototype.transpile = function transpile(
                  code,
                  transforms
                ) {
                  if (
                    transforms.templateString &&
                    this.parent.type !== 'TaggedTemplateExpression'
                  ) {
                    var ordered = this.expressions
                      .concat(this.quasis)
                      .sort(function(a, b) {
                        return a.start - b.start || a.end - b.end
                      })
                      .filter(function(node, i) {
                        // include all expressions
                        if (node.type !== 'TemplateElement') return true

                        // include all non-empty strings
                        if (node.value.raw) return true

                        // exclude all empty strings not at the head
                        return !i
                      })

                    // special case  we may be able to skip the first element,
                    // if it's the empty string, but only if the second and
                    // third elements aren't both expressions (since they maybe
                    // be numeric, and `1 + 2 + '3' === '33'`)
                    if (ordered.length >= 3) {
                      var first = ordered[0]
                      var third = ordered[2]
                      if (
                        first.type === 'TemplateElement' &&
                        first.value.raw === '' &&
                        third.type === 'TemplateElement'
                      ) {
                        ordered.shift()
                      }
                    }

                    var parenthesise =
                      (this.quasis.length !== 1 ||
                        this.expressions.length !== 0) &&
                      this.parent.type !== 'AssignmentExpression' &&
                      this.parent.type !== 'AssignmentPattern' &&
                      this.parent.type !== 'VariableDeclarator' &&
                      (this.parent.type !== 'BinaryExpression' ||
                        this.parent.operator !== '+')

                    if (parenthesise) code.insertRight(this.start, '(')

                    var lastIndex = this.start

                    ordered.forEach(function(node, i) {
                      if (node.type === 'TemplateElement') {
                        var replacement = ''
                        if (i) replacement += ' + '
                        replacement += JSON.stringify(node.value.cooked)

                        code.overwrite(lastIndex, node.end, replacement)
                      } else {
                        var parenthesise = node.type !== 'Identifier' // TODO other cases where it's safe

                        var replacement$1 = ''
                        if (i) replacement$1 += ' + '
                        if (parenthesise) replacement$1 += '('

                        code.overwrite(lastIndex, node.start, replacement$1)

                        if (parenthesise) code.insertLeft(node.end, ')')
                      }

                      lastIndex = node.end
                    })

                    var close = ''
                    if (parenthesise) close += ')'

                    code.overwrite(lastIndex, this.end, close)
                  }

                  Node.prototype.transpile.call(this, code, transforms)
                }

                return TemplateLiteral
              })(Node)

              var ThisExpression = (function(Node) {
                function ThisExpression() {
                  Node.apply(this, arguments)
                }

                if (Node) ThisExpression.__proto__ = Node
                ThisExpression.prototype = Object.create(Node && Node.prototype)
                ThisExpression.prototype.constructor = ThisExpression

                ThisExpression.prototype.initialise = function initialise(
                  transforms
                ) {
                  if (transforms.arrow) {
                    var lexicalBoundary = this.findLexicalBoundary()
                    var arrowFunction = this.findNearest(
                      'ArrowFunctionExpression'
                    )
                    var loop = this.findNearest(loopStatement)

                    if (
                      (arrowFunction &&
                        arrowFunction.depth > lexicalBoundary.depth) ||
                      (loop &&
                        loop.body.contains(this) &&
                        loop.depth > lexicalBoundary.depth) ||
                      (loop && loop.right && loop.right.contains(this))
                    ) {
                      this.alias = lexicalBoundary.getThisAlias()
                    }
                  }
                }

                ThisExpression.prototype.transpile = function transpile(code) {
                  if (this.alias) {
                    code.overwrite(this.start, this.end, this.alias, true)
                  }
                }

                return ThisExpression
              })(Node)

              var UpdateExpression = (function(Node) {
                function UpdateExpression() {
                  Node.apply(this, arguments)
                }

                if (Node) UpdateExpression.__proto__ = Node
                UpdateExpression.prototype = Object.create(
                  Node && Node.prototype
                )
                UpdateExpression.prototype.constructor = UpdateExpression

                UpdateExpression.prototype.initialise = function initialise(
                  transforms
                ) {
                  if (this.argument.type === 'Identifier') {
                    var declaration = this.findScope(false).findDeclaration(
                      this.argument.name
                    )
                    if (declaration && declaration.kind === 'const') {
                      throw new CompileError(
                        this,
                        this.argument.name + ' is read-only'
                      )
                    }

                    // special case  https://gitlab.com/Rich-Harris/buble/issues/150
                    var statement = declaration && declaration.node.ancestor(3)
                    if (
                      statement &&
                      statement.type === 'ForStatement' &&
                      statement.body.contains(this)
                    ) {
                      statement.reassigned[this.argument.name] = true
                    }
                  }

                  Node.prototype.initialise.call(this, transforms)
                }

                return UpdateExpression
              })(Node)

              var VariableDeclaration = (function(Node) {
                function VariableDeclaration() {
                  Node.apply(this, arguments)
                }

                if (Node) VariableDeclaration.__proto__ = Node
                VariableDeclaration.prototype = Object.create(
                  Node && Node.prototype
                )
                VariableDeclaration.prototype.constructor = VariableDeclaration

                VariableDeclaration.prototype.initialise = function initialise(
                  transforms
                ) {
                  this.scope = this.findScope(this.kind === 'var')
                  this.declarations.forEach(function(declarator) {
                    return declarator.initialise(transforms)
                  })
                }

                VariableDeclaration.prototype.transpile = function transpile(
                  code,
                  transforms
                ) {
                  var this$1 = this

                  var i0 = this.getIndentation()
                  var kind = this.kind

                  if (transforms.letConst && kind !== 'var') {
                    kind = 'var'
                    code.overwrite(
                      this.start,
                      this.start + this.kind.length,
                      kind,
                      true
                    )
                  }

                  if (
                    transforms.destructuring &&
                    this.parent.type !== 'ForOfStatement'
                  ) {
                    var c = this.start
                    var lastDeclaratorIsPattern

                    this.declarations.forEach(function(declarator, i) {
                      if (declarator.id.type === 'Identifier') {
                        if (
                          i > 0 &&
                          this$1.declarations[i - 1].id.type !== 'Identifier'
                        ) {
                          code.overwrite(c, declarator.id.start, 'var ')
                        }
                      } else {
                        var inline = loopStatement.test(this$1.parent.type)

                        if (i === 0) {
                          code.remove(c, declarator.id.start)
                        } else {
                          code.overwrite(c, declarator.id.start, ';\n' + i0)
                        }

                        var simple =
                          declarator.init.type === 'Identifier' &&
                          !declarator.init.rewritten

                        var name = simple
                          ? declarator.init.name
                          : declarator.findScope(true).createIdentifier('ref')

                        var c$1 = declarator.start

                        var statementGenerators = []

                        if (simple) {
                          code.remove(declarator.id.end, declarator.end)
                        } else {
                          statementGenerators.push(function(
                            start,
                            prefix,
                            suffix
                          ) {
                            code.insertRight(declarator.id.end, 'var ' + name)
                            code.insertLeft(declarator.init.end, '' + suffix)
                            code.move(declarator.id.end, declarator.end, start)
                          })
                        }

                        destructure(
                          code,
                          declarator.findScope(false),
                          declarator.id,
                          name,
                          inline,
                          statementGenerators
                        )

                        var prefix = inline ? 'var ' : ''
                        var suffix = inline ? ', ' : ';\n' + i0
                        statementGenerators.forEach(function(fn, j) {
                          if (
                            i === this$1.declarations.length - 1 &&
                            j === statementGenerators.length - 1
                          ) {
                            suffix = inline ? '' : ';'
                          }

                          fn(declarator.start, j === 0 ? prefix : '', suffix)
                        })
                      }

                      declarator.transpile(code, transforms)

                      c = declarator.end
                      lastDeclaratorIsPattern =
                        declarator.id.type !== 'Identifier'
                    })

                    if (lastDeclaratorIsPattern) {
                      code.remove(c, this.end)
                    }
                  } else {
                    this.declarations.forEach(function(declarator) {
                      declarator.transpile(code, transforms)
                    })
                  }
                }

                return VariableDeclaration
              })(Node)

              var VariableDeclarator = (function(Node) {
                function VariableDeclarator() {
                  Node.apply(this, arguments)
                }

                if (Node) VariableDeclarator.__proto__ = Node
                VariableDeclarator.prototype = Object.create(
                  Node && Node.prototype
                )
                VariableDeclarator.prototype.constructor = VariableDeclarator

                VariableDeclarator.prototype.initialise = function initialise(
                  transforms
                ) {
                  var kind = this.parent.kind
                  if (
                    kind === 'let' &&
                    this.parent.parent.type === 'ForStatement'
                  ) {
                    kind = 'for.let' // special case...
                  }

                  this.parent.scope.addDeclaration(this.id, kind)
                  Node.prototype.initialise.call(this, transforms)
                }

                VariableDeclarator.prototype.transpile = function transpile(
                  code,
                  transforms
                ) {
                  if (
                    !this.init &&
                    transforms.letConst &&
                    this.parent.kind !== 'var'
                  ) {
                    var inLoop = this.findNearest(
                      /Function|^For(In|Of)?Statement|^(?:Do)?WhileStatement/
                    )
                    if (
                      inLoop &&
                      !/Function/.test(inLoop.type) &&
                      !this.isLeftDeclaratorOfLoop()
                    ) {
                      code.insertLeft(this.id.end, ' = (void 0)')
                    }
                  }

                  if (this.id) this.id.transpile(code, transforms)
                  if (this.init) this.init.transpile(code, transforms)
                }

                VariableDeclarator.prototype.isLeftDeclaratorOfLoop = function isLeftDeclaratorOfLoop() {
                  return (
                    this.parent &&
                    this.parent.type === 'VariableDeclaration' &&
                    this.parent.parent &&
                    (this.parent.parent.type === 'ForInStatement' ||
                      this.parent.parent.type === 'ForOfStatement') &&
                    this.parent.parent.left &&
                    this.parent.parent.left.declarations[0] === this
                  )
                }

                return VariableDeclarator
              })(Node)

              var types = {
                ArrayExpression: ArrayExpression,
                ArrowFunctionExpression: ArrowFunctionExpression,
                AssignmentExpression: AssignmentExpression,
                BinaryExpression: BinaryExpression,
                BreakStatement: BreakStatement,
                CallExpression: CallExpression,
                ClassBody: ClassBody,
                ClassDeclaration: ClassDeclaration,
                ClassExpression: ClassExpression,
                ContinueStatement: ContinueStatement,
                DoWhileStatement: LoopStatement,
                ExportNamedDeclaration: ExportNamedDeclaration,
                ExportDefaultDeclaration: ExportDefaultDeclaration,
                ForStatement: ForStatement,
                ForInStatement: ForInStatement,
                ForOfStatement: ForOfStatement,
                FunctionDeclaration: FunctionDeclaration,
                FunctionExpression: FunctionExpression,
                Identifier: Identifier,
                IfStatement: IfStatement,
                ImportDeclaration: ImportDeclaration,
                ImportDefaultSpecifier: ImportDefaultSpecifier,
                ImportSpecifier: ImportSpecifier,
                JSXAttribute: JSXAttribute,
                JSXClosingElement: JSXClosingElement,
                JSXElement: JSXElement,
                JSXExpressionContainer: JSXExpressionContainer,
                JSXOpeningElement: JSXOpeningElement,
                JSXSpreadAttribute: JSXSpreadAttribute,
                Literal: Literal,
                MemberExpression: MemberExpression,
                NewExpression: NewExpression,
                ObjectExpression: ObjectExpression,
                Property: Property,
                ReturnStatement: ReturnStatement,
                SpreadProperty: SpreadProperty,
                Super: Super,
                TaggedTemplateExpression: TaggedTemplateExpression,
                TemplateElement: TemplateElement,
                TemplateLiteral: TemplateLiteral,
                ThisExpression: ThisExpression,
                UpdateExpression: UpdateExpression,
                VariableDeclaration: VariableDeclaration,
                VariableDeclarator: VariableDeclarator,
                WhileStatement: LoopStatement,
              }

              var statementsWithBlocks = {
                IfStatement: 'consequent',
                ForStatement: 'body',
                ForInStatement: 'body',
                ForOfStatement: 'body',
                WhileStatement: 'body',
                DoWhileStatement: 'body',
                ArrowFunctionExpression: 'body',
              }

              function wrap(raw, parent) {
                if (!raw) return

                if ('length' in raw) {
                  var i = raw.length
                  while (i--) wrap(raw[i], parent)
                  return
                }

                // with e.g. shorthand properties, key and value are
                // the same node. We don't want to wrap an object twice
                if (raw.__wrapped) return
                raw.__wrapped = true

                if (!keys[raw.type]) {
                  keys[raw.type] = Object.keys(raw).filter(function(key) {
                    return typeof raw[key] === 'object'
                  })
                }

                // special case  body-less if/for/while statements. TODO others?
                var bodyType = statementsWithBlocks[raw.type]
                if (bodyType && raw[bodyType].type !== 'BlockStatement') {
                  var expression = raw[bodyType]

                  // create a synthetic block statement, otherwise all hell
                  // breaks loose when it comes to block scoping
                  raw[bodyType] = {
                    start: expression.start,
                    end: expression.end,
                    type: 'BlockStatement',
                    body: [expression],
                    synthetic: true,
                  }
                }

                new Node(raw, parent)

                var type =
                  (raw.type === 'BlockStatement'
                    ? BlockStatement
                    : types[raw.type]) || Node
                raw.__proto__ = type.prototype
              }

              var letConst = /^(?:let|const)$/

              function Scope(options) {
                options = options || {}

                this.parent = options.parent
                this.isBlockScope = !!options.block

                var scope = this
                while (scope.isBlockScope) scope = scope.parent
                this.functionScope = scope

                this.identifiers = []
                this.declarations = Object.create(null)
                this.references = Object.create(null)
                this.blockScopedDeclarations = this.isBlockScope
                  ? null
                  : Object.create(null)
                this.aliases = this.isBlockScope ? null : Object.create(null)
              }

              Scope.prototype = {
                addDeclaration: function addDeclaration(node, kind) {
                  for (
                    var i = 0, list = extractNames(node);
                    i < list.length;
                    i += 1
                  ) {
                    var identifier = list[i]

                    var name = identifier.name
                    var existingDeclaration = this.declarations[name]
                    if (
                      existingDeclaration &&
                      (letConst.test(kind) ||
                        letConst.test(existingDeclaration.kind))
                    ) {
                      // TODO warn about double var declarations?
                      throw new CompileError(
                        identifier,
                        name + ' is already declared'
                      )
                    }

                    var declaration = {
                      name: name,
                      node: identifier,
                      kind: kind,
                      instances: [],
                    }
                    this.declarations[name] = declaration

                    if (this.isBlockScope) {
                      if (!this.functionScope.blockScopedDeclarations[name])
                        this.functionScope.blockScopedDeclarations[name] = []
                      this.functionScope.blockScopedDeclarations[name].push(
                        declaration
                      )
                    }
                  }
                },

                addReference: function addReference(identifier) {
                  if (this.consolidated) {
                    this.consolidateReference(identifier)
                  } else {
                    this.identifiers.push(identifier)
                  }
                },

                consolidate: function consolidate() {
                  var this$1 = this

                  for (var i = 0; i < this$1.identifiers.length; i += 1) {
                    // we might push to the array during consolidation, so don't cache length
                    var identifier = this$1.identifiers[i]
                    this$1.consolidateReference(identifier)
                  }

                  this.consolidated = true // TODO understand why this is necessary... seems bad
                },

                consolidateReference: function consolidateReference(
                  identifier
                ) {
                  var declaration = this.declarations[identifier.name]
                  if (declaration) {
                    declaration.instances.push(identifier)
                  } else {
                    this.references[identifier.name] = true
                    if (this.parent) this.parent.addReference(identifier)
                  }
                },

                contains: function contains(name) {
                  return (
                    this.declarations[name] ||
                    (this.parent ? this.parent.contains(name) : false)
                  )
                },

                createIdentifier: function createIdentifier(base) {
                  var this$1 = this

                  if (typeof base === 'number') base = base.toString()

                  base = base
                    .replace(/\s/g, '')
                    .replace(/\[([^\]]+)\]/g, '_$1')
                    .replace(/[^a-zA-Z0-9_$]/g, '_')
                    .replace(/_{2,}/, '_')

                  var name = base
                  var counter = 1

                  while (
                    this$1.declarations[name] ||
                    this$1.references[name] ||
                    this$1.aliases[name] ||
                    name in reserved
                  ) {
                    name = base + '$' + counter++
                  }

                  this.aliases[name] = true
                  return name
                },

                findDeclaration: function findDeclaration(name) {
                  return (
                    this.declarations[name] ||
                    (this.parent && this.parent.findDeclaration(name))
                  )
                },
              }

              function isUseStrict(node) {
                if (!node) return false
                if (node.type !== 'ExpressionStatement') return false
                if (node.expression.type !== 'Literal') return false
                return node.expression.value === 'use strict'
              }

              var BlockStatement = (function(Node) {
                function BlockStatement() {
                  Node.apply(this, arguments)
                }

                if (Node) BlockStatement.__proto__ = Node
                BlockStatement.prototype = Object.create(Node && Node.prototype)
                BlockStatement.prototype.constructor = BlockStatement

                BlockStatement.prototype.createScope = function createScope() {
                  var this$1 = this

                  this.parentIsFunction = /Function/.test(this.parent.type)
                  this.isFunctionBlock =
                    this.parentIsFunction || this.parent.type === 'Root'
                  this.scope = new Scope({
                    block: !this.isFunctionBlock,
                    parent: this.parent.findScope(false),
                  })

                  if (this.parentIsFunction) {
                    this.parent.params.forEach(function(node) {
                      this$1.scope.addDeclaration(node, 'param')
                    })
                  }
                }

                BlockStatement.prototype.initialise = function initialise(
                  transforms
                ) {
                  this.thisAlias = null
                  this.argumentsAlias = null
                  this.defaultParameters = []

                  // normally the scope gets created here, during initialisation,
                  // but in some cases (e.g. `for` statements), we need to create
                  // the scope early, as it pertains to both the init block and
                  // the body of the statement
                  if (!this.scope) this.createScope()

                  this.body.forEach(function(node) {
                    return node.initialise(transforms)
                  })

                  this.scope.consolidate()
                }

                BlockStatement.prototype.findLexicalBoundary = function findLexicalBoundary() {
                  if (this.type === 'Program') return this
                  if (/^Function/.test(this.parent.type)) return this

                  return this.parent.findLexicalBoundary()
                }

                BlockStatement.prototype.findScope = function findScope(
                  functionScope
                ) {
                  if (functionScope && !this.isFunctionBlock)
                    return this.parent.findScope(functionScope)
                  return this.scope
                }

                BlockStatement.prototype.getArgumentsAlias = function getArgumentsAlias() {
                  if (!this.argumentsAlias) {
                    this.argumentsAlias = this.scope.createIdentifier(
                      'arguments'
                    )
                  }

                  return this.argumentsAlias
                }

                BlockStatement.prototype.getArgumentsArrayAlias = function getArgumentsArrayAlias() {
                  if (!this.argumentsArrayAlias) {
                    this.argumentsArrayAlias = this.scope.createIdentifier(
                      'argsArray'
                    )
                  }

                  return this.argumentsArrayAlias
                }

                BlockStatement.prototype.getThisAlias = function getThisAlias() {
                  if (!this.thisAlias) {
                    this.thisAlias = this.scope.createIdentifier('this')
                  }

                  return this.thisAlias
                }

                BlockStatement.prototype.getIndentation = function getIndentation() {
                  var this$1 = this

                  if (this.indentation === undefined) {
                    var source = this.program.magicString.original

                    var useOuter = this.synthetic || !this.body.length
                    var c = useOuter ? this.start : this.body[0].start

                    while (c && source[c] !== '\n') c -= 1

                    this.indentation = ''

                    while (true) {
                      // eslint-disable-line no-constant-condition
                      c += 1
                      var char = source[c]

                      if (char !== ' ' && char !== '\t') break

                      this$1.indentation += char
                    }

                    var indentString = this.program.magicString.getIndentString()

                    // account for dedented class constructors
                    var parent = this.parent
                    while (parent) {
                      if (
                        parent.kind === 'constructor' &&
                        !parent.parent.parent.superClass
                      ) {
                        this$1.indentation = this$1.indentation.replace(
                          indentString,
                          ''
                        )
                      }

                      parent = parent.parent
                    }

                    if (useOuter) this.indentation += indentString
                  }

                  return this.indentation
                }

                BlockStatement.prototype.transpile = function transpile(
                  code,
                  transforms
                ) {
                  var this$1 = this

                  var indentation = this.getIndentation()

                  var introStatementGenerators = []

                  if (this.argumentsAlias) {
                    introStatementGenerators.push(function(
                      start,
                      prefix,
                      suffix
                    ) {
                      var assignment =
                        prefix +
                        'var ' +
                        this$1.argumentsAlias +
                        ' = arguments' +
                        suffix
                      code.insertLeft(start, assignment)
                    })
                  }

                  if (this.thisAlias) {
                    introStatementGenerators.push(function(
                      start,
                      prefix,
                      suffix
                    ) {
                      var assignment =
                        prefix + 'var ' + this$1.thisAlias + ' = this' + suffix
                      code.insertLeft(start, assignment)
                    })
                  }

                  if (this.argumentsArrayAlias) {
                    introStatementGenerators.push(function(
                      start,
                      prefix,
                      suffix
                    ) {
                      var i = this$1.scope.createIdentifier('i')
                      var assignment =
                        prefix +
                        'var ' +
                        i +
                        ' = arguments.length, ' +
                        this$1.argumentsArrayAlias +
                        ' = Array(' +
                        i +
                        ');\n' +
                        indentation +
                        'while ( ' +
                        i +
                        '-- ) ' +
                        this$1.argumentsArrayAlias +
                        '[' +
                        i +
                        '] = arguments[' +
                        i +
                        ']' +
                        suffix
                      code.insertLeft(start, assignment)
                    })
                  }

                  if (/Function/.test(this.parent.type)) {
                    this.transpileParameters(
                      code,
                      transforms,
                      indentation,
                      introStatementGenerators
                    )
                  }

                  if (transforms.letConst && this.isFunctionBlock) {
                    this.transpileBlockScopedIdentifiers(code)
                  }

                  Node.prototype.transpile.call(this, code, transforms)

                  if (this.synthetic) {
                    if (this.parent.type === 'ArrowFunctionExpression') {
                      var expr = this.body[0]

                      if (introStatementGenerators.length) {
                        code
                          .insertLeft(this.start, '{')
                          .insertRight(
                            this.end,
                            this.parent.getIndentation() + '}'
                          )

                        code.insertRight(
                          expr.start,
                          '\n' + indentation + 'return '
                        )
                        code.insertLeft(expr.end, ';\n')
                      } else if (transforms.arrow) {
                        code.insertLeft(expr.start, '{ return ')
                        code.insertLeft(expr.end, '; }')
                      }
                    } else if (introStatementGenerators.length) {
                      code
                        .insertLeft(this.start, '{')
                        .insertRight(this.end, '}')
                    }
                  }

                  var start
                  if (isUseStrict(this.body[0])) {
                    start = this.body[0].end
                  } else if (this.synthetic || this.parent.type === 'Root') {
                    start = this.start
                  } else {
                    start = this.start + 1
                  }

                  var prefix = '\n' + indentation
                  var suffix = ';'
                  introStatementGenerators.forEach(function(fn, i) {
                    if (i === introStatementGenerators.length - 1)
                      suffix = ';\n'
                    fn(start, prefix, suffix)
                  })
                }

                BlockStatement.prototype.transpileParameters = function transpileParameters(
                  code,
                  transforms,
                  indentation,
                  introStatementGenerators
                ) {
                  var this$1 = this

                  var params = this.parent.params

                  params.forEach(function(param) {
                    if (
                      param.type === 'AssignmentPattern' &&
                      param.left.type === 'Identifier'
                    ) {
                      if (transforms.defaultParameter) {
                        introStatementGenerators.push(function(
                          start,
                          prefix,
                          suffix
                        ) {
                          var lhs =
                            prefix +
                            'if ( ' +
                            param.left.name +
                            ' === void 0 ) ' +
                            param.left.name

                          code
                            .insertRight(param.left.end, lhs)
                            .move(param.left.end, param.right.end, start)
                            .insertLeft(param.right.end, suffix)
                        })
                      }
                    } else if (param.type === 'RestElement') {
                      if (transforms.spreadRest) {
                        introStatementGenerators.push(function(
                          start,
                          prefix,
                          suffix
                        ) {
                          var penultimateParam = params[params.length - 2]

                          if (penultimateParam) {
                            code.remove(
                              penultimateParam
                                ? penultimateParam.end
                                : param.start,
                              param.end
                            )
                          } else {
                            var start$1 = param.start,
                              end = param.end // TODO https://gitlab.com/Rich-Harris/buble/issues/8

                            while (/\s/.test(code.original[start$1 - 1]))
                              start$1 -= 1
                            while (/\s/.test(code.original[end])) end += 1

                            code.remove(start$1, end)
                          }

                          var name = param.argument.name
                          var len = this$1.scope.createIdentifier('len')
                          var count = params.length - 1

                          if (count) {
                            code.insertLeft(
                              start,
                              prefix +
                                'var ' +
                                name +
                                ' = [], ' +
                                len +
                                ' = arguments.length - ' +
                                count +
                                ';\n' +
                                indentation +
                                'while ( ' +
                                len +
                                '-- > 0 ) ' +
                                name +
                                '[ ' +
                                len +
                                ' ] = arguments[ ' +
                                len +
                                ' + ' +
                                count +
                                ' ]' +
                                suffix
                            )
                          } else {
                            code.insertLeft(
                              start,
                              prefix +
                                'var ' +
                                name +
                                ' = [], ' +
                                len +
                                ' = arguments.length;\n' +
                                indentation +
                                'while ( ' +
                                len +
                                '-- ) ' +
                                name +
                                '[ ' +
                                len +
                                ' ] = arguments[ ' +
                                len +
                                ' ]' +
                                suffix
                            )
                          }
                        })
                      }
                    } else if (param.type !== 'Identifier') {
                      if (transforms.parameterDestructuring) {
                        var ref = this$1.scope.createIdentifier('ref')
                        destructure(
                          code,
                          this$1.scope,
                          param,
                          ref,
                          false,
                          introStatementGenerators
                        )
                        code.insertLeft(param.start, ref)
                      }
                    }
                  })
                }

                BlockStatement.prototype.transpileBlockScopedIdentifiers = function transpileBlockScopedIdentifiers(
                  code
                ) {
                  var this$1 = this

                  Object.keys(
                    this.scope.blockScopedDeclarations
                  ).forEach(function(name) {
                    var declarations =
                      this$1.scope.blockScopedDeclarations[name]

                    for (
                      var i = 0, list = declarations;
                      i < list.length;
                      i += 1
                    ) {
                      var declaration = list[i]

                      var cont = false // TODO implement proper continue...

                      if (declaration.kind === 'for.let') {
                        // special case
                        var forStatement = declaration.node.findNearest(
                          'ForStatement'
                        )

                        if (forStatement.shouldRewriteAsFunction) {
                          var outerAlias = this$1.scope.createIdentifier(name)
                          var innerAlias = forStatement.reassigned[name]
                            ? this$1.scope.createIdentifier(name)
                            : name

                          declaration.name = outerAlias
                          code.overwrite(
                            declaration.node.start,
                            declaration.node.end,
                            outerAlias,
                            true
                          )

                          forStatement.aliases[name] = {
                            outer: outerAlias,
                            inner: innerAlias,
                          }

                          for (
                            var i$1 = 0, list$1 = declaration.instances;
                            i$1 < list$1.length;
                            i$1 += 1
                          ) {
                            var identifier = list$1[i$1]

                            var alias = forStatement.body.contains(identifier)
                              ? innerAlias
                              : outerAlias

                            if (name !== alias) {
                              code.overwrite(
                                identifier.start,
                                identifier.end,
                                alias,
                                true
                              )
                            }
                          }

                          cont = true
                        }
                      }

                      if (!cont) {
                        var alias$1 = this$1.scope.createIdentifier(name)

                        if (name !== alias$1) {
                          declaration.name = alias$1
                          code.overwrite(
                            declaration.node.start,
                            declaration.node.end,
                            alias$1,
                            true
                          )

                          for (
                            var i$2 = 0, list$2 = declaration.instances;
                            i$2 < list$2.length;
                            i$2 += 1
                          ) {
                            var identifier$1 = list$2[i$2]

                            identifier$1.rewritten = true
                            code.overwrite(
                              identifier$1.start,
                              identifier$1.end,
                              alias$1,
                              true
                            )
                          }
                        }
                      }
                    }
                  })
                }

                return BlockStatement
              })(Node)

              function Program(source, ast, transforms, options) {
                var this$1 = this

                this.type = 'Root'

                // options
                this.jsx = options.jsx || 'React.createElement'
                this.options = options

                this.source = source
                this.magicString = new MagicString(source)

                this.ast = ast
                this.depth = 0

                wrap((this.body = ast), this)
                this.body.__proto__ = BlockStatement.prototype

                this.indentExclusionElements = []
                this.body.initialise(transforms)

                this.indentExclusions = Object.create(null)
                for (
                  var i$1 = 0, list = this.indentExclusionElements;
                  i$1 < list.length;
                  i$1 += 1
                ) {
                  var node = list[i$1]

                  for (var i = node.start; i < node.end; i += 1) {
                    this$1.indentExclusions[i] = true
                  }
                }

                this.body.transpile(this.magicString, transforms)
              }

              Program.prototype = {
                export: function export$1(options) {
                  if (options === void 0) options = {}

                  return {
                    code: this.magicString.toString(),
                    map: this.magicString.generateMap({
                      file: options.file,
                      source: options.source,
                      includeContent: options.includeContent !== false,
                    }),
                  }
                },

                findNearest: function findNearest() {
                  return null
                },

                findScope: function findScope() {
                  return null
                },
              }

              var matrix = {
                chrome: {
                  48: 1333689725,
                  49: 1342078975,
                  50: 1610514431,
                  51: 1610514431,
                  52: 2147385343,
                },
                firefox: {
                  43: 1207307741,
                  44: 1207307741,
                  45: 1207307741,
                  46: 1476267485,
                  47: 1476296671,
                  48: 1476296671,
                },
                safari: {
                  8: 1073741824,
                  9: 1328940894,
                },
                ie: {
                  8: 0,
                  9: 1073741824,
                  10: 1073741824,
                  11: 1073770592,
                },
                edge: {
                  12: 1591620701,
                  13: 1608400479,
                },
                node: {
                  '0.10': 1075052608,
                  '0.12': 1091830852,
                  4: 1327398527,
                  5: 1327398527,
                  6: 1610514431,
                },
              }

              var features = [
                'arrow',
                'classes',
                'collections',
                'computedProperty',
                'conciseMethodProperty',
                'constLoop',
                'constRedef',
                'defaultParameter',
                'destructuring',
                'extendNatives',
                'forOf',
                'generator',
                'letConst',
                'letLoop',
                'letLoopScope',
                'moduleExport',
                'moduleImport',
                'numericLiteral',
                'objectProto',
                'objectSuper',
                'oldOctalLiteral',
                'parameterDestructuring',
                'spreadRest',
                'stickyRegExp',
                'symbol',
                'templateString',
                'unicodeEscape',
                'unicodeIdentifier',
                'unicodeRegExp',

                // ES2016
                'exponentiation',

                // additional transforms, not from
                // https://featuretests.io
                'reservedProperties',
              ]

              var version = '0.15.2'

              var ref = [acornObjectSpread, acornJsx].reduce(function(
                final,
                plugin
              ) {
                return plugin(final)
              }, acorn)
              var parse = ref.parse

              var dangerousTransforms = [
                'dangerousTaggedTemplateString',
                'dangerousForOf',
              ]

              function target(target) {
                var targets = Object.keys(target)
                var bitmask = targets.length ? 2147483647 : 1073741824

                Object.keys(target).forEach(function(environment) {
                  var versions = matrix[environment]
                  if (!versions)
                    throw new Error(
                      "Unknown environment '" +
                        environment +
                        "'. Please raise an issue at https://gitlab.com/Rich-Harris/buble/issues"
                    )

                  var targetVersion = target[environment]
                  if (!(targetVersion in versions))
                    throw new Error(
                      'Support data exists for the following versions of ' +
                        environment +
                        ': ' +
                        Object.keys(versions).join(', ') +
                        '. Please raise an issue at https://gitlab.com/Rich-Harris/buble/issues'
                    )
                  var support = versions[targetVersion]

                  bitmask &= support
                })

                var transforms = Object.create(null)
                features.forEach(function(name, i) {
                  transforms[name] = !(bitmask & (1 << i))
                })

                dangerousTransforms.forEach(function(name) {
                  transforms[name] = false
                })

                return transforms
              }

              function transform(source, options) {
                if (options === void 0) options = {}

                var ast

                try {
                  ast = parse(source, {
                    ecmaVersion: 7,
                    preserveParens: true,
                    sourceType: 'module',
                    plugins: {
                      jsx: true,
                      objectSpread: true,
                    },
                  })
                } catch (err) {
                  err.snippet = getSnippet(source, err.loc)
                  err.toString = function() {
                    return err.name + ': ' + err.message + '\n' + err.snippet
                  }
                  throw err
                }

                var transforms = target(options.target || {})
                Object.keys(options.transforms || {}).forEach(function(name) {
                  if (name === 'modules') {
                    if (!('moduleImport' in options.transforms))
                      transforms.moduleImport = options.transforms.modules
                    if (!('moduleExport' in options.transforms))
                      transforms.moduleExport = options.transforms.modules
                    return
                  }

                  if (!(name in transforms))
                    throw new Error("Unknown transform '" + name + "'")
                  transforms[name] = options.transforms[name]
                })

                return new Program(source, ast, transforms, options).export(
                  options
                )
              }

              exports.target = target
              exports.transform = transform
              exports.VERSION = version

              Object.defineProperty(exports, '__esModule', { value: true })
            })
          }.call(
            this,
            typeof global !== 'undefined'
              ? global
              : typeof self !== 'undefined'
                ? self
                : typeof window !== 'undefined' ? window : {}
          ))
        },
        { 'acorn/dist/acorn.js': 120, 'magic-string': 501 },
      ],
      120: [
        function(require, module, exports) {
          ;(function(global, factory) {
            typeof exports === 'object' && typeof module !== 'undefined'
              ? factory(exports)
              : typeof define === 'function' && define.amd
                ? define(['exports'], factory)
                : factory((global.acorn = global.acorn || {}))
          })(this, function(exports) {
            'use strict'
            // Reserved word lists for various dialects of the language

            var reservedWords = {
              3: 'abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile',
              5: 'class enum extends super const export import',
              6: 'enum',
              7: 'enum',
              strict:
                'implements interface let package private protected public static yield',
              strictBind: 'eval arguments',
            }

            // And the keywords

            var ecma5AndLessKeywords =
              'break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this'

            var keywords = {
              5: ecma5AndLessKeywords,
              6:
                ecma5AndLessKeywords +
                  ' const class extends export import super',
            }

            // ## Character categories

            // Big ugly regular expressions that match characters in the
            // whitespace, identifier, and identifier-start categories. These
            // are only applied when a character is found to actually have a
            // code point above 128.
            // Generated by `bin/generate-identifier-regex.js`.

            var nonASCIIidentifierStartChars =
              '\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fd5\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7ae\ua7b0-\ua7b7\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab65\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc'
            var nonASCIIidentifierChars =
              '\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d4-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c03\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d01-\u0d03\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf2-\u1cf4\u1cf8\u1cf9\u1dc0-\u1df5\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua900-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f'

            var nonASCIIidentifierStart = new RegExp(
              '[' + nonASCIIidentifierStartChars + ']'
            )
            var nonASCIIidentifier = new RegExp(
              '[' + nonASCIIidentifierStartChars + nonASCIIidentifierChars + ']'
            )

            nonASCIIidentifierStartChars = nonASCIIidentifierChars = null

            // These are a run-length and offset encoded representation of the
            // >0xffff code points that are a valid part of identifiers. The
            // offset starts at 0x10000, and each pair of numbers represents an
            // offset to the next range, and then a size of the range. They were
            // generated by bin/generate-identifier-regex.js
            var astralIdentifierStartCodes = [
              0,
              11,
              2,
              25,
              2,
              18,
              2,
              1,
              2,
              14,
              3,
              13,
              35,
              122,
              70,
              52,
              268,
              28,
              4,
              48,
              48,
              31,
              17,
              26,
              6,
              37,
              11,
              29,
              3,
              35,
              5,
              7,
              2,
              4,
              43,
              157,
              19,
              35,
              5,
              35,
              5,
              39,
              9,
              51,
              157,
              310,
              10,
              21,
              11,
              7,
              153,
              5,
              3,
              0,
              2,
              43,
              2,
              1,
              4,
              0,
              3,
              22,
              11,
              22,
              10,
              30,
              66,
              18,
              2,
              1,
              11,
              21,
              11,
              25,
              71,
              55,
              7,
              1,
              65,
              0,
              16,
              3,
              2,
              2,
              2,
              26,
              45,
              28,
              4,
              28,
              36,
              7,
              2,
              27,
              28,
              53,
              11,
              21,
              11,
              18,
              14,
              17,
              111,
              72,
              56,
              50,
              14,
              50,
              785,
              52,
              76,
              44,
              33,
              24,
              27,
              35,
              42,
              34,
              4,
              0,
              13,
              47,
              15,
              3,
              22,
              0,
              2,
              0,
              36,
              17,
              2,
              24,
              85,
              6,
              2,
              0,
              2,
              3,
              2,
              14,
              2,
              9,
              8,
              46,
              39,
              7,
              3,
              1,
              3,
              21,
              2,
              6,
              2,
              1,
              2,
              4,
              4,
              0,
              19,
              0,
              13,
              4,
              159,
              52,
              19,
              3,
              54,
              47,
              21,
              1,
              2,
              0,
              185,
              46,
              42,
              3,
              37,
              47,
              21,
              0,
              60,
              42,
              86,
              25,
              391,
              63,
              32,
              0,
              449,
              56,
              264,
              8,
              2,
              36,
              18,
              0,
              50,
              29,
              881,
              921,
              103,
              110,
              18,
              195,
              2749,
              1070,
              4050,
              582,
              8634,
              568,
              8,
              30,
              114,
              29,
              19,
              47,
              17,
              3,
              32,
              20,
              6,
              18,
              881,
              68,
              12,
              0,
              67,
              12,
              65,
              0,
              32,
              6124,
              20,
              754,
              9486,
              1,
              3071,
              106,
              6,
              12,
              4,
              8,
              8,
              9,
              5991,
              84,
              2,
              70,
              2,
              1,
              3,
              0,
              3,
              1,
              3,
              3,
              2,
              11,
              2,
              0,
              2,
              6,
              2,
              64,
              2,
              3,
              3,
              7,
              2,
              6,
              2,
              27,
              2,
              3,
              2,
              4,
              2,
              0,
              4,
              6,
              2,
              339,
              3,
              24,
              2,
              24,
              2,
              30,
              2,
              24,
              2,
              30,
              2,
              24,
              2,
              30,
              2,
              24,
              2,
              30,
              2,
              24,
              2,
              7,
              4149,
              196,
              60,
              67,
              1213,
              3,
              2,
              26,
              2,
              1,
              2,
              0,
              3,
              0,
              2,
              9,
              2,
              3,
              2,
              0,
              2,
              0,
              7,
              0,
              5,
              0,
              2,
              0,
              2,
              0,
              2,
              2,
              2,
              1,
              2,
              0,
              3,
              0,
              2,
              0,
              2,
              0,
              2,
              0,
              2,
              0,
              2,
              1,
              2,
              0,
              3,
              3,
              2,
              6,
              2,
              3,
              2,
              3,
              2,
              0,
              2,
              9,
              2,
              16,
              6,
              2,
              2,
              4,
              2,
              16,
              4421,
              42710,
              42,
              4148,
              12,
              221,
              3,
              5761,
              10591,
              541,
            ]
            var astralIdentifierCodes = [
              509,
              0,
              227,
              0,
              150,
              4,
              294,
              9,
              1368,
              2,
              2,
              1,
              6,
              3,
              41,
              2,
              5,
              0,
              166,
              1,
              1306,
              2,
              54,
              14,
              32,
              9,
              16,
              3,
              46,
              10,
              54,
              9,
              7,
              2,
              37,
              13,
              2,
              9,
              52,
              0,
              13,
              2,
              49,
              13,
              10,
              2,
              4,
              9,
              83,
              11,
              7,
              0,
              161,
              11,
              6,
              9,
              7,
              3,
              57,
              0,
              2,
              6,
              3,
              1,
              3,
              2,
              10,
              0,
              11,
              1,
              3,
              6,
              4,
              4,
              193,
              17,
              10,
              9,
              87,
              19,
              13,
              9,
              214,
              6,
              3,
              8,
              28,
              1,
              83,
              16,
              16,
              9,
              82,
              12,
              9,
              9,
              84,
              14,
              5,
              9,
              423,
              9,
              838,
              7,
              2,
              7,
              17,
              9,
              57,
              21,
              2,
              13,
              19882,
              9,
              135,
              4,
              60,
              6,
              26,
              9,
              1016,
              45,
              17,
              3,
              19723,
              1,
              5319,
              4,
              4,
              5,
              9,
              7,
              3,
              6,
              31,
              3,
              149,
              2,
              1418,
              49,
              513,
              54,
              5,
              49,
              9,
              0,
              15,
              0,
              23,
              4,
              2,
              14,
              1361,
              6,
              2,
              16,
              3,
              6,
              2,
              1,
              2,
              4,
              2214,
              6,
              110,
              6,
              6,
              9,
              792487,
              239,
            ]

            // This has a complexity linear to the value of the code. The
            // assumption is that looking up astral identifier characters is
            // rare.
            function isInAstralSet(code, set) {
              var pos = 0x10000
              for (var i = 0; i < set.length; i += 2) {
                pos += set[i]
                if (pos > code) return false
                pos += set[i + 1]
                if (pos >= code) return true
              }
            }

            // Test whether a given character code starts an identifier.

            function isIdentifierStart(code, astral) {
              if (code < 65) return code === 36
              if (code < 91) return true
              if (code < 97) return code === 95
              if (code < 123) return true
              if (code <= 0xffff)
                return (
                  code >= 0xaa &&
                  nonASCIIidentifierStart.test(String.fromCharCode(code))
                )
              if (astral === false) return false
              return isInAstralSet(code, astralIdentifierStartCodes)
            }

            // Test whether a given character is part of an identifier.

            function isIdentifierChar(code, astral) {
              if (code < 48) return code === 36
              if (code < 58) return true
              if (code < 65) return false
              if (code < 91) return true
              if (code < 97) return code === 95
              if (code < 123) return true
              if (code <= 0xffff)
                return (
                  code >= 0xaa &&
                  nonASCIIidentifier.test(String.fromCharCode(code))
                )
              if (astral === false) return false
              return (
                isInAstralSet(code, astralIdentifierStartCodes) ||
                isInAstralSet(code, astralIdentifierCodes)
              )
            }

            // ## Token types

            // The assignment of fine-grained, information-carrying type objects
            // allows the tokenizer to store the information it has about a
            // token in a way that is very cheap for the parser to look up.

            // All token type variables start with an underscore, to make them
            // easy to recognize.

            // The `beforeExpr` property is used to disambiguate between regular
            // expressions and divisions. It is set on all token types that can
            // be followed by an expression (thus, a slash after them would be a
            // regular expression).
            //
            // The `startsExpr` property is used to check if the token ends a
            // `yield` expression. It is set on all token types that either can
            // directly start an expression (like a quotation mark) or can
            // continue an expression (like the body of a string).
            //
            // `isLoop` marks a keyword as starting a loop, which is important
            // to know when parsing a label, in order to allow or disallow
            // continue jumps to that label.

            var TokenType = function TokenType(label, conf) {
              if (conf === void 0) conf = {}

              this.label = label
              this.keyword = conf.keyword
              this.beforeExpr = !!conf.beforeExpr
              this.startsExpr = !!conf.startsExpr
              this.isLoop = !!conf.isLoop
              this.isAssign = !!conf.isAssign
              this.prefix = !!conf.prefix
              this.postfix = !!conf.postfix
              this.binop = conf.binop || null
              this.updateContext = null
            }

            function binop(name, prec) {
              return new TokenType(name, { beforeExpr: true, binop: prec })
            }
            var beforeExpr = { beforeExpr: true }
            var startsExpr = { startsExpr: true }
            // Map keyword names to token types.

            var keywordTypes = {}

            // Succinct definitions of keyword token types
            function kw(name, options) {
              if (options === void 0) options = {}

              options.keyword = name
              return (keywordTypes[name] = new TokenType(name, options))
            }

            var tt = {
              num: new TokenType('num', startsExpr),
              regexp: new TokenType('regexp', startsExpr),
              string: new TokenType('string', startsExpr),
              name: new TokenType('name', startsExpr),
              eof: new TokenType('eof'),

              // Punctuation token types.
              bracketL: new TokenType('[', {
                beforeExpr: true,
                startsExpr: true,
              }),
              bracketR: new TokenType(']'),
              braceL: new TokenType('{', {
                beforeExpr: true,
                startsExpr: true,
              }),
              braceR: new TokenType('}'),
              parenL: new TokenType('(', {
                beforeExpr: true,
                startsExpr: true,
              }),
              parenR: new TokenType(')'),
              comma: new TokenType(',', beforeExpr),
              semi: new TokenType(';', beforeExpr),
              colon: new TokenType(':', beforeExpr),
              dot: new TokenType('.'),
              question: new TokenType('?', beforeExpr),
              arrow: new TokenType('=>', beforeExpr),
              template: new TokenType('template'),
              ellipsis: new TokenType('...', beforeExpr),
              backQuote: new TokenType('`', startsExpr),
              dollarBraceL: new TokenType('${', {
                beforeExpr: true,
                startsExpr: true,
              }),

              // Operators. These carry several kinds of properties to help the
              // parser use them properly (the presence of these properties is
              // what categorizes them as operators).
              //
              // `binop`, when present, specifies that this operator is a binary
              // operator, and will refer to its precedence.
              //
              // `prefix` and `postfix` mark the operator as a prefix or postfix
              // unary operator.
              //
              // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
              // binary operators with a very low precedence, that should result
              // in AssignmentExpression nodes.

              eq: new TokenType('=', { beforeExpr: true, isAssign: true }),
              assign: new TokenType('_=', { beforeExpr: true, isAssign: true }),
              incDec: new TokenType('++/--', {
                prefix: true,
                postfix: true,
                startsExpr: true,
              }),
              prefix: new TokenType('prefix', {
                beforeExpr: true,
                prefix: true,
                startsExpr: true,
              }),
              logicalOR: binop('||', 1),
              logicalAND: binop('&&', 2),
              bitwiseOR: binop('|', 3),
              bitwiseXOR: binop('^', 4),
              bitwiseAND: binop('&', 5),
              equality: binop('==/!=', 6),
              relational: binop('</>', 7),
              bitShift: binop('<</>>', 8),
              plusMin: new TokenType('+/-', {
                beforeExpr: true,
                binop: 9,
                prefix: true,
                startsExpr: true,
              }),
              modulo: binop('%', 10),
              star: binop('*', 10),
              slash: binop('/', 10),
              starstar: new TokenType('**', { beforeExpr: true }),

              // Keyword token types.
              _break: kw('break'),
              _case: kw('case', beforeExpr),
              _catch: kw('catch'),
              _continue: kw('continue'),
              _debugger: kw('debugger'),
              _default: kw('default', beforeExpr),
              _do: kw('do', { isLoop: true, beforeExpr: true }),
              _else: kw('else', beforeExpr),
              _finally: kw('finally'),
              _for: kw('for', { isLoop: true }),
              _function: kw('function', startsExpr),
              _if: kw('if'),
              _return: kw('return', beforeExpr),
              _switch: kw('switch'),
              _throw: kw('throw', beforeExpr),
              _try: kw('try'),
              _var: kw('var'),
              _const: kw('const'),
              _while: kw('while', { isLoop: true }),
              _with: kw('with'),
              _new: kw('new', { beforeExpr: true, startsExpr: true }),
              _this: kw('this', startsExpr),
              _super: kw('super', startsExpr),
              _class: kw('class'),
              _extends: kw('extends', beforeExpr),
              _export: kw('export'),
              _import: kw('import'),
              _null: kw('null', startsExpr),
              _true: kw('true', startsExpr),
              _false: kw('false', startsExpr),
              _in: kw('in', { beforeExpr: true, binop: 7 }),
              _instanceof: kw('instanceof', { beforeExpr: true, binop: 7 }),
              _typeof: kw('typeof', {
                beforeExpr: true,
                prefix: true,
                startsExpr: true,
              }),
              _void: kw('void', {
                beforeExpr: true,
                prefix: true,
                startsExpr: true,
              }),
              _delete: kw('delete', {
                beforeExpr: true,
                prefix: true,
                startsExpr: true,
              }),
            }

            // Matches a whole line break (where CRLF is considered a single
            // line break). Used to count lines.

            var lineBreak = /\r\n?|\n|\u2028|\u2029/
            var lineBreakG = new RegExp(lineBreak.source, 'g')

            function isNewLine(code) {
              return (
                code === 10 || code === 13 || code === 0x2028 || code == 0x2029
              )
            }

            var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/

            var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g

            function isArray(obj) {
              return Object.prototype.toString.call(obj) === '[object Array]'
            }

            // Checks if an object has a property.

            function has(obj, propName) {
              return Object.prototype.hasOwnProperty.call(obj, propName)
            }

            // These are used when `options.locations` is on, for the
            // `startLoc` and `endLoc` properties.

            var Position = function Position(line, col) {
              this.line = line
              this.column = col
            }

            Position.prototype.offset = function offset(n) {
              return new Position(this.line, this.column + n)
            }

            var SourceLocation = function SourceLocation(p, start, end) {
              this.start = start
              this.end = end
              if (p.sourceFile !== null) this.source = p.sourceFile
            }

            // The `getLineInfo` function is mostly useful when the
            // `locations` option is off (for performance reasons) and you
            // want to find the line/column position for a given character
            // offset. `input` should be the code string that the offset refers
            // into.

            function getLineInfo(input, offset) {
              for (var line = 1, cur = 0; ; ) {
                lineBreakG.lastIndex = cur
                var match = lineBreakG.exec(input)
                if (match && match.index < offset) {
                  ++line
                  cur = match.index + match[0].length
                } else {
                  return new Position(line, offset - cur)
                }
              }
            }

            // A second optional argument can be given to further configure
            // the parser process. These options are recognized:

            var defaultOptions = {
              // `ecmaVersion` indicates the ECMAScript version to parse. Must
              // be either 3, or 5, or 6. This influences support for strict
              // mode, the set of reserved words, support for getters and
              // setters and other features. The default is 6.
              ecmaVersion: 6,
              // Source type ("script" or "module") for different semantics
              sourceType: 'script',
              // `onInsertedSemicolon` can be a callback that will be called
              // when a semicolon is automatically inserted. It will be passed
              // th position of the comma as an offset, and if `locations` is
              // enabled, it is given the location as a `{line, column}` object
              // as second argument.
              onInsertedSemicolon: null,
              // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
              // trailing commas.
              onTrailingComma: null,
              // By default, reserved words are only enforced if ecmaVersion >= 5.
              // Set `allowReserved` to a boolean value to explicitly turn this on
              // an off. When this option has the value "never", reserved words
              // and keywords can also not be used as property names.
              allowReserved: null,
              // When enabled, a return at the top level is not considered an
              // error.
              allowReturnOutsideFunction: false,
              // When enabled, import/export statements are not constrained to
              // appearing at the top of the program.
              allowImportExportEverywhere: false,
              // When enabled, hashbang directive in the beginning of file
              // is allowed and treated as a line comment.
              allowHashBang: false,
              // When `locations` is on, `loc` properties holding objects with
              // `start` and `end` properties in `{line, column}` form (with
              // line being 1-based and column 0-based) will be attached to the
              // nodes.
              locations: false,
              // A function can be passed as `onToken` option, which will
              // cause Acorn to call that function with object in the same
              // format as tokens returned from `tokenizer().getToken()`. Note
              // that you are not allowed to call the parser from the
              // callbackthat will corrupt its internal state.
              onToken: null,
              // A function can be passed as `onComment` option, which will
              // cause Acorn to call that function with `(block, text, start,
              // end)` parameters whenever a comment is skipped. `block` is a
              // boolean indicating whether this is a block (`/* */`) comment,
              // `text` is the content of the comment, and `start` and `end` are
              // character offsets that denote the start and end of the comment.
              // When the `locations` option is on, two more parameters are
              // passed, the full `{line, column}` locations of the start and
              // end of the comments. Note that you are not allowed to call the
              // parser from the callbackthat will corrupt its internal state.
              onComment: null,
              // Nodes have their start and end characters offsets recorded in
              // `start` and `end` properties (directly on the node, rather than
              // the `loc` object, which holds line/column data. To also add a
              // [semi-standardized][range] `range` property holding a `[start,
              // end]` array with the same numbers, set the `ranges` option to
              // `true`.
              //
              // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
              ranges: false,
              // It is possible to parse multiple files into a single AST by
              // passing the tree produced by parsing the first file as
              // `program` option in subsequent parses. This will add the
              // toplevel forms of the parsed file to the `Program` (top) node
              // of an existing parse tree.
              program: null,
              // When `locations` is on, you can pass this to record the source
              // file in every node's `loc` object.
              sourceFile: null,
              // This value, if given, is stored in every node, whether
              // `locations` is on or off.
              directSourceFile: null,
              // When enabled, parenthesized expressions are represented by
              // (non-standard) ParenthesizedExpression nodes
              preserveParens: false,
              plugins: {},
            }

            // Interpret and default an options object

            function getOptions(opts) {
              var options = {}
              for (var opt in defaultOptions)
                options[opt] = opts && has(opts, opt)
                  ? opts[opt]
                  : defaultOptions[opt]
              if (options.allowReserved == null)
                options.allowReserved = options.ecmaVersion < 5

              if (isArray(options.onToken)) {
                var tokens = options.onToken
                options.onToken = function(token) {
                  return tokens.push(token)
                }
              }
              if (isArray(options.onComment))
                options.onComment = pushComment(options, options.onComment)

              return options
            }

            function pushComment(options, array) {
              return function(block, text, start, end, startLoc, endLoc) {
                var comment = {
                  type: block ? 'Block' : 'Line',
                  value: text,
                  start: start,
                  end: end,
                }
                if (options.locations)
                  comment.loc = new SourceLocation(this, startLoc, endLoc)
                if (options.ranges) comment.range = [start, end]
                array.push(comment)
              }
            }

            // Registered plugins
            var plugins = {}

            function keywordRegexp(words) {
              return new RegExp('^(' + words.replace(/ /g, '|') + ')$')
            }

            var Parser = function Parser(options, input, startPos) {
              this.options = options = getOptions(options)
              this.sourceFile = options.sourceFile
              this.keywords = keywordRegexp(
                keywords[options.ecmaVersion >= 6 ? 6 : 5]
              )
              var reserved = options.allowReserved
                ? ''
                : reservedWords[options.ecmaVersion] +
                    (options.sourceType == 'module' ? ' await' : '')
              this.reservedWords = keywordRegexp(reserved)
              var reservedStrict =
                (reserved ? reserved + ' ' : '') + reservedWords.strict
              this.reservedWordsStrict = keywordRegexp(reservedStrict)
              this.reservedWordsStrictBind = keywordRegexp(
                reservedStrict + ' ' + reservedWords.strictBind
              )
              this.input = String(input)

              // Used to signal to callers of `readWord1` whether the word
              // contained any escape sequences. This is needed because words with
              // escape sequences must not be interpreted as keywords.
              this.containsEsc = false

              // Load plugins
              this.loadPlugins(options.plugins)

              // Set up token state

              // The current position of the tokenizer in the input.
              if (startPos) {
                this.pos = startPos
                this.lineStart = Math.max(
                  0,
                  this.input.lastIndexOf('\n', startPos)
                )
                this.curLine = this.input
                  .slice(0, this.lineStart)
                  .split(lineBreak).length
              } else {
                this.pos = this.lineStart = 0
                this.curLine = 1
              }

              // Properties of the current token:
              // Its type
              this.type = tt.eof
              // For tokens that include more information than their type, the value
              this.value = null
              // Its start and end offset
              this.start = this.end = this.pos
              // And, if locations are used, the {line, column} object
              // corresponding to those offsets
              this.startLoc = this.endLoc = this.curPosition()

              // Position information for the previous token
              this.lastTokEndLoc = this.lastTokStartLoc = null
              this.lastTokStart = this.lastTokEnd = this.pos

              // The context stack is used to superficially track syntactic
              // context to predict whether a regular expression is allowed in a
              // given position.
              this.context = this.initialContext()
              this.exprAllowed = true

              // Figure out if it's a module code.
              this.strict = this.inModule = options.sourceType === 'module'

              // Used to signify the start of a potential arrow function
              this.potentialArrowAt = -1

              // Flags to track whether we are in a function, a generator.
              this.inFunction = this.inGenerator = false
              // Labels in scope.
              this.labels = []

              // If enabled, skip leading hashbang line.
              if (
                this.pos === 0 &&
                options.allowHashBang &&
                this.input.slice(0, 2) === '#!'
              )
                this.skipLineComment(2)
            }

            // DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them
            Parser.prototype.isKeyword = function isKeyword(word) {
              return this.keywords.test(word)
            }
            Parser.prototype.isReservedWord = function isReservedWord(word) {
              return this.reservedWords.test(word)
            }

            Parser.prototype.extend = function extend(name, f) {
              this[name] = f(this[name])
            }

            Parser.prototype.loadPlugins = function loadPlugins(pluginConfigs) {
              var this$1 = this

              for (var name in pluginConfigs) {
                var plugin = plugins[name]
                if (!plugin) throw new Error("Plugin '" + name + "' not found")
                plugin(this$1, pluginConfigs[name])
              }
            }

            Parser.prototype.parse = function parse() {
              var node = this.options.program || this.startNode()
              this.nextToken()
              return this.parseTopLevel(node)
            }

            var pp = Parser.prototype

            // ## Parser utilities

            // Test whether a statement node is the string literal `"use strict"`.

            pp.isUseStrict = function(stmt) {
              return (
                this.options.ecmaVersion >= 5 &&
                stmt.type === 'ExpressionStatement' &&
                stmt.expression.type === 'Literal' &&
                stmt.expression.raw.slice(1, -1) === 'use strict'
              )
            }

            // Predicate that tests whether the next token is of the given
            // type, and if yes, consumes it as a side effect.

            pp.eat = function(type) {
              if (this.type === type) {
                this.next()
                return true
              } else {
                return false
              }
            }

            // Tests whether parsed token is a contextual keyword.

            pp.isContextual = function(name) {
              return this.type === tt.name && this.value === name
            }

            // Consumes contextual keyword if possible.

            pp.eatContextual = function(name) {
              return this.value === name && this.eat(tt.name)
            }

            // Asserts that following token is given contextual keyword.

            pp.expectContextual = function(name) {
              if (!this.eatContextual(name)) this.unexpected()
            }

            // Test whether a semicolon can be inserted at the current position.

            pp.canInsertSemicolon = function() {
              return (
                this.type === tt.eof ||
                this.type === tt.braceR ||
                lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
              )
            }

            pp.insertSemicolon = function() {
              if (this.canInsertSemicolon()) {
                if (this.options.onInsertedSemicolon)
                  this.options.onInsertedSemicolon(
                    this.lastTokEnd,
                    this.lastTokEndLoc
                  )
                return true
              }
            }

            // Consume a semicolon, or, failing that, see if we are allowed to
            // pretend that there is a semicolon at this position.

            pp.semicolon = function() {
              if (!this.eat(tt.semi) && !this.insertSemicolon())
                this.unexpected()
            }

            pp.afterTrailingComma = function(tokType) {
              if (this.type == tokType) {
                if (this.options.onTrailingComma)
                  this.options.onTrailingComma(
                    this.lastTokStart,
                    this.lastTokStartLoc
                  )
                this.next()
                return true
              }
            }

            // Expect a token of a given type. If found, consume it, otherwise,
            // raise an unexpected token error.

            pp.expect = function(type) {
              this.eat(type) || this.unexpected()
            }

            // Raise an unexpected token error.

            pp.unexpected = function(pos) {
              this.raise(pos != null ? pos : this.start, 'Unexpected token')
            }

            var DestructuringErrors = function DestructuringErrors() {
              this.shorthandAssign = 0
              this.trailingComma = 0
            }

            pp.checkPatternErrors = function(refDestructuringErrors, andThrow) {
              var trailing =
                refDestructuringErrors && refDestructuringErrors.trailingComma
              if (!andThrow) return !!trailing
              if (trailing)
                this.raise(
                  trailing,
                  'Comma is not permitted after the rest element'
                )
            }

            pp.checkExpressionErrors = function(
              refDestructuringErrors,
              andThrow
            ) {
              var pos =
                refDestructuringErrors && refDestructuringErrors.shorthandAssign
              if (!andThrow) return !!pos
              if (pos)
                this.raise(
                  pos,
                  'Shorthand property assignments are valid only in destructuring patterns'
                )
            }

            var pp$1 = Parser.prototype

            // ### Statement parsing

            // Parse a program. Initializes the parser, reads any number of
            // statements, and wraps them in a Program node.  Optionally takes a
            // `program` argument.  If present, the statements will be appended
            // to its body instead of creating a new node.

            pp$1.parseTopLevel = function(node) {
              var this$1 = this

              var first = true
              if (!node.body) node.body = []
              while (this.type !== tt.eof) {
                var stmt = this$1.parseStatement(true, true)
                node.body.push(stmt)
                if (first) {
                  if (this$1.isUseStrict(stmt)) this$1.setStrict(true)
                  first = false
                }
              }
              this.next()
              if (this.options.ecmaVersion >= 6) {
                node.sourceType = this.options.sourceType
              }
              return this.finishNode(node, 'Program')
            }

            var loopLabel = { kind: 'loop' }
            var switchLabel = { kind: 'switch' }
            pp$1.isLet = function() {
              if (
                this.type !== tt.name ||
                this.options.ecmaVersion < 6 ||
                this.value != 'let'
              )
                return false
              skipWhiteSpace.lastIndex = this.pos
              var skip = skipWhiteSpace.exec(this.input)
              var next = this.pos + skip[0].length,
                nextCh = this.input.charCodeAt(next)
              if (nextCh === 91 || nextCh == 123) return true // '{' and '['
              if (isIdentifierStart(nextCh, true)) {
                for (
                  var pos = next + 1;
                  isIdentifierChar(this.input.charCodeAt(pos), true);
                  ++pos
                ) {}
                var ident = this.input.slice(next, pos)
                if (!this.isKeyword(ident)) return true
              }
              return false
            }

            // Parse a single statement.
            //
            // If expecting a statement and finding a slash operator, parse a
            // regular expression literal. This is to handle cases like
            // `if (foo) /blah/.exec(foo)`, where looking at the previous token
            // does not help.

            pp$1.parseStatement = function(declaration, topLevel) {
              var starttype = this.type,
                node = this.startNode(),
                kind

              if (this.isLet()) {
                starttype = tt._var
                kind = 'let'
              }

              // Most types of statements are recognized by the keyword they
              // start with. Many are trivial to parse, some require a bit of
              // complexity.

              switch (starttype) {
                case tt._break:
                case tt._continue:
                  return this.parseBreakContinueStatement(
                    node,
                    starttype.keyword
                  )
                case tt._debugger:
                  return this.parseDebuggerStatement(node)
                case tt._do:
                  return this.parseDoStatement(node)
                case tt._for:
                  return this.parseForStatement(node)
                case tt._function:
                  if (!declaration && this.options.ecmaVersion >= 6)
                    this.unexpected()
                  return this.parseFunctionStatement(node)
                case tt._class:
                  if (!declaration) this.unexpected()
                  return this.parseClass(node, true)
                case tt._if:
                  return this.parseIfStatement(node)
                case tt._return:
                  return this.parseReturnStatement(node)
                case tt._switch:
                  return this.parseSwitchStatement(node)
                case tt._throw:
                  return this.parseThrowStatement(node)
                case tt._try:
                  return this.parseTryStatement(node)
                case tt._const:
                case tt._var:
                  kind = kind || this.value
                  if (!declaration && kind != 'var') this.unexpected()
                  return this.parseVarStatement(node, kind)
                case tt._while:
                  return this.parseWhileStatement(node)
                case tt._with:
                  return this.parseWithStatement(node)
                case tt.braceL:
                  return this.parseBlock()
                case tt.semi:
                  return this.parseEmptyStatement(node)
                case tt._export:
                case tt._import:
                  if (!this.options.allowImportExportEverywhere) {
                    if (!topLevel)
                      this.raise(
                        this.start,
                        "'import' and 'export' may only appear at the top level"
                      )
                    if (!this.inModule)
                      this.raise(
                        this.start,
                        "'import' and 'export' may appear only with 'sourceType: module'"
                      )
                  }
                  return starttype === tt._import
                    ? this.parseImport(node)
                    : this.parseExport(node)

                // If the statement does not start with a statement keyword or a
                // brace, it's an ExpressionStatement or LabeledStatement. We
                // simply start parsing an expression, and afterwards, if the
                // next token is a colon and the expression was a simple
                // Identifier node, we switch to interpreting it as a label.
                default:
                  var maybeName = this.value,
                    expr = this.parseExpression()
                  if (
                    starttype === tt.name &&
                    expr.type === 'Identifier' &&
                    this.eat(tt.colon)
                  )
                    return this.parseLabeledStatement(node, maybeName, expr)
                  else return this.parseExpressionStatement(node, expr)
              }
            }

            pp$1.parseBreakContinueStatement = function(node, keyword) {
              var this$1 = this

              var isBreak = keyword == 'break'
              this.next()
              if (this.eat(tt.semi) || this.insertSemicolon()) node.label = null
              else if (this.type !== tt.name) this.unexpected()
              else {
                node.label = this.parseIdent()
                this.semicolon()
              }

              // Verify that there is an actual destination to break or
              // continue to.
              for (var i = 0; i < this.labels.length; ++i) {
                var lab = this$1.labels[i]
                if (node.label == null || lab.name === node.label.name) {
                  if (lab.kind != null && (isBreak || lab.kind === 'loop'))
                    break
                  if (node.label && isBreak) break
                }
              }
              if (i === this.labels.length)
                this.raise(node.start, 'Unsyntactic ' + keyword)
              return this.finishNode(
                node,
                isBreak ? 'BreakStatement' : 'ContinueStatement'
              )
            }

            pp$1.parseDebuggerStatement = function(node) {
              this.next()
              this.semicolon()
              return this.finishNode(node, 'DebuggerStatement')
            }

            pp$1.parseDoStatement = function(node) {
              this.next()
              this.labels.push(loopLabel)
              node.body = this.parseStatement(false)
              this.labels.pop()
              this.expect(tt._while)
              node.test = this.parseParenExpression()
              if (this.options.ecmaVersion >= 6) this.eat(tt.semi)
              else this.semicolon()
              return this.finishNode(node, 'DoWhileStatement')
            }

            // Disambiguating between a `for` and a `for`/`in` or `for`/`of`
            // loop is non-trivial. Basically, we have to parse the init `var`
            // statement or expression, disallowing the `in` operator (see
            // the second parameter to `parseExpression`), and then check
            // whether the next token is `in` or `of`. When there is no init
            // part (semicolon immediately after the opening parenthesis), it
            // is a regular `for` loop.

            pp$1.parseForStatement = function(node) {
              this.next()
              this.labels.push(loopLabel)
              this.expect(tt.parenL)
              if (this.type === tt.semi) return this.parseFor(node, null)
              var isLet = this.isLet()
              if (this.type === tt._var || this.type === tt._const || isLet) {
                var init$1 = this.startNode(),
                  kind = isLet ? 'let' : this.value
                this.next()
                this.parseVar(init$1, true, kind)
                this.finishNode(init$1, 'VariableDeclaration')
                if (
                  (this.type === tt._in ||
                    (this.options.ecmaVersion >= 6 &&
                      this.isContextual('of'))) &&
                  init$1.declarations.length === 1 &&
                  !(kind !== 'var' && init$1.declarations[0].init)
                )
                  return this.parseForIn(node, init$1)
                return this.parseFor(node, init$1)
              }
              var refDestructuringErrors = new DestructuringErrors()
              var init = this.parseExpression(true, refDestructuringErrors)
              if (
                this.type === tt._in ||
                (this.options.ecmaVersion >= 6 && this.isContextual('of'))
              ) {
                this.checkPatternErrors(refDestructuringErrors, true)
                this.toAssignable(init)
                this.checkLVal(init)
                return this.parseForIn(node, init)
              } else {
                this.checkExpressionErrors(refDestructuringErrors, true)
              }
              return this.parseFor(node, init)
            }

            pp$1.parseFunctionStatement = function(node) {
              this.next()
              return this.parseFunction(node, true)
            }

            pp$1.parseIfStatement = function(node) {
              this.next()
              node.test = this.parseParenExpression()
              node.consequent = this.parseStatement(false)
              node.alternate = this.eat(tt._else)
                ? this.parseStatement(false)
                : null
              return this.finishNode(node, 'IfStatement')
            }

            pp$1.parseReturnStatement = function(node) {
              if (!this.inFunction && !this.options.allowReturnOutsideFunction)
                this.raise(this.start, "'return' outside of function")
              this.next()

              // In `return` (and `break`/`continue`), the keywords with
              // optional arguments, we eagerly look for a semicolon or the
              // possibility to insert one.

              if (this.eat(tt.semi) || this.insertSemicolon())
                node.argument = null
              else {
                node.argument = this.parseExpression()
                this.semicolon()
              }
              return this.finishNode(node, 'ReturnStatement')
            }

            pp$1.parseSwitchStatement = function(node) {
              var this$1 = this

              this.next()
              node.discriminant = this.parseParenExpression()
              node.cases = []
              this.expect(tt.braceL)
              this.labels.push(switchLabel)

              // Statements under must be grouped (by label) in SwitchCase
              // nodes. `cur` is used to keep the node that we are currently
              // adding statements to.

              for (var cur, sawDefault = false; this.type != tt.braceR; ) {
                if (this$1.type === tt._case || this$1.type === tt._default) {
                  var isCase = this$1.type === tt._case
                  if (cur) this$1.finishNode(cur, 'SwitchCase')
                  node.cases.push((cur = this$1.startNode()))
                  cur.consequent = []
                  this$1.next()
                  if (isCase) {
                    cur.test = this$1.parseExpression()
                  } else {
                    if (sawDefault)
                      this$1.raiseRecoverable(
                        this$1.lastTokStart,
                        'Multiple default clauses'
                      )
                    sawDefault = true
                    cur.test = null
                  }
                  this$1.expect(tt.colon)
                } else {
                  if (!cur) this$1.unexpected()
                  cur.consequent.push(this$1.parseStatement(true))
                }
              }
              if (cur) this.finishNode(cur, 'SwitchCase')
              this.next() // Closing brace
              this.labels.pop()
              return this.finishNode(node, 'SwitchStatement')
            }

            pp$1.parseThrowStatement = function(node) {
              this.next()
              if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
                this.raise(this.lastTokEnd, 'Illegal newline after throw')
              node.argument = this.parseExpression()
              this.semicolon()
              return this.finishNode(node, 'ThrowStatement')
            }

            // Reused empty array added for node fields that are always empty.

            var empty = []

            pp$1.parseTryStatement = function(node) {
              this.next()
              node.block = this.parseBlock()
              node.handler = null
              if (this.type === tt._catch) {
                var clause = this.startNode()
                this.next()
                this.expect(tt.parenL)
                clause.param = this.parseBindingAtom()
                this.checkLVal(clause.param, true)
                this.expect(tt.parenR)
                clause.body = this.parseBlock()
                node.handler = this.finishNode(clause, 'CatchClause')
              }
              node.finalizer = this.eat(tt._finally) ? this.parseBlock() : null
              if (!node.handler && !node.finalizer)
                this.raise(node.start, 'Missing catch or finally clause')
              return this.finishNode(node, 'TryStatement')
            }

            pp$1.parseVarStatement = function(node, kind) {
              this.next()
              this.parseVar(node, false, kind)
              this.semicolon()
              return this.finishNode(node, 'VariableDeclaration')
            }

            pp$1.parseWhileStatement = function(node) {
              this.next()
              node.test = this.parseParenExpression()
              this.labels.push(loopLabel)
              node.body = this.parseStatement(false)
              this.labels.pop()
              return this.finishNode(node, 'WhileStatement')
            }

            pp$1.parseWithStatement = function(node) {
              if (this.strict) this.raise(this.start, "'with' in strict mode")
              this.next()
              node.object = this.parseParenExpression()
              node.body = this.parseStatement(false)
              return this.finishNode(node, 'WithStatement')
            }

            pp$1.parseEmptyStatement = function(node) {
              this.next()
              return this.finishNode(node, 'EmptyStatement')
            }

            pp$1.parseLabeledStatement = function(node, maybeName, expr) {
              var this$1 = this

              for (var i = 0; i < this.labels.length; ++i)
                if (this$1.labels[i].name === maybeName)
                  this$1.raise(
                    expr.start,
                    "Label '" + maybeName + "' is already declared"
                  )
              var kind = this.type.isLoop
                ? 'loop'
                : this.type === tt._switch ? 'switch' : null
              for (var i$1 = this.labels.length - 1; i$1 >= 0; i$1--) {
                var label = this$1.labels[i$1]
                if (label.statementStart == node.start) {
                  label.statementStart = this$1.start
                  label.kind = kind
                } else break
              }
              this.labels.push({
                name: maybeName,
                kind: kind,
                statementStart: this.start,
              })
              node.body = this.parseStatement(true)
              this.labels.pop()
              node.label = expr
              return this.finishNode(node, 'LabeledStatement')
            }

            pp$1.parseExpressionStatement = function(node, expr) {
              node.expression = expr
              this.semicolon()
              return this.finishNode(node, 'ExpressionStatement')
            }

            // Parse a semicolon-enclosed block of statements, handling `"use
            // strict"` declarations when `allowStrict` is true (used for
            // function bodies).

            pp$1.parseBlock = function(allowStrict) {
              var this$1 = this

              var node = this.startNode(),
                first = true,
                oldStrict
              node.body = []
              this.expect(tt.braceL)
              while (!this.eat(tt.braceR)) {
                var stmt = this$1.parseStatement(true)
                node.body.push(stmt)
                if (first && allowStrict && this$1.isUseStrict(stmt)) {
                  oldStrict = this$1.strict
                  this$1.setStrict((this$1.strict = true))
                }
                first = false
              }
              if (oldStrict === false) this.setStrict(false)
              return this.finishNode(node, 'BlockStatement')
            }

            // Parse a regular `for` loop. The disambiguation code in
            // `parseStatement` will already have parsed the init statement or
            // expression.

            pp$1.parseFor = function(node, init) {
              node.init = init
              this.expect(tt.semi)
              node.test = this.type === tt.semi ? null : this.parseExpression()
              this.expect(tt.semi)
              node.update = this.type === tt.parenR
                ? null
                : this.parseExpression()
              this.expect(tt.parenR)
              node.body = this.parseStatement(false)
              this.labels.pop()
              return this.finishNode(node, 'ForStatement')
            }

            // Parse a `for`/`in` and `for`/`of` loop, which are almost
            // same from parser's perspective.

            pp$1.parseForIn = function(node, init) {
              var type = this.type === tt._in
                ? 'ForInStatement'
                : 'ForOfStatement'
              this.next()
              node.left = init
              node.right = this.parseExpression()
              this.expect(tt.parenR)
              node.body = this.parseStatement(false)
              this.labels.pop()
              return this.finishNode(node, type)
            }

            // Parse a list of variable declarations.

            pp$1.parseVar = function(node, isFor, kind) {
              var this$1 = this

              node.declarations = []
              node.kind = kind
              for (;;) {
                var decl = this$1.startNode()
                this$1.parseVarId(decl)
                if (this$1.eat(tt.eq)) {
                  decl.init = this$1.parseMaybeAssign(isFor)
                } else if (
                  kind === 'const' &&
                  !(
                    this$1.type === tt._in ||
                    (this$1.options.ecmaVersion >= 6 &&
                      this$1.isContextual('of'))
                  )
                ) {
                  this$1.unexpected()
                } else if (
                  decl.id.type != 'Identifier' &&
                  !(
                    isFor &&
                    (this$1.type === tt._in || this$1.isContextual('of'))
                  )
                ) {
                  this$1.raise(
                    this$1.lastTokEnd,
                    'Complex binding patterns require an initialization value'
                  )
                } else {
                  decl.init = null
                }
                node.declarations.push(
                  this$1.finishNode(decl, 'VariableDeclarator')
                )
                if (!this$1.eat(tt.comma)) break
              }
              return node
            }

            pp$1.parseVarId = function(decl) {
              decl.id = this.parseBindingAtom()
              this.checkLVal(decl.id, true)
            }

            // Parse a function declaration or literal (depending on the
            // `isStatement` parameter).

            pp$1.parseFunction = function(
              node,
              isStatement,
              allowExpressionBody
            ) {
              this.initFunction(node)
              if (this.options.ecmaVersion >= 6)
                node.generator = this.eat(tt.star)
              var oldInGen = this.inGenerator
              this.inGenerator = node.generator
              if (isStatement || this.type === tt.name)
                node.id = this.parseIdent()
              this.parseFunctionParams(node)
              this.parseFunctionBody(node, allowExpressionBody)
              this.inGenerator = oldInGen
              return this.finishNode(
                node,
                isStatement ? 'FunctionDeclaration' : 'FunctionExpression'
              )
            }

            pp$1.parseFunctionParams = function(node) {
              this.expect(tt.parenL)
              node.params = this.parseBindingList(tt.parenR, false, false, true)
            }

            // Parse a class declaration or literal (depending on the
            // `isStatement` parameter).

            pp$1.parseClass = function(node, isStatement) {
              var this$1 = this

              this.next()
              this.parseClassId(node, isStatement)
              this.parseClassSuper(node)
              var classBody = this.startNode()
              var hadConstructor = false
              classBody.body = []
              this.expect(tt.braceL)
              while (!this.eat(tt.braceR)) {
                if (this$1.eat(tt.semi)) continue
                var method = this$1.startNode()
                var isGenerator = this$1.eat(tt.star)
                var isMaybeStatic =
                  this$1.type === tt.name && this$1.value === 'static'
                this$1.parsePropertyName(method)
                method.static = isMaybeStatic && this$1.type !== tt.parenL
                if (method.static) {
                  if (isGenerator) this$1.unexpected()
                  isGenerator = this$1.eat(tt.star)
                  this$1.parsePropertyName(method)
                }
                method.kind = 'method'
                var isGetSet = false
                if (!method.computed) {
                  var key = method.key
                  if (
                    !isGenerator &&
                    key.type === 'Identifier' &&
                    this$1.type !== tt.parenL &&
                    (key.name === 'get' || key.name === 'set')
                  ) {
                    isGetSet = true
                    method.kind = key.name
                    key = this$1.parsePropertyName(method)
                  }
                  if (
                    !method.static &&
                    ((key.type === 'Identifier' &&
                      key.name === 'constructor') ||
                      (key.type === 'Literal' && key.value === 'constructor'))
                  ) {
                    if (hadConstructor)
                      this$1.raise(
                        key.start,
                        'Duplicate constructor in the same class'
                      )
                    if (isGetSet)
                      this$1.raise(
                        key.start,
                        "Constructor can't have get/set modifier"
                      )
                    if (isGenerator)
                      this$1.raise(
                        key.start,
                        "Constructor can't be a generator"
                      )
                    method.kind = 'constructor'
                    hadConstructor = true
                  }
                }
                this$1.parseClassMethod(classBody, method, isGenerator)
                if (isGetSet) {
                  var paramCount = method.kind === 'get' ? 0 : 1
                  if (method.value.params.length !== paramCount) {
                    var start = method.value.start
                    if (method.kind === 'get')
                      this$1.raiseRecoverable(
                        start,
                        'getter should have no params'
                      )
                    else
                      this$1.raiseRecoverable(
                        start,
                        'setter should have exactly one param'
                      )
                  }
                  if (
                    method.kind === 'set' &&
                    method.value.params[0].type === 'RestElement'
                  )
                    this$1.raise(
                      method.value.params[0].start,
                      'Setter cannot use rest params'
                    )
                }
              }
              node.body = this.finishNode(classBody, 'ClassBody')
              return this.finishNode(
                node,
                isStatement ? 'ClassDeclaration' : 'ClassExpression'
              )
            }

            pp$1.parseClassMethod = function(classBody, method, isGenerator) {
              method.value = this.parseMethod(isGenerator)
              classBody.body.push(this.finishNode(method, 'MethodDefinition'))
            }

            pp$1.parseClassId = function(node, isStatement) {
              node.id = this.type === tt.name
                ? this.parseIdent()
                : isStatement ? this.unexpected() : null
            }

            pp$1.parseClassSuper = function(node) {
              node.superClass = this.eat(tt._extends)
                ? this.parseExprSubscripts()
                : null
            }

            // Parses module export declaration.

            pp$1.parseExport = function(node) {
              var this$1 = this

              this.next()
              // export * from '...'
              if (this.eat(tt.star)) {
                this.expectContextual('from')
                node.source = this.type === tt.string
                  ? this.parseExprAtom()
                  : this.unexpected()
                this.semicolon()
                return this.finishNode(node, 'ExportAllDeclaration')
              }
              if (this.eat(tt._default)) {
                // export default ...
                var parens = this.type == tt.parenL
                var expr = this.parseMaybeAssign()
                var needsSemi = true
                if (
                  !parens &&
                  (expr.type == 'FunctionExpression' ||
                    expr.type == 'ClassExpression')
                ) {
                  needsSemi = false
                  if (expr.id) {
                    expr.type = expr.type == 'FunctionExpression'
                      ? 'FunctionDeclaration'
                      : 'ClassDeclaration'
                  }
                }
                node.declaration = expr
                if (needsSemi) this.semicolon()
                return this.finishNode(node, 'ExportDefaultDeclaration')
              }
              // export var|const|let|function|class ...
              if (this.shouldParseExportStatement()) {
                node.declaration = this.parseStatement(true)
                node.specifiers = []
                node.source = null
              } else {
                // export { x, y as z } [from '...']
                node.declaration = null
                node.specifiers = this.parseExportSpecifiers()
                if (this.eatContextual('from')) {
                  node.source = this.type === tt.string
                    ? this.parseExprAtom()
                    : this.unexpected()
                } else {
                  // check for keywords used as local names
                  for (var i = 0; i < node.specifiers.length; i++) {
                    if (
                      this$1.keywords.test(node.specifiers[i].local.name) ||
                      this$1.reservedWords.test(node.specifiers[i].local.name)
                    ) {
                      this$1.unexpected(node.specifiers[i].local.start)
                    }
                  }

                  node.source = null
                }
                this.semicolon()
              }
              return this.finishNode(node, 'ExportNamedDeclaration')
            }

            pp$1.shouldParseExportStatement = function() {
              return this.type.keyword || this.isLet()
            }

            // Parses a comma-separated list of module exports.

            pp$1.parseExportSpecifiers = function() {
              var this$1 = this

              var nodes = [],
                first = true
              // export { x, y as z } [from '...']
              this.expect(tt.braceL)
              while (!this.eat(tt.braceR)) {
                if (!first) {
                  this$1.expect(tt.comma)
                  if (this$1.afterTrailingComma(tt.braceR)) break
                } else first = false

                var node = this$1.startNode()
                node.local = this$1.parseIdent(this$1.type === tt._default)
                node.exported = this$1.eatContextual('as')
                  ? this$1.parseIdent(true)
                  : node.local
                nodes.push(this$1.finishNode(node, 'ExportSpecifier'))
              }
              return nodes
            }

            // Parses import declaration.

            pp$1.parseImport = function(node) {
              this.next()
              // import '...'
              if (this.type === tt.string) {
                node.specifiers = empty
                node.source = this.parseExprAtom()
              } else {
                node.specifiers = this.parseImportSpecifiers()
                this.expectContextual('from')
                node.source = this.type === tt.string
                  ? this.parseExprAtom()
                  : this.unexpected()
              }
              this.semicolon()
              return this.finishNode(node, 'ImportDeclaration')
            }

            // Parses a comma-separated list of module imports.

            pp$1.parseImportSpecifiers = function() {
              var this$1 = this

              var nodes = [],
                first = true
              if (this.type === tt.name) {
                // import defaultObj, { x, y as z } from '...'
                var node = this.startNode()
                node.local = this.parseIdent()
                this.checkLVal(node.local, true)
                nodes.push(this.finishNode(node, 'ImportDefaultSpecifier'))
                if (!this.eat(tt.comma)) return nodes
              }
              if (this.type === tt.star) {
                var node$1 = this.startNode()
                this.next()
                this.expectContextual('as')
                node$1.local = this.parseIdent()
                this.checkLVal(node$1.local, true)
                nodes.push(this.finishNode(node$1, 'ImportNamespaceSpecifier'))
                return nodes
              }
              this.expect(tt.braceL)
              while (!this.eat(tt.braceR)) {
                if (!first) {
                  this$1.expect(tt.comma)
                  if (this$1.afterTrailingComma(tt.braceR)) break
                } else first = false

                var node$2 = this$1.startNode()
                node$2.imported = this$1.parseIdent(true)
                if (this$1.eatContextual('as')) {
                  node$2.local = this$1.parseIdent()
                } else {
                  node$2.local = node$2.imported
                  if (this$1.isKeyword(node$2.local.name))
                    this$1.unexpected(node$2.local.start)
                  if (this$1.reservedWordsStrict.test(node$2.local.name))
                    this$1.raise(
                      node$2.local.start,
                      "The keyword '" + node$2.local.name + "' is reserved"
                    )
                }
                this$1.checkLVal(node$2.local, true)
                nodes.push(this$1.finishNode(node$2, 'ImportSpecifier'))
              }
              return nodes
            }

            var pp$2 = Parser.prototype

            // Convert existing expression atom to assignable pattern
            // if possible.

            pp$2.toAssignable = function(node, isBinding) {
              var this$1 = this

              if (this.options.ecmaVersion >= 6 && node) {
                switch (node.type) {
                  case 'Identifier':
                  case 'ObjectPattern':
                  case 'ArrayPattern':
                    break

                  case 'ObjectExpression':
                    node.type = 'ObjectPattern'
                    for (var i = 0; i < node.properties.length; i++) {
                      var prop = node.properties[i]
                      if (prop.kind !== 'init')
                        this$1.raise(
                          prop.key.start,
                          "Object pattern can't contain getter or setter"
                        )
                      this$1.toAssignable(prop.value, isBinding)
                    }
                    break

                  case 'ArrayExpression':
                    node.type = 'ArrayPattern'
                    this.toAssignableList(node.elements, isBinding)
                    break

                  case 'AssignmentExpression':
                    if (node.operator === '=') {
                      node.type = 'AssignmentPattern'
                      delete node.operator
                      // falls through to AssignmentPattern
                    } else {
                      this.raise(
                        node.left.end,
                        "Only '=' operator can be used for specifying default value."
                      )
                      break
                    }

                  case 'AssignmentPattern':
                    if (node.right.type === 'YieldExpression')
                      this.raise(
                        node.right.start,
                        'Yield expression cannot be a default value'
                      )
                    break

                  case 'ParenthesizedExpression':
                    node.expression = this.toAssignable(
                      node.expression,
                      isBinding
                    )
                    break

                  case 'MemberExpression':
                    if (!isBinding) break

                  default:
                    this.raise(node.start, 'Assigning to rvalue')
                }
              }
              return node
            }

            // Convert list of expression atoms to binding list.

            pp$2.toAssignableList = function(exprList, isBinding) {
              var this$1 = this

              var end = exprList.length
              if (end) {
                var last = exprList[end - 1]
                if (last && last.type == 'RestElement') {
                  --end
                } else if (last && last.type == 'SpreadElement') {
                  last.type = 'RestElement'
                  var arg = last.argument
                  this.toAssignable(arg, isBinding)
                  if (
                    arg.type !== 'Identifier' &&
                    arg.type !== 'MemberExpression' &&
                    arg.type !== 'ArrayPattern'
                  )
                    this.unexpected(arg.start)
                  --end
                }

                if (
                  isBinding &&
                  last &&
                  last.type === 'RestElement' &&
                  last.argument.type !== 'Identifier'
                )
                  this.unexpected(last.argument.start)
              }
              for (var i = 0; i < end; i++) {
                var elt = exprList[i]
                if (elt) this$1.toAssignable(elt, isBinding)
              }
              return exprList
            }

            // Parses spread element.

            pp$2.parseSpread = function(refDestructuringErrors) {
              var node = this.startNode()
              this.next()
              node.argument = this.parseMaybeAssign(
                false,
                refDestructuringErrors
              )
              return this.finishNode(node, 'SpreadElement')
            }

            pp$2.parseRest = function(allowNonIdent) {
              var node = this.startNode()
              this.next()

              // RestElement inside of a function parameter must be an identifier
              if (allowNonIdent)
                node.argument = this.type === tt.name
                  ? this.parseIdent()
                  : this.unexpected()
              else
                node.argument = this.type === tt.name ||
                  this.type === tt.bracketL
                  ? this.parseBindingAtom()
                  : this.unexpected()

              return this.finishNode(node, 'RestElement')
            }

            // Parses lvalue (assignable) atom.

            pp$2.parseBindingAtom = function() {
              if (this.options.ecmaVersion < 6) return this.parseIdent()
              switch (this.type) {
                case tt.name:
                  return this.parseIdent()

                case tt.bracketL:
                  var node = this.startNode()
                  this.next()
                  node.elements = this.parseBindingList(tt.bracketR, true, true)
                  return this.finishNode(node, 'ArrayPattern')

                case tt.braceL:
                  return this.parseObj(true)

                default:
                  this.unexpected()
              }
            }

            pp$2.parseBindingList = function(
              close,
              allowEmpty,
              allowTrailingComma,
              allowNonIdent
            ) {
              var this$1 = this

              var elts = [],
                first = true
              while (!this.eat(close)) {
                if (first) first = false
                else this$1.expect(tt.comma)
                if (allowEmpty && this$1.type === tt.comma) {
                  elts.push(null)
                } else if (
                  allowTrailingComma &&
                  this$1.afterTrailingComma(close)
                ) {
                  break
                } else if (this$1.type === tt.ellipsis) {
                  var rest = this$1.parseRest(allowNonIdent)
                  this$1.parseBindingListItem(rest)
                  elts.push(rest)
                  if (this$1.type === tt.comma)
                    this$1.raise(
                      this$1.start,
                      'Comma is not permitted after the rest element'
                    )
                  this$1.expect(close)
                  break
                } else {
                  var elem = this$1.parseMaybeDefault(
                    this$1.start,
                    this$1.startLoc
                  )
                  this$1.parseBindingListItem(elem)
                  elts.push(elem)
                }
              }
              return elts
            }

            pp$2.parseBindingListItem = function(param) {
              return param
            }

            // Parses assignment pattern around given atom if possible.

            pp$2.parseMaybeDefault = function(startPos, startLoc, left) {
              left = left || this.parseBindingAtom()
              if (this.options.ecmaVersion < 6 || !this.eat(tt.eq)) return left
              var node = this.startNodeAt(startPos, startLoc)
              node.left = left
              node.right = this.parseMaybeAssign()
              return this.finishNode(node, 'AssignmentPattern')
            }

            // Verify that a node is an lval  something that can be assigned
            // to.

            pp$2.checkLVal = function(expr, isBinding, checkClashes) {
              var this$1 = this

              switch (expr.type) {
                case 'Identifier':
                  if (
                    this.strict &&
                    this.reservedWordsStrictBind.test(expr.name)
                  )
                    this.raiseRecoverable(
                      expr.start,
                      (isBinding ? 'Binding ' : 'Assigning to ') +
                        expr.name +
                        ' in strict mode'
                    )
                  if (checkClashes) {
                    if (has(checkClashes, expr.name))
                      this.raiseRecoverable(expr.start, 'Argument name clash')
                    checkClashes[expr.name] = true
                  }
                  break

                case 'MemberExpression':
                  if (isBinding)
                    this.raiseRecoverable(
                      expr.start,
                      (isBinding ? 'Binding' : 'Assigning to') +
                        ' member expression'
                    )
                  break

                case 'ObjectPattern':
                  for (var i = 0; i < expr.properties.length; i++)
                    this$1.checkLVal(
                      expr.properties[i].value,
                      isBinding,
                      checkClashes
                    )
                  break

                case 'ArrayPattern':
                  for (var i$1 = 0; i$1 < expr.elements.length; i$1++) {
                    var elem = expr.elements[i$1]
                    if (elem) this$1.checkLVal(elem, isBinding, checkClashes)
                  }
                  break

                case 'AssignmentPattern':
                  this.checkLVal(expr.left, isBinding, checkClashes)
                  break

                case 'RestElement':
                  this.checkLVal(expr.argument, isBinding, checkClashes)
                  break

                case 'ParenthesizedExpression':
                  this.checkLVal(expr.expression, isBinding, checkClashes)
                  break

                default:
                  this.raise(
                    expr.start,
                    (isBinding ? 'Binding' : 'Assigning to') + ' rvalue'
                  )
              }
            }

            var pp$3 = Parser.prototype

            // Check if property name clashes with already added.
            // Object/class getters and setters are not allowed to clash 
            // either with each other or with an init property  and in
            // strict mode, init properties are also not allowed to be repeated.

            pp$3.checkPropClash = function(prop, propHash) {
              if (
                this.options.ecmaVersion >= 6 &&
                (prop.computed || prop.method || prop.shorthand)
              )
                return
              var key = prop.key
              var name
              switch (key.type) {
                case 'Identifier':
                  name = key.name
                  break
                case 'Literal':
                  name = String(key.value)
                  break
                default:
                  return
              }
              var kind = prop.kind
              if (this.options.ecmaVersion >= 6) {
                if (name === '__proto__' && kind === 'init') {
                  if (propHash.proto)
                    this.raiseRecoverable(
                      key.start,
                      'Redefinition of __proto__ property'
                    )
                  propHash.proto = true
                }
                return
              }
              name = '$' + name
              var other = propHash[name]
              if (other) {
                var isGetSet = kind !== 'init'
                if (
                  ((this.strict || isGetSet) && other[kind]) ||
                  !(isGetSet ^ other.init)
                )
                  this.raiseRecoverable(key.start, 'Redefinition of property')
              } else {
                other = propHash[name] = {
                  init: false,
                  get: false,
                  set: false,
                }
              }
              other[kind] = true
            }

            // ### Expression parsing

            // These nest, from the most general expression type at the top to
            // 'atomic', nondivisible expression types at the bottom. Most of
            // the functions will simply let the function(s) below them parse,
            // and, *if* the syntactic construct they handle is present, wrap
            // the AST node that the inner parser gave them in another node.

            // Parse a full expression. The optional arguments are used to
            // forbid the `in` operator (in for loops initalization expressions)
            // and provide reference for storing '=' operator inside shorthand
            // property assignment in contexts where both object expression
            // and object pattern might appear (so it's possible to raise
            // delayed syntax error at correct position).

            pp$3.parseExpression = function(noIn, refDestructuringErrors) {
              var this$1 = this

              var startPos = this.start,
                startLoc = this.startLoc
              var expr = this.parseMaybeAssign(noIn, refDestructuringErrors)
              if (this.type === tt.comma) {
                var node = this.startNodeAt(startPos, startLoc)
                node.expressions = [expr]
                while (this.eat(tt.comma))
                  node.expressions.push(
                    this$1.parseMaybeAssign(noIn, refDestructuringErrors)
                  )
                return this.finishNode(node, 'SequenceExpression')
              }
              return expr
            }

            // Parse an assignment expression. This includes applications of
            // operators like `+=`.

            pp$3.parseMaybeAssign = function(
              noIn,
              refDestructuringErrors,
              afterLeftParse
            ) {
              if (this.inGenerator && this.isContextual('yield'))
                return this.parseYield()

              var ownDestructuringErrors = false
              if (!refDestructuringErrors) {
                refDestructuringErrors = new DestructuringErrors()
                ownDestructuringErrors = true
              }
              var startPos = this.start,
                startLoc = this.startLoc
              if (this.type == tt.parenL || this.type == tt.name)
                this.potentialArrowAt = this.start
              var left = this.parseMaybeConditional(
                noIn,
                refDestructuringErrors
              )
              if (afterLeftParse)
                left = afterLeftParse.call(this, left, startPos, startLoc)
              if (this.type.isAssign) {
                this.checkPatternErrors(refDestructuringErrors, true)
                if (!ownDestructuringErrors)
                  DestructuringErrors.call(refDestructuringErrors)
                var node = this.startNodeAt(startPos, startLoc)
                node.operator = this.value
                node.left = this.type === tt.eq ? this.toAssignable(left) : left
                refDestructuringErrors.shorthandAssign = 0 // reset because shorthand default was used correctly
                this.checkLVal(left)
                this.next()
                node.right = this.parseMaybeAssign(noIn)
                return this.finishNode(node, 'AssignmentExpression')
              } else {
                if (ownDestructuringErrors)
                  this.checkExpressionErrors(refDestructuringErrors, true)
              }
              return left
            }

            // Parse a ternary conditional (`?:`) operator.

            pp$3.parseMaybeConditional = function(
              noIn,
              refDestructuringErrors
            ) {
              var startPos = this.start,
                startLoc = this.startLoc
              var expr = this.parseExprOps(noIn, refDestructuringErrors)
              if (this.checkExpressionErrors(refDestructuringErrors))
                return expr
              if (this.eat(tt.question)) {
                var node = this.startNodeAt(startPos, startLoc)
                node.test = expr
                node.consequent = this.parseMaybeAssign()
                this.expect(tt.colon)
                node.alternate = this.parseMaybeAssign(noIn)
                return this.finishNode(node, 'ConditionalExpression')
              }
              return expr
            }

            // Start the precedence parser.

            pp$3.parseExprOps = function(noIn, refDestructuringErrors) {
              var startPos = this.start,
                startLoc = this.startLoc
              var expr = this.parseMaybeUnary(refDestructuringErrors, false)
              if (this.checkExpressionErrors(refDestructuringErrors))
                return expr
              return this.parseExprOp(expr, startPos, startLoc, -1, noIn)
            }

            // Parse binary operators with the operator precedence parsing
            // algorithm. `left` is the left-hand side of the operator.
            // `minPrec` provides context that allows the function to stop and
            // defer further parser to one of its callers when it encounters an
            // operator that has a lower precedence than the set it is parsing.

            pp$3.parseExprOp = function(
              left,
              leftStartPos,
              leftStartLoc,
              minPrec,
              noIn
            ) {
              var prec = this.type.binop
              if (prec != null && (!noIn || this.type !== tt._in)) {
                if (prec > minPrec) {
                  var logical =
                    this.type === tt.logicalOR || this.type === tt.logicalAND
                  var op = this.value
                  this.next()
                  var startPos = this.start,
                    startLoc = this.startLoc
                  var right = this.parseExprOp(
                    this.parseMaybeUnary(null, false),
                    startPos,
                    startLoc,
                    prec,
                    noIn
                  )
                  var node = this.buildBinary(
                    leftStartPos,
                    leftStartLoc,
                    left,
                    right,
                    op,
                    logical
                  )
                  return this.parseExprOp(
                    node,
                    leftStartPos,
                    leftStartLoc,
                    minPrec,
                    noIn
                  )
                }
              }
              return left
            }

            pp$3.buildBinary = function(
              startPos,
              startLoc,
              left,
              right,
              op,
              logical
            ) {
              var node = this.startNodeAt(startPos, startLoc)
              node.left = left
              node.operator = op
              node.right = right
              return this.finishNode(
                node,
                logical ? 'LogicalExpression' : 'BinaryExpression'
              )
            }

            // Parse unary operators, both prefix and postfix.

            pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {
              var this$1 = this

              var startPos = this.start,
                startLoc = this.startLoc,
                expr
              if (this.type.prefix) {
                var node = this.startNode(),
                  update = this.type === tt.incDec
                node.operator = this.value
                node.prefix = true
                this.next()
                node.argument = this.parseMaybeUnary(null, true)
                this.checkExpressionErrors(refDestructuringErrors, true)
                if (update) this.checkLVal(node.argument)
                else if (
                  this.strict &&
                  node.operator === 'delete' &&
                  node.argument.type === 'Identifier'
                )
                  this.raiseRecoverable(
                    node.start,
                    'Deleting local variable in strict mode'
                  )
                else sawUnary = true
                expr = this.finishNode(
                  node,
                  update ? 'UpdateExpression' : 'UnaryExpression'
                )
              } else {
                expr = this.parseExprSubscripts(refDestructuringErrors)
                if (this.checkExpressionErrors(refDestructuringErrors))
                  return expr
                while (this.type.postfix && !this.canInsertSemicolon()) {
                  var node$1 = this$1.startNodeAt(startPos, startLoc)
                  node$1.operator = this$1.value
                  node$1.prefix = false
                  node$1.argument = expr
                  this$1.checkLVal(expr)
                  this$1.next()
                  expr = this$1.finishNode(node$1, 'UpdateExpression')
                }
              }

              if (!sawUnary && this.eat(tt.starstar))
                return this.buildBinary(
                  startPos,
                  startLoc,
                  expr,
                  this.parseMaybeUnary(null, false),
                  '**',
                  false
                )
              else return expr
            }

            // Parse call, dot, and `[]`-subscript expressions.

            pp$3.parseExprSubscripts = function(refDestructuringErrors) {
              var startPos = this.start,
                startLoc = this.startLoc
              var expr = this.parseExprAtom(refDestructuringErrors)
              var skipArrowSubscripts =
                expr.type === 'ArrowFunctionExpression' &&
                this.input.slice(this.lastTokStart, this.lastTokEnd) !== ')'
              if (
                this.checkExpressionErrors(refDestructuringErrors) ||
                skipArrowSubscripts
              )
                return expr
              return this.parseSubscripts(expr, startPos, startLoc)
            }

            pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {
              var this$1 = this

              for (;;) {
                if (this$1.eat(tt.dot)) {
                  var node = this$1.startNodeAt(startPos, startLoc)
                  node.object = base
                  node.property = this$1.parseIdent(true)
                  node.computed = false
                  base = this$1.finishNode(node, 'MemberExpression')
                } else if (this$1.eat(tt.bracketL)) {
                  var node$1 = this$1.startNodeAt(startPos, startLoc)
                  node$1.object = base
                  node$1.property = this$1.parseExpression()
                  node$1.computed = true
                  this$1.expect(tt.bracketR)
                  base = this$1.finishNode(node$1, 'MemberExpression')
                } else if (!noCalls && this$1.eat(tt.parenL)) {
                  var node$2 = this$1.startNodeAt(startPos, startLoc)
                  node$2.callee = base
                  node$2.arguments = this$1.parseExprList(tt.parenR, false)
                  base = this$1.finishNode(node$2, 'CallExpression')
                } else if (this$1.type === tt.backQuote) {
                  var node$3 = this$1.startNodeAt(startPos, startLoc)
                  node$3.tag = base
                  node$3.quasi = this$1.parseTemplate()
                  base = this$1.finishNode(node$3, 'TaggedTemplateExpression')
                } else {
                  return base
                }
              }
            }

            // Parse an atomic expression  either a single token that is an
            // expression, an expression started by a keyword like `function` or
            // `new`, or an expression wrapped in punctuation like `()`, `[]`,
            // or `{}`.

            pp$3.parseExprAtom = function(refDestructuringErrors) {
              var node,
                canBeArrow = this.potentialArrowAt == this.start
              switch (this.type) {
                case tt._super:
                  if (!this.inFunction)
                    this.raise(
                      this.start,
                      "'super' outside of function or class"
                    )

                case tt._this:
                  var type = this.type === tt._this ? 'ThisExpression' : 'Super'
                  node = this.startNode()
                  this.next()
                  return this.finishNode(node, type)

                case tt.name:
                  var startPos = this.start,
                    startLoc = this.startLoc
                  var id = this.parseIdent(this.type !== tt.name)
                  if (
                    canBeArrow &&
                    !this.canInsertSemicolon() &&
                    this.eat(tt.arrow)
                  )
                    return this.parseArrowExpression(
                      this.startNodeAt(startPos, startLoc),
                      [id]
                    )
                  return id

                case tt.regexp:
                  var value = this.value
                  node = this.parseLiteral(value.value)
                  node.regex = { pattern: value.pattern, flags: value.flags }
                  return node

                case tt.num:
                case tt.string:
                  return this.parseLiteral(this.value)

                case tt._null:
                case tt._true:
                case tt._false:
                  node = this.startNode()
                  node.value = this.type === tt._null
                    ? null
                    : this.type === tt._true
                  node.raw = this.type.keyword
                  this.next()
                  return this.finishNode(node, 'Literal')

                case tt.parenL:
                  return this.parseParenAndDistinguishExpression(canBeArrow)

                case tt.bracketL:
                  node = this.startNode()
                  this.next()
                  node.elements = this.parseExprList(
                    tt.bracketR,
                    true,
                    true,
                    refDestructuringErrors
                  )
                  return this.finishNode(node, 'ArrayExpression')

                case tt.braceL:
                  return this.parseObj(false, refDestructuringErrors)

                case tt._function:
                  node = this.startNode()
                  this.next()
                  return this.parseFunction(node, false)

                case tt._class:
                  return this.parseClass(this.startNode(), false)

                case tt._new:
                  return this.parseNew()

                case tt.backQuote:
                  return this.parseTemplate()

                default:
                  this.unexpected()
              }
            }

            pp$3.parseLiteral = function(value) {
              var node = this.startNode()
              node.value = value
              node.raw = this.input.slice(this.start, this.end)
              this.next()
              return this.finishNode(node, 'Literal')
            }

            pp$3.parseParenExpression = function() {
              this.expect(tt.parenL)
              var val = this.parseExpression()
              this.expect(tt.parenR)
              return val
            }

            pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {
              var this$1 = this

              var startPos = this.start,
                startLoc = this.startLoc,
                val
              if (this.options.ecmaVersion >= 6) {
                this.next()

                var innerStartPos = this.start,
                  innerStartLoc = this.startLoc
                var exprList = [],
                  first = true
                var refDestructuringErrors = new DestructuringErrors(),
                  spreadStart,
                  innerParenStart
                while (this.type !== tt.parenR) {
                  first ? (first = false) : this$1.expect(tt.comma)
                  if (this$1.type === tt.ellipsis) {
                    spreadStart = this$1.start
                    exprList.push(this$1.parseParenItem(this$1.parseRest()))
                    break
                  } else {
                    if (this$1.type === tt.parenL && !innerParenStart) {
                      innerParenStart = this$1.start
                    }
                    exprList.push(
                      this$1.parseMaybeAssign(
                        false,
                        refDestructuringErrors,
                        this$1.parseParenItem
                      )
                    )
                  }
                }
                var innerEndPos = this.start,
                  innerEndLoc = this.startLoc
                this.expect(tt.parenR)

                if (
                  canBeArrow &&
                  !this.canInsertSemicolon() &&
                  this.eat(tt.arrow)
                ) {
                  this.checkPatternErrors(refDestructuringErrors, true)
                  if (innerParenStart) this.unexpected(innerParenStart)
                  return this.parseParenArrowList(startPos, startLoc, exprList)
                }

                if (!exprList.length) this.unexpected(this.lastTokStart)
                if (spreadStart) this.unexpected(spreadStart)
                this.checkExpressionErrors(refDestructuringErrors, true)

                if (exprList.length > 1) {
                  val = this.startNodeAt(innerStartPos, innerStartLoc)
                  val.expressions = exprList
                  this.finishNodeAt(
                    val,
                    'SequenceExpression',
                    innerEndPos,
                    innerEndLoc
                  )
                } else {
                  val = exprList[0]
                }
              } else {
                val = this.parseParenExpression()
              }

              if (this.options.preserveParens) {
                var par = this.startNodeAt(startPos, startLoc)
                par.expression = val
                return this.finishNode(par, 'ParenthesizedExpression')
              } else {
                return val
              }
            }

            pp$3.parseParenItem = function(item) {
              return item
            }

            pp$3.parseParenArrowList = function(startPos, startLoc, exprList) {
              return this.parseArrowExpression(
                this.startNodeAt(startPos, startLoc),
                exprList
              )
            }

            // New's precedence is slightly tricky. It must allow its argument to
            // be a `[]` or dot subscript expression, but not a call  at least,
            // not without wrapping it in parentheses. Thus, it uses the noCalls
            // argument to parseSubscripts to prevent it from consuming the
            // argument list.

            var empty$1 = []

            pp$3.parseNew = function() {
              var node = this.startNode()
              var meta = this.parseIdent(true)
              if (this.options.ecmaVersion >= 6 && this.eat(tt.dot)) {
                node.meta = meta
                node.property = this.parseIdent(true)
                if (node.property.name !== 'target')
                  this.raiseRecoverable(
                    node.property.start,
                    'The only valid meta property for new is new.target'
                  )
                if (!this.inFunction)
                  this.raiseRecoverable(
                    node.start,
                    'new.target can only be used in functions'
                  )
                return this.finishNode(node, 'MetaProperty')
              }
              var startPos = this.start,
                startLoc = this.startLoc
              node.callee = this.parseSubscripts(
                this.parseExprAtom(),
                startPos,
                startLoc,
                true
              )
              if (this.eat(tt.parenL))
                node.arguments = this.parseExprList(tt.parenR, false)
              else node.arguments = empty$1
              return this.finishNode(node, 'NewExpression')
            }

            // Parse template expression.

            pp$3.parseTemplateElement = function() {
              var elem = this.startNode()
              elem.value = {
                raw: this.input
                  .slice(this.start, this.end)
                  .replace(/\r\n?/g, '\n'),
                cooked: this.value,
              }
              this.next()
              elem.tail = this.type === tt.backQuote
              return this.finishNode(elem, 'TemplateElement')
            }

            pp$3.parseTemplate = function() {
              var this$1 = this

              var node = this.startNode()
              this.next()
              node.expressions = []
              var curElt = this.parseTemplateElement()
              node.quasis = [curElt]
              while (!curElt.tail) {
                this$1.expect(tt.dollarBraceL)
                node.expressions.push(this$1.parseExpression())
                this$1.expect(tt.braceR)
                node.quasis.push((curElt = this$1.parseTemplateElement()))
              }
              this.next()
              return this.finishNode(node, 'TemplateLiteral')
            }

            // Parse an object literal or binding pattern.

            pp$3.parseObj = function(isPattern, refDestructuringErrors) {
              var this$1 = this

              var node = this.startNode(),
                first = true,
                propHash = {}
              node.properties = []
              this.next()
              while (!this.eat(tt.braceR)) {
                if (!first) {
                  this$1.expect(tt.comma)
                  if (this$1.afterTrailingComma(tt.braceR)) break
                } else first = false

                var prop = this$1.startNode(),
                  isGenerator,
                  startPos,
                  startLoc
                if (this$1.options.ecmaVersion >= 6) {
                  prop.method = false
                  prop.shorthand = false
                  if (isPattern || refDestructuringErrors) {
                    startPos = this$1.start
                    startLoc = this$1.startLoc
                  }
                  if (!isPattern) isGenerator = this$1.eat(tt.star)
                }
                this$1.parsePropertyName(prop)
                this$1.parsePropertyValue(
                  prop,
                  isPattern,
                  isGenerator,
                  startPos,
                  startLoc,
                  refDestructuringErrors
                )
                this$1.checkPropClash(prop, propHash)
                node.properties.push(this$1.finishNode(prop, 'Property'))
              }
              return this.finishNode(
                node,
                isPattern ? 'ObjectPattern' : 'ObjectExpression'
              )
            }

            pp$3.parsePropertyValue = function(
              prop,
              isPattern,
              isGenerator,
              startPos,
              startLoc,
              refDestructuringErrors
            ) {
              if (this.eat(tt.colon)) {
                prop.value = isPattern
                  ? this.parseMaybeDefault(this.start, this.startLoc)
                  : this.parseMaybeAssign(false, refDestructuringErrors)
                prop.kind = 'init'
              } else if (
                this.options.ecmaVersion >= 6 &&
                this.type === tt.parenL
              ) {
                if (isPattern) this.unexpected()
                prop.kind = 'init'
                prop.method = true
                prop.value = this.parseMethod(isGenerator)
              } else if (
                this.options.ecmaVersion >= 5 &&
                !prop.computed &&
                prop.key.type === 'Identifier' &&
                (prop.key.name === 'get' || prop.key.name === 'set') &&
                (this.type != tt.comma && this.type != tt.braceR)
              ) {
                if (isGenerator || isPattern) this.unexpected()
                prop.kind = prop.key.name
                this.parsePropertyName(prop)
                prop.value = this.parseMethod(false)
                var paramCount = prop.kind === 'get' ? 0 : 1
                if (prop.value.params.length !== paramCount) {
                  var start = prop.value.start
                  if (prop.kind === 'get')
                    this.raiseRecoverable(start, 'getter should have no params')
                  else
                    this.raiseRecoverable(
                      start,
                      'setter should have exactly one param'
                    )
                }
                if (
                  prop.kind === 'set' &&
                  prop.value.params[0].type === 'RestElement'
                )
                  this.raiseRecoverable(
                    prop.value.params[0].start,
                    'Setter cannot use rest params'
                  )
              } else if (
                this.options.ecmaVersion >= 6 &&
                !prop.computed &&
                prop.key.type === 'Identifier'
              ) {
                if (
                  this.keywords.test(prop.key.name) ||
                  (this.strict
                    ? this.reservedWordsStrictBind
                    : this.reservedWords).test(prop.key.name) ||
                  (this.inGenerator && prop.key.name == 'yield')
                )
                  this.raiseRecoverable(
                    prop.key.start,
                    "'" +
                      prop.key.name +
                      "' can not be used as shorthand property"
                  )
                prop.kind = 'init'
                if (isPattern) {
                  prop.value = this.parseMaybeDefault(
                    startPos,
                    startLoc,
                    prop.key
                  )
                } else if (this.type === tt.eq && refDestructuringErrors) {
                  if (!refDestructuringErrors.shorthandAssign)
                    refDestructuringErrors.shorthandAssign = this.start
                  prop.value = this.parseMaybeDefault(
                    startPos,
                    startLoc,
                    prop.key
                  )
                } else {
                  prop.value = prop.key
                }
                prop.shorthand = true
              } else this.unexpected()
            }

            pp$3.parsePropertyName = function(prop) {
              if (this.options.ecmaVersion >= 6) {
                if (this.eat(tt.bracketL)) {
                  prop.computed = true
                  prop.key = this.parseMaybeAssign()
                  this.expect(tt.bracketR)
                  return prop.key
                } else {
                  prop.computed = false
                }
              }
              return (prop.key = this.type === tt.num || this.type === tt.string
                ? this.parseExprAtom()
                : this.parseIdent(true))
            }

            // Initialize empty function node.

            pp$3.initFunction = function(node) {
              node.id = null
              if (this.options.ecmaVersion >= 6) {
                node.generator = false
                node.expression = false
              }
            }

            // Parse object or class method.

            pp$3.parseMethod = function(isGenerator) {
              var node = this.startNode(),
                oldInGen = this.inGenerator
              this.inGenerator = isGenerator
              this.initFunction(node)
              this.expect(tt.parenL)
              node.params = this.parseBindingList(tt.parenR, false, false)
              if (this.options.ecmaVersion >= 6) node.generator = isGenerator
              this.parseFunctionBody(node, false)
              this.inGenerator = oldInGen
              return this.finishNode(node, 'FunctionExpression')
            }

            // Parse arrow function expression with given parameters.

            pp$3.parseArrowExpression = function(node, params) {
              var oldInGen = this.inGenerator
              this.inGenerator = false
              this.initFunction(node)
              node.params = this.toAssignableList(params, true)
              this.parseFunctionBody(node, true)
              this.inGenerator = oldInGen
              return this.finishNode(node, 'ArrowFunctionExpression')
            }

            // Parse function body and check parameters.

            pp$3.parseFunctionBody = function(node, isArrowFunction) {
              var isExpression = isArrowFunction && this.type !== tt.braceL

              if (isExpression) {
                node.body = this.parseMaybeAssign()
                node.expression = true
              } else {
                // Start a new scope with regard to labels and the `inFunction`
                // flag (restore them to their old value afterwards).
                var oldInFunc = this.inFunction,
                  oldLabels = this.labels
                this.inFunction = true
                this.labels = []
                node.body = this.parseBlock(true)
                node.expression = false
                this.inFunction = oldInFunc
                this.labels = oldLabels
              }

              // If this is a strict mode function, verify that argument names
              // are not repeated, and it does not try to bind the words `eval`
              // or `arguments`.
              var useStrict = !isExpression &&
                node.body.body.length &&
                this.isUseStrict(node.body.body[0])
                ? node.body.body[0]
                : null
              if (this.strict || useStrict) {
                var oldStrict = this.strict
                this.strict = true
                if (node.id) this.checkLVal(node.id, true)
                this.checkParams(node, useStrict)
                this.strict = oldStrict
              } else if (isArrowFunction) {
                this.checkParams(node, useStrict)
              }
            }

            // Checks function params for various disallowed patterns such as using "eval"
            // or "arguments" and duplicate parameters.

            pp$3.checkParams = function(node, useStrict) {
              var this$1 = this

              var nameHash = {}
              for (var i = 0; i < node.params.length; i++) {
                if (
                  useStrict &&
                  this$1.options.ecmaVersion >= 7 &&
                  node.params[i].type !== 'Identifier'
                )
                  this$1.raiseRecoverable(
                    useStrict.start,
                    "Illegal 'use strict' directive in function with non-simple parameter list"
                  )
                this$1.checkLVal(node.params[i], true, nameHash)
              }
            }

            // Parses a comma-separated list of expressions, and returns them as
            // an array. `close` is the token type that ends the list, and
            // `allowEmpty` can be turned on to allow subsequent commas with
            // nothing in between them to be parsed as `null` (which is needed
            // for array literals).

            pp$3.parseExprList = function(
              close,
              allowTrailingComma,
              allowEmpty,
              refDestructuringErrors
            ) {
              var this$1 = this

              var elts = [],
                first = true
              while (!this.eat(close)) {
                if (!first) {
                  this$1.expect(tt.comma)
                  if (allowTrailingComma && this$1.afterTrailingComma(close))
                    break
                } else first = false

                var elt
                if (allowEmpty && this$1.type === tt.comma) elt = null
                else if (this$1.type === tt.ellipsis) {
                  elt = this$1.parseSpread(refDestructuringErrors)
                  if (
                    this$1.type === tt.comma &&
                    refDestructuringErrors &&
                    !refDestructuringErrors.trailingComma
                  ) {
                    refDestructuringErrors.trailingComma = this$1.lastTokStart
                  }
                } else
                  elt = this$1.parseMaybeAssign(false, refDestructuringErrors)
                elts.push(elt)
              }
              return elts
            }

            // Parse the next token as an identifier. If `liberal` is true (used
            // when parsing properties), it will also convert keywords into
            // identifiers.

            pp$3.parseIdent = function(liberal) {
              var node = this.startNode()
              if (liberal && this.options.allowReserved == 'never')
                liberal = false
              if (this.type === tt.name) {
                if (
                  !liberal &&
                  (this.strict
                    ? this.reservedWordsStrict
                    : this.reservedWords).test(this.value) &&
                  (this.options.ecmaVersion >= 6 ||
                    this.input.slice(this.start, this.end).indexOf('\\') == -1)
                )
                  this.raiseRecoverable(
                    this.start,
                    "The keyword '" + this.value + "' is reserved"
                  )
                if (!liberal && this.inGenerator && this.value === 'yield')
                  this.raiseRecoverable(
                    this.start,
                    "Can not use 'yield' as identifier inside a generator"
                  )
                node.name = this.value
              } else if (liberal && this.type.keyword) {
                node.name = this.type.keyword
              } else {
                this.unexpected()
              }
              this.next()
              return this.finishNode(node, 'Identifier')
            }

            // Parses yield expression inside generator.

            pp$3.parseYield = function() {
              var node = this.startNode()
              this.next()
              if (
                this.type == tt.semi ||
                this.canInsertSemicolon() ||
                (this.type != tt.star && !this.type.startsExpr)
              ) {
                node.delegate = false
                node.argument = null
              } else {
                node.delegate = this.eat(tt.star)
                node.argument = this.parseMaybeAssign()
              }
              return this.finishNode(node, 'YieldExpression')
            }

            var pp$4 = Parser.prototype

            // This function is used to raise exceptions on parse errors. It
            // takes an offset integer (into the current `input`) to indicate
            // the location of the error, attaches the position to the end
            // of the error message, and then raises a `SyntaxError` with that
            // message.

            pp$4.raise = function(pos, message) {
              var loc = getLineInfo(this.input, pos)
              message += ' (' + loc.line + ':' + loc.column + ')'
              var err = new SyntaxError(message)
              err.pos = pos
              err.loc = loc
              err.raisedAt = this.pos
              throw err
            }

            pp$4.raiseRecoverable = pp$4.raise

            pp$4.curPosition = function() {
              if (this.options.locations) {
                return new Position(this.curLine, this.pos - this.lineStart)
              }
            }

            var Node = function Node(parser, pos, loc) {
              this.type = ''
              this.start = pos
              this.end = 0
              if (parser.options.locations)
                this.loc = new SourceLocation(parser, loc)
              if (parser.options.directSourceFile)
                this.sourceFile = parser.options.directSourceFile
              if (parser.options.ranges) this.range = [pos, 0]
            }

            // Start an AST node, attaching a start offset.

            var pp$5 = Parser.prototype

            pp$5.startNode = function() {
              return new Node(this, this.start, this.startLoc)
            }

            pp$5.startNodeAt = function(pos, loc) {
              return new Node(this, pos, loc)
            }

            // Finish an AST node, adding `type` and `end` properties.

            function finishNodeAt(node, type, pos, loc) {
              node.type = type
              node.end = pos
              if (this.options.locations) node.loc.end = loc
              if (this.options.ranges) node.range[1] = pos
              return node
            }

            pp$5.finishNode = function(node, type) {
              return finishNodeAt.call(
                this,
                node,
                type,
                this.lastTokEnd,
                this.lastTokEndLoc
              )
            }

            // Finish node at given position

            pp$5.finishNodeAt = function(node, type, pos, loc) {
              return finishNodeAt.call(this, node, type, pos, loc)
            }

            var TokContext = function TokContext(
              token,
              isExpr,
              preserveSpace,
              override
            ) {
              this.token = token
              this.isExpr = !!isExpr
              this.preserveSpace = !!preserveSpace
              this.override = override
            }

            var types = {
              b_stat: new TokContext('{', false),
              b_expr: new TokContext('{', true),
              b_tmpl: new TokContext('${', true),
              p_stat: new TokContext('(', false),
              p_expr: new TokContext('(', true),
              q_tmpl: new TokContext('`', true, true, function(p) {
                return p.readTmplToken()
              }),
              f_expr: new TokContext('function', true),
            }

            var pp$6 = Parser.prototype

            pp$6.initialContext = function() {
              return [types.b_stat]
            }

            pp$6.braceIsBlock = function(prevType) {
              if (prevType === tt.colon) {
                var parent = this.curContext()
                if (parent === types.b_stat || parent === types.b_expr)
                  return !parent.isExpr
              }
              if (prevType === tt._return)
                return lineBreak.test(
                  this.input.slice(this.lastTokEnd, this.start)
                )
              if (
                prevType === tt._else ||
                prevType === tt.semi ||
                prevType === tt.eof ||
                prevType === tt.parenR
              )
                return true
              if (prevType == tt.braceL)
                return this.curContext() === types.b_stat
              return !this.exprAllowed
            }

            pp$6.updateContext = function(prevType) {
              var update,
                type = this.type
              if (type.keyword && prevType == tt.dot) this.exprAllowed = false
              else if ((update = type.updateContext))
                update.call(this, prevType)
              else this.exprAllowed = type.beforeExpr
            }

            // Token-specific context update code

            tt.parenR.updateContext = tt.braceR.updateContext = function() {
              if (this.context.length == 1) {
                this.exprAllowed = true
                return
              }
              var out = this.context.pop()
              if (out === types.b_stat && this.curContext() === types.f_expr) {
                this.context.pop()
                this.exprAllowed = false
              } else if (out === types.b_tmpl) {
                this.exprAllowed = true
              } else {
                this.exprAllowed = !out.isExpr
              }
            }

            tt.braceL.updateContext = function(prevType) {
              this.context.push(
                this.braceIsBlock(prevType) ? types.b_stat : types.b_expr
              )
              this.exprAllowed = true
            }

            tt.dollarBraceL.updateContext = function() {
              this.context.push(types.b_tmpl)
              this.exprAllowed = true
            }

            tt.parenL.updateContext = function(prevType) {
              var statementParens =
                prevType === tt._if ||
                prevType === tt._for ||
                prevType === tt._with ||
                prevType === tt._while
              this.context.push(statementParens ? types.p_stat : types.p_expr)
              this.exprAllowed = true
            }

            tt.incDec.updateContext = function() {
              // tokExprAllowed stays unchanged
            }

            tt._function.updateContext = function(prevType) {
              if (
                prevType.beforeExpr &&
                prevType !== tt.semi &&
                prevType !== tt._else &&
                !(
                  (prevType === tt.colon || prevType === tt.braceL) &&
                  this.curContext() === types.b_stat
                )
              )
                this.context.push(types.f_expr)
              this.exprAllowed = false
            }

            tt.backQuote.updateContext = function() {
              if (this.curContext() === types.q_tmpl) this.context.pop()
              else this.context.push(types.q_tmpl)
              this.exprAllowed = false
            }

            // Object type used to represent tokens. Note that normally, tokens
            // simply exist as properties on the parser object. This is only
            // used for the onToken callback and the external tokenizer.

            var Token = function Token(p) {
              this.type = p.type
              this.value = p.value
              this.start = p.start
              this.end = p.end
              if (p.options.locations)
                this.loc = new SourceLocation(p, p.startLoc, p.endLoc)
              if (p.options.ranges) this.range = [p.start, p.end]
            }

            // ## Tokenizer

            var pp$7 = Parser.prototype

            // Are we running under Rhino?
            var isRhino =
              typeof Packages == 'object' &&
              Object.prototype.toString.call(Packages) == '[object JavaPackage]'

            // Move to the next token

            pp$7.next = function() {
              if (this.options.onToken) this.options.onToken(new Token(this))

              this.lastTokEnd = this.end
              this.lastTokStart = this.start
              this.lastTokEndLoc = this.endLoc
              this.lastTokStartLoc = this.startLoc
              this.nextToken()
            }

            pp$7.getToken = function() {
              this.next()
              return new Token(this)
            }

            // If we're in an ES6 environment, make parsers iterable
            if (typeof Symbol !== 'undefined')
              pp$7[Symbol.iterator] = function() {
                var self = this
                return {
                  next: function() {
                    var token = self.getToken()
                    return {
                      done: token.type === tt.eof,
                      value: token,
                    }
                  },
                }
              }

            // Toggle strict mode. Re-reads the next number or string to please
            // pedantic tests (`"use strict"; 010;` should fail).

            pp$7.setStrict = function(strict) {
              var this$1 = this

              this.strict = strict
              if (this.type !== tt.num && this.type !== tt.string) return
              this.pos = this.start
              if (this.options.locations) {
                while (this.pos < this.lineStart) {
                  this$1.lineStart =
                    this$1.input.lastIndexOf('\n', this$1.lineStart - 2) + 1
                  --this$1.curLine
                }
              }
              this.nextToken()
            }

            pp$7.curContext = function() {
              return this.context[this.context.length - 1]
            }

            // Read a single token, updating the parser object's token-related
            // properties.

            pp$7.nextToken = function() {
              var curContext = this.curContext()
              if (!curContext || !curContext.preserveSpace) this.skipSpace()

              this.start = this.pos
              if (this.options.locations) this.startLoc = this.curPosition()
              if (this.pos >= this.input.length) return this.finishToken(tt.eof)

              if (curContext.override) return curContext.override(this)
              else this.readToken(this.fullCharCodeAtPos())
            }

            pp$7.readToken = function(code) {
              // Identifier or keyword. '\uXXXX' sequences are allowed in
              // identifiers, so '\' also dispatches to that.
              if (
                isIdentifierStart(code, this.options.ecmaVersion >= 6) ||
                code === 92 /* '\' */
              )
                return this.readWord()

              return this.getTokenFromCode(code)
            }

            pp$7.fullCharCodeAtPos = function() {
              var code = this.input.charCodeAt(this.pos)
              if (code <= 0xd7ff || code >= 0xe000) return code
              var next = this.input.charCodeAt(this.pos + 1)
              return (code << 10) + next - 0x35fdc00
            }

            pp$7.skipBlockComment = function() {
              var this$1 = this

              var startLoc = this.options.onComment && this.curPosition()
              var start = this.pos,
                end = this.input.indexOf('*/', (this.pos += 2))
              if (end === -1) this.raise(this.pos - 2, 'Unterminated comment')
              this.pos = end + 2
              if (this.options.locations) {
                lineBreakG.lastIndex = start
                var match
                while (
                  (match = lineBreakG.exec(this.input)) &&
                  match.index < this.pos
                ) {
                  ++this$1.curLine
                  this$1.lineStart = match.index + match[0].length
                }
              }
              if (this.options.onComment)
                this.options.onComment(
                  true,
                  this.input.slice(start + 2, end),
                  start,
                  this.pos,
                  startLoc,
                  this.curPosition()
                )
            }

            pp$7.skipLineComment = function(startSkip) {
              var this$1 = this

              var start = this.pos
              var startLoc = this.options.onComment && this.curPosition()
              var ch = this.input.charCodeAt((this.pos += startSkip))
              while (
                this.pos < this.input.length &&
                ch !== 10 &&
                ch !== 13 &&
                ch !== 8232 &&
                ch !== 8233
              ) {
                ++this$1.pos
                ch = this$1.input.charCodeAt(this$1.pos)
              }
              if (this.options.onComment)
                this.options.onComment(
                  false,
                  this.input.slice(start + startSkip, this.pos),
                  start,
                  this.pos,
                  startLoc,
                  this.curPosition()
                )
            }

            // Called at the start of the parse and after every token. Skips
            // whitespace and comments, and.

            pp$7.skipSpace = function() {
              var this$1 = this

              loop: while (this.pos < this.input.length) {
                var ch = this$1.input.charCodeAt(this$1.pos)
                switch (ch) {
                  case 32:
                  case 160: // ' '
                    ++this$1.pos
                    break
                  case 13:
                    if (this$1.input.charCodeAt(this$1.pos + 1) === 10) {
                      ++this$1.pos
                    }
                  case 10:
                  case 8232:
                  case 8233:
                    ++this$1.pos
                    if (this$1.options.locations) {
                      ++this$1.curLine
                      this$1.lineStart = this$1.pos
                    }
                    break
                  case 47: // '/'
                    switch (this$1.input.charCodeAt(this$1.pos + 1)) {
                      case 42: // '*'
                        this$1.skipBlockComment()
                        break
                      case 47:
                        this$1.skipLineComment(2)
                        break
                      default:
                        break loop
                    }
                    break
                  default:
                    if (
                      (ch > 8 && ch < 14) ||
                      (ch >= 5760 &&
                        nonASCIIwhitespace.test(String.fromCharCode(ch)))
                    ) {
                      ++this$1.pos
                    } else {
                      break loop
                    }
                }
              }
            }

            // Called at the end of every token. Sets `end`, `val`, and
            // maintains `context` and `exprAllowed`, and skips the space after
            // the token, so that the next one's `start` will point at the
            // right position.

            pp$7.finishToken = function(type, val) {
              this.end = this.pos
              if (this.options.locations) this.endLoc = this.curPosition()
              var prevType = this.type
              this.type = type
              this.value = val

              this.updateContext(prevType)
            }

            // ### Token reading

            // This is the function that is called to fetch the next token. It
            // is somewhat obscure, because it works in character codes rather
            // than characters, and because operator parsing has been inlined
            // into it.
            //
            // All in the name of speed.
            //
            pp$7.readToken_dot = function() {
              var next = this.input.charCodeAt(this.pos + 1)
              if (next >= 48 && next <= 57) return this.readNumber(true)
              var next2 = this.input.charCodeAt(this.pos + 2)
              if (
                this.options.ecmaVersion >= 6 &&
                next === 46 &&
                next2 === 46
              ) {
                // 46 = dot '.'
                this.pos += 3
                return this.finishToken(tt.ellipsis)
              } else {
                ++this.pos
                return this.finishToken(tt.dot)
              }
            }

            pp$7.readToken_slash = function() {
              // '/'
              var next = this.input.charCodeAt(this.pos + 1)
              if (this.exprAllowed) {
                ++this.pos
                return this.readRegexp()
              }
              if (next === 61) return this.finishOp(tt.assign, 2)
              return this.finishOp(tt.slash, 1)
            }

            pp$7.readToken_mult_modulo_exp = function(code) {
              // '%*'
              var next = this.input.charCodeAt(this.pos + 1)
              var size = 1
              var tokentype = code === 42 ? tt.star : tt.modulo

              // exponentiation operator ** and **=
              if (this.options.ecmaVersion >= 7 && next === 42) {
                ++size
                tokentype = tt.starstar
                next = this.input.charCodeAt(this.pos + 2)
              }

              if (next === 61) return this.finishOp(tt.assign, size + 1)
              return this.finishOp(tokentype, size)
            }

            pp$7.readToken_pipe_amp = function(code) {
              // '|&'
              var next = this.input.charCodeAt(this.pos + 1)
              if (next === code)
                return this.finishOp(
                  code === 124 ? tt.logicalOR : tt.logicalAND,
                  2
                )
              if (next === 61) return this.finishOp(tt.assign, 2)
              return this.finishOp(
                code === 124 ? tt.bitwiseOR : tt.bitwiseAND,
                1
              )
            }

            pp$7.readToken_caret = function() {
              // '^'
              var next = this.input.charCodeAt(this.pos + 1)
              if (next === 61) return this.finishOp(tt.assign, 2)
              return this.finishOp(tt.bitwiseXOR, 1)
            }

            pp$7.readToken_plus_min = function(code) {
              // '+-'
              var next = this.input.charCodeAt(this.pos + 1)
              if (next === code) {
                if (
                  next == 45 &&
                  this.input.charCodeAt(this.pos + 2) == 62 &&
                  lineBreak.test(this.input.slice(this.lastTokEnd, this.pos))
                ) {
                  // A `-->` line comment
                  this.skipLineComment(3)
                  this.skipSpace()
                  return this.nextToken()
                }
                return this.finishOp(tt.incDec, 2)
              }
              if (next === 61) return this.finishOp(tt.assign, 2)
              return this.finishOp(tt.plusMin, 1)
            }

            pp$7.readToken_lt_gt = function(code) {
              // '<>'
              var next = this.input.charCodeAt(this.pos + 1)
              var size = 1
              if (next === code) {
                size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62
                  ? 3
                  : 2
                if (this.input.charCodeAt(this.pos + size) === 61)
                  return this.finishOp(tt.assign, size + 1)
                return this.finishOp(tt.bitShift, size)
              }
              if (
                next == 33 &&
                code == 60 &&
                this.input.charCodeAt(this.pos + 2) == 45 &&
                this.input.charCodeAt(this.pos + 3) == 45
              ) {
                if (this.inModule) this.unexpected()
                // `<!--`, an XML-style comment that should be interpreted as a line comment
                this.skipLineComment(4)
                this.skipSpace()
                return this.nextToken()
              }
              if (next === 61) size = 2
              return this.finishOp(tt.relational, size)
            }

            pp$7.readToken_eq_excl = function(code) {
              // '=!'
              var next = this.input.charCodeAt(this.pos + 1)
              if (next === 61)
                return this.finishOp(
                  tt.equality,
                  this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2
                )
              if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
                // '=>'
                this.pos += 2
                return this.finishToken(tt.arrow)
              }
              return this.finishOp(code === 61 ? tt.eq : tt.prefix, 1)
            }

            pp$7.getTokenFromCode = function(code) {
              switch (code) {
                // The interpretation of a dot depends on whether it is followed
                // by a digit or another two dots.
                case 46: // '.'
                  return this.readToken_dot()

                // Punctuation tokens.
                case 40:
                  ++this.pos
                  return this.finishToken(tt.parenL)
                case 41:
                  ++this.pos
                  return this.finishToken(tt.parenR)
                case 59:
                  ++this.pos
                  return this.finishToken(tt.semi)
                case 44:
                  ++this.pos
                  return this.finishToken(tt.comma)
                case 91:
                  ++this.pos
                  return this.finishToken(tt.bracketL)
                case 93:
                  ++this.pos
                  return this.finishToken(tt.bracketR)
                case 123:
                  ++this.pos
                  return this.finishToken(tt.braceL)
                case 125:
                  ++this.pos
                  return this.finishToken(tt.braceR)
                case 58:
                  ++this.pos
                  return this.finishToken(tt.colon)
                case 63:
                  ++this.pos
                  return this.finishToken(tt.question)

                case 96: // '`'
                  if (this.options.ecmaVersion < 6) break
                  ++this.pos
                  return this.finishToken(tt.backQuote)

                case 48: // '0'
                  var next = this.input.charCodeAt(this.pos + 1)
                  if (next === 120 || next === 88)
                    return this.readRadixNumber(16) // '0x', '0X' - hex number
                  if (this.options.ecmaVersion >= 6) {
                    if (next === 111 || next === 79)
                      return this.readRadixNumber(8) // '0o', '0O' - octal number
                    if (next === 98 || next === 66)
                      return this.readRadixNumber(2) // '0b', '0B' - binary number
                  }
                // Anything else beginning with a digit is an integer, octal
                // number, or float.
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                case 56:
                case 57: // 1-9
                  return this.readNumber(false)

                // Quotes produce strings.
                case 34:
                case 39: // '"', "'"
                  return this.readString(code)

                // Operators are parsed inline in tiny state machines. '=' (61) is
                // often referred to. `finishOp` simply skips the amount of
                // characters it is given as second argument, and returns a token
                // of the type given by its first argument.

                case 47: // '/'
                  return this.readToken_slash()

                case 37:
                case 42: // '%*'
                  return this.readToken_mult_modulo_exp(code)

                case 124:
                case 38: // '|&'
                  return this.readToken_pipe_amp(code)

                case 94: // '^'
                  return this.readToken_caret()

                case 43:
                case 45: // '+-'
                  return this.readToken_plus_min(code)

                case 60:
                case 62: // '<>'
                  return this.readToken_lt_gt(code)

                case 61:
                case 33: // '=!'
                  return this.readToken_eq_excl(code)

                case 126: // '~'
                  return this.finishOp(tt.prefix, 1)
              }

              this.raise(
                this.pos,
                "Unexpected character '" + codePointToString(code) + "'"
              )
            }

            pp$7.finishOp = function(type, size) {
              var str = this.input.slice(this.pos, this.pos + size)
              this.pos += size
              return this.finishToken(type, str)
            }

            // Parse a regular expression. Some context-awareness is necessary,
            // since a '/' inside a '[]' set does not end the expression.

            function tryCreateRegexp(src, flags, throwErrorAt, parser) {
              try {
                return new RegExp(src, flags)
              } catch (e) {
                if (throwErrorAt !== undefined) {
                  if (e instanceof SyntaxError)
                    parser.raise(
                      throwErrorAt,
                      'Error parsing regular expression: ' + e.message
                    )
                  throw e
                }
              }
            }

            var regexpUnicodeSupport = !!tryCreateRegexp('\uffff', 'u')

            pp$7.readRegexp = function() {
              var this$1 = this

              var escaped,
                inClass,
                start = this.pos
              for (;;) {
                if (this$1.pos >= this$1.input.length)
                  this$1.raise(start, 'Unterminated regular expression')
                var ch = this$1.input.charAt(this$1.pos)
                if (lineBreak.test(ch))
                  this$1.raise(start, 'Unterminated regular expression')
                if (!escaped) {
                  if (ch === '[') inClass = true
                  else if (ch === ']' && inClass) inClass = false
                  else if (ch === '/' && !inClass) break
                  escaped = ch === '\\'
                } else escaped = false
                ++this$1.pos
              }
              var content = this.input.slice(start, this.pos)
              ++this.pos
              // Need to use `readWord1` because '\uXXXX' sequences are allowed
              // here (don't ask).
              var mods = this.readWord1()
              var tmp = content,
                tmpFlags = ''
              if (mods) {
                var validFlags = /^[gim]*$/
                if (this.options.ecmaVersion >= 6) validFlags = /^[gimuy]*$/
                if (!validFlags.test(mods))
                  this.raise(start, 'Invalid regular expression flag')
                if (mods.indexOf('u') >= 0) {
                  if (regexpUnicodeSupport) {
                    tmpFlags = 'u'
                  } else {
                    // Replace each astral symbol and every Unicode escape sequence that
                    // possibly represents an astral symbol or a paired surrogate with a
                    // single ASCII symbol to avoid throwing on regular expressions that
                    // are only valid in combination with the `/u` flag.
                    // Note: replacing with the ASCII symbol `x` might cause false
                    // negatives in unlikely scenarios. For example, `[\u{61}-b]` is a
                    // perfectly valid pattern that is equivalent to `[a-b]`, but it would
                    // be replaced by `[x-b]` which throws an error.
                    tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}/g, function(
                      _match,
                      code,
                      offset
                    ) {
                      code = Number('0x' + code)
                      if (code > 0x10ffff)
                        this$1.raise(
                          start + offset + 3,
                          'Code point out of bounds'
                        )
                      return 'x'
                    })
                    tmp = tmp.replace(
                      /\\u([a-fA-F0-9]{4})|[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
                      'x'
                    )
                    tmpFlags = tmpFlags.replace('u', '')
                  }
                }
              }
              // Detect invalid regular expressions.
              var value = null
              // Rhino's regular expression parser is flaky and throws uncatchable exceptions,
              // so don't do detection if we are running under Rhino
              if (!isRhino) {
                tryCreateRegexp(tmp, tmpFlags, start, this)
                // Get a regular expression object for this pattern-flag pair, or `null` in
                // case the current environment doesn't support the flags it uses.
                value = tryCreateRegexp(content, mods)
              }
              return this.finishToken(tt.regexp, {
                pattern: content,
                flags: mods,
                value: value,
              })
            }

            // Read an integer in the given radix. Return null if zero digits
            // were read, the integer value otherwise. When `len` is given, this
            // will return `null` unless the integer has exactly `len` digits.

            pp$7.readInt = function(radix, len) {
              var this$1 = this

              var start = this.pos,
                total = 0
              for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
                var code = this$1.input.charCodeAt(this$1.pos),
                  val
                if (code >= 97) val = code - 97 + 10
                else if (code >= 65)
                  // a
                  val = code - 65 + 10
                else if (code >= 48 && code <= 57)
                  // A
                  val = code - 48 // 0-9
                else val = Infinity
                if (val >= radix) break
                ++this$1.pos
                total = total * radix + val
              }
              if (
                this.pos === start ||
                (len != null && this.pos - start !== len)
              )
                return null

              return total
            }

            pp$7.readRadixNumber = function(radix) {
              this.pos += 2 // 0x
              var val = this.readInt(radix)
              if (val == null)
                this.raise(this.start + 2, 'Expected number in radix ' + radix)
              if (isIdentifierStart(this.fullCharCodeAtPos()))
                this.raise(this.pos, 'Identifier directly after number')
              return this.finishToken(tt.num, val)
            }

            // Read an integer, octal integer, or floating-point number.

            pp$7.readNumber = function(startsWithDot) {
              var start = this.pos,
                isFloat = false,
                octal = this.input.charCodeAt(this.pos) === 48
              if (!startsWithDot && this.readInt(10) === null)
                this.raise(start, 'Invalid number')
              var next = this.input.charCodeAt(this.pos)
              if (next === 46) {
                // '.'
                ++this.pos
                this.readInt(10)
                isFloat = true
                next = this.input.charCodeAt(this.pos)
              }
              if (next === 69 || next === 101) {
                // 'eE'
                next = this.input.charCodeAt(++this.pos)
                if (next === 43 || next === 45) ++this.pos // '+-'
                if (this.readInt(10) === null)
                  this.raise(start, 'Invalid number')
                isFloat = true
              }
              if (isIdentifierStart(this.fullCharCodeAtPos()))
                this.raise(this.pos, 'Identifier directly after number')

              var str = this.input.slice(start, this.pos),
                val
              if (isFloat) val = parseFloat(str)
              else if (!octal || str.length === 1) val = parseInt(str, 10)
              else if (/[89]/.test(str) || this.strict)
                this.raise(start, 'Invalid number')
              else val = parseInt(str, 8)
              return this.finishToken(tt.num, val)
            }

            // Read a string value, interpreting backslash-escapes.

            pp$7.readCodePoint = function() {
              var ch = this.input.charCodeAt(this.pos),
                code

              if (ch === 123) {
                if (this.options.ecmaVersion < 6) this.unexpected()
                var codePos = ++this.pos
                code = this.readHexChar(
                  this.input.indexOf('}', this.pos) - this.pos
                )
                ++this.pos
                if (code > 0x10ffff)
                  this.raise(codePos, 'Code point out of bounds')
              } else {
                code = this.readHexChar(4)
              }
              return code
            }

            function codePointToString(code) {
              // UTF-16 Decoding
              if (code <= 0xffff) return String.fromCharCode(code)
              code -= 0x10000
              return String.fromCharCode(
                (code >> 10) + 0xd800,
                (code & 1023) + 0xdc00
              )
            }

            pp$7.readString = function(quote) {
              var this$1 = this

              var out = '',
                chunkStart = ++this.pos
              for (;;) {
                if (this$1.pos >= this$1.input.length)
                  this$1.raise(this$1.start, 'Unterminated string constant')
                var ch = this$1.input.charCodeAt(this$1.pos)
                if (ch === quote) break
                if (ch === 92) {
                  // '\'
                  out += this$1.input.slice(chunkStart, this$1.pos)
                  out += this$1.readEscapedChar(false)
                  chunkStart = this$1.pos
                } else {
                  if (isNewLine(ch))
                    this$1.raise(this$1.start, 'Unterminated string constant')
                  ++this$1.pos
                }
              }
              out += this.input.slice(chunkStart, this.pos++)
              return this.finishToken(tt.string, out)
            }

            // Reads template string tokens.

            pp$7.readTmplToken = function() {
              var this$1 = this

              var out = '',
                chunkStart = this.pos
              for (;;) {
                if (this$1.pos >= this$1.input.length)
                  this$1.raise(this$1.start, 'Unterminated template')
                var ch = this$1.input.charCodeAt(this$1.pos)
                if (
                  ch === 96 ||
                  (ch === 36 && this$1.input.charCodeAt(this$1.pos + 1) === 123)
                ) {
                  // '`', '${'
                  if (
                    this$1.pos === this$1.start &&
                    this$1.type === tt.template
                  ) {
                    if (ch === 36) {
                      this$1.pos += 2
                      return this$1.finishToken(tt.dollarBraceL)
                    } else {
                      ++this$1.pos
                      return this$1.finishToken(tt.backQuote)
                    }
                  }
                  out += this$1.input.slice(chunkStart, this$1.pos)
                  return this$1.finishToken(tt.template, out)
                }
                if (ch === 92) {
                  // '\'
                  out += this$1.input.slice(chunkStart, this$1.pos)
                  out += this$1.readEscapedChar(true)
                  chunkStart = this$1.pos
                } else if (isNewLine(ch)) {
                  out += this$1.input.slice(chunkStart, this$1.pos)
                  ++this$1.pos
                  switch (ch) {
                    case 13:
                      if (this$1.input.charCodeAt(this$1.pos) === 10)
                        ++this$1.pos
                    case 10:
                      out += '\n'
                      break
                    default:
                      out += String.fromCharCode(ch)
                      break
                  }
                  if (this$1.options.locations) {
                    ++this$1.curLine
                    this$1.lineStart = this$1.pos
                  }
                  chunkStart = this$1.pos
                } else {
                  ++this$1.pos
                }
              }
            }

            // Used to read escaped characters

            pp$7.readEscapedChar = function(inTemplate) {
              var ch = this.input.charCodeAt(++this.pos)
              ++this.pos
              switch (ch) {
                case 110:
                  return '\n' // 'n' -> '\n'
                case 114:
                  return '\r' // 'r' -> '\r'
                case 120:
                  return String.fromCharCode(this.readHexChar(2)) // 'x'
                case 117:
                  return codePointToString(this.readCodePoint()) // 'u'
                case 116:
                  return '\t' // 't' -> '\t'
                case 98:
                  return '\b' // 'b' -> '\b'
                case 118:
                  return '\u000b' // 'v' -> '\u000b'
                case 102:
                  return '\f' // 'f' -> '\f'
                case 13:
                  if (this.input.charCodeAt(this.pos) === 10) ++this.pos // '\r\n'
                case 10: // ' \n'
                  if (this.options.locations) {
                    this.lineStart = this.pos
                    ++this.curLine
                  }
                  return ''
                default:
                  if (ch >= 48 && ch <= 55) {
                    var octalStr = this.input
                      .substr(this.pos - 1, 3)
                      .match(/^[0-7]+/)[0]
                    var octal = parseInt(octalStr, 8)
                    if (octal > 255) {
                      octalStr = octalStr.slice(0, -1)
                      octal = parseInt(octalStr, 8)
                    }
                    if (octalStr !== '0' && (this.strict || inTemplate)) {
                      this.raise(this.pos - 2, 'Octal literal in strict mode')
                    }
                    this.pos += octalStr.length - 1
                    return String.fromCharCode(octal)
                  }
                  return String.fromCharCode(ch)
              }
            }

            // Used to read character escape sequences ('\x', '\u', '\U').

            pp$7.readHexChar = function(len) {
              var codePos = this.pos
              var n = this.readInt(16, len)
              if (n === null)
                this.raise(codePos, 'Bad character escape sequence')
              return n
            }

            // Read an identifier, and return it as a string. Sets `this.containsEsc`
            // to whether the word contained a '\u' escape.
            //
            // Incrementally adds only escaped chars, adding other chunks as-is
            // as a micro-optimization.

            pp$7.readWord1 = function() {
              var this$1 = this

              this.containsEsc = false
              var word = '',
                first = true,
                chunkStart = this.pos
              var astral = this.options.ecmaVersion >= 6
              while (this.pos < this.input.length) {
                var ch = this$1.fullCharCodeAtPos()
                if (isIdentifierChar(ch, astral)) {
                  this$1.pos += ch <= 0xffff ? 1 : 2
                } else if (ch === 92) {
                  // "\"
                  this$1.containsEsc = true
                  word += this$1.input.slice(chunkStart, this$1.pos)
                  var escStart = this$1.pos
                  if (
                    this$1.input.charCodeAt(++this$1.pos) != 117 // "u"
                  )
                    this$1.raise(
                      this$1.pos,
                      'Expecting Unicode escape sequence \\uXXXX'
                    )
                  ++this$1.pos
                  var esc = this$1.readCodePoint()
                  if (
                    !(first ? isIdentifierStart : isIdentifierChar)(esc, astral)
                  )
                    this$1.raise(escStart, 'Invalid Unicode escape')
                  word += codePointToString(esc)
                  chunkStart = this$1.pos
                } else {
                  break
                }
                first = false
              }
              return word + this.input.slice(chunkStart, this.pos)
            }

            // Read an identifier or keyword token. Will check for reserved
            // words when necessary.

            pp$7.readWord = function() {
              var word = this.readWord1()
              var type = tt.name
              if (
                (this.options.ecmaVersion >= 6 || !this.containsEsc) &&
                this.keywords.test(word)
              )
                type = keywordTypes[word]
              return this.finishToken(type, word)
            }

            var version = '3.3.0'

            // The main exported interface (under `self.acorn` when in the
            // browser) is a `parse` function that takes a code string and
            // returns an abstract syntax tree as specified by [Mozilla parser
            // API][api].
            //
            // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API

            function parse(input, options) {
              return new Parser(options, input).parse()
            }

            // This function tries to parse a single expression at a given
            // offset in a string. Useful for parsing mixed-language formats
            // that embed JavaScript expressions.

            function parseExpressionAt(input, pos, options) {
              var p = new Parser(options, input, pos)
              p.nextToken()
              return p.parseExpression()
            }

            // Acorn is organized as a tokenizer and a recursive-descent parser.
            // The `tokenizer` export provides an interface to the tokenizer.

            function tokenizer(input, options) {
              return new Parser(options, input)
            }

            exports.version = version
            exports.parse = parse
            exports.parseExpressionAt = parseExpressionAt
            exports.tokenizer = tokenizer
            exports.Parser = Parser
            exports.plugins = plugins
            exports.defaultOptions = defaultOptions
            exports.Position = Position
            exports.SourceLocation = SourceLocation
            exports.getLineInfo = getLineInfo
            exports.Node = Node
            exports.TokenType = TokenType
            exports.tokTypes = tt
            exports.TokContext = TokContext
            exports.tokContexts = types
            exports.isIdentifierChar = isIdentifierChar
            exports.isIdentifierStart = isIdentifierStart
            exports.Token = Token
            exports.isNewLine = isNewLine
            exports.lineBreak = lineBreak
            exports.lineBreakG = lineBreakG

            Object.defineProperty(exports, '__esModule', { value: true })
          })
        },
        {},
      ],
      121: [
        function(require, module, exports) {
          /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
          /* eslint-disable no-proto */

          'use strict'
          var base64 = require('base64-js')
          var ieee754 = require('ieee754')

          exports.Buffer = Buffer
          exports.SlowBuffer = SlowBuffer
          exports.INSPECT_MAX_BYTES = 50

          var K_MAX_LENGTH = 0x7fffffff
          exports.kMaxLength = K_MAX_LENGTH

          /**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
          Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

          if (
            !Buffer.TYPED_ARRAY_SUPPORT &&
            typeof console !== 'undefined' &&
            typeof console.error === 'function'
          ) {
            console.error(
              'This browser lacks typed array (Uint8Array) support which is required by ' +
                '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
            )
          }

          function typedArraySupport() {
            // Can typed array instances can be augmented?
            try {
              var arr = new Uint8Array(1)
              arr.__proto__ = {
                __proto__: Uint8Array.prototype,
                foo: function() {
                  return 42
                },
              }
              return arr.foo() === 42
            } catch (e) {
              return false
            }
          }

          function createBuffer(length) {
            if (length > K_MAX_LENGTH) {
              throw new RangeError('Invalid typed array length')
            }
            // Return an augmented `Uint8Array` instance
            var buf = new Uint8Array(length)
            buf.__proto__ = Buffer.prototype
            return buf
          }

          /**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

          function Buffer(arg, encodingOrOffset, length) {
            // Common case.
            if (typeof arg === 'number') {
              if (typeof encodingOrOffset === 'string') {
                throw new Error(
                  'If encoding is specified then the first argument must be a string'
                )
              }
              return allocUnsafe(arg)
            }
            return from(arg, encodingOrOffset, length)
          }

          // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
          if (
            typeof Symbol !== 'undefined' &&
            Symbol.species &&
            Buffer[Symbol.species] === Buffer
          ) {
            Object.defineProperty(Buffer, Symbol.species, {
              value: null,
              configurable: true,
              enumerable: false,
              writable: false,
            })
          }

          Buffer.poolSize = 8192 // not used by this implementation

          function from(value, encodingOrOffset, length) {
            if (typeof value === 'number') {
              throw new TypeError('"value" argument must not be a number')
            }

            if (value instanceof ArrayBuffer) {
              return fromArrayBuffer(value, encodingOrOffset, length)
            }

            if (typeof value === 'string') {
              return fromString(value, encodingOrOffset)
            }

            return fromObject(value)
          }

          /**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
          Buffer.from = function(value, encodingOrOffset, length) {
            return from(value, encodingOrOffset, length)
          }

          // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
          // https://github.com/feross/buffer/pull/148
          Buffer.prototype.__proto__ = Uint8Array.prototype
          Buffer.__proto__ = Uint8Array

          function assertSize(size) {
            if (typeof size !== 'number') {
              throw new TypeError('"size" argument must be a number')
            } else if (size < 0) {
              throw new RangeError('"size" argument must not be negative')
            }
          }

          function alloc(size, fill, encoding) {
            assertSize(size)
            if (size <= 0) {
              return createBuffer(size)
            }
            if (fill !== undefined) {
              // Only pay attention to encoding if it's a string. This
              // prevents accidentally sending in a number that would
              // be interpretted as a start offset.
              return typeof encoding === 'string'
                ? createBuffer(size).fill(fill, encoding)
                : createBuffer(size).fill(fill)
            }
            return createBuffer(size)
          }

          /**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
          Buffer.alloc = function(size, fill, encoding) {
            return alloc(size, fill, encoding)
          }

          function allocUnsafe(size) {
            assertSize(size)
            return createBuffer(size < 0 ? 0 : checked(size) | 0)
          }

          /**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
          Buffer.allocUnsafe = function(size) {
            return allocUnsafe(size)
          }
          /**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
          Buffer.allocUnsafeSlow = function(size) {
            return allocUnsafe(size)
          }

          function fromString(string, encoding) {
            if (typeof encoding !== 'string' || encoding === '') {
              encoding = 'utf8'
            }

            if (!Buffer.isEncoding(encoding)) {
              throw new TypeError('"encoding" must be a valid string encoding')
            }

            var length = byteLength(string, encoding) | 0
            var buf = createBuffer(length)

            var actual = buf.write(string, encoding)

            if (actual !== length) {
              // Writing a hex string, for example, that contains invalid characters will
              // cause everything after the first invalid character to be ignored. (e.g.
              // 'abxxcd' will be treated as 'ab')
              buf = buf.slice(0, actual)
            }

            return buf
          }

          function fromArrayLike(array) {
            var length = array.length < 0 ? 0 : checked(array.length) | 0
            var buf = createBuffer(length)
            for (var i = 0; i < length; i += 1) {
              buf[i] = array[i] & 255
            }
            return buf
          }

          function fromArrayBuffer(array, byteOffset, length) {
            if (byteOffset < 0 || array.byteLength < byteOffset) {
              throw new RangeError("'offset' is out of bounds")
            }

            if (array.byteLength < byteOffset + (length || 0)) {
              throw new RangeError("'length' is out of bounds")
            }

            var buf
            if (byteOffset === undefined && length === undefined) {
              buf = new Uint8Array(array)
            } else if (length === undefined) {
              buf = new Uint8Array(array, byteOffset)
            } else {
              buf = new Uint8Array(array, byteOffset, length)
            }

            // Return an augmented `Uint8Array` instance
            buf.__proto__ = Buffer.prototype
            return buf
          }

          function fromObject(obj) {
            if (Buffer.isBuffer(obj)) {
              var len = checked(obj.length) | 0
              var buf = createBuffer(len)

              if (buf.length === 0) {
                return buf
              }

              obj.copy(buf, 0, 0, len)
              return buf
            }

            if (obj) {
              if (isArrayBufferView(obj) || 'length' in obj) {
                if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
                  return createBuffer(0)
                }
                return fromArrayLike(obj)
              }

              if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
                return fromArrayLike(obj.data)
              }
            }

            throw new TypeError(
              'First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.'
            )
          }

          function checked(length) {
            // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
            // length is NaN (which is otherwise coerced to zero.)
            if (length >= K_MAX_LENGTH) {
              throw new RangeError(
                'Attempt to allocate Buffer larger than maximum ' +
                  'size: 0x' +
                  K_MAX_LENGTH.toString(16) +
                  ' bytes'
              )
            }
            return length | 0
          }

          function SlowBuffer(length) {
            if (+length != length) {
              // eslint-disable-line eqeqeq
              length = 0
            }
            return Buffer.alloc(+length)
          }

          Buffer.isBuffer = function isBuffer(b) {
            return b != null && b._isBuffer === true
          }

          Buffer.compare = function compare(a, b) {
            if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
              throw new TypeError('Arguments must be Buffers')
            }

            if (a === b) return 0

            var x = a.length
            var y = b.length

            for (var i = 0, len = Math.min(x, y); i < len; ++i) {
              if (a[i] !== b[i]) {
                x = a[i]
                y = b[i]
                break
              }
            }

            if (x < y) return -1
            if (y < x) return 1
            return 0
          }

          Buffer.isEncoding = function isEncoding(encoding) {
            switch (String(encoding).toLowerCase()) {
              case 'hex':
              case 'utf8':
              case 'utf-8':
              case 'ascii':
              case 'latin1':
              case 'binary':
              case 'base64':
              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return true
              default:
                return false
            }
          }

          Buffer.concat = function concat(list, length) {
            if (!Array.isArray(list)) {
              throw new TypeError('"list" argument must be an Array of Buffers')
            }

            if (list.length === 0) {
              return Buffer.alloc(0)
            }

            var i
            if (length === undefined) {
              length = 0
              for (i = 0; i < list.length; ++i) {
                length += list[i].length
              }
            }

            var buffer = Buffer.allocUnsafe(length)
            var pos = 0
            for (i = 0; i < list.length; ++i) {
              var buf = list[i]
              if (!Buffer.isBuffer(buf)) {
                throw new TypeError(
                  '"list" argument must be an Array of Buffers'
                )
              }
              buf.copy(buffer, pos)
              pos += buf.length
            }
            return buffer
          }

          function byteLength(string, encoding) {
            if (Buffer.isBuffer(string)) {
              return string.length
            }
            if (isArrayBufferView(string) || string instanceof ArrayBuffer) {
              return string.byteLength
            }
            if (typeof string !== 'string') {
              string = '' + string
            }

            var len = string.length
            if (len === 0) return 0

            // Use a for loop to avoid recursion
            var loweredCase = false
            for (;;) {
              switch (encoding) {
                case 'ascii':
                case 'latin1':
                case 'binary':
                  return len
                case 'utf8':
                case 'utf-8':
                case undefined:
                  return utf8ToBytes(string).length
                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                  return len * 2
                case 'hex':
                  return len >>> 1
                case 'base64':
                  return base64ToBytes(string).length
                default:
                  if (loweredCase) return utf8ToBytes(string).length // assume utf8
                  encoding = ('' + encoding).toLowerCase()
                  loweredCase = true
              }
            }
          }
          Buffer.byteLength = byteLength

          function slowToString(encoding, start, end) {
            var loweredCase = false

            // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
            // property of a typed array.

            // This behaves neither like String nor Uint8Array in that we set start/end
            // to their upper/lower bounds if the value passed is out of range.
            // undefined is handled specially as per ECMA-262 6th Edition,
            // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
            if (start === undefined || start < 0) {
              start = 0
            }
            // Return early if start > this.length. Done here to prevent potential uint32
            // coercion fail below.
            if (start > this.length) {
              return ''
            }

            if (end === undefined || end > this.length) {
              end = this.length
            }

            if (end <= 0) {
              return ''
            }

            // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
            end >>>= 0
            start >>>= 0

            if (end <= start) {
              return ''
            }

            if (!encoding) encoding = 'utf8'

            while (true) {
              switch (encoding) {
                case 'hex':
                  return hexSlice(this, start, end)

                case 'utf8':
                case 'utf-8':
                  return utf8Slice(this, start, end)

                case 'ascii':
                  return asciiSlice(this, start, end)

                case 'latin1':
                case 'binary':
                  return latin1Slice(this, start, end)

                case 'base64':
                  return base64Slice(this, start, end)

                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                  return utf16leSlice(this, start, end)

                default:
                  if (loweredCase)
                    throw new TypeError('Unknown encoding: ' + encoding)
                  encoding = (encoding + '').toLowerCase()
                  loweredCase = true
              }
            }
          }

          // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
          // to detect a Buffer instance. It's not possible to use `instanceof Buffer`
          // reliably in a browserify context because there could be multiple different
          // copies of the 'buffer' package in use. This method works even for Buffer
          // instances that were created from another copy of the `buffer` package.
          // See: https://github.com/feross/buffer/issues/154
          Buffer.prototype._isBuffer = true

          function swap(b, n, m) {
            var i = b[n]
            b[n] = b[m]
            b[m] = i
          }

          Buffer.prototype.swap16 = function swap16() {
            var len = this.length
            if (len % 2 !== 0) {
              throw new RangeError('Buffer size must be a multiple of 16-bits')
            }
            for (var i = 0; i < len; i += 2) {
              swap(this, i, i + 1)
            }
            return this
          }

          Buffer.prototype.swap32 = function swap32() {
            var len = this.length
            if (len % 4 !== 0) {
              throw new RangeError('Buffer size must be a multiple of 32-bits')
            }
            for (var i = 0; i < len; i += 4) {
              swap(this, i, i + 3)
              swap(this, i + 1, i + 2)
            }
            return this
          }

          Buffer.prototype.swap64 = function swap64() {
            var len = this.length
            if (len % 8 !== 0) {
              throw new RangeError('Buffer size must be a multiple of 64-bits')
            }
            for (var i = 0; i < len; i += 8) {
              swap(this, i, i + 7)
              swap(this, i + 1, i + 6)
              swap(this, i + 2, i + 5)
              swap(this, i + 3, i + 4)
            }
            return this
          }

          Buffer.prototype.toString = function toString() {
            var length = this.length
            if (length === 0) return ''
            if (arguments.length === 0) return utf8Slice(this, 0, length)
            return slowToString.apply(this, arguments)
          }

          Buffer.prototype.equals = function equals(b) {
            if (!Buffer.isBuffer(b))
              throw new TypeError('Argument must be a Buffer')
            if (this === b) return true
            return Buffer.compare(this, b) === 0
          }

          Buffer.prototype.inspect = function inspect() {
            var str = ''
            var max = exports.INSPECT_MAX_BYTES
            if (this.length > 0) {
              str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
              if (this.length > max) str += ' ... '
            }
            return '<Buffer ' + str + '>'
          }

          Buffer.prototype.compare = function compare(
            target,
            start,
            end,
            thisStart,
            thisEnd
          ) {
            if (!Buffer.isBuffer(target)) {
              throw new TypeError('Argument must be a Buffer')
            }

            if (start === undefined) {
              start = 0
            }
            if (end === undefined) {
              end = target ? target.length : 0
            }
            if (thisStart === undefined) {
              thisStart = 0
            }
            if (thisEnd === undefined) {
              thisEnd = this.length
            }

            if (
              start < 0 ||
              end > target.length ||
              thisStart < 0 ||
              thisEnd > this.length
            ) {
              throw new RangeError('out of range index')
            }

            if (thisStart >= thisEnd && start >= end) {
              return 0
            }
            if (thisStart >= thisEnd) {
              return -1
            }
            if (start >= end) {
              return 1
            }

            start >>>= 0
            end >>>= 0
            thisStart >>>= 0
            thisEnd >>>= 0

            if (this === target) return 0

            var x = thisEnd - thisStart
            var y = end - start
            var len = Math.min(x, y)

            var thisCopy = this.slice(thisStart, thisEnd)
            var targetCopy = target.slice(start, end)

            for (var i = 0; i < len; ++i) {
              if (thisCopy[i] !== targetCopy[i]) {
                x = thisCopy[i]
                y = targetCopy[i]
                break
              }
            }

            if (x < y) return -1
            if (y < x) return 1
            return 0
          }

          // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
          // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
          //
          // Arguments:
          // - buffer - a Buffer to search
          // - val - a string, Buffer, or number
          // - byteOffset - an index into `buffer`; will be clamped to an int32
          // - encoding - an optional encoding, relevant is val is a string
          // - dir - true for indexOf, false for lastIndexOf
          function bidirectionalIndexOf(
            buffer,
            val,
            byteOffset,
            encoding,
            dir
          ) {
            // Empty buffer means no match
            if (buffer.length === 0) return -1

            // Normalize byteOffset
            if (typeof byteOffset === 'string') {
              encoding = byteOffset
              byteOffset = 0
            } else if (byteOffset > 0x7fffffff) {
              byteOffset = 0x7fffffff
            } else if (byteOffset < -0x80000000) {
              byteOffset = -0x80000000
            }
            byteOffset = +byteOffset // Coerce to Number.
            if (numberIsNaN(byteOffset)) {
              // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
              byteOffset = dir ? 0 : buffer.length - 1
            }

            // Normalize byteOffset: negative offsets start from the end of the buffer
            if (byteOffset < 0) byteOffset = buffer.length + byteOffset
            if (byteOffset >= buffer.length) {
              if (dir) return -1
              else byteOffset = buffer.length - 1
            } else if (byteOffset < 0) {
              if (dir) byteOffset = 0
              else return -1
            }

            // Normalize val
            if (typeof val === 'string') {
              val = Buffer.from(val, encoding)
            }

            // Finally, search either indexOf (if dir is true) or lastIndexOf
            if (Buffer.isBuffer(val)) {
              // Special case: looking for empty string/buffer always fails
              if (val.length === 0) {
                return -1
              }
              return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
            } else if (typeof val === 'number') {
              val = val & 0xff // Search for a byte value [0-255]
              if (typeof Uint8Array.prototype.indexOf === 'function') {
                if (dir) {
                  return Uint8Array.prototype.indexOf.call(
                    buffer,
                    val,
                    byteOffset
                  )
                } else {
                  return Uint8Array.prototype.lastIndexOf.call(
                    buffer,
                    val,
                    byteOffset
                  )
                }
              }
              return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
            }

            throw new TypeError('val must be string, number or Buffer')
          }

          function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
            var indexSize = 1
            var arrLength = arr.length
            var valLength = val.length

            if (encoding !== undefined) {
              encoding = String(encoding).toLowerCase()
              if (
                encoding === 'ucs2' ||
                encoding === 'ucs-2' ||
                encoding === 'utf16le' ||
                encoding === 'utf-16le'
              ) {
                if (arr.length < 2 || val.length < 2) {
                  return -1
                }
                indexSize = 2
                arrLength /= 2
                valLength /= 2
                byteOffset /= 2
              }
            }

            function read(buf, i) {
              if (indexSize === 1) {
                return buf[i]
              } else {
                return buf.readUInt16BE(i * indexSize)
              }
            }

            var i
            if (dir) {
              var foundIndex = -1
              for (i = byteOffset; i < arrLength; i++) {
                if (
                  read(arr, i) ===
                  read(val, foundIndex === -1 ? 0 : i - foundIndex)
                ) {
                  if (foundIndex === -1) foundIndex = i
                  if (i - foundIndex + 1 === valLength)
                    return foundIndex * indexSize
                } else {
                  if (foundIndex !== -1) i -= i - foundIndex
                  foundIndex = -1
                }
              }
            } else {
              if (byteOffset + valLength > arrLength)
                byteOffset = arrLength - valLength
              for (i = byteOffset; i >= 0; i--) {
                var found = true
                for (var j = 0; j < valLength; j++) {
                  if (read(arr, i + j) !== read(val, j)) {
                    found = false
                    break
                  }
                }
                if (found) return i
              }
            }

            return -1
          }

          Buffer.prototype.includes = function includes(
            val,
            byteOffset,
            encoding
          ) {
            return this.indexOf(val, byteOffset, encoding) !== -1
          }

          Buffer.prototype.indexOf = function indexOf(
            val,
            byteOffset,
            encoding
          ) {
            return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
          }

          Buffer.prototype.lastIndexOf = function lastIndexOf(
            val,
            byteOffset,
            encoding
          ) {
            return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
          }

          function hexWrite(buf, string, offset, length) {
            offset = Number(offset) || 0
            var remaining = buf.length - offset
            if (!length) {
              length = remaining
            } else {
              length = Number(length)
              if (length > remaining) {
                length = remaining
              }
            }

            // must be an even number of digits
            var strLen = string.length
            if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

            if (length > strLen / 2) {
              length = strLen / 2
            }
            for (var i = 0; i < length; ++i) {
              var parsed = parseInt(string.substr(i * 2, 2), 16)
              if (numberIsNaN(parsed)) return i
              buf[offset + i] = parsed
            }
            return i
          }

          function utf8Write(buf, string, offset, length) {
            return blitBuffer(
              utf8ToBytes(string, buf.length - offset),
              buf,
              offset,
              length
            )
          }

          function asciiWrite(buf, string, offset, length) {
            return blitBuffer(asciiToBytes(string), buf, offset, length)
          }

          function latin1Write(buf, string, offset, length) {
            return asciiWrite(buf, string, offset, length)
          }

          function base64Write(buf, string, offset, length) {
            return blitBuffer(base64ToBytes(string), buf, offset, length)
          }

          function ucs2Write(buf, string, offset, length) {
            return blitBuffer(
              utf16leToBytes(string, buf.length - offset),
              buf,
              offset,
              length
            )
          }

          Buffer.prototype.write = function write(
            string,
            offset,
            length,
            encoding
          ) {
            // Buffer#write(string)
            if (offset === undefined) {
              encoding = 'utf8'
              length = this.length
              offset = 0
              // Buffer#write(string, encoding)
            } else if (length === undefined && typeof offset === 'string') {
              encoding = offset
              length = this.length
              offset = 0
              // Buffer#write(string, offset[, length][, encoding])
            } else if (isFinite(offset)) {
              offset = offset >>> 0
              if (isFinite(length)) {
                length = length >>> 0
                if (encoding === undefined) encoding = 'utf8'
              } else {
                encoding = length
                length = undefined
              }
            } else {
              throw new Error(
                'Buffer.write(string, encoding, offset[, length]) is no longer supported'
              )
            }

            var remaining = this.length - offset
            if (length === undefined || length > remaining) length = remaining

            if (
              (string.length > 0 && (length < 0 || offset < 0)) ||
              offset > this.length
            ) {
              throw new RangeError('Attempt to write outside buffer bounds')
            }

            if (!encoding) encoding = 'utf8'

            var loweredCase = false
            for (;;) {
              switch (encoding) {
                case 'hex':
                  return hexWrite(this, string, offset, length)

                case 'utf8':
                case 'utf-8':
                  return utf8Write(this, string, offset, length)

                case 'ascii':
                  return asciiWrite(this, string, offset, length)

                case 'latin1':
                case 'binary':
                  return latin1Write(this, string, offset, length)

                case 'base64':
                  // Warning: maxLength not taken into account in base64Write
                  return base64Write(this, string, offset, length)

                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                  return ucs2Write(this, string, offset, length)

                default:
                  if (loweredCase)
                    throw new TypeError('Unknown encoding: ' + encoding)
                  encoding = ('' + encoding).toLowerCase()
                  loweredCase = true
              }
            }
          }

          Buffer.prototype.toJSON = function toJSON() {
            return {
              type: 'Buffer',
              data: Array.prototype.slice.call(this._arr || this, 0),
            }
          }

          function base64Slice(buf, start, end) {
            if (start === 0 && end === buf.length) {
              return base64.fromByteArray(buf)
            } else {
              return base64.fromByteArray(buf.slice(start, end))
            }
          }

          function utf8Slice(buf, start, end) {
            end = Math.min(buf.length, end)
            var res = []

            var i = start
            while (i < end) {
              var firstByte = buf[i]
              var codePoint = null
              var bytesPerSequence = firstByte > 0xef
                ? 4
                : firstByte > 0xdf ? 3 : firstByte > 0xbf ? 2 : 1

              if (i + bytesPerSequence <= end) {
                var secondByte, thirdByte, fourthByte, tempCodePoint

                switch (bytesPerSequence) {
                  case 1:
                    if (firstByte < 0x80) {
                      codePoint = firstByte
                    }
                    break
                  case 2:
                    secondByte = buf[i + 1]
                    if ((secondByte & 0xc0) === 0x80) {
                      tempCodePoint =
                        ((firstByte & 0x1f) << 0x6) | (secondByte & 0x3f)
                      if (tempCodePoint > 0x7f) {
                        codePoint = tempCodePoint
                      }
                    }
                    break
                  case 3:
                    secondByte = buf[i + 1]
                    thirdByte = buf[i + 2]
                    if (
                      (secondByte & 0xc0) === 0x80 &&
                      (thirdByte & 0xc0) === 0x80
                    ) {
                      tempCodePoint =
                        ((firstByte & 0xf) << 0xc) |
                        ((secondByte & 0x3f) << 0x6) |
                        (thirdByte & 0x3f)
                      if (
                        tempCodePoint > 0x7ff &&
                        (tempCodePoint < 0xd800 || tempCodePoint > 0xdfff)
                      ) {
                        codePoint = tempCodePoint
                      }
                    }
                    break
                  case 4:
                    secondByte = buf[i + 1]
                    thirdByte = buf[i + 2]
                    fourthByte = buf[i + 3]
                    if (
                      (secondByte & 0xc0) === 0x80 &&
                      (thirdByte & 0xc0) === 0x80 &&
                      (fourthByte & 0xc0) === 0x80
                    ) {
                      tempCodePoint =
                        ((firstByte & 0xf) << 0x12) |
                        ((secondByte & 0x3f) << 0xc) |
                        ((thirdByte & 0x3f) << 0x6) |
                        (fourthByte & 0x3f)
                      if (tempCodePoint > 0xffff && tempCodePoint < 0x110000) {
                        codePoint = tempCodePoint
                      }
                    }
                }
              }

              if (codePoint === null) {
                // we did not generate a valid codePoint so insert a
                // replacement char (U+FFFD) and advance only 1 byte
                codePoint = 0xfffd
                bytesPerSequence = 1
              } else if (codePoint > 0xffff) {
                // encode to utf16 (surrogate pair dance)
                codePoint -= 0x10000
                res.push(((codePoint >>> 10) & 0x3ff) | 0xd800)
                codePoint = 0xdc00 | (codePoint & 0x3ff)
              }

              res.push(codePoint)
              i += bytesPerSequence
            }

            return decodeCodePointsArray(res)
          }

          // Based on http://stackoverflow.com/a/22747272/680742, the browser with
          // the lowest limit is Chrome, with 0x10000 args.
          // We go 1 magnitude less, for safety
          var MAX_ARGUMENTS_LENGTH = 0x1000

          function decodeCodePointsArray(codePoints) {
            var len = codePoints.length
            if (len <= MAX_ARGUMENTS_LENGTH) {
              return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
            }

            // Decode in chunks to avoid "call stack size exceeded".
            var res = ''
            var i = 0
            while (i < len) {
              res += String.fromCharCode.apply(
                String,
                codePoints.slice(i, (i += MAX_ARGUMENTS_LENGTH))
              )
            }
            return res
          }

          function asciiSlice(buf, start, end) {
            var ret = ''
            end = Math.min(buf.length, end)

            for (var i = start; i < end; ++i) {
              ret += String.fromCharCode(buf[i] & 0x7f)
            }
            return ret
          }

          function latin1Slice(buf, start, end) {
            var ret = ''
            end = Math.min(buf.length, end)

            for (var i = start; i < end; ++i) {
              ret += String.fromCharCode(buf[i])
            }
            return ret
          }

          function hexSlice(buf, start, end) {
            var len = buf.length

            if (!start || start < 0) start = 0
            if (!end || end < 0 || end > len) end = len

            var out = ''
            for (var i = start; i < end; ++i) {
              out += toHex(buf[i])
            }
            return out
          }

          function utf16leSlice(buf, start, end) {
            var bytes = buf.slice(start, end)
            var res = ''
            for (var i = 0; i < bytes.length; i += 2) {
              res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
            }
            return res
          }

          Buffer.prototype.slice = function slice(start, end) {
            var len = this.length
            start = ~~start
            end = end === undefined ? len : ~~end

            if (start < 0) {
              start += len
              if (start < 0) start = 0
            } else if (start > len) {
              start = len
            }

            if (end < 0) {
              end += len
              if (end < 0) end = 0
            } else if (end > len) {
              end = len
            }

            if (end < start) end = start

            var newBuf = this.subarray(start, end)
            // Return an augmented `Uint8Array` instance
            newBuf.__proto__ = Buffer.prototype
            return newBuf
          }

          /*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
          function checkOffset(offset, ext, length) {
            if (offset % 1 !== 0 || offset < 0)
              throw new RangeError('offset is not uint')
            if (offset + ext > length)
              throw new RangeError('Trying to access beyond buffer length')
          }

          Buffer.prototype.readUIntLE = function readUIntLE(
            offset,
            byteLength,
            noAssert
          ) {
            offset = offset >>> 0
            byteLength = byteLength >>> 0
            if (!noAssert) checkOffset(offset, byteLength, this.length)

            var val = this[offset]
            var mul = 1
            var i = 0
            while (++i < byteLength && (mul *= 0x100)) {
              val += this[offset + i] * mul
            }

            return val
          }

          Buffer.prototype.readUIntBE = function readUIntBE(
            offset,
            byteLength,
            noAssert
          ) {
            offset = offset >>> 0
            byteLength = byteLength >>> 0
            if (!noAssert) {
              checkOffset(offset, byteLength, this.length)
            }

            var val = this[offset + --byteLength]
            var mul = 1
            while (byteLength > 0 && (mul *= 0x100)) {
              val += this[offset + --byteLength] * mul
            }

            return val
          }

          Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
            offset = offset >>> 0
            if (!noAssert) checkOffset(offset, 1, this.length)
            return this[offset]
          }

          Buffer.prototype.readUInt16LE = function readUInt16LE(
            offset,
            noAssert
          ) {
            offset = offset >>> 0
            if (!noAssert) checkOffset(offset, 2, this.length)
            return this[offset] | (this[offset + 1] << 8)
          }

          Buffer.prototype.readUInt16BE = function readUInt16BE(
            offset,
            noAssert
          ) {
            offset = offset >>> 0
            if (!noAssert) checkOffset(offset, 2, this.length)
            return (this[offset] << 8) | this[offset + 1]
          }

          Buffer.prototype.readUInt32LE = function readUInt32LE(
            offset,
            noAssert
          ) {
            offset = offset >>> 0
            if (!noAssert) checkOffset(offset, 4, this.length)

            return (
              (this[offset] |
                (this[offset + 1] << 8) |
                (this[offset + 2] << 16)) +
              this[offset + 3] * 0x1000000
            )
          }

          Buffer.prototype.readUInt32BE = function readUInt32BE(
            offset,
            noAssert
          ) {
            offset = offset >>> 0
            if (!noAssert) checkOffset(offset, 4, this.length)

            return (
              this[offset] * 0x1000000 +
              ((this[offset + 1] << 16) |
                (this[offset + 2] << 8) |
                this[offset + 3])
            )
          }

          Buffer.prototype.readIntLE = function readIntLE(
            offset,
            byteLength,
            noAssert
          ) {
            offset = offset >>> 0
            byteLength = byteLength >>> 0
            if (!noAssert) checkOffset(offset, byteLength, this.length)

            var val = this[offset]
            var mul = 1
            var i = 0
            while (++i < byteLength && (mul *= 0x100)) {
              val += this[offset + i] * mul
            }
            mul *= 0x80

            if (val >= mul) val -= Math.pow(2, 8 * byteLength)

            return val
          }

          Buffer.prototype.readIntBE = function readIntBE(
            offset,
            byteLength,
            noAssert
          ) {
            offset = offset >>> 0
            byteLength = byteLength >>> 0
            if (!noAssert) checkOffset(offset, byteLength, this.length)

            var i = byteLength
            var mul = 1
            var val = this[offset + --i]
            while (i > 0 && (mul *= 0x100)) {
              val += this[offset + --i] * mul
            }
            mul *= 0x80

            if (val >= mul) val -= Math.pow(2, 8 * byteLength)

            return val
          }

          Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
            offset = offset >>> 0
            if (!noAssert) checkOffset(offset, 1, this.length)
            if (!(this[offset] & 0x80)) return this[offset]
            return (0xff - this[offset] + 1) * -1
          }

          Buffer.prototype.readInt16LE = function readInt16LE(
            offset,
            noAssert
          ) {
            offset = offset >>> 0
            if (!noAssert) checkOffset(offset, 2, this.length)
            var val = this[offset] | (this[offset + 1] << 8)
            return val & 0x8000 ? val | 0xffff0000 : val
          }

          Buffer.prototype.readInt16BE = function readInt16BE(
            offset,
            noAssert
          ) {
            offset = offset >>> 0
            if (!noAssert) checkOffset(offset, 2, this.length)
            var val = this[offset + 1] | (this[offset] << 8)
            return val & 0x8000 ? val | 0xffff0000 : val
          }

          Buffer.prototype.readInt32LE = function readInt32LE(
            offset,
            noAssert
          ) {
            offset = offset >>> 0
            if (!noAssert) checkOffset(offset, 4, this.length)

            return (
              this[offset] |
              (this[offset + 1] << 8) |
              (this[offset + 2] << 16) |
              (this[offset + 3] << 24)
            )
          }

          Buffer.prototype.readInt32BE = function readInt32BE(
            offset,
            noAssert
          ) {
            offset = offset >>> 0
            if (!noAssert) checkOffset(offset, 4, this.length)

            return (
              (this[offset] << 24) |
              (this[offset + 1] << 16) |
              (this[offset + 2] << 8) |
              this[offset + 3]
            )
          }

          Buffer.prototype.readFloatLE = function readFloatLE(
            offset,
            noAssert
          ) {
            offset = offset >>> 0
            if (!noAssert) checkOffset(offset, 4, this.length)
            return ieee754.read(this, offset, true, 23, 4)
          }

          Buffer.prototype.readFloatBE = function readFloatBE(
            offset,
            noAssert
          ) {
            offset = offset >>> 0
            if (!noAssert) checkOffset(offset, 4, this.length)
            return ieee754.read(this, offset, false, 23, 4)
          }

          Buffer.prototype.readDoubleLE = function readDoubleLE(
            offset,
            noAssert
          ) {
            offset = offset >>> 0
            if (!noAssert) checkOffset(offset, 8, this.length)
            return ieee754.read(this, offset, true, 52, 8)
          }

          Buffer.prototype.readDoubleBE = function readDoubleBE(
            offset,
            noAssert
          ) {
            offset = offset >>> 0
            if (!noAssert) checkOffset(offset, 8, this.length)
            return ieee754.read(this, offset, false, 52, 8)
          }

          function checkInt(buf, value, offset, ext, max, min) {
            if (!Buffer.isBuffer(buf))
              throw new TypeError('"buffer" argument must be a Buffer instance')
            if (value > max || value < min)
              throw new RangeError('"value" argument is out of bounds')
            if (offset + ext > buf.length)
              throw new RangeError('Index out of range')
          }

          Buffer.prototype.writeUIntLE = function writeUIntLE(
            value,
            offset,
            byteLength,
            noAssert
          ) {
            value = +value
            offset = offset >>> 0
            byteLength = byteLength >>> 0
            if (!noAssert) {
              var maxBytes = Math.pow(2, 8 * byteLength) - 1
              checkInt(this, value, offset, byteLength, maxBytes, 0)
            }

            var mul = 1
            var i = 0
            this[offset] = value & 0xff
            while (++i < byteLength && (mul *= 0x100)) {
              this[offset + i] = (value / mul) & 0xff
            }

            return offset + byteLength
          }

          Buffer.prototype.writeUIntBE = function writeUIntBE(
            value,
            offset,
            byteLength,
            noAssert
          ) {
            value = +value
            offset = offset >>> 0
            byteLength = byteLength >>> 0
            if (!noAssert) {
              var maxBytes = Math.pow(2, 8 * byteLength) - 1
              checkInt(this, value, offset, byteLength, maxBytes, 0)
            }

            var i = byteLength - 1
            var mul = 1
            this[offset + i] = value & 0xff
            while (--i >= 0 && (mul *= 0x100)) {
              this[offset + i] = (value / mul) & 0xff
            }

            return offset + byteLength
          }

          Buffer.prototype.writeUInt8 = function writeUInt8(
            value,
            offset,
            noAssert
          ) {
            value = +value
            offset = offset >>> 0
            if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
            this[offset] = value & 0xff
            return offset + 1
          }

          Buffer.prototype.writeUInt16LE = function writeUInt16LE(
            value,
            offset,
            noAssert
          ) {
            value = +value
            offset = offset >>> 0
            if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
            this[offset] = value & 0xff
            this[offset + 1] = value >>> 8
            return offset + 2
          }

          Buffer.prototype.writeUInt16BE = function writeUInt16BE(
            value,
            offset,
            noAssert
          ) {
            value = +value
            offset = offset >>> 0
            if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
            this[offset] = value >>> 8
            this[offset + 1] = value & 0xff
            return offset + 2
          }

          Buffer.prototype.writeUInt32LE = function writeUInt32LE(
            value,
            offset,
            noAssert
          ) {
            value = +value
            offset = offset >>> 0
            if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
            this[offset + 3] = value >>> 24
            this[offset + 2] = value >>> 16
            this[offset + 1] = value >>> 8
            this[offset] = value & 0xff
            return offset + 4
          }

          Buffer.prototype.writeUInt32BE = function writeUInt32BE(
            value,
            offset,
            noAssert
          ) {
            value = +value
            offset = offset >>> 0
            if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
            this[offset] = value >>> 24
            this[offset + 1] = value >>> 16
            this[offset + 2] = value >>> 8
            this[offset + 3] = value & 0xff
            return offset + 4
          }

          Buffer.prototype.writeIntLE = function writeIntLE(
            value,
            offset,
            byteLength,
            noAssert
          ) {
            value = +value
            offset = offset >>> 0
            if (!noAssert) {
              var limit = Math.pow(2, 8 * byteLength - 1)

              checkInt(this, value, offset, byteLength, limit - 1, -limit)
            }

            var i = 0
            var mul = 1
            var sub = 0
            this[offset] = value & 0xff
            while (++i < byteLength && (mul *= 0x100)) {
              if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                sub = 1
              }
              this[offset + i] = (((value / mul) >> 0) - sub) & 0xff
            }

            return offset + byteLength
          }

          Buffer.prototype.writeIntBE = function writeIntBE(
            value,
            offset,
            byteLength,
            noAssert
          ) {
            value = +value
            offset = offset >>> 0
            if (!noAssert) {
              var limit = Math.pow(2, 8 * byteLength - 1)

              checkInt(this, value, offset, byteLength, limit - 1, -limit)
            }

            var i = byteLength - 1
            var mul = 1
            var sub = 0
            this[offset + i] = value & 0xff
            while (--i >= 0 && (mul *= 0x100)) {
              if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                sub = 1
              }
              this[offset + i] = (((value / mul) >> 0) - sub) & 0xff
            }

            return offset + byteLength
          }

          Buffer.prototype.writeInt8 = function writeInt8(
            value,
            offset,
            noAssert
          ) {
            value = +value
            offset = offset >>> 0
            if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
            if (value < 0) value = 0xff + value + 1
            this[offset] = value & 0xff
            return offset + 1
          }

          Buffer.prototype.writeInt16LE = function writeInt16LE(
            value,
            offset,
            noAssert
          ) {
            value = +value
            offset = offset >>> 0
            if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
            this[offset] = value & 0xff
            this[offset + 1] = value >>> 8
            return offset + 2
          }

          Buffer.prototype.writeInt16BE = function writeInt16BE(
            value,
            offset,
            noAssert
          ) {
            value = +value
            offset = offset >>> 0
            if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
            this[offset] = value >>> 8
            this[offset + 1] = value & 0xff
            return offset + 2
          }

          Buffer.prototype.writeInt32LE = function writeInt32LE(
            value,
            offset,
            noAssert
          ) {
            value = +value
            offset = offset >>> 0
            if (!noAssert)
              checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
            this[offset] = value & 0xff
            this[offset + 1] = value >>> 8
            this[offset + 2] = value >>> 16
            this[offset + 3] = value >>> 24
            return offset + 4
          }

          Buffer.prototype.writeInt32BE = function writeInt32BE(
            value,
            offset,
            noAssert
          ) {
            value = +value
            offset = offset >>> 0
            if (!noAssert)
              checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
            if (value < 0) value = 0xffffffff + value + 1
            this[offset] = value >>> 24
            this[offset + 1] = value >>> 16
            this[offset + 2] = value >>> 8
            this[offset + 3] = value & 0xff
            return offset + 4
          }

          function checkIEEE754(buf, value, offset, ext, max, min) {
            if (offset + ext > buf.length)
              throw new RangeError('Index out of range')
            if (offset < 0) throw new RangeError('Index out of range')
          }

          function writeFloat(buf, value, offset, littleEndian, noAssert) {
            value = +value
            offset = offset >>> 0
            if (!noAssert) {
              checkIEEE754(
                buf,
                value,
                offset,
                4,
                3.4028234663852886e38,
                -3.4028234663852886e38
              )
            }
            ieee754.write(buf, value, offset, littleEndian, 23, 4)
            return offset + 4
          }

          Buffer.prototype.writeFloatLE = function writeFloatLE(
            value,
            offset,
            noAssert
          ) {
            return writeFloat(this, value, offset, true, noAssert)
          }

          Buffer.prototype.writeFloatBE = function writeFloatBE(
            value,
            offset,
            noAssert
          ) {
            return writeFloat(this, value, offset, false, noAssert)
          }

          function writeDouble(buf, value, offset, littleEndian, noAssert) {
            value = +value
            offset = offset >>> 0
            if (!noAssert) {
              checkIEEE754(
                buf,
                value,
                offset,
                8,
                1.7976931348623157e308,
                -1.7976931348623157e308
              )
            }
            ieee754.write(buf, value, offset, littleEndian, 52, 8)
            return offset + 8
          }

          Buffer.prototype.writeDoubleLE = function writeDoubleLE(
            value,
            offset,
            noAssert
          ) {
            return writeDouble(this, value, offset, true, noAssert)
          }

          Buffer.prototype.writeDoubleBE = function writeDoubleBE(
            value,
            offset,
            noAssert
          ) {
            return writeDouble(this, value, offset, false, noAssert)
          }

          // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
          Buffer.prototype.copy = function copy(
            target,
            targetStart,
            start,
            end
          ) {
            if (!start) start = 0
            if (!end && end !== 0) end = this.length
            if (targetStart >= target.length) targetStart = target.length
            if (!targetStart) targetStart = 0
            if (end > 0 && end < start) end = start

            // Copy 0 bytes; we're done
            if (end === start) return 0
            if (target.length === 0 || this.length === 0) return 0

            // Fatal error conditions
            if (targetStart < 0) {
              throw new RangeError('targetStart out of bounds')
            }
            if (start < 0 || start >= this.length)
              throw new RangeError('sourceStart out of bounds')
            if (end < 0) throw new RangeError('sourceEnd out of bounds')

            // Are we oob?
            if (end > this.length) end = this.length
            if (target.length - targetStart < end - start) {
              end = target.length - targetStart + start
            }

            var len = end - start
            var i

            if (this === target && start < targetStart && targetStart < end) {
              // descending copy from end
              for (i = len - 1; i >= 0; --i) {
                target[i + targetStart] = this[i + start]
              }
            } else if (len < 1000) {
              // ascending copy from start
              for (i = 0; i < len; ++i) {
                target[i + targetStart] = this[i + start]
              }
            } else {
              Uint8Array.prototype.set.call(
                target,
                this.subarray(start, start + len),
                targetStart
              )
            }

            return len
          }

          // Usage:
          //    buffer.fill(number[, offset[, end]])
          //    buffer.fill(buffer[, offset[, end]])
          //    buffer.fill(string[, offset[, end]][, encoding])
          Buffer.prototype.fill = function fill(val, start, end, encoding) {
            // Handle string cases:
            if (typeof val === 'string') {
              if (typeof start === 'string') {
                encoding = start
                start = 0
                end = this.length
              } else if (typeof end === 'string') {
                encoding = end
                end = this.length
              }
              if (val.length === 1) {
                var code = val.charCodeAt(0)
                if (code < 256) {
                  val = code
                }
              }
              if (encoding !== undefined && typeof encoding !== 'string') {
                throw new TypeError('encoding must be a string')
              }
              if (
                typeof encoding === 'string' &&
                !Buffer.isEncoding(encoding)
              ) {
                throw new TypeError('Unknown encoding: ' + encoding)
              }
            } else if (typeof val === 'number') {
              val = val & 255
            }

            // Invalid ranges are not set to a default, so can range check early.
            if (start < 0 || this.length < start || this.length < end) {
              throw new RangeError('Out of range index')
            }

            if (end <= start) {
              return this
            }

            start = start >>> 0
            end = end === undefined ? this.length : end >>> 0

            if (!val) val = 0

            var i
            if (typeof val === 'number') {
              for (i = start; i < end; ++i) {
                this[i] = val
              }
            } else {
              var bytes = Buffer.isBuffer(val) ? val : new Buffer(val, encoding)
              var len = bytes.length
              for (i = 0; i < end - start; ++i) {
                this[i + start] = bytes[i % len]
              }
            }

            return this
          }

          // HELPER FUNCTIONS
          // ================

          var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

          function base64clean(str) {
            // Node strips out invalid characters like \n and \t from the string, base64-js does not
            str = str.trim().replace(INVALID_BASE64_RE, '')
            // Node converts strings with length < 2 to ''
            if (str.length < 2) return ''
            // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
            while (str.length % 4 !== 0) {
              str = str + '='
            }
            return str
          }

          function toHex(n) {
            if (n < 16) return '0' + n.toString(16)
            return n.toString(16)
          }

          function utf8ToBytes(string, units) {
            units = units || Infinity
            var codePoint
            var length = string.length
            var leadSurrogate = null
            var bytes = []

            for (var i = 0; i < length; ++i) {
              codePoint = string.charCodeAt(i)

              // is surrogate component
              if (codePoint > 0xd7ff && codePoint < 0xe000) {
                // last char was a lead
                if (!leadSurrogate) {
                  // no lead yet
                  if (codePoint > 0xdbff) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd)
                    continue
                  } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd)
                    continue
                  }

                  // valid lead
                  leadSurrogate = codePoint

                  continue
                }

                // 2 leads in a row
                if (codePoint < 0xdc00) {
                  if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd)
                  leadSurrogate = codePoint
                  continue
                }

                // valid surrogate pair
                codePoint =
                  (((leadSurrogate - 0xd800) << 10) | (codePoint - 0xdc00)) +
                  0x10000
              } else if (leadSurrogate) {
                // valid bmp char, but last char was a lead
                if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd)
              }

              leadSurrogate = null

              // encode utf8
              if (codePoint < 0x80) {
                if ((units -= 1) < 0) break
                bytes.push(codePoint)
              } else if (codePoint < 0x800) {
                if ((units -= 2) < 0) break
                bytes.push((codePoint >> 0x6) | 0xc0, (codePoint & 0x3f) | 0x80)
              } else if (codePoint < 0x10000) {
                if ((units -= 3) < 0) break
                bytes.push(
                  (codePoint >> 0xc) | 0xe0,
                  ((codePoint >> 0x6) & 0x3f) | 0x80,
                  (codePoint & 0x3f) | 0x80
                )
              } else if (codePoint < 0x110000) {
                if ((units -= 4) < 0) break
                bytes.push(
                  (codePoint >> 0x12) | 0xf0,
                  ((codePoint >> 0xc) & 0x3f) | 0x80,
                  ((codePoint >> 0x6) & 0x3f) | 0x80,
                  (codePoint & 0x3f) | 0x80
                )
              } else {
                throw new Error('Invalid code point')
              }
            }

            return bytes
          }

          function asciiToBytes(str) {
            var byteArray = []
            for (var i = 0; i < str.length; ++i) {
              // Node's code seems to be doing this and not & 0x7F..
              byteArray.push(str.charCodeAt(i) & 0xff)
            }
            return byteArray
          }

          function utf16leToBytes(str, units) {
            var c, hi, lo
            var byteArray = []
            for (var i = 0; i < str.length; ++i) {
              if ((units -= 2) < 0) break

              c = str.charCodeAt(i)
              hi = c >> 8
              lo = c % 256
              byteArray.push(lo)
              byteArray.push(hi)
            }

            return byteArray
          }

          function base64ToBytes(str) {
            return base64.toByteArray(base64clean(str))
          }

          function blitBuffer(src, dst, offset, length) {
            for (var i = 0; i < length; ++i) {
              if (i + offset >= dst.length || i >= src.length) break
              dst[i + offset] = src[i]
            }
            return i
          }

          // Node 0.10 supports `ArrayBuffer` but lacks `ArrayBuffer.isView`
          function isArrayBufferView(obj) {
            return (
              typeof ArrayBuffer.isView === 'function' &&
              ArrayBuffer.isView(obj)
            )
          }

          function numberIsNaN(obj) {
            return obj !== obj // eslint-disable-line no-self-compare
          }
        },
        { 'base64-js': 116, ieee754: 267 },
      ],
      122: [
        function(require, module, exports) {
          ;(function(process) {
            'use strict'
            var escapeStringRegexp = require('escape-string-regexp')
            var ansiStyles = require('ansi-styles')
            var stripAnsi = require('strip-ansi')
            var hasAnsi = require('has-ansi')
            var supportsColor = require('supports-color')
            var defineProps = Object.defineProperties
            var isSimpleWindowsTerm =
              process.platform === 'win32' && !/^xterm/i.test(process.env.TERM)

            function Chalk(options) {
              // detect mode if not set manually
              this.enabled = !options || options.enabled === undefined
                ? supportsColor
                : options.enabled
            }

            // use bright blue on Windows as the normal blue color is illegible
            if (isSimpleWindowsTerm) {
              ansiStyles.blue.open = '\u001b[94m'
            }

            var styles = (function() {
              var ret = {}

              Object.keys(ansiStyles).forEach(function(key) {
                ansiStyles[key].closeRe = new RegExp(
                  escapeStringRegexp(ansiStyles[key].close),
                  'g'
                )

                ret[key] = {
                  get: function() {
                    return build.call(this, this._styles.concat(key))
                  },
                }
              })

              return ret
            })()

            var proto = defineProps(function chalk() {}, styles)

            function build(_styles) {
              var builder = function() {
                return applyStyle.apply(builder, arguments)
              }

              builder._styles = _styles
              builder.enabled = this.enabled
              // __proto__ is used because we must return a function, but there is
              // no way to create a function with a different prototype.
              /* eslint-disable no-proto */
              builder.__proto__ = proto

              return builder
            }

            function applyStyle() {
              // support varags, but simply cast to string in case there's only one arg
              var args = arguments
              var argsLen = args.length
              var str = argsLen !== 0 && String(arguments[0])

              if (argsLen > 1) {
                // don't slice `arguments`, it prevents v8 optimizations
                for (var a = 1; a < argsLen; a++) {
                  str += ' ' + args[a]
                }
              }

              if (!this.enabled || !str) {
                return str
              }

              var nestedStyles = this._styles
              var i = nestedStyles.length

              // Turns out that on Windows dimmed gray text becomes invisible in cmd.exe,
              // see https://github.com/chalk/chalk/issues/58
              // If we're on Windows and we're dealing with a gray color, temporarily make 'dim' a noop.
              var originalDim = ansiStyles.dim.open
              if (
                isSimpleWindowsTerm &&
                (nestedStyles.indexOf('gray') !== -1 ||
                  nestedStyles.indexOf('grey') !== -1)
              ) {
                ansiStyles.dim.open = ''
              }

              while (i--) {
                var code = ansiStyles[nestedStyles[i]]

                // Replace any instances already present with a re-opening code
                // otherwise only the part of the string until said closing code
                // will be colored, and the rest will simply be 'plain'.
                str =
                  code.open + str.replace(code.closeRe, code.open) + code.close
              }

              // Reset the original 'dim' if we changed it to work around the Windows dimmed gray issue.
              ansiStyles.dim.open = originalDim

              return str
            }

            function init() {
              var ret = {}

              Object.keys(styles).forEach(function(name) {
                ret[name] = {
                  get: function() {
                    return build.call(this, [name])
                  },
                }
              })

              return ret
            }

            defineProps(Chalk.prototype, init())

            module.exports = new Chalk()
            module.exports.styles = ansiStyles
            module.exports.hasColor = hasAnsi
            module.exports.stripColor = stripAnsi
            module.exports.supportsColor = supportsColor
          }.call(this, require('_process')))
        },
        {
          _process: 507,
          'ansi-styles': 3,
          'escape-string-regexp': 247,
          'has-ansi': 265,
          'strip-ansi': 527,
          'supports-color': 123,
        },
      ],
      123: [
        function(require, module, exports) {
          ;(function(process) {
            'use strict'
            var argv = process.argv

            var terminator = argv.indexOf('--')
            var hasFlag = function(flag) {
              flag = '--' + flag
              var pos = argv.indexOf(flag)
              return pos !== -1 && (terminator !== -1 ? pos < terminator : true)
            }

            module.exports = (function() {
              if ('FORCE_COLOR' in process.env) {
                return true
              }

              if (
                hasFlag('no-color') ||
                hasFlag('no-colors') ||
                hasFlag('color=false')
              ) {
                return false
              }

              if (
                hasFlag('color') ||
                hasFlag('colors') ||
                hasFlag('color=true') ||
                hasFlag('color=always')
              ) {
                return true
              }

              if (process.stdout && !process.stdout.isTTY) {
                return false
              }

              if (process.platform === 'win32') {
                return true
              }

              if ('COLORTERM' in process.env) {
                return true
              }

              if (process.env.TERM === 'dumb') {
                return false
              }

              if (
                /^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(
                  process.env.TERM
                )
              ) {
                return true
              }

              return false
            })()
          }.call(this, require('_process')))
        },
        { _process: 507 },
      ],
      124: [
        function(require, module, exports) {
          /* MIT license */
          var cssKeywords = require('color-name')

          // NOTE: conversions should only return primitive values (i.e. arrays, or
          //       values that give correct `typeof` results).
          //       do not use box values types (i.e. Number(), String(), etc.)

          var reverseKeywords = {}
          for (var key in cssKeywords) {
            if (cssKeywords.hasOwnProperty(key)) {
              reverseKeywords[cssKeywords[key]] = key
            }
          }

          var convert = (module.exports = {
            rgb: { channels: 3, labels: 'rgb' },
            hsl: { channels: 3, labels: 'hsl' },
            hsv: { channels: 3, labels: 'hsv' },
            hwb: { channels: 3, labels: 'hwb' },
            cmyk: { channels: 4, labels: 'cmyk' },
            xyz: { channels: 3, labels: 'xyz' },
            lab: { channels: 3, labels: 'lab' },
            lch: { channels: 3, labels: 'lch' },
            hex: { channels: 1, labels: ['hex'] },
            keyword: { channels: 1, labels: ['keyword'] },
            ansi16: { channels: 1, labels: ['ansi16'] },
            ansi256: { channels: 1, labels: ['ansi256'] },
            hcg: { channels: 3, labels: ['h', 'c', 'g'] },
            apple: { channels: 3, labels: ['r16', 'g16', 'b16'] },
            gray: { channels: 1, labels: ['gray'] },
          })

          // hide .channels and .labels properties
          for (var model in convert) {
            if (convert.hasOwnProperty(model)) {
              if (!('channels' in convert[model])) {
                throw new Error('missing channels property: ' + model)
              }

              if (!('labels' in convert[model])) {
                throw new Error('missing channel labels property: ' + model)
              }

              if (convert[model].labels.length !== convert[model].channels) {
                throw new Error('channel and label counts mismatch: ' + model)
              }

              var channels = convert[model].channels
              var labels = convert[model].labels
              delete convert[model].channels
              delete convert[model].labels
              Object.defineProperty(convert[model], 'channels', {
                value: channels,
              })
              Object.defineProperty(convert[model], 'labels', { value: labels })
            }
          }

          convert.rgb.hsl = function(rgb) {
            var r = rgb[0] / 255
            var g = rgb[1] / 255
            var b = rgb[2] / 255
            var min = Math.min(r, g, b)
            var max = Math.max(r, g, b)
            var delta = max - min
            var h
            var s
            var l

            if (max === min) {
              h = 0
            } else if (r === max) {
              h = (g - b) / delta
            } else if (g === max) {
              h = 2 + (b - r) / delta
            } else if (b === max) {
              h = 4 + (r - g) / delta
            }

            h = Math.min(h * 60, 360)

            if (h < 0) {
              h += 360
            }

            l = (min + max) / 2

            if (max === min) {
              s = 0
            } else if (l <= 0.5) {
              s = delta / (max + min)
            } else {
              s = delta / (2 - max - min)
            }

            return [h, s * 100, l * 100]
          }

          convert.rgb.hsv = function(rgb) {
            var r = rgb[0]
            var g = rgb[1]
            var b = rgb[2]
            var min = Math.min(r, g, b)
            var max = Math.max(r, g, b)
            var delta = max - min
            var h
            var s
            var v

            if (max === 0) {
              s = 0
            } else {
              s = delta / max * 1000 / 10
            }

            if (max === min) {
              h = 0
            } else if (r === max) {
              h = (g - b) / delta
            } else if (g === max) {
              h = 2 + (b - r) / delta
            } else if (b === max) {
              h = 4 + (r - g) / delta
            }

            h = Math.min(h * 60, 360)

            if (h < 0) {
              h += 360
            }

            v = max / 255 * 1000 / 10

            return [h, s, v]
          }

          convert.rgb.hwb = function(rgb) {
            var r = rgb[0]
            var g = rgb[1]
            var b = rgb[2]
            var h = convert.rgb.hsl(rgb)[0]
            var w = 1 / 255 * Math.min(r, Math.min(g, b))

            b = 1 - 1 / 255 * Math.max(r, Math.max(g, b))

            return [h, w * 100, b * 100]
          }

          convert.rgb.cmyk = function(rgb) {
            var r = rgb[0] / 255
            var g = rgb[1] / 255
            var b = rgb[2] / 255
            var c
            var m
            var y
            var k

            k = Math.min(1 - r, 1 - g, 1 - b)
            c = (1 - r - k) / (1 - k) || 0
            m = (1 - g - k) / (1 - k) || 0
            y = (1 - b - k) / (1 - k) || 0

            return [c * 100, m * 100, y * 100, k * 100]
          }

          /**
 * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
 * */
          function comparativeDistance(x, y) {
            return (
              Math.pow(x[0] - y[0], 2) +
              Math.pow(x[1] - y[1], 2) +
              Math.pow(x[2] - y[2], 2)
            )
          }

          convert.rgb.keyword = function(rgb) {
            var reversed = reverseKeywords[rgb]
            if (reversed) {
              return reversed
            }

            var currentClosestDistance = Infinity
            var currentClosestKeyword

            for (var keyword in cssKeywords) {
              if (cssKeywords.hasOwnProperty(keyword)) {
                var value = cssKeywords[keyword]

                // Compute comparative distance
                var distance = comparativeDistance(rgb, value)

                // Check if its less, if so set as closest
                if (distance < currentClosestDistance) {
                  currentClosestDistance = distance
                  currentClosestKeyword = keyword
                }
              }
            }

            return currentClosestKeyword
          }

          convert.keyword.rgb = function(keyword) {
            return cssKeywords[keyword]
          }

          convert.rgb.xyz = function(rgb) {
            var r = rgb[0] / 255
            var g = rgb[1] / 255
            var b = rgb[2] / 255

            // assume sRGB
            r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92
            g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92
            b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92

            var x = r * 0.4124 + g * 0.3576 + b * 0.1805
            var y = r * 0.2126 + g * 0.7152 + b * 0.0722
            var z = r * 0.0193 + g * 0.1192 + b * 0.9505

            return [x * 100, y * 100, z * 100]
          }

          convert.rgb.lab = function(rgb) {
            var xyz = convert.rgb.xyz(rgb)
            var x = xyz[0]
            var y = xyz[1]
            var z = xyz[2]
            var l
            var a
            var b

            x /= 95.047
            y /= 100
            z /= 108.883

            x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116
            y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116
            z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116

            l = 116 * y - 16
            a = 500 * (x - y)
            b = 200 * (y - z)

            return [l, a, b]
          }

          convert.hsl.rgb = function(hsl) {
            var h = hsl[0] / 360
            var s = hsl[1] / 100
            var l = hsl[2] / 100
            var t1
            var t2
            var t3
            var rgb
            var val

            if (s === 0) {
              val = l * 255
              return [val, val, val]
            }

            if (l < 0.5) {
              t2 = l * (1 + s)
            } else {
              t2 = l + s - l * s
            }

            t1 = 2 * l - t2

            rgb = [0, 0, 0]
            for (var i = 0; i < 3; i++) {
              t3 = h + 1 / 3 * -(i - 1)
              if (t3 < 0) {
                t3++
              }
              if (t3 > 1) {
                t3--
              }

              if (6 * t3 < 1) {
                val = t1 + (t2 - t1) * 6 * t3
              } else if (2 * t3 < 1) {
                val = t2
              } else if (3 * t3 < 2) {
                val = t1 + (t2 - t1) * (2 / 3 - t3) * 6
              } else {
                val = t1
              }

              rgb[i] = val * 255
            }

            return rgb
          }

          convert.hsl.hsv = function(hsl) {
            var h = hsl[0]
            var s = hsl[1] / 100
            var l = hsl[2] / 100
            var smin = s
            var lmin = Math.max(l, 0.01)
            var sv
            var v

            l *= 2
            s *= l <= 1 ? l : 2 - l
            smin *= lmin <= 1 ? lmin : 2 - lmin
            v = (l + s) / 2
            sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s)

            return [h, sv * 100, v * 100]
          }

          convert.hsv.rgb = function(hsv) {
            var h = hsv[0] / 60
            var s = hsv[1] / 100
            var v = hsv[2] / 100
            var hi = Math.floor(h) % 6

            var f = h - Math.floor(h)
            var p = 255 * v * (1 - s)
            var q = 255 * v * (1 - s * f)
            var t = 255 * v * (1 - s * (1 - f))
            v *= 255

            switch (hi) {
              case 0:
                return [v, t, p]
              case 1:
                return [q, v, p]
              case 2:
                return [p, v, t]
              case 3:
                return [p, q, v]
              case 4:
                return [t, p, v]
              case 5:
                return [v, p, q]
            }
          }

          convert.hsv.hsl = function(hsv) {
            var h = hsv[0]
            var s = hsv[1] / 100
            var v = hsv[2] / 100
            var vmin = Math.max(v, 0.01)
            var lmin
            var sl
            var l

            l = (2 - s) * v
            lmin = (2 - s) * vmin
            sl = s * vmin
            sl /= lmin <= 1 ? lmin : 2 - lmin
            sl = sl || 0
            l /= 2

            return [h, sl * 100, l * 100]
          }

          // http://dev.w3.org/csswg/css-color/#hwb-to-rgb
          convert.hwb.rgb = function(hwb) {
            var h = hwb[0] / 360
            var wh = hwb[1] / 100
            var bl = hwb[2] / 100
            var ratio = wh + bl
            var i
            var v
            var f
            var n

            // wh + bl cant be > 1
            if (ratio > 1) {
              wh /= ratio
              bl /= ratio
            }

            i = Math.floor(6 * h)
            v = 1 - bl
            f = 6 * h - i

            if ((i & 0x01) !== 0) {
              f = 1 - f
            }

            n = wh + f * (v - wh) // linear interpolation

            var r
            var g
            var b
            switch (i) {
              default:
              case 6:
              case 0:
                r = v
                g = n
                b = wh
                break
              case 1:
                r = n
                g = v
                b = wh
                break
              case 2:
                r = wh
                g = v
                b = n
                break
              case 3:
                r = wh
                g = n
                b = v
                break
              case 4:
                r = n
                g = wh
                b = v
                break
              case 5:
                r = v
                g = wh
                b = n
                break
            }

            return [r * 255, g * 255, b * 255]
          }

          convert.cmyk.rgb = function(cmyk) {
            var c = cmyk[0] / 100
            var m = cmyk[1] / 100
            var y = cmyk[2] / 100
            var k = cmyk[3] / 100
            var r
            var g
            var b

            r = 1 - Math.min(1, c * (1 - k) + k)
            g = 1 - Math.min(1, m * (1 - k) + k)
            b = 1 - Math.min(1, y * (1 - k) + k)

            return [r * 255, g * 255, b * 255]
          }

          convert.xyz.rgb = function(xyz) {
            var x = xyz[0] / 100
            var y = xyz[1] / 100
            var z = xyz[2] / 100
            var r
            var g
            var b

            r = x * 3.2406 + y * -1.5372 + z * -0.4986
            g = x * -0.9689 + y * 1.8758 + z * 0.0415
            b = x * 0.0557 + y * -0.204 + z * 1.057

            // assume sRGB
            r = r > 0.0031308
              ? 1.055 * Math.pow(r, 1.0 / 2.4) - 0.055
              : r * 12.92

            g = g > 0.0031308
              ? 1.055 * Math.pow(g, 1.0 / 2.4) - 0.055
              : g * 12.92

            b = b > 0.0031308
              ? 1.055 * Math.pow(b, 1.0 / 2.4) - 0.055
              : b * 12.92

            r = Math.min(Math.max(0, r), 1)
            g = Math.min(Math.max(0, g), 1)
            b = Math.min(Math.max(0, b), 1)

            return [r * 255, g * 255, b * 255]
          }

          convert.xyz.lab = function(xyz) {
            var x = xyz[0]
            var y = xyz[1]
            var z = xyz[2]
            var l
            var a
            var b

            x /= 95.047
            y /= 100
            z /= 108.883

            x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116
            y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116
            z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116

            l = 116 * y - 16
            a = 500 * (x - y)
            b = 200 * (y - z)

            return [l, a, b]
          }

          convert.lab.xyz = function(lab) {
            var l = lab[0]
            var a = lab[1]
            var b = lab[2]
            var x
            var y
            var z

            y = (l + 16) / 116
            x = a / 500 + y
            z = y - b / 200

            var y2 = Math.pow(y, 3)
            var x2 = Math.pow(x, 3)
            var z2 = Math.pow(z, 3)
            y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787
            x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787
            z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787

            x *= 95.047
            y *= 100
            z *= 108.883

            return [x, y, z]
          }

          convert.lab.lch = function(lab) {
            var l = lab[0]
            var a = lab[1]
            var b = lab[2]
            var hr
            var h
            var c

            hr = Math.atan2(b, a)
            h = hr * 360 / 2 / Math.PI

            if (h < 0) {
              h += 360
            }

            c = Math.sqrt(a * a + b * b)

            return [l, c, h]
          }

          convert.lch.lab = function(lch) {
            var l = lch[0]
            var c = lch[1]
            var h = lch[2]
            var a
            var b
            var hr

            hr = h / 360 * 2 * Math.PI
            a = c * Math.cos(hr)
            b = c * Math.sin(hr)

            return [l, a, b]
          }

          convert.rgb.ansi16 = function(args) {
            var r = args[0]
            var g = args[1]
            var b = args[2]
            var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2] // hsv -> ansi16 optimization

            value = Math.round(value / 50)

            if (value === 0) {
              return 30
            }

            var ansi =
              30 +
              ((Math.round(b / 255) << 2) |
                (Math.round(g / 255) << 1) |
                Math.round(r / 255))

            if (value === 2) {
              ansi += 60
            }

            return ansi
          }

          convert.hsv.ansi16 = function(args) {
            // optimization here; we already know the value and don't need to get
            // it converted for us.
            return convert.rgb.ansi16(convert.hsv.rgb(args), args[2])
          }

          convert.rgb.ansi256 = function(args) {
            var r = args[0]
            var g = args[1]
            var b = args[2]

            // we use the extended greyscale palette here, with the exception of
            // black and white. normal palette only has 4 greyscale shades.
            if (r === g && g === b) {
              if (r < 8) {
                return 16
              }

              if (r > 248) {
                return 231
              }

              return Math.round((r - 8) / 247 * 24) + 232
            }

            var ansi =
              16 +
              36 * Math.round(r / 255 * 5) +
              6 * Math.round(g / 255 * 5) +
              Math.round(b / 255 * 5)

            return ansi
          }

          convert.ansi16.rgb = function(args) {
            var color = args % 10

            // handle greyscale
            if (color === 0 || color === 7) {
              if (args > 50) {
                color += 3.5
              }

              color = color / 10.5 * 255

              return [color, color, color]
            }

            var mult = (~~(args > 50) + 1) * 0.5
            var r = (color & 1) * mult * 255
            var g = ((color >> 1) & 1) * mult * 255
            var b = ((color >> 2) & 1) * mult * 255

            return [r, g, b]
          }

          convert.ansi256.rgb = function(args) {
            // handle greyscale
            if (args >= 232) {
              var c = (args - 232) * 10 + 8
              return [c, c, c]
            }

            args -= 16

            var rem
            var r = Math.floor(args / 36) / 5 * 255
            var g = Math.floor((rem = args % 36) / 6) / 5 * 255
            var b = rem % 6 / 5 * 255

            return [r, g, b]
          }

          convert.rgb.hex = function(args) {
            var integer =
              ((Math.round(args[0]) & 0xff) << 16) +
              ((Math.round(args[1]) & 0xff) << 8) +
              (Math.round(args[2]) & 0xff)

            var string = integer.toString(16).toUpperCase()
            return '000000'.substring(string.length) + string
          }

          convert.hex.rgb = function(args) {
            var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i)
            if (!match) {
              return [0, 0, 0]
            }

            var colorString = match[0]

            if (match[0].length === 3) {
              colorString = colorString
                .split('')
                .map(function(char) {
                  return char + char
                })
                .join('')
            }

            var integer = parseInt(colorString, 16)
            var r = (integer >> 16) & 0xff
            var g = (integer >> 8) & 0xff
            var b = integer & 0xff

            return [r, g, b]
          }

          convert.rgb.hcg = function(rgb) {
            var r = rgb[0] / 255
            var g = rgb[1] / 255
            var b = rgb[2] / 255
            var max = Math.max(Math.max(r, g), b)
            var min = Math.min(Math.min(r, g), b)
            var chroma = max - min
            var grayscale
            var hue

            if (chroma < 1) {
              grayscale = min / (1 - chroma)
            } else {
              grayscale = 0
            }

            if (chroma <= 0) {
              hue = 0
            } else if (max === r) {
              hue = (g - b) / chroma % 6
            } else if (max === g) {
              hue = 2 + (b - r) / chroma
            } else {
              hue = 4 + (r - g) / chroma + 4
            }

            hue /= 6
            hue %= 1

            return [hue * 360, chroma * 100, grayscale * 100]
          }

          convert.hsl.hcg = function(hsl) {
            var s = hsl[1] / 100
            var l = hsl[2] / 100
            var c = 1
            var f = 0

            if (l < 0.5) {
              c = 2.0 * s * l
            } else {
              c = 2.0 * s * (1.0 - l)
            }

            if (c < 1.0) {
              f = (l - 0.5 * c) / (1.0 - c)
            }

            return [hsl[0], c * 100, f * 100]
          }

          convert.hsv.hcg = function(hsv) {
            var s = hsv[1] / 100
            var v = hsv[2] / 100

            var c = s * v
            var f = 0

            if (c < 1.0) {
              f = (v - c) / (1 - c)
            }

            return [hsv[0], c * 100, f * 100]
          }

          convert.hcg.rgb = function(hcg) {
            var h = hcg[0] / 360
            var c = hcg[1] / 100
            var g = hcg[2] / 100

            if (c === 0.0) {
              return [g * 255, g * 255, g * 255]
            }

            var pure = [0, 0, 0]
            var hi = h % 1 * 6
            var v = hi % 1
            var w = 1 - v
            var mg = 0

            switch (Math.floor(hi)) {
              case 0:
                pure[0] = 1
                pure[1] = v
                pure[2] = 0
                break
              case 1:
                pure[0] = w
                pure[1] = 1
                pure[2] = 0
                break
              case 2:
                pure[0] = 0
                pure[1] = 1
                pure[2] = v
                break
              case 3:
                pure[0] = 0
                pure[1] = w
                pure[2] = 1
                break
              case 4:
                pure[0] = v
                pure[1] = 0
                pure[2] = 1
                break
              default:
                pure[0] = 1
                pure[1] = 0
                pure[2] = w
            }

            mg = (1.0 - c) * g

            return [
              (c * pure[0] + mg) * 255,
              (c * pure[1] + mg) * 255,
              (c * pure[2] + mg) * 255,
            ]
          }

          convert.hcg.hsv = function(hcg) {
            var c = hcg[1] / 100
            var g = hcg[2] / 100

            var v = c + g * (1.0 - c)
            var f = 0

            if (v > 0.0) {
              f = c / v
            }

            return [hcg[0], f * 100, v * 100]
          }

          convert.hcg.hsl = function(hcg) {
            var c = hcg[1] / 100
            var g = hcg[2] / 100

            var l = g * (1.0 - c) + 0.5 * c
            var s = 0

            if (l > 0.0 && l < 0.5) {
              s = c / (2 * l)
            } else if (l >= 0.5 && l < 1.0) {
              s = c / (2 * (1 - l))
            }

            return [hcg[0], s * 100, l * 100]
          }

          convert.hcg.hwb = function(hcg) {
            var c = hcg[1] / 100
            var g = hcg[2] / 100
            var v = c + g * (1.0 - c)
            return [hcg[0], (v - c) * 100, (1 - v) * 100]
          }

          convert.hwb.hcg = function(hwb) {
            var w = hwb[1] / 100
            var b = hwb[2] / 100
            var v = 1 - b
            var c = v - w
            var g = 0

            if (c < 1) {
              g = (v - c) / (1 - c)
            }

            return [hwb[0], c * 100, g * 100]
          }

          convert.apple.rgb = function(apple) {
            return [
              apple[0] / 65535 * 255,
              apple[1] / 65535 * 255,
              apple[2] / 65535 * 255,
            ]
          }

          convert.rgb.apple = function(rgb) {
            return [
              rgb[0] / 255 * 65535,
              rgb[1] / 255 * 65535,
              rgb[2] / 255 * 65535,
            ]
          }

          convert.gray.rgb = function(args) {
            return [
              args[0] / 100 * 255,
              args[0] / 100 * 255,
              args[0] / 100 * 255,
            ]
          }

          convert.gray.hsl = convert.gray.hsv = function(args) {
            return [0, 0, args[0]]
          }

          convert.gray.hwb = function(gray) {
            return [0, 100, gray[0]]
          }

          convert.gray.cmyk = function(gray) {
            return [0, 0, 0, gray[0]]
          }

          convert.gray.lab = function(gray) {
            return [gray[0], 0, 0]
          }

          convert.gray.hex = function(gray) {
            var val = Math.round(gray[0] / 100 * 255) & 0xff
            var integer = (val << 16) + (val << 8) + val

            var string = integer.toString(16).toUpperCase()
            return '000000'.substring(string.length) + string
          }

          convert.rgb.gray = function(rgb) {
            var val = (rgb[0] + rgb[1] + rgb[2]) / 3
            return [val / 255 * 100]
          }
        },
        { 'color-name': 127 },
      ],
      125: [
        function(require, module, exports) {
          var conversions = require('./conversions')
          var route = require('./route')

          var convert = {}

          var models = Object.keys(conversions)

          function wrapRaw(fn) {
            var wrappedFn = function(args) {
              if (args === undefined || args === null) {
                return args
              }

              if (arguments.length > 1) {
                args = Array.prototype.slice.call(arguments)
              }

              return fn(args)
            }

            // preserve .conversion property if there is one
            if ('conversion' in fn) {
              wrappedFn.conversion = fn.conversion
            }

            return wrappedFn
          }

          function wrapRounded(fn) {
            var wrappedFn = function(args) {
              if (args === undefined || args === null) {
                return args
              }

              if (arguments.length > 1) {
                args = Array.prototype.slice.call(arguments)
              }

              var result = fn(args)

              // we're assuming the result is an array here.
              // see notice in conversions.js; don't use box types
              // in conversion functions.
              if (typeof result === 'object') {
                for (var len = result.length, i = 0; i < len; i++) {
                  result[i] = Math.round(result[i])
                }
              }

              return result
            }

            // preserve .conversion property if there is one
            if ('conversion' in fn) {
              wrappedFn.conversion = fn.conversion
            }

            return wrappedFn
          }

          models.forEach(function(fromModel) {
            convert[fromModel] = {}

            Object.defineProperty(convert[fromModel], 'channels', {
              value: conversions[fromModel].channels,
            })
            Object.defineProperty(convert[fromModel], 'labels', {
              value: conversions[fromModel].labels,
            })

            var routes = route(fromModel)
            var routeModels = Object.keys(routes)

            routeModels.forEach(function(toModel) {
              var fn = routes[toModel]

              convert[fromModel][toModel] = wrapRounded(fn)
              convert[fromModel][toModel].raw = wrapRaw(fn)
            })
          })

          module.exports = convert
        },
        { './conversions': 124, './route': 126 },
      ],
      126: [
        function(require, module, exports) {
          var conversions = require('./conversions')

          /*
	this function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/

          // https://jsperf.com/object-keys-vs-for-in-with-closure/3
          var models = Object.keys(conversions)

          function buildGraph() {
            var graph = {}

            for (var len = models.length, i = 0; i < len; i++) {
              graph[models[i]] = {
                // http://jsperf.com/1-vs-infinity
                // micro-opt, but this is simple.
                distance: -1,
                parent: null,
              }
            }

            return graph
          }

          // https://en.wikipedia.org/wiki/Breadth-first_search
          function deriveBFS(fromModel) {
            var graph = buildGraph()
            var queue = [fromModel] // unshift -> queue -> pop

            graph[fromModel].distance = 0

            while (queue.length) {
              var current = queue.pop()
              var adjacents = Object.keys(conversions[current])

              for (var len = adjacents.length, i = 0; i < len; i++) {
                var adjacent = adjacents[i]
                var node = graph[adjacent]

                if (node.distance === -1) {
                  node.distance = graph[current].distance + 1
                  node.parent = current
                  queue.unshift(adjacent)
                }
              }
            }

            return graph
          }

          function link(from, to) {
            return function(args) {
              return to(from(args))
            }
          }

          function wrapConversion(toModel, graph) {
            var path = [graph[toModel].parent, toModel]
            var fn = conversions[graph[toModel].parent][toModel]

            var cur = graph[toModel].parent
            while (graph[cur].parent) {
              path.unshift(graph[cur].parent)
              fn = link(conversions[graph[cur].parent][cur], fn)
              cur = graph[cur].parent
            }

            fn.conversion = path
            return fn
          }

          module.exports = function(fromModel) {
            var graph = deriveBFS(fromModel)
            var conversion = {}

            var models = Object.keys(graph)
            for (var len = models.length, i = 0; i < len; i++) {
              var toModel = models[i]
              var node = graph[toModel]

              if (node.parent === null) {
                // no possible conversion, or this node is the source model.
                continue
              }

              conversion[toModel] = wrapConversion(toModel, graph)
            }

            return conversion
          }
        },
        { './conversions': 124 },
      ],
      127: [
        function(require, module, exports) {
          module.exports = {
            aliceblue: [240, 248, 255],
            antiquewhite: [250, 235, 215],
            aqua: [0, 255, 255],
            aquamarine: [127, 255, 212],
            azure: [240, 255, 255],
            beige: [245, 245, 220],
            bisque: [255, 228, 196],
            black: [0, 0, 0],
            blanchedalmond: [255, 235, 205],
            blue: [0, 0, 255],
            blueviolet: [138, 43, 226],
            brown: [165, 42, 42],
            burlywood: [222, 184, 135],
            cadetblue: [95, 158, 160],
            chartreuse: [127, 255, 0],
            chocolate: [210, 105, 30],
            coral: [255, 127, 80],
            cornflowerblue: [100, 149, 237],
            cornsilk: [255, 248, 220],
            crimson: [220, 20, 60],
            cyan: [0, 255, 255],
            darkblue: [0, 0, 139],
            darkcyan: [0, 139, 139],
            darkgoldenrod: [184, 134, 11],
            darkgray: [169, 169, 169],
            darkgreen: [0, 100, 0],
            darkgrey: [169, 169, 169],
            darkkhaki: [189, 183, 107],
            darkmagenta: [139, 0, 139],
            darkolivegreen: [85, 107, 47],
            darkorange: [255, 140, 0],
            darkorchid: [153, 50, 204],
            darkred: [139, 0, 0],
            darksalmon: [233, 150, 122],
            darkseagreen: [143, 188, 143],
            darkslateblue: [72, 61, 139],
            darkslategray: [47, 79, 79],
            darkslategrey: [47, 79, 79],
            darkturquoise: [0, 206, 209],
            darkviolet: [148, 0, 211],
            deeppink: [255, 20, 147],
            deepskyblue: [0, 191, 255],
            dimgray: [105, 105, 105],
            dimgrey: [105, 105, 105],
            dodgerblue: [30, 144, 255],
            firebrick: [178, 34, 34],
            floralwhite: [255, 250, 240],
            forestgreen: [34, 139, 34],
            fuchsia: [255, 0, 255],
            gainsboro: [220, 220, 220],
            ghostwhite: [248, 248, 255],
            gold: [255, 215, 0],
            goldenrod: [218, 165, 32],
            gray: [128, 128, 128],
            green: [0, 128, 0],
            greenyellow: [173, 255, 47],
            grey: [128, 128, 128],
            honeydew: [240, 255, 240],
            hotpink: [255, 105, 180],
            indianred: [205, 92, 92],
            indigo: [75, 0, 130],
            ivory: [255, 255, 240],
            khaki: [240, 230, 140],
            lavender: [230, 230, 250],
            lavenderblush: [255, 240, 245],
            lawngreen: [124, 252, 0],
            lemonchiffon: [255, 250, 205],
            lightblue: [173, 216, 230],
            lightcoral: [240, 128, 128],
            lightcyan: [224, 255, 255],
            lightgoldenrodyellow: [250, 250, 210],
            lightgray: [211, 211, 211],
            lightgreen: [144, 238, 144],
            lightgrey: [211, 211, 211],
            lightpink: [255, 182, 193],
            lightsalmon: [255, 160, 122],
            lightseagreen: [32, 178, 170],
            lightskyblue: [135, 206, 250],
            lightslategray: [119, 136, 153],
            lightslategrey: [119, 136, 153],
            lightsteelblue: [176, 196, 222],
            lightyellow: [255, 255, 224],
            lime: [0, 255, 0],
            limegreen: [50, 205, 50],
            linen: [250, 240, 230],
            magenta: [255, 0, 255],
            maroon: [128, 0, 0],
            mediumaquamarine: [102, 205, 170],
            mediumblue: [0, 0, 205],
            mediumorchid: [186, 85, 211],
            mediumpurple: [147, 112, 219],
            mediumseagreen: [60, 179, 113],
            mediumslateblue: [123, 104, 238],
            mediumspringgreen: [0, 250, 154],
            mediumturquoise: [72, 209, 204],
            mediumvioletred: [199, 21, 133],
            midnightblue: [25, 25, 112],
            mintcream: [245, 255, 250],
            mistyrose: [255, 228, 225],
            moccasin: [255, 228, 181],
            navajowhite: [255, 222, 173],
            navy: [0, 0, 128],
            oldlace: [253, 245, 230],
            olive: [128, 128, 0],
            olivedrab: [107, 142, 35],
            orange: [255, 165, 0],
            orangered: [255, 69, 0],
            orchid: [218, 112, 214],
            palegoldenrod: [238, 232, 170],
            palegreen: [152, 251, 152],
            paleturquoise: [175, 238, 238],
            palevioletred: [219, 112, 147],
            papayawhip: [255, 239, 213],
            peachpuff: [255, 218, 185],
            peru: [205, 133, 63],
            pink: [255, 192, 203],
            plum: [221, 160, 221],
            powderblue: [176, 224, 230],
            purple: [128, 0, 128],
            rebeccapurple: [102, 51, 153],
            red: [255, 0, 0],
            rosybrown: [188, 143, 143],
            royalblue: [65, 105, 225],
            saddlebrown: [139, 69, 19],
            salmon: [250, 128, 114],
            sandybrown: [244, 164, 96],
            seagreen: [46, 139, 87],
            seashell: [255, 245, 238],
            sienna: [160, 82, 45],
            silver: [192, 192, 192],
            skyblue: [135, 206, 235],
            slateblue: [106, 90, 205],
            slategray: [112, 128, 144],
            slategrey: [112, 128, 144],
            snow: [255, 250, 250],
            springgreen: [0, 255, 127],
            steelblue: [70, 130, 180],
            tan: [210, 180, 140],
            teal: [0, 128, 128],
            thistle: [216, 191, 216],
            tomato: [255, 99, 71],
            turquoise: [64, 224, 208],
            violet: [238, 130, 238],
            wheat: [245, 222, 179],
            white: [255, 255, 255],
            whitesmoke: [245, 245, 245],
            yellow: [255, 255, 0],
            yellowgreen: [154, 205, 50],
          }
        },
        {},
      ],
      128: [
        function(require, module, exports) {
          /* MIT license */
          var colorNames = require('color-name')
          var swizzle = require('simple-swizzle')

          var reverseNames = {}

          // create a list of reverse color names
          for (var name in colorNames) {
            if (colorNames.hasOwnProperty(name)) {
              reverseNames[colorNames[name]] = name
            }
          }

          var cs = (module.exports = {
            to: {},
          })

          cs.get = function(string) {
            var prefix = string.substring(0, 3).toLowerCase()
            var val
            var model
            switch (prefix) {
              case 'hsl':
                val = cs.get.hsl(string)
                model = 'hsl'
                break
              case 'hwb':
                val = cs.get.hwb(string)
                model = 'hwb'
                break
              default:
                val = cs.get.rgb(string)
                model = 'rgb'
                break
            }

            if (!val) {
              return null
            }

            return { model: model, value: val }
          }

          cs.get.rgb = function(string) {
            if (!string) {
              return null
            }

            var abbr = /^#([a-f0-9]{3,4})$/i
            var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i
            var rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/
            var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/
            var keyword = /(\D+)/

            var rgb = [0, 0, 0, 1]
            var match
            var i
            var hexAlpha

            if ((match = string.match(hex))) {
              hexAlpha = match[2]
              match = match[1]

              for (i = 0; i < 3; i++) {
                // https://jsperf.com/slice-vs-substr-vs-substring-methods-long-string/19
                var i2 = i * 2
                rgb[i] = parseInt(match.slice(i2, i2 + 2), 16)
              }

              if (hexAlpha) {
                rgb[3] = Math.round(parseInt(hexAlpha, 16) / 255 * 100) / 100
              }
            } else if ((match = string.match(abbr))) {
              match = match[1]
              hexAlpha = match[3]

              for (i = 0; i < 3; i++) {
                rgb[i] = parseInt(match[i] + match[i], 16)
              }

              if (hexAlpha) {
                rgb[3] =
                  Math.round(parseInt(hexAlpha + hexAlpha, 16) / 255 * 100) /
                  100
              }
            } else if ((match = string.match(rgba))) {
              for (i = 0; i < 3; i++) {
                rgb[i] = parseInt(match[i + 1], 0)
              }

              if (match[4]) {
                rgb[3] = parseFloat(match[4])
              }
            } else if ((match = string.match(per))) {
              for (i = 0; i < 3; i++) {
                rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55)
              }

              if (match[4]) {
                rgb[3] = parseFloat(match[4])
              }
            } else if ((match = string.match(keyword))) {
              if (match[1] === 'transparent') {
                return [0, 0, 0, 0]
              }

              rgb = colorNames[match[1]]

              if (!rgb) {
                return null
              }

              rgb[3] = 1

              return rgb
            } else {
              return null
            }

            for (i = 0; i < 3; i++) {
              rgb[i] = clamp(rgb[i], 0, 255)
            }
            rgb[3] = clamp(rgb[3], 0, 1)

            return rgb
          }

          cs.get.hsl = function(string) {
            if (!string) {
              return null
            }

            var hsl = /^hsla?\(\s*([+-]?\d*[\.]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/
            var match = string.match(hsl)

            if (match) {
              var alpha = parseFloat(match[4])
              var h = (parseFloat(match[1]) % 360 + 360) % 360
              var s = clamp(parseFloat(match[2]), 0, 100)
              var l = clamp(parseFloat(match[3]), 0, 100)
              var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1)

              return [h, s, l, a]
            }

            return null
          }

          cs.get.hwb = function(string) {
            if (!string) {
              return null
            }

            var hwb = /^hwb\(\s*([+-]?\d*[\.]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/
            var match = string.match(hwb)

            if (match) {
              var alpha = parseFloat(match[4])
              var h = (parseFloat(match[1]) % 360 + 360) % 360
              var w = clamp(parseFloat(match[2]), 0, 100)
              var b = clamp(parseFloat(match[3]), 0, 100)
              var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1)
              return [h, w, b, a]
            }

            return null
          }

          cs.to.hex = function() {
            var rgba = swizzle(arguments)

            return (
              '#' +
              hexDouble(rgba[0]) +
              hexDouble(rgba[1]) +
              hexDouble(rgba[2]) +
              (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : '')
            )
          }

          cs.to.rgb = function() {
            var rgba = swizzle(arguments)

            return rgba.length < 4 || rgba[3] === 1
              ? 'rgb(' +
                  Math.round(rgba[0]) +
                  ', ' +
                  Math.round(rgba[1]) +
                  ', ' +
                  Math.round(rgba[2]) +
                  ')'
              : 'rgba(' +
                  Math.round(rgba[0]) +
                  ', ' +
                  Math.round(rgba[1]) +
                  ', ' +
                  Math.round(rgba[2]) +
                  ', ' +
                  rgba[3] +
                  ')'
          }

          cs.to.rgb.percent = function() {
            var rgba = swizzle(arguments)

            var r = Math.round(rgba[0] / 255 * 100)
            var g = Math.round(rgba[1] / 255 * 100)
            var b = Math.round(rgba[2] / 255 * 100)

            return rgba.length < 4 || rgba[3] === 1
              ? 'rgb(' + r + '%, ' + g + '%, ' + b + '%)'
              : 'rgba(' + r + '%, ' + g + '%, ' + b + '%, ' + rgba[3] + ')'
          }

          cs.to.hsl = function() {
            var hsla = swizzle(arguments)
            return hsla.length < 4 || hsla[3] === 1
              ? 'hsl(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%)'
              : 'hsla(' +
                  hsla[0] +
                  ', ' +
                  hsla[1] +
                  '%, ' +
                  hsla[2] +
                  '%, ' +
                  hsla[3] +
                  ')'
          }

          // hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
          // (hwb have alpha optional & 1 is default value)
          cs.to.hwb = function() {
            var hwba = swizzle(arguments)

            var a = ''
            if (hwba.length >= 4 && hwba[3] !== 1) {
              a = ', ' + hwba[3]
            }

            return (
              'hwb(' +
              hwba[0] +
              ', ' +
              hwba[1] +
              '%, ' +
              hwba[2] +
              '%' +
              a +
              ')'
            )
          }

          cs.to.keyword = function(rgb) {
            return reverseNames[rgb.slice(0, 3)]
          }

          // helpers
          function clamp(num, min, max) {
            return Math.min(Math.max(min, num), max)
          }

          function hexDouble(num) {
            var str = num.toString(16).toUpperCase()
            return str.length < 2 ? '0' + str : str
          }
        },
        { 'color-name': 127, 'simple-swizzle': 514 },
      ],
      129: [
        function(require, module, exports) {
          'use strict'
          var colorString = require('color-string')
          var convert = require('color-convert')

          var _slice = [].slice

          var skippedModels = [
            // to be honest, I don't really feel like keyword belongs in color convert, but eh.
            'keyword',

            // gray conflicts with some method names, and has its own method defined.
            'gray',

            // shouldn't really be in color-convert either...
            'hex',
          ]

          var hashedModelKeys = {}
          Object.keys(convert).forEach(function(model) {
            hashedModelKeys[
              _slice.call(convert[model].labels).sort().join('')
            ] = model
          })

          var limiters = {}

          function Color(obj, model) {
            if (!(this instanceof Color)) {
              return new Color(obj, model)
            }

            if (model && model in skippedModels) {
              model = null
            }

            if (model && !(model in convert)) {
              throw new Error('Unknown model: ' + model)
            }

            var i
            var channels

            if (!obj) {
              this.model = 'rgb'
              this.color = [0, 0, 0]
              this.valpha = 1
            } else if (obj instanceof Color) {
              this.model = obj.model
              this.color = obj.color.slice()
              this.valpha = obj.valpha
            } else if (typeof obj === 'string') {
              var result = colorString.get(obj)
              if (result === null) {
                throw new Error('Unable to parse color from string: ' + obj)
              }

              this.model = result.model
              channels = convert[this.model].channels
              this.color = result.value.slice(0, channels)
              this.valpha = typeof result.value[channels] === 'number'
                ? result.value[channels]
                : 1
            } else if (obj.length) {
              this.model = model || 'rgb'
              channels = convert[this.model].channels
              var newArr = _slice.call(obj, 0, channels)
              this.color = zeroArray(newArr, channels)
              this.valpha = typeof obj[channels] === 'number'
                ? obj[channels]
                : 1
            } else if (typeof obj === 'number') {
              // this is always RGB - can be converted later on.
              obj &= 0xffffff
              this.model = 'rgb'
              this.color = [(obj >> 16) & 0xff, (obj >> 8) & 0xff, obj & 0xff]
              this.valpha = 1
            } else {
              this.valpha = 1

              var keys = Object.keys(obj)
              if ('alpha' in obj) {
                keys.splice(keys.indexOf('alpha'), 1)
                this.valpha = typeof obj.alpha === 'number' ? obj.alpha : 0
              }

              var hashedKeys = keys.sort().join('')
              if (!(hashedKeys in hashedModelKeys)) {
                throw new Error(
                  'Unable to parse color from object: ' + JSON.stringify(obj)
                )
              }

              this.model = hashedModelKeys[hashedKeys]

              var labels = convert[this.model].labels
              var color = []
              for (i = 0; i < labels.length; i++) {
                color.push(obj[labels[i]])
              }

              this.color = zeroArray(color)
            }

            // perform limitations (clamping, etc.)
            if (limiters[this.model]) {
              channels = convert[this.model].channels
              for (i = 0; i < channels; i++) {
                var limit = limiters[this.model][i]
                if (limit) {
                  this.color[i] = limit(this.color[i])
                }
              }
            }

            this.valpha = Math.max(0, Math.min(1, this.valpha))

            if (Object.freeze) {
              Object.freeze(this)
            }
          }

          Color.prototype = {
            toString: function() {
              return this.string()
            },

            toJSON: function() {
              return this[this.model]()
            },

            string: function(places) {
              var self = this.model in colorString.to ? this : this.rgb()
              self = self.round(typeof places === 'number' ? places : 1)
              var args = self.valpha === 1
                ? self.color
                : self.color.concat(this.valpha)
              return colorString.to[self.model](args)
            },

            percentString: function(places) {
              var self = this.rgb().round(
                typeof places === 'number' ? places : 1
              )
              var args = self.valpha === 1
                ? self.color
                : self.color.concat(this.valpha)
              return colorString.to.rgb.percent(args)
            },

            array: function() {
              return this.valpha === 1
                ? this.color.slice()
                : this.color.concat(this.valpha)
            },

            object: function() {
              var result = {}
              var channels = convert[this.model].channels
              var labels = convert[this.model].labels

              for (var i = 0; i < channels; i++) {
                result[labels[i]] = this.color[i]
              }

              if (this.valpha !== 1) {
                result.alpha = this.valpha
              }

              return result
            },

            unitArray: function() {
              var rgb = this.rgb().color
              rgb[0] /= 255
              rgb[1] /= 255
              rgb[2] /= 255

              if (this.valpha !== 1) {
                rgb.push(this.valpha)
              }

              return rgb
            },

            unitObject: function() {
              var rgb = this.rgb().object()
              rgb.r /= 255
              rgb.g /= 255
              rgb.b /= 255

              if (this.valpha !== 1) {
                rgb.alpha = this.valpha
              }

              return rgb
            },

            round: function(places) {
              places = Math.max(places || 0, 0)
              return new Color(
                this.color.map(roundToPlace(places)).concat(this.valpha),
                this.model
              )
            },

            alpha: function(val) {
              if (arguments.length) {
                return new Color(
                  this.color.concat(Math.max(0, Math.min(1, val))),
                  this.model
                )
              }

              return this.valpha
            },

            // rgb
            red: getset('rgb', 0, maxfn(255)),
            green: getset('rgb', 1, maxfn(255)),
            blue: getset('rgb', 2, maxfn(255)),

            hue: getset(['hsl', 'hsv', 'hsl', 'hwb', 'hcg'], 0, function(val) {
              return (val % 360 + 360) % 360
            }), // eslint-disable-line brace-style

            saturationl: getset('hsl', 1, maxfn(100)),
            lightness: getset('hsl', 2, maxfn(100)),

            saturationv: getset('hsv', 1, maxfn(100)),
            value: getset('hsv', 2, maxfn(100)),

            chroma: getset('hcg', 1, maxfn(100)),
            gray: getset('hcg', 2, maxfn(100)),

            white: getset('hwb', 1, maxfn(100)),
            wblack: getset('hwb', 2, maxfn(100)),

            cyan: getset('cmyk', 0, maxfn(100)),
            magenta: getset('cmyk', 1, maxfn(100)),
            yellow: getset('cmyk', 2, maxfn(100)),
            black: getset('cmyk', 3, maxfn(100)),

            x: getset('xyz', 0, maxfn(100)),
            y: getset('xyz', 1, maxfn(100)),
            z: getset('xyz', 2, maxfn(100)),

            l: getset('lab', 0, maxfn(100)),
            a: getset('lab', 1),
            b: getset('lab', 2),

            keyword: function(val) {
              if (arguments.length) {
                return new Color(val)
              }

              return convert[this.model].keyword(this.color)
            },

            hex: function(val) {
              if (arguments.length) {
                return new Color(val)
              }

              return colorString.to.hex(this.rgb().round().color)
            },

            rgbNumber: function() {
              var rgb = this.rgb().color
              return (
                ((rgb[0] & 0xff) << 16) |
                ((rgb[1] & 0xff) << 8) |
                (rgb[2] & 0xff)
              )
            },

            luminosity: function() {
              // http://www.w3.org/TR/WCAG20/#relativeluminancedef
              var rgb = this.rgb().color

              var lum = []
              for (var i = 0; i < rgb.length; i++) {
                var chan = rgb[i] / 255
                lum[i] = chan <= 0.03928
                  ? chan / 12.92
                  : Math.pow((chan + 0.055) / 1.055, 2.4)
              }

              return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2]
            },

            contrast: function(color2) {
              // http://www.w3.org/TR/WCAG20/#contrast-ratiodef
              var lum1 = this.luminosity()
              var lum2 = color2.luminosity()

              if (lum1 > lum2) {
                return (lum1 + 0.05) / (lum2 + 0.05)
              }

              return (lum2 + 0.05) / (lum1 + 0.05)
            },

            level: function(color2) {
              var contrastRatio = this.contrast(color2)
              if (contrastRatio >= 7.1) {
                return 'AAA'
              }

              return contrastRatio >= 4.5 ? 'AA' : ''
            },

            dark: function() {
              // YIQ equation from http://24ways.org/2010/calculating-color-contrast
              var rgb = this.rgb().color
              var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000
              return yiq < 128
            },

            light: function() {
              return !this.dark()
            },

            negate: function() {
              var rgb = this.rgb()
              for (var i = 0; i < 3; i++) {
                rgb.color[i] = 255 - rgb.color[i]
              }
              return rgb
            },

            lighten: function(ratio) {
              var hsl = this.hsl()
              hsl.color[2] += hsl.color[2] * ratio
              return hsl
            },

            darken: function(ratio) {
              var hsl = this.hsl()
              hsl.color[2] -= hsl.color[2] * ratio
              return hsl
            },

            saturate: function(ratio) {
              var hsl = this.hsl()
              hsl.color[1] += hsl.color[1] * ratio
              return hsl
            },

            desaturate: function(ratio) {
              var hsl = this.hsl()
              hsl.color[1] -= hsl.color[1] * ratio
              return hsl
            },

            whiten: function(ratio) {
              var hwb = this.hwb()
              hwb.color[1] += hwb.color[1] * ratio
              return hwb
            },

            blacken: function(ratio) {
              var hwb = this.hwb()
              hwb.color[2] += hwb.color[2] * ratio
              return hwb
            },

            grayscale: function() {
              // http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
              var rgb = this.rgb().color
              var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11
              return Color.rgb(val, val, val)
            },

            fade: function(ratio) {
              return this.alpha(this.valpha - this.valpha * ratio)
            },

            opaquer: function(ratio) {
              return this.alpha(this.valpha + this.valpha * ratio)
            },

            rotate: function(degrees) {
              var hsl = this.hsl()
              var hue = hsl.color[0]
              hue = (hue + degrees) % 360
              hue = hue < 0 ? 360 + hue : hue
              hsl.color[0] = hue
              return hsl
            },

            mix: function(mixinColor, weight) {
              // ported from sass implementation in C
              // https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
              var color1 = this.rgb()
              var color2 = mixinColor.rgb()
              var p = weight === undefined ? 0.5 : weight

              var w = 2 * p - 1
              var a = color1.alpha() - color2.alpha()

              var w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0
              var w2 = 1 - w1

              return Color.rgb(
                w1 * color1.red() + w2 * color2.red(),
                w1 * color1.green() + w2 * color2.green(),
                w1 * color1.blue() + w2 * color2.blue(),
                color1.alpha() * p + color2.alpha() * (1 - p)
              )
            },
          }

          // model conversion methods and static constructors
          Object.keys(convert).forEach(function(model) {
            if (skippedModels.indexOf(model) !== -1) {
              return
            }

            var channels = convert[model].channels

            // conversion methods
            Color.prototype[model] = function() {
              if (this.model === model) {
                return new Color(this)
              }

              if (arguments.length) {
                return new Color(arguments, model)
              }

              var newAlpha = typeof arguments[channels] === 'number'
                ? channels
                : this.valpha
              return new Color(
                assertArray(convert[this.model][model].raw(this.color)).concat(
                  newAlpha
                ),
                model
              )
            }

            // 'static' construction methods
            Color[model] = function(color) {
              if (typeof color === 'number') {
                color = zeroArray(_slice.call(arguments), channels)
              }
              return new Color(color, model)
            }
          })

          function roundTo(num, places) {
            return Number(num.toFixed(places))
          }

          function roundToPlace(places) {
            return function(num) {
              return roundTo(num, places)
            }
          }

          function getset(model, channel, modifier) {
            model = Array.isArray(model) ? model : [model]

            model.forEach(function(m) {
              ;(limiters[m] || (limiters[m] = []))[channel] = modifier
            })

            model = model[0]

            return function(val) {
              var result

              if (arguments.length) {
                if (modifier) {
                  val = modifier(val)
                }

                result = this[model]()
                result.color[channel] = val
                return result
              }

              result = this[model]().color[channel]
              if (modifier) {
                result = modifier(result)
              }

              return result
            }
          }

          function maxfn(max) {
            return function(v) {
              return Math.max(0, Math.min(max, v))
            }
          }

          function assertArray(val) {
            return Array.isArray(val) ? val : [val]
          }

          function zeroArray(arr, length) {
            for (var i = 0; i < length; i++) {
              if (typeof arr[i] !== 'number') {
                arr[i] = 0
              }
            }

            return arr
          }

          module.exports = Color
        },
        { 'color-convert': 125, 'color-string': 128 },
      ],
      130: [
        function(require, module, exports) {
          module.exports = function(xs, fn) {
            var res = []
            for (var i = 0; i < xs.length; i++) {
              var x = fn(xs[i], i)
              if (isArray(x)) res.push.apply(res, x)
              else res.push(x)
            }
            return res
          }

          var isArray =
            Array.isArray ||
            function(xs) {
              return Object.prototype.toString.call(xs) === '[object Array]'
            }
        },
        {},
      ],
      131: [
        function(require, module, exports) {
          module.exports = {
            O_RDONLY: 0,
            O_WRONLY: 1,
            O_RDWR: 2,
            S_IFMT: 61440,
            S_IFREG: 32768,
            S_IFDIR: 16384,
            S_IFCHR: 8192,
            S_IFBLK: 24576,
            S_IFIFO: 4096,
            S_IFLNK: 40960,
            S_IFSOCK: 49152,
            O_CREAT: 512,
            O_EXCL: 2048,
            O_NOCTTY: 131072,
            O_TRUNC: 1024,
            O_APPEND: 8,
            O_DIRECTORY: 1048576,
            O_NOFOLLOW: 256,
            O_SYNC: 128,
            O_SYMLINK: 2097152,
            O_NONBLOCK: 4,
            S_IRWXU: 448,
            S_IRUSR: 256,
            S_IWUSR: 128,
            S_IXUSR: 64,
            S_IRWXG: 56,
            S_IRGRP: 32,
            S_IWGRP: 16,
            S_IXGRP: 8,
            S_IRWXO: 7,
            S_IROTH: 4,
            S_IWOTH: 2,
            S_IXOTH: 1,
            E2BIG: 7,
            EACCES: 13,
            EADDRINUSE: 48,
            EADDRNOTAVAIL: 49,
            EAFNOSUPPORT: 47,
            EAGAIN: 35,
            EALREADY: 37,
            EBADF: 9,
            EBADMSG: 94,
            EBUSY: 16,
            ECANCELED: 89,
            ECHILD: 10,
            ECONNABORTED: 53,
            ECONNREFUSED: 61,
            ECONNRESET: 54,
            EDEADLK: 11,
            EDESTADDRREQ: 39,
            EDOM: 33,
            EDQUOT: 69,
            EEXIST: 17,
            EFAULT: 14,
            EFBIG: 27,
            EHOSTUNREACH: 65,
            EIDRM: 90,
            EILSEQ: 92,
            EINPROGRESS: 36,
            EINTR: 4,
            EINVAL: 22,
            EIO: 5,
            EISCONN: 56,
            EISDIR: 21,
            ELOOP: 62,
            EMFILE: 24,
            EMLINK: 31,
            EMSGSIZE: 40,
            EMULTIHOP: 95,
            ENAMETOOLONG: 63,
            ENETDOWN: 50,
            ENETRESET: 52,
            ENETUNREACH: 51,
            ENFILE: 23,
            ENOBUFS: 55,
            ENODATA: 96,
            ENODEV: 19,
            ENOENT: 2,
            ENOEXEC: 8,
            ENOLCK: 77,
            ENOLINK: 97,
            ENOMEM: 12,
            ENOMSG: 91,
            ENOPROTOOPT: 42,
            ENOSPC: 28,
            ENOSR: 98,
            ENOSTR: 99,
            ENOSYS: 78,
            ENOTCONN: 57,
            ENOTDIR: 20,
            ENOTEMPTY: 66,
            ENOTSOCK: 38,
            ENOTSUP: 45,
            ENOTTY: 25,
            ENXIO: 6,
            EOPNOTSUPP: 102,
            EOVERFLOW: 84,
            EPERM: 1,
            EPIPE: 32,
            EPROTO: 100,
            EPROTONOSUPPORT: 43,
            EPROTOTYPE: 41,
            ERANGE: 34,
            EROFS: 30,
            ESPIPE: 29,
            ESRCH: 3,
            ESTALE: 70,
            ETIME: 101,
            ETIMEDOUT: 60,
            ETXTBSY: 26,
            EWOULDBLOCK: 35,
            EXDEV: 18,
            SIGHUP: 1,
            SIGINT: 2,
            SIGQUIT: 3,
            SIGILL: 4,
            SIGTRAP: 5,
            SIGABRT: 6,
            SIGIOT: 6,
            SIGBUS: 10,
            SIGFPE: 8,
            SIGKILL: 9,
            SIGUSR1: 30,
            SIGSEGV: 11,
            SIGUSR2: 31,
            SIGPIPE: 13,
            SIGALRM: 14,
            SIGTERM: 15,
            SIGCHLD: 20,
            SIGCONT: 19,
            SIGSTOP: 17,
            SIGTSTP: 18,
            SIGTTIN: 21,
            SIGTTOU: 22,
            SIGURG: 16,
            SIGXCPU: 24,
            SIGXFSZ: 25,
            SIGVTALRM: 26,
            SIGPROF: 27,
            SIGWINCH: 28,
            SIGIO: 23,
            SIGSYS: 12,
            SSL_OP_ALL: 2147486719,
            SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION: 262144,
            SSL_OP_CIPHER_SERVER_PREFERENCE: 4194304,
            SSL_OP_CISCO_ANYCONNECT: 32768,
            SSL_OP_COOKIE_EXCHANGE: 8192,
            SSL_OP_CRYPTOPRO_TLSEXT_BUG: 2147483648,
            SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS: 2048,
            SSL_OP_EPHEMERAL_RSA: 0,
            SSL_OP_LEGACY_SERVER_CONNECT: 4,
            SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER: 32,
            SSL_OP_MICROSOFT_SESS_ID_BUG: 1,
            SSL_OP_MSIE_SSLV2_RSA_PADDING: 0,
            SSL_OP_NETSCAPE_CA_DN_BUG: 536870912,
            SSL_OP_NETSCAPE_CHALLENGE_BUG: 2,
            SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG: 1073741824,
            SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG: 8,
            SSL_OP_NO_COMPRESSION: 131072,
            SSL_OP_NO_QUERY_MTU: 4096,
            SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION: 65536,
            SSL_OP_NO_SSLv2: 16777216,
            SSL_OP_NO_SSLv3: 33554432,
            SSL_OP_NO_TICKET: 16384,
            SSL_OP_NO_TLSv1: 67108864,
            SSL_OP_NO_TLSv1_1: 268435456,
            SSL_OP_NO_TLSv1_2: 134217728,
            SSL_OP_PKCS1_CHECK_1: 0,
            SSL_OP_PKCS1_CHECK_2: 0,
            SSL_OP_SINGLE_DH_USE: 1048576,
            SSL_OP_SINGLE_ECDH_USE: 524288,
            SSL_OP_SSLEAY_080_CLIENT_DH_BUG: 128,
            SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG: 0,
            SSL_OP_TLS_BLOCK_PADDING_BUG: 512,
            SSL_OP_TLS_D5_BUG: 256,
            SSL_OP_TLS_ROLLBACK_BUG: 8388608,
            ENGINE_METHOD_DSA: 2,
            ENGINE_METHOD_DH: 4,
            ENGINE_METHOD_RAND: 8,
            ENGINE_METHOD_ECDH: 16,
            ENGINE_METHOD_ECDSA: 32,
            ENGINE_METHOD_CIPHERS: 64,
            ENGINE_METHOD_DIGESTS: 128,
            ENGINE_METHOD_STORE: 256,
            ENGINE_METHOD_PKEY_METHS: 512,
            ENGINE_METHOD_PKEY_ASN1_METHS: 1024,
            ENGINE_METHOD_ALL: 65535,
            ENGINE_METHOD_NONE: 0,
            DH_CHECK_P_NOT_SAFE_PRIME: 2,
            DH_CHECK_P_NOT_PRIME: 1,
            DH_UNABLE_TO_CHECK_GENERATOR: 4,
            DH_NOT_SUITABLE_GENERATOR: 8,
            NPN_ENABLED: 1,
            RSA_PKCS1_PADDING: 1,
            RSA_SSLV23_PADDING: 2,
            RSA_NO_PADDING: 3,
            RSA_PKCS1_OAEP_PADDING: 4,
            RSA_X931_PADDING: 5,
            RSA_PKCS1_PSS_PADDING: 6,
            POINT_CONVERSION_COMPRESSED: 2,
            POINT_CONVERSION_UNCOMPRESSED: 4,
            POINT_CONVERSION_HYBRID: 6,
            F_OK: 0,
            R_OK: 4,
            W_OK: 2,
            X_OK: 1,
            UV_UDP_REUSEADDR: 4,
          }
        },
        {},
      ],
      132: [
        function(require, module, exports) {
          ;(function(Buffer) {
            'use strict'
            var fs = require('fs')
            var path = require('path')

            Object.defineProperty(exports, 'commentRegex', {
              get: function getCommentRegex() {
                return /^\s*\/(?:\/|\*)[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(?:.*)$/gm
              },
            })

            Object.defineProperty(exports, 'mapFileCommentRegex', {
              get: function getMapFileCommentRegex() {
                //Example (Extra space between slashes added to solve Safari bug. Exclude space in production):
                //     / /# sourceMappingURL=foo.js.map
                return /(?:\/\/[@#][ \t]+sourceMappingURL=([^\s'"]+?)[ \t]*$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^\*]+?)[ \t]*(?:\*\/){1}[ \t]*$)/gm
              },
            })

            function decodeBase64(base64) {
              return new Buffer(base64, 'base64').toString()
            }

            function stripComment(sm) {
              return sm.split(',').pop()
            }

            function readFromFileMap(sm, dir) {
              // NOTE: this will only work on the server since it attempts to read the map file

              var r = exports.mapFileCommentRegex.exec(sm)

              // for some odd reason //# .. captures in 1 and /* .. */ in 2
              var filename = r[1] || r[2]
              var filepath = path.resolve(dir, filename)

              try {
                return fs.readFileSync(filepath, 'utf8')
              } catch (e) {
                throw new Error(
                  'An error occurred while trying to read the map file at ' +
                    filepath +
                    '\n' +
                    e
                )
              }
            }

            function Converter(sm, opts) {
              opts = opts || {}

              if (opts.isFileComment)
                sm = readFromFileMap(sm, opts.commentFileDir)
              if (opts.hasComment) sm = stripComment(sm)
              if (opts.isEncoded) sm = decodeBase64(sm)
              if (opts.isJSON || opts.isEncoded) sm = JSON.parse(sm)

              this.sourcemap = sm
            }

            Converter.prototype.toJSON = function(space) {
              return JSON.stringify(this.sourcemap, null, space)
            }

            Converter.prototype.toBase64 = function() {
              var json = this.toJSON()
              return new Buffer(json).toString('base64')
            }

            Converter.prototype.toComment = function(options) {
              var base64 = this.toBase64()
              var data =
                'sourceMappingURL=data:application/json;charset=utf-8;base64,' +
                base64
              return options && options.multiline
                ? '/*# ' + data + ' */'
                : '//# ' + data
            }

            // returns copy instead of original
            Converter.prototype.toObject = function() {
              return JSON.parse(this.toJSON())
            }

            Converter.prototype.addProperty = function(key, value) {
              if (this.sourcemap.hasOwnProperty(key))
                throw new Error(
                  'property %s already exists on the sourcemap, use set property instead'
                )
              return this.setProperty(key, value)
            }

            Converter.prototype.setProperty = function(key, value) {
              this.sourcemap[key] = value
              return this
            }

            Converter.prototype.getProperty = function(key) {
              return this.sourcemap[key]
            }

            exports.fromObject = function(obj) {
              return new Converter(obj)
            }

            exports.fromJSON = function(json) {
              return new Converter(json, { isJSON: true })
            }

            exports.fromBase64 = function(base64) {
              return new Converter(base64, { isEncoded: true })
            }

            exports.fromComment = function(comment) {
              comment = comment.replace(/^\/\*/g, '//').replace(/\*\/$/g, '')

              return new Converter(comment, {
                isEncoded: true,
                hasComment: true,
              })
            }

            exports.fromMapFileComment = function(comment, dir) {
              return new Converter(comment, {
                commentFileDir: dir,
                isFileComment: true,
                isJSON: true,
              })
            }

            // Finds last sourcemap comment in file or returns null if none was found
            exports.fromSource = function(content) {
              var m = content.match(exports.commentRegex)
              return m ? exports.fromComment(m.pop()) : null
            }

            // Finds last sourcemap comment in file or returns null if none was found
            exports.fromMapFileSource = function(content, dir) {
              var m = content.match(exports.mapFileCommentRegex)
              return m ? exports.fromMapFileComment(m.pop(), dir) : null
            }

            exports.removeComments = function(src) {
              return src.replace(exports.commentRegex, '')
            }

            exports.removeMapFileComments = function(src) {
              return src.replace(exports.mapFileCommentRegex, '')
            }

            exports.generateMapFileComment = function(file, options) {
              var data = 'sourceMappingURL=' + file
              return options && options.multiline
                ? '/*# ' + data + ' */'
                : '//# ' + data
            }
          }.call(this, require('buffer').Buffer))
        },
        { buffer: 121, fs: 118, path: 505 },
      ],
      133: [
        function(require, module, exports) {
          require('../modules/web.dom.iterable')
          require('../modules/es6.string.iterator')
          module.exports = require('../modules/core.get-iterator')
        },
        {
          '../modules/core.get-iterator': 222,
          '../modules/es6.string.iterator': 231,
          '../modules/web.dom.iterable': 238,
        },
      ],
      134: [
        function(require, module, exports) {
          var core = require('../../modules/_core'),
            $JSON = core.JSON || (core.JSON = { stringify: JSON.stringify })
          module.exports = function stringify(it) {
            // eslint-disable-line no-unused-vars
            return $JSON.stringify.apply($JSON, arguments)
          }
        },
        { '../../modules/_core': 162 },
      ],
      135: [
        function(require, module, exports) {
          require('../modules/es6.object.to-string')
          require('../modules/es6.string.iterator')
          require('../modules/web.dom.iterable')
          require('../modules/es6.map')
          require('../modules/es7.map.to-json')
          module.exports = require('../modules/_core').Map
        },
        {
          '../modules/_core': 162,
          '../modules/es6.map': 224,
          '../modules/es6.object.to-string': 230,
          '../modules/es6.string.iterator': 231,
          '../modules/es7.map.to-json': 235,
          '../modules/web.dom.iterable': 238,
        },
      ],
      136: [
        function(require, module, exports) {
          require('../../modules/es6.number.max-safe-integer')
          module.exports = 0x1fffffffffffff
        },
        { '../../modules/es6.number.max-safe-integer': 225 },
      ],
      137: [
        function(require, module, exports) {
          require('../../modules/es6.object.assign')
          module.exports = require('../../modules/_core').Object.assign
        },
        { '../../modules/_core': 162, '../../modules/es6.object.assign': 226 },
      ],
      138: [
        function(require, module, exports) {
          require('../../modules/es6.object.create')
          var $Object = require('../../modules/_core').Object
          module.exports = function create(P, D) {
            return $Object.create(P, D)
          }
        },
        { '../../modules/_core': 162, '../../modules/es6.object.create': 227 },
      ],
      139: [
        function(require, module, exports) {
          require('../../modules/es6.symbol')
          module.exports = require('../../modules/_core').Object.getOwnPropertySymbols
        },
        { '../../modules/_core': 162, '../../modules/es6.symbol': 232 },
      ],
      140: [
        function(require, module, exports) {
          require('../../modules/es6.object.keys')
          module.exports = require('../../modules/_core').Object.keys
        },
        { '../../modules/_core': 162, '../../modules/es6.object.keys': 228 },
      ],
      141: [
        function(require, module, exports) {
          require('../../modules/es6.object.set-prototype-of')
          module.exports = require('../../modules/_core').Object.setPrototypeOf
        },
        {
          '../../modules/_core': 162,
          '../../modules/es6.object.set-prototype-of': 229,
        },
      ],
      142: [
        function(require, module, exports) {
          require('../../modules/es6.symbol')
          module.exports = require('../../modules/_core').Symbol['for']
        },
        { '../../modules/_core': 162, '../../modules/es6.symbol': 232 },
      ],
      143: [
        function(require, module, exports) {
          require('../../modules/es6.symbol')
          require('../../modules/es6.object.to-string')
          require('../../modules/es7.symbol.async-iterator')
          require('../../modules/es7.symbol.observable')
          module.exports = require('../../modules/_core').Symbol
        },
        {
          '../../modules/_core': 162,
          '../../modules/es6.object.to-string': 230,
          '../../modules/es6.symbol': 232,
          '../../modules/es7.symbol.async-iterator': 236,
          '../../modules/es7.symbol.observable': 237,
        },
      ],
      144: [
        function(require, module, exports) {
          require('../../modules/es6.string.iterator')
          require('../../modules/web.dom.iterable')
          module.exports = require('../../modules/_wks-ext').f('iterator')
        },
        {
          '../../modules/_wks-ext': 219,
          '../../modules/es6.string.iterator': 231,
          '../../modules/web.dom.iterable': 238,
        },
      ],
      145: [
        function(require, module, exports) {
          require('../modules/es6.object.to-string')
          require('../modules/web.dom.iterable')
          require('../modules/es6.weak-map')
          module.exports = require('../modules/_core').WeakMap
        },
        {
          '../modules/_core': 162,
          '../modules/es6.object.to-string': 230,
          '../modules/es6.weak-map': 233,
          '../modules/web.dom.iterable': 238,
        },
      ],
      146: [
        function(require, module, exports) {
          require('../modules/es6.object.to-string')
          require('../modules/web.dom.iterable')
          require('../modules/es6.weak-set')
          module.exports = require('../modules/_core').WeakSet
        },
        {
          '../modules/_core': 162,
          '../modules/es6.object.to-string': 230,
          '../modules/es6.weak-set': 234,
          '../modules/web.dom.iterable': 238,
        },
      ],
      147: [
        function(require, module, exports) {
          module.exports = function(it) {
            if (typeof it != 'function')
              throw TypeError(it + ' is not a function!')
            return it
          }
        },
        {},
      ],
      148: [
        function(require, module, exports) {
          module.exports = function() {
            /* empty */
          }
        },
        {},
      ],
      149: [
        function(require, module, exports) {
          module.exports = function(it, Constructor, name, forbiddenField) {
            if (
              !(it instanceof Constructor) ||
              (forbiddenField !== undefined && forbiddenField in it)
            ) {
              throw TypeError(name + ': incorrect invocation!')
            }
            return it
          }
        },
        {},
      ],
      150: [
        function(require, module, exports) {
          var isObject = require('./_is-object')
          module.exports = function(it) {
            if (!isObject(it)) throw TypeError(it + ' is not an object!')
            return it
          }
        },
        { './_is-object': 180 },
      ],
      151: [
        function(require, module, exports) {
          var forOf = require('./_for-of')

          module.exports = function(iter, ITERATOR) {
            var result = []
            forOf(iter, false, result.push, result, ITERATOR)
            return result
          }
        },
        { './_for-of': 171 },
      ],
      152: [
        function(require, module, exports) {
          // false -> Array#indexOf
          // true  -> Array#includes
          var toIObject = require('./_to-iobject'),
            toLength = require('./_to-length'),
            toIndex = require('./_to-index')
          module.exports = function(IS_INCLUDES) {
            return function($this, el, fromIndex) {
              var O = toIObject($this),
                length = toLength(O.length),
                index = toIndex(fromIndex, length),
                value
              // Array#includes uses SameValueZero equality algorithm
              if (IS_INCLUDES && el != el)
                while (length > index) {
                  value = O[index++]
                  if (value != value) return true
                  // Array#toIndex ignores holes, Array#includes - not
                }
              else
                for (; length > index; index++)
                  if (IS_INCLUDES || index in O) {
                    if (O[index] === el) return IS_INCLUDES || index || 0
                  }
              return !IS_INCLUDES && -1
            }
          }
        },
        { './_to-index': 211, './_to-iobject': 213, './_to-length': 214 },
      ],
      153: [
        function(require, module, exports) {
          // 0 -> Array#forEach
          // 1 -> Array#map
          // 2 -> Array#filter
          // 3 -> Array#some
          // 4 -> Array#every
          // 5 -> Array#find
          // 6 -> Array#findIndex
          var ctx = require('./_ctx'),
            IObject = require('./_iobject'),
            toObject = require('./_to-object'),
            toLength = require('./_to-length'),
            asc = require('./_array-species-create')
          module.exports = function(TYPE, $create) {
            var IS_MAP = TYPE == 1,
              IS_FILTER = TYPE == 2,
              IS_SOME = TYPE == 3,
              IS_EVERY = TYPE == 4,
              IS_FIND_INDEX = TYPE == 6,
              NO_HOLES = TYPE == 5 || IS_FIND_INDEX,
              create = $create || asc
            return function($this, callbackfn, that) {
              var O = toObject($this),
                self = IObject(O),
                f = ctx(callbackfn, that, 3),
                length = toLength(self.length),
                index = 0,
                result = IS_MAP
                  ? create($this, length)
                  : IS_FILTER ? create($this, 0) : undefined,
                val,
                res
              for (; length > index; index++)
                if (NO_HOLES || index in self) {
                  val = self[index]
                  res = f(val, index, O)
                  if (TYPE) {
                    if (IS_MAP) result[index] = res
                    else if (res)
                      // map
                      switch (TYPE) {
                        case 3:
                          return true // some
                        case 5:
                          return val // find
                        case 6:
                          return index // findIndex
                        case 2:
                          result.push(val) // filter
                      }
                    else if (IS_EVERY) return false // every
                  }
                }
              return IS_FIND_INDEX
                ? -1
                : IS_SOME || IS_EVERY ? IS_EVERY : result
            }
          }
        },
        {
          './_array-species-create': 155,
          './_ctx': 163,
          './_iobject': 177,
          './_to-length': 214,
          './_to-object': 215,
        },
      ],
      154: [
        function(require, module, exports) {
          var isObject = require('./_is-object'),
            isArray = require('./_is-array'),
            SPECIES = require('./_wks')('species')

          module.exports = function(original) {
            var C
            if (isArray(original)) {
              C = original.constructor
              // cross-realm fallback
              if (
                typeof C == 'function' &&
                (C === Array || isArray(C.prototype))
              )
                C = undefined
              if (isObject(C)) {
                C = C[SPECIES]
                if (C === null) C = undefined
              }
            }
            return C === undefined ? Array : C
          }
        },
        { './_is-array': 179, './_is-object': 180, './_wks': 220 },
      ],
      155: [
        function(require, module, exports) {
          // 9.4.2.3 ArraySpeciesCreate(originalArray, length)
          var speciesConstructor = require('./_array-species-constructor')

          module.exports = function(original, length) {
            return new (speciesConstructor(original))(length)
          }
        },
        { './_array-species-constructor': 154 },
      ],
      156: [
        function(require, module, exports) {
          // getting tag from 19.1.3.6 Object.prototype.toString()
          var cof = require('./_cof'),
            TAG = require('./_wks')('toStringTag'),
            // ES3 wrong here
            ARG =
              cof(
                (function() {
                  return arguments
                })()
              ) == 'Arguments'

          // fallback for IE11 Script Access Denied error
          var tryGet = function(it, key) {
            try {
              return it[key]
            } catch (e) {
              /* empty */
            }
          }

          module.exports = function(it) {
            var O, T, B
            return it === undefined
              ? 'Undefined'
              : it === null
                ? 'Null'
                : // @@toStringTag case
                  typeof (T = tryGet((O = Object(it)), TAG)) == 'string'
                  ? T
                  : // builtinTag case
                    ARG
                    ? cof(O)
                    : // ES3 arguments fallback
                      (B = cof(O)) == 'Object' && typeof O.callee == 'function'
                      ? 'Arguments'
                      : B
          }
        },
        { './_cof': 157, './_wks': 220 },
      ],
      157: [
        function(require, module, exports) {
          var toString = {}.toString

          module.exports = function(it) {
            return toString.call(it).slice(8, -1)
          }
        },
        {},
      ],
      158: [
        function(require, module, exports) {
          'use strict'
          var dP = require('./_object-dp').f,
            create = require('./_object-create'),
            redefineAll = require('./_redefine-all'),
            ctx = require('./_ctx'),
            anInstance = require('./_an-instance'),
            defined = require('./_defined'),
            forOf = require('./_for-of'),
            $iterDefine = require('./_iter-define'),
            step = require('./_iter-step'),
            setSpecies = require('./_set-species'),
            DESCRIPTORS = require('./_descriptors'),
            fastKey = require('./_meta').fastKey,
            SIZE = DESCRIPTORS ? '_s' : 'size'

          var getEntry = function(that, key) {
            // fast case
            var index = fastKey(key),
              entry
            if (index !== 'F') return that._i[index]
            // frozen object case
            for (entry = that._f; entry; entry = entry.n) {
              if (entry.k == key) return entry
            }
          }

          module.exports = {
            getConstructor: function(wrapper, NAME, IS_MAP, ADDER) {
              var C = wrapper(function(that, iterable) {
                anInstance(that, C, NAME, '_i')
                that._i = create(null) // index
                that._f = undefined // first entry
                that._l = undefined // last entry
                that[SIZE] = 0 // size
                if (iterable != undefined)
                  forOf(iterable, IS_MAP, that[ADDER], that)
              })
              redefineAll(C.prototype, {
                // 23.1.3.1 Map.prototype.clear()
                // 23.2.3.2 Set.prototype.clear()
                clear: function clear() {
                  for (
                    var that = this, data = that._i, entry = that._f;
                    entry;
                    entry = entry.n
                  ) {
                    entry.r = true
                    if (entry.p) entry.p = entry.p.n = undefined
                    delete data[entry.i]
                  }
                  that._f = that._l = undefined
                  that[SIZE] = 0
                },
                // 23.1.3.3 Map.prototype.delete(key)
                // 23.2.3.4 Set.prototype.delete(value)
                delete: function(key) {
                  var that = this,
                    entry = getEntry(that, key)
                  if (entry) {
                    var next = entry.n,
                      prev = entry.p
                    delete that._i[entry.i]
                    entry.r = true
                    if (prev) prev.n = next
                    if (next) next.p = prev
                    if (that._f == entry) that._f = next
                    if (that._l == entry) that._l = prev
                    that[SIZE]--
                  }
                  return !!entry
                },
                // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
                // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
                forEach: function forEach(callbackfn /*, that = undefined */) {
                  anInstance(this, C, 'forEach')
                  var f = ctx(
                    callbackfn,
                    arguments.length > 1 ? arguments[1] : undefined,
                    3
                  ),
                    entry
                  while ((entry = entry ? entry.n : this._f)) {
                    f(entry.v, entry.k, this)
                    // revert to the last existing entry
                    while (entry && entry.r) entry = entry.p
                  }
                },
                // 23.1.3.7 Map.prototype.has(key)
                // 23.2.3.7 Set.prototype.has(value)
                has: function has(key) {
                  return !!getEntry(this, key)
                },
              })
              if (DESCRIPTORS)
                dP(C.prototype, 'size', {
                  get: function() {
                    return defined(this[SIZE])
                  },
                })
              return C
            },
            def: function(that, key, value) {
              var entry = getEntry(that, key),
                prev,
                index
              // change existing entry
              if (entry) {
                entry.v = value
                // create new entry
              } else {
                that._l = entry = {
                  i: (index = fastKey(key, true)), // <- index
                  k: key, // <- key
                  v: value, // <- value
                  p: (prev = that._l), // <- previous entry
                  n: undefined, // <- next entry
                  r: false, // <- removed
                }
                if (!that._f) that._f = entry
                if (prev) prev.n = entry
                that[SIZE]++
                // add to index
                if (index !== 'F') that._i[index] = entry
              }
              return that
            },
            getEntry: getEntry,
            setStrong: function(C, NAME, IS_MAP) {
              // add .keys, .values, .entries, [@@iterator]
              // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
              $iterDefine(
                C,
                NAME,
                function(iterated, kind) {
                  this._t = iterated // target
                  this._k = kind // kind
                  this._l = undefined // previous
                },
                function() {
                  var that = this,
                    kind = that._k,
                    entry = that._l
                  // revert to the last existing entry
                  while (entry && entry.r) entry = entry.p
                  // get next entry
                  if (
                    !that._t ||
                    !(that._l = entry = entry ? entry.n : that._t._f)
                  ) {
                    // or finish the iteration
                    that._t = undefined
                    return step(1)
                  }
                  // return step by kind
                  if (kind == 'keys') return step(0, entry.k)
                  if (kind == 'values') return step(0, entry.v)
                  return step(0, [entry.k, entry.v])
                },
                IS_MAP ? 'entries' : 'values',
                !IS_MAP,
                true
              )

              // add [@@species], 23.1.2.2, 23.2.2.2
              setSpecies(NAME)
            },
          }
        },
        {
          './_an-instance': 149,
          './_ctx': 163,
          './_defined': 164,
          './_descriptors': 165,
          './_for-of': 171,
          './_iter-define': 183,
          './_iter-step': 184,
          './_meta': 188,
          './_object-create': 190,
          './_object-dp': 191,
          './_redefine-all': 203,
          './_set-species': 206,
        },
      ],
      159: [
        function(require, module, exports) {
          // https://github.com/DavidBruant/Map-Set.prototype.toJSON
          var classof = require('./_classof'),
            from = require('./_array-from-iterable')
          module.exports = function(NAME) {
            return function toJSON() {
              if (classof(this) != NAME)
                throw TypeError(NAME + "#toJSON isn't generic")
              return from(this)
            }
          }
        },
        { './_array-from-iterable': 151, './_classof': 156 },
      ],
      160: [
        function(require, module, exports) {
          'use strict'
          var redefineAll = require('./_redefine-all'),
            getWeak = require('./_meta').getWeak,
            anObject = require('./_an-object'),
            isObject = require('./_is-object'),
            anInstance = require('./_an-instance'),
            forOf = require('./_for-of'),
            createArrayMethod = require('./_array-methods'),
            $has = require('./_has'),
            arrayFind = createArrayMethod(5),
            arrayFindIndex = createArrayMethod(6),
            id = 0

          // fallback for uncaught frozen keys
          var uncaughtFrozenStore = function(that) {
            return that._l || (that._l = new UncaughtFrozenStore())
          }
          var UncaughtFrozenStore = function() {
            this.a = []
          }
          var findUncaughtFrozen = function(store, key) {
            return arrayFind(store.a, function(it) {
              return it[0] === key
            })
          }
          UncaughtFrozenStore.prototype = {
            get: function(key) {
              var entry = findUncaughtFrozen(this, key)
              if (entry) return entry[1]
            },
            has: function(key) {
              return !!findUncaughtFrozen(this, key)
            },
            set: function(key, value) {
              var entry = findUncaughtFrozen(this, key)
              if (entry) entry[1] = value
              else this.a.push([key, value])
            },
            delete: function(key) {
              var index = arrayFindIndex(this.a, function(it) {
                return it[0] === key
              })
              if (~index) this.a.splice(index, 1)
              return !!~index
            },
          }

          module.exports = {
            getConstructor: function(wrapper, NAME, IS_MAP, ADDER) {
              var C = wrapper(function(that, iterable) {
                anInstance(that, C, NAME, '_i')
                that._i = id++ // collection id
                that._l = undefined // leak store for uncaught frozen objects
                if (iterable != undefined)
                  forOf(iterable, IS_MAP, that[ADDER], that)
              })
              redefineAll(C.prototype, {
                // 23.3.3.2 WeakMap.prototype.delete(key)
                // 23.4.3.3 WeakSet.prototype.delete(value)
                delete: function(key) {
                  if (!isObject(key)) return false
                  var data = getWeak(key)
                  if (data === true)
                    return uncaughtFrozenStore(this)['delete'](key)
                  return data && $has(data, this._i) && delete data[this._i]
                },
                // 23.3.3.4 WeakMap.prototype.has(key)
                // 23.4.3.4 WeakSet.prototype.has(value)
                has: function has(key) {
                  if (!isObject(key)) return false
                  var data = getWeak(key)
                  if (data === true) return uncaughtFrozenStore(this).has(key)
                  return data && $has(data, this._i)
                },
              })
              return C
            },
            def: function(that, key, value) {
              var data = getWeak(anObject(key), true)
              if (data === true) uncaughtFrozenStore(that).set(key, value)
              else data[that._i] = value
              return that
            },
            ufstore: uncaughtFrozenStore,
          }
        },
        {
          './_an-instance': 149,
          './_an-object': 150,
          './_array-methods': 153,
          './_for-of': 171,
          './_has': 173,
          './_is-object': 180,
          './_meta': 188,
          './_redefine-all': 203,
        },
      ],
      161: [
        function(require, module, exports) {
          'use strict'
          var global = require('./_global'),
            $export = require('./_export'),
            meta = require('./_meta'),
            fails = require('./_fails'),
            hide = require('./_hide'),
            redefineAll = require('./_redefine-all'),
            forOf = require('./_for-of'),
            anInstance = require('./_an-instance'),
            isObject = require('./_is-object'),
            setToStringTag = require('./_set-to-string-tag'),
            dP = require('./_object-dp').f,
            each = require('./_array-methods')(0),
            DESCRIPTORS = require('./_descriptors')

          module.exports = function(
            NAME,
            wrapper,
            methods,
            common,
            IS_MAP,
            IS_WEAK
          ) {
            var Base = global[NAME],
              C = Base,
              ADDER = IS_MAP ? 'set' : 'add',
              proto = C && C.prototype,
              O = {}
            if (
              !DESCRIPTORS ||
              typeof C != 'function' ||
              !(
                IS_WEAK ||
                (proto.forEach &&
                  !fails(function() {
                    new C().entries().next()
                  }))
              )
            ) {
              // create collection constructor
              C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER)
              redefineAll(C.prototype, methods)
              meta.NEED = true
            } else {
              C = wrapper(function(target, iterable) {
                anInstance(target, C, NAME, '_c')
                target._c = new Base()
                if (iterable != undefined)
                  forOf(iterable, IS_MAP, target[ADDER], target)
              })
              each(
                'add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(
                  ','
                ),
                function(KEY) {
                  var IS_ADDER = KEY == 'add' || KEY == 'set'
                  if (KEY in proto && !(IS_WEAK && KEY == 'clear'))
                    hide(C.prototype, KEY, function(a, b) {
                      anInstance(this, C, KEY)
                      if (!IS_ADDER && IS_WEAK && !isObject(a))
                        return KEY == 'get' ? undefined : false
                      var result = this._c[KEY](a === 0 ? 0 : a, b)
                      return IS_ADDER ? this : result
                    })
                }
              )
              if ('size' in proto)
                dP(C.prototype, 'size', {
                  get: function() {
                    return this._c.size
                  },
                })
            }

            setToStringTag(C, NAME)

            O[NAME] = C
            $export($export.G + $export.W + $export.F, O)

            if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP)

            return C
          }
        },
        {
          './_an-instance': 149,
          './_array-methods': 153,
          './_descriptors': 165,
          './_export': 169,
          './_fails': 170,
          './_for-of': 171,
          './_global': 172,
          './_hide': 174,
          './_is-object': 180,
          './_meta': 188,
          './_object-dp': 191,
          './_redefine-all': 203,
          './_set-to-string-tag': 207,
        },
      ],
      162: [
        function(require, module, exports) {
          var core = (module.exports = { version: '2.4.0' })
          if (typeof __e == 'number') __e = core // eslint-disable-line no-undef
        },
        {},
      ],
      163: [
        function(require, module, exports) {
          // optional / simple context binding
          var aFunction = require('./_a-function')
          module.exports = function(fn, that, length) {
            aFunction(fn)
            if (that === undefined) return fn
            switch (length) {
              case 1:
                return function(a) {
                  return fn.call(that, a)
                }
              case 2:
                return function(a, b) {
                  return fn.call(that, a, b)
                }
              case 3:
                return function(a, b, c) {
                  return fn.call(that, a, b, c)
                }
            }
            return function(/* ...args */) {
              return fn.apply(that, arguments)
            }
          }
        },
        { './_a-function': 147 },
      ],
      164: [
        function(require, module, exports) {
          // 7.2.1 RequireObjectCoercible(argument)
          module.exports = function(it) {
            if (it == undefined) throw TypeError("Can't call method on  " + it)
            return it
          }
        },
        {},
      ],
      165: [
        function(require, module, exports) {
          // Thank's IE8 for his funny defineProperty
          module.exports = !require('./_fails')(function() {
            return (
              Object.defineProperty({}, 'a', {
                get: function() {
                  return 7
                },
              }).a != 7
            )
          })
        },
        { './_fails': 170 },
      ],
      166: [
        function(require, module, exports) {
          var isObject = require('./_is-object'),
            document = require('./_global').document,
            // in old IE typeof document.createElement is 'object'
            is = isObject(document) && isObject(document.createElement)
          module.exports = function(it) {
            return is ? document.createElement(it) : {}
          }
        },
        { './_global': 172, './_is-object': 180 },
      ],
      167: [
        function(require, module, exports) {
          // IE 8- don't enum bug keys
          module.exports = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(
            ','
          )
        },
        {},
      ],
      168: [
        function(require, module, exports) {
          // all enumerable object keys, includes symbols
          var getKeys = require('./_object-keys'),
            gOPS = require('./_object-gops'),
            pIE = require('./_object-pie')
          module.exports = function(it) {
            var result = getKeys(it),
              getSymbols = gOPS.f
            if (getSymbols) {
              var symbols = getSymbols(it),
                isEnum = pIE.f,
                i = 0,
                key
              while (symbols.length > i)
                if (isEnum.call(it, (key = symbols[i++]))) result.push(key)
            }
            return result
          }
        },
        { './_object-gops': 196, './_object-keys': 199, './_object-pie': 200 },
      ],
      169: [
        function(require, module, exports) {
          var global = require('./_global'),
            core = require('./_core'),
            ctx = require('./_ctx'),
            hide = require('./_hide'),
            PROTOTYPE = 'prototype'

          var $export = function(type, name, source) {
            var IS_FORCED = type & $export.F,
              IS_GLOBAL = type & $export.G,
              IS_STATIC = type & $export.S,
              IS_PROTO = type & $export.P,
              IS_BIND = type & $export.B,
              IS_WRAP = type & $export.W,
              exports = IS_GLOBAL ? core : core[name] || (core[name] = {}),
              expProto = exports[PROTOTYPE],
              target = IS_GLOBAL
                ? global
                : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE],
              key,
              own,
              out
            if (IS_GLOBAL) source = name
            for (key in source) {
              // contains in native
              own = !IS_FORCED && target && target[key] !== undefined
              if (own && key in exports) continue
              // export native or passed
              out = own ? target[key] : source[key]
              // prevent global pollution for namespaces
              exports[key] = IS_GLOBAL && typeof target[key] != 'function'
                ? source[key]
                : // bind timers to global for call from export context
                  IS_BIND && own
                  ? ctx(out, global)
                  : // wrap global constructors for prevent change them in library
                    IS_WRAP && target[key] == out
                    ? (function(C) {
                        var F = function(a, b, c) {
                          if (this instanceof C) {
                            switch (arguments.length) {
                              case 0:
                                return new C()
                              case 1:
                                return new C(a)
                              case 2:
                                return new C(a, b)
                            }
                            return new C(a, b, c)
                          }
                          return C.apply(this, arguments)
                        }
                        F[PROTOTYPE] = C[PROTOTYPE]
                        return F
                        // make static versions for prototype methods
                      })(out)
                    : IS_PROTO && typeof out == 'function'
                      ? ctx(Function.call, out)
                      : out
              // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
              if (IS_PROTO) {
                ;(exports.virtual || (exports.virtual = {}))[key] = out
                // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
                if (type & $export.R && expProto && !expProto[key])
                  hide(expProto, key, out)
              }
            }
          }
          // type bitmap
          $export.F = 1 // forced
          $export.G = 2 // global
          $export.S = 4 // static
          $export.P = 8 // proto
          $export.B = 16 // bind
          $export.W = 32 // wrap
          $export.U = 64 // safe
          $export.R = 128 // real proto method for `library`
          module.exports = $export
        },
        { './_core': 162, './_ctx': 163, './_global': 172, './_hide': 174 },
      ],
      170: [
        function(require, module, exports) {
          module.exports = function(exec) {
            try {
              return !!exec()
            } catch (e) {
              return true
            }
          }
        },
        {},
      ],
      171: [
        function(require, module, exports) {
          var ctx = require('./_ctx'),
            call = require('./_iter-call'),
            isArrayIter = require('./_is-array-iter'),
            anObject = require('./_an-object'),
            toLength = require('./_to-length'),
            getIterFn = require('./core.get-iterator-method'),
            BREAK = {},
            RETURN = {}
          var exports = (module.exports = function(
            iterable,
            entries,
            fn,
            that,
            ITERATOR
          ) {
            var iterFn = ITERATOR
              ? function() {
                  return iterable
                }
              : getIterFn(iterable),
              f = ctx(fn, that, entries ? 2 : 1),
              index = 0,
              length,
              step,
              iterator,
              result
            if (typeof iterFn != 'function')
              throw TypeError(iterable + ' is not iterable!')
            // fast case for arrays with default iterator
            if (isArrayIter(iterFn))
              for (
                length = toLength(iterable.length);
                length > index;
                index++
              ) {
                result = entries
                  ? f(anObject((step = iterable[index]))[0], step[1])
                  : f(iterable[index])
                if (result === BREAK || result === RETURN) return result
              }
            else
              for (
                iterator = iterFn.call(iterable);
                !(step = iterator.next()).done;

              ) {
                result = call(iterator, f, step.value, entries)
                if (result === BREAK || result === RETURN) return result
              }
          })
          exports.BREAK = BREAK
          exports.RETURN = RETURN
        },
        {
          './_an-object': 150,
          './_ctx': 163,
          './_is-array-iter': 178,
          './_iter-call': 181,
          './_to-length': 214,
          './core.get-iterator-method': 221,
        },
      ],
      172: [
        function(require, module, exports) {
          // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
          var global = (module.exports = typeof window != 'undefined' &&
            window.Math == Math
            ? window
            : typeof self != 'undefined' && self.Math == Math
              ? self
              : Function('return this')())
          if (typeof __g == 'number') __g = global // eslint-disable-line no-undef
        },
        {},
      ],
      173: [
        function(require, module, exports) {
          var hasOwnProperty = {}.hasOwnProperty
          module.exports = function(it, key) {
            return hasOwnProperty.call(it, key)
          }
        },
        {},
      ],
      174: [
        function(require, module, exports) {
          var dP = require('./_object-dp'),
            createDesc = require('./_property-desc')
          module.exports = require('./_descriptors')
            ? function(object, key, value) {
                return dP.f(object, key, createDesc(1, value))
              }
            : function(object, key, value) {
                object[key] = value
                return object
              }
        },
        { './_descriptors': 165, './_object-dp': 191, './_property-desc': 202 },
      ],
      175: [
        function(require, module, exports) {
          module.exports =
            require('./_global').document && document.documentElement
        },
        { './_global': 172 },
      ],
      176: [
        function(require, module, exports) {
          module.exports =
            !require('./_descriptors') &&
            !require('./_fails')(function() {
              return (
                Object.defineProperty(require('./_dom-create')('div'), 'a', {
                  get: function() {
                    return 7
                  },
                }).a != 7
              )
            })
        },
        { './_descriptors': 165, './_dom-create': 166, './_fails': 170 },
      ],
      177: [
        function(require, module, exports) {
          // fallback for non-array-like ES3 and non-enumerable old V8 strings
          var cof = require('./_cof')
          module.exports = Object('z').propertyIsEnumerable(0)
            ? Object
            : function(it) {
                return cof(it) == 'String' ? it.split('') : Object(it)
              }
        },
        { './_cof': 157 },
      ],
      178: [
        function(require, module, exports) {
          // check on default Array iterator
          var Iterators = require('./_iterators'),
            ITERATOR = require('./_wks')('iterator'),
            ArrayProto = Array.prototype

          module.exports = function(it) {
            return (
              it !== undefined &&
              (Iterators.Array === it || ArrayProto[ITERATOR] === it)
            )
          }
        },
        { './_iterators': 185, './_wks': 220 },
      ],
      179: [
        function(require, module, exports) {
          // 7.2.2 IsArray(argument)
          var cof = require('./_cof')
          module.exports =
            Array.isArray ||
            function isArray(arg) {
              return cof(arg) == 'Array'
            }
        },
        { './_cof': 157 },
      ],
      180: [
        function(require, module, exports) {
          module.exports = function(it) {
            return typeof it === 'object'
              ? it !== null
              : typeof it === 'function'
          }
        },
        {},
      ],
      181: [
        function(require, module, exports) {
          // call something on iterator step with safe closing on error
          var anObject = require('./_an-object')
          module.exports = function(iterator, fn, value, entries) {
            try {
              return entries ? fn(anObject(value)[0], value[1]) : fn(value)
              // 7.4.6 IteratorClose(iterator, completion)
            } catch (e) {
              var ret = iterator['return']
              if (ret !== undefined) anObject(ret.call(iterator))
              throw e
            }
          }
        },
        { './_an-object': 150 },
      ],
      182: [
        function(require, module, exports) {
          'use strict'
          var create = require('./_object-create'),
            descriptor = require('./_property-desc'),
            setToStringTag = require('./_set-to-string-tag'),
            IteratorPrototype = {}

          // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
          require('./_hide')(
            IteratorPrototype,
            require('./_wks')('iterator'),
            function() {
              return this
            }
          )

          module.exports = function(Constructor, NAME, next) {
            Constructor.prototype = create(IteratorPrototype, {
              next: descriptor(1, next),
            })
            setToStringTag(Constructor, NAME + ' Iterator')
          }
        },
        {
          './_hide': 174,
          './_object-create': 190,
          './_property-desc': 202,
          './_set-to-string-tag': 207,
          './_wks': 220,
        },
      ],
      183: [
        function(require, module, exports) {
          'use strict'
          var LIBRARY = require('./_library'),
            $export = require('./_export'),
            redefine = require('./_redefine'),
            hide = require('./_hide'),
            has = require('./_has'),
            Iterators = require('./_iterators'),
            $iterCreate = require('./_iter-create'),
            setToStringTag = require('./_set-to-string-tag'),
            getPrototypeOf = require('./_object-gpo'),
            ITERATOR = require('./_wks')('iterator'),
            BUGGY = !([].keys && 'next' in [].keys()), // Safari has buggy iterators w/o `next`
            FF_ITERATOR = '@@iterator',
            KEYS = 'keys',
            VALUES = 'values'

          var returnThis = function() {
            return this
          }

          module.exports = function(
            Base,
            NAME,
            Constructor,
            next,
            DEFAULT,
            IS_SET,
            FORCED
          ) {
            $iterCreate(Constructor, NAME, next)
            var getMethod = function(kind) {
              if (!BUGGY && kind in proto) return proto[kind]
              switch (kind) {
                case KEYS:
                  return function keys() {
                    return new Constructor(this, kind)
                  }
                case VALUES:
                  return function values() {
                    return new Constructor(this, kind)
                  }
              }
              return function entries() {
                return new Constructor(this, kind)
              }
            }
            var TAG = NAME + ' Iterator',
              DEF_VALUES = DEFAULT == VALUES,
              VALUES_BUG = false,
              proto = Base.prototype,
              $native =
                proto[ITERATOR] ||
                proto[FF_ITERATOR] ||
                (DEFAULT && proto[DEFAULT]),
              $default = $native || getMethod(DEFAULT),
              $entries = DEFAULT
                ? !DEF_VALUES ? $default : getMethod('entries')
                : undefined,
              $anyNative = NAME == 'Array' ? proto.entries || $native : $native,
              methods,
              key,
              IteratorPrototype
            // Fix native
            if ($anyNative) {
              IteratorPrototype = getPrototypeOf($anyNative.call(new Base()))
              if (IteratorPrototype !== Object.prototype) {
                // Set @@toStringTag to native iterators
                setToStringTag(IteratorPrototype, TAG, true)
                // fix for some old engines
                if (!LIBRARY && !has(IteratorPrototype, ITERATOR))
                  hide(IteratorPrototype, ITERATOR, returnThis)
              }
            }
            // fix Array#{values, @@iterator}.name in V8 / FF
            if (DEF_VALUES && $native && $native.name !== VALUES) {
              VALUES_BUG = true
              $default = function values() {
                return $native.call(this)
              }
            }
            // Define iterator
            if (
              (!LIBRARY || FORCED) &&
              (BUGGY || VALUES_BUG || !proto[ITERATOR])
            ) {
              hide(proto, ITERATOR, $default)
            }
            // Plug for library
            Iterators[NAME] = $default
            Iterators[TAG] = returnThis
            if (DEFAULT) {
              methods = {
                values: DEF_VALUES ? $default : getMethod(VALUES),
                keys: IS_SET ? $default : getMethod(KEYS),
                entries: $entries,
              }
              if (FORCED)
                for (key in methods) {
                  if (!(key in proto)) redefine(proto, key, methods[key])
                }
              else
                $export(
                  $export.P + $export.F * (BUGGY || VALUES_BUG),
                  NAME,
                  methods
                )
            }
            return methods
          }
        },
        {
          './_export': 169,
          './_has': 173,
          './_hide': 174,
          './_iter-create': 182,
          './_iterators': 185,
          './_library': 187,
          './_object-gpo': 197,
          './_redefine': 204,
          './_set-to-string-tag': 207,
          './_wks': 220,
        },
      ],
      184: [
        function(require, module, exports) {
          module.exports = function(done, value) {
            return { value: value, done: !!done }
          }
        },
        {},
      ],
      185: [
        function(require, module, exports) {
          module.exports = {}
        },
        {},
      ],
      186: [
        function(require, module, exports) {
          var getKeys = require('./_object-keys'),
            toIObject = require('./_to-iobject')
          module.exports = function(object, el) {
            var O = toIObject(object),
              keys = getKeys(O),
              length = keys.length,
              index = 0,
              key
            while (length > index)
              if (O[(key = keys[index++])] === el) return key
          }
        },
        { './_object-keys': 199, './_to-iobject': 213 },
      ],
      187: [
        function(require, module, exports) {
          module.exports = true
        },
        {},
      ],
      188: [
        function(require, module, exports) {
          var META = require('./_uid')('meta'),
            isObject = require('./_is-object'),
            has = require('./_has'),
            setDesc = require('./_object-dp').f,
            id = 0
          var isExtensible =
            Object.isExtensible ||
            function() {
              return true
            }
          var FREEZE = !require('./_fails')(function() {
            return isExtensible(Object.preventExtensions({}))
          })
          var setMeta = function(it) {
            setDesc(it, META, {
              value: {
                i: 'O' + ++id, // object ID
                w: {}, // weak collections IDs
              },
            })
          }
          var fastKey = function(it, create) {
            // return primitive with prefix
            if (!isObject(it))
              return typeof it == 'symbol'
                ? it
                : (typeof it == 'string' ? 'S' : 'P') + it
            if (!has(it, META)) {
              // can't set metadata to uncaught frozen object
              if (!isExtensible(it)) return 'F'
              // not necessary to add metadata
              if (!create) return 'E'
              // add missing metadata
              setMeta(it)
              // return object ID
            }
            return it[META].i
          }
          var getWeak = function(it, create) {
            if (!has(it, META)) {
              // can't set metadata to uncaught frozen object
              if (!isExtensible(it)) return true
              // not necessary to add metadata
              if (!create) return false
              // add missing metadata
              setMeta(it)
              // return hash weak collections IDs
            }
            return it[META].w
          }
          // add metadata on freeze-family methods calling
          var onFreeze = function(it) {
            if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META))
              setMeta(it)
            return it
          }
          var meta = (module.exports = {
            KEY: META,
            NEED: false,
            fastKey: fastKey,
            getWeak: getWeak,
            onFreeze: onFreeze,
          })
        },
        {
          './_fails': 170,
          './_has': 173,
          './_is-object': 180,
          './_object-dp': 191,
          './_uid': 217,
        },
      ],
      189: [
        function(require, module, exports) {
          'use strict'
          // 19.1.2.1 Object.assign(target, source, ...)
          var getKeys = require('./_object-keys'),
            gOPS = require('./_object-gops'),
            pIE = require('./_object-pie'),
            toObject = require('./_to-object'),
            IObject = require('./_iobject'),
            $assign = Object.assign

          // should work with symbols and should have deterministic property order (V8 bug)
          module.exports = !$assign ||
            require('./_fails')(function() {
              var A = {},
                B = {},
                S = Symbol(),
                K = 'abcdefghijklmnopqrst'
              A[S] = 7
              K.split('').forEach(function(k) {
                B[k] = k
              })
              return (
                $assign({}, A)[S] != 7 ||
                Object.keys($assign({}, B)).join('') != K
              )
            })
            ? function assign(target, source) {
                // eslint-disable-line no-unused-vars
                var T = toObject(target),
                  aLen = arguments.length,
                  index = 1,
                  getSymbols = gOPS.f,
                  isEnum = pIE.f
                while (aLen > index) {
                  var S = IObject(arguments[index++]),
                    keys = getSymbols
                      ? getKeys(S).concat(getSymbols(S))
                      : getKeys(S),
                    length = keys.length,
                    j = 0,
                    key
                  while (length > j)
                    if (isEnum.call(S, (key = keys[j++]))) T[key] = S[key]
                }
                return T
              }
            : $assign
        },
        {
          './_fails': 170,
          './_iobject': 177,
          './_object-gops': 196,
          './_object-keys': 199,
          './_object-pie': 200,
          './_to-object': 215,
        },
      ],
      190: [
        function(require, module, exports) {
          // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
          var anObject = require('./_an-object'),
            dPs = require('./_object-dps'),
            enumBugKeys = require('./_enum-bug-keys'),
            IE_PROTO = require('./_shared-key')('IE_PROTO'),
            Empty = function() {
              /* empty */
            },
            PROTOTYPE = 'prototype'

          // Create object with fake `null` prototype: use iframe Object with cleared prototype
          var createDict = function() {
            // Thrash, waste and sodomy: IE GC bug
            var iframe = require('./_dom-create')('iframe'),
              i = enumBugKeys.length,
              lt = '<',
              gt = '>',
              iframeDocument
            iframe.style.display = 'none'
            require('./_html').appendChild(iframe)
            iframe.src = 'javascript:' // eslint-disable-line no-script-url
            // createDict = iframe.contentWindow.Object;
            // html.removeChild(iframe);
            iframeDocument = iframe.contentWindow.document
            iframeDocument.open()
            iframeDocument.write(
              lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt
            )
            iframeDocument.close()
            createDict = iframeDocument.F
            while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]]
            return createDict()
          }

          module.exports =
            Object.create ||
            function create(O, Properties) {
              var result
              if (O !== null) {
                Empty[PROTOTYPE] = anObject(O)
                result = new Empty()
                Empty[PROTOTYPE] = null
                // add "__proto__" for Object.getPrototypeOf polyfill
                result[IE_PROTO] = O
              } else result = createDict()
              return Properties === undefined ? result : dPs(result, Properties)
            }
        },
        {
          './_an-object': 150,
          './_dom-create': 166,
          './_enum-bug-keys': 167,
          './_html': 175,
          './_object-dps': 192,
          './_shared-key': 208,
        },
      ],
      191: [
        function(require, module, exports) {
          var anObject = require('./_an-object'),
            IE8_DOM_DEFINE = require('./_ie8-dom-define'),
            toPrimitive = require('./_to-primitive'),
            dP = Object.defineProperty

          exports.f = require('./_descriptors')
            ? Object.defineProperty
            : function defineProperty(O, P, Attributes) {
                anObject(O)
                P = toPrimitive(P, true)
                anObject(Attributes)
                if (IE8_DOM_DEFINE)
                  try {
                    return dP(O, P, Attributes)
                  } catch (e) {
                    /* empty */
                  }
                if ('get' in Attributes || 'set' in Attributes)
                  throw TypeError('Accessors not supported!')
                if ('value' in Attributes) O[P] = Attributes.value
                return O
              }
        },
        {
          './_an-object': 150,
          './_descriptors': 165,
          './_ie8-dom-define': 176,
          './_to-primitive': 216,
        },
      ],
      192: [
        function(require, module, exports) {
          var dP = require('./_object-dp'),
            anObject = require('./_an-object'),
            getKeys = require('./_object-keys')

          module.exports = require('./_descriptors')
            ? Object.defineProperties
            : function defineProperties(O, Properties) {
                anObject(O)
                var keys = getKeys(Properties),
                  length = keys.length,
                  i = 0,
                  P
                while (length > i) dP.f(O, (P = keys[i++]), Properties[P])
                return O
              }
        },
        {
          './_an-object': 150,
          './_descriptors': 165,
          './_object-dp': 191,
          './_object-keys': 199,
        },
      ],
      193: [
        function(require, module, exports) {
          var pIE = require('./_object-pie'),
            createDesc = require('./_property-desc'),
            toIObject = require('./_to-iobject'),
            toPrimitive = require('./_to-primitive'),
            has = require('./_has'),
            IE8_DOM_DEFINE = require('./_ie8-dom-define'),
            gOPD = Object.getOwnPropertyDescriptor

          exports.f = require('./_descriptors')
            ? gOPD
            : function getOwnPropertyDescriptor(O, P) {
                O = toIObject(O)
                P = toPrimitive(P, true)
                if (IE8_DOM_DEFINE)
                  try {
                    return gOPD(O, P)
                  } catch (e) {
                    /* empty */
                  }
                if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P])
              }
        },
        {
          './_descriptors': 165,
          './_has': 173,
          './_ie8-dom-define': 176,
          './_object-pie': 200,
          './_property-desc': 202,
          './_to-iobject': 213,
          './_to-primitive': 216,
        },
      ],
      194: [
        function(require, module, exports) {
          // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
          var toIObject = require('./_to-iobject'),
            gOPN = require('./_object-gopn').f,
            toString = {}.toString

          var windowNames = typeof window == 'object' &&
            window &&
            Object.getOwnPropertyNames
            ? Object.getOwnPropertyNames(window)
            : []

          var getWindowNames = function(it) {
            try {
              return gOPN(it)
            } catch (e) {
              return windowNames.slice()
            }
          }

          module.exports.f = function getOwnPropertyNames(it) {
            return windowNames && toString.call(it) == '[object Window]'
              ? getWindowNames(it)
              : gOPN(toIObject(it))
          }
        },
        { './_object-gopn': 195, './_to-iobject': 213 },
      ],
      195: [
        function(require, module, exports) {
          // 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
          var $keys = require('./_object-keys-internal'),
            hiddenKeys = require('./_enum-bug-keys').concat(
              'length',
              'prototype'
            )

          exports.f =
            Object.getOwnPropertyNames ||
            function getOwnPropertyNames(O) {
              return $keys(O, hiddenKeys)
            }
        },
        { './_enum-bug-keys': 167, './_object-keys-internal': 198 },
      ],
      196: [
        function(require, module, exports) {
          exports.f = Object.getOwnPropertySymbols
        },
        {},
      ],
      197: [
        function(require, module, exports) {
          // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
          var has = require('./_has'),
            toObject = require('./_to-object'),
            IE_PROTO = require('./_shared-key')('IE_PROTO'),
            ObjectProto = Object.prototype

          module.exports =
            Object.getPrototypeOf ||
            function(O) {
              O = toObject(O)
              if (has(O, IE_PROTO)) return O[IE_PROTO]
              if (
                typeof O.constructor == 'function' &&
                O instanceof O.constructor
              ) {
                return O.constructor.prototype
              }
              return O instanceof Object ? ObjectProto : null
            }
        },
        { './_has': 173, './_shared-key': 208, './_to-object': 215 },
      ],
      198: [
        function(require, module, exports) {
          var has = require('./_has'),
            toIObject = require('./_to-iobject'),
            arrayIndexOf = require('./_array-includes')(false),
            IE_PROTO = require('./_shared-key')('IE_PROTO')

          module.exports = function(object, names) {
            var O = toIObject(object),
              i = 0,
              result = [],
              key
            for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key)
            // Don't enum bug & hidden keys
            while (names.length > i)
              if (has(O, (key = names[i++]))) {
                ~arrayIndexOf(result, key) || result.push(key)
              }
            return result
          }
        },
        {
          './_array-includes': 152,
          './_has': 173,
          './_shared-key': 208,
          './_to-iobject': 213,
        },
      ],
      199: [
        function(require, module, exports) {
          // 19.1.2.14 / 15.2.3.14 Object.keys(O)
          var $keys = require('./_object-keys-internal'),
            enumBugKeys = require('./_enum-bug-keys')

          module.exports =
            Object.keys ||
            function keys(O) {
              return $keys(O, enumBugKeys)
            }
        },
        { './_enum-bug-keys': 167, './_object-keys-internal': 198 },
      ],
      200: [
        function(require, module, exports) {
          exports.f = {}.propertyIsEnumerable
        },
        {},
      ],
      201: [
        function(require, module, exports) {
          // most Object methods by ES6 should accept primitives
          var $export = require('./_export'),
            core = require('./_core'),
            fails = require('./_fails')
          module.exports = function(KEY, exec) {
            var fn = (core.Object || {})[KEY] || Object[KEY],
              exp = {}
            exp[KEY] = exec(fn)
            $export(
              $export.S +
                $export.F *
                  fails(function() {
                    fn(1)
                  }),
              'Object',
              exp
            )
          }
        },
        { './_core': 162, './_export': 169, './_fails': 170 },
      ],
      202: [
        function(require, module, exports) {
          module.exports = function(bitmap, value) {
            return {
              enumerable: !(bitmap & 1),
              configurable: !(bitmap & 2),
              writable: !(bitmap & 4),
              value: value,
            }
          }
        },
        {},
      ],
      203: [
        function(require, module, exports) {
          var hide = require('./_hide')
          module.exports = function(target, src, safe) {
            for (var key in src) {
              if (safe && target[key]) target[key] = src[key]
              else hide(target, key, src[key])
            }
            return target
          }
        },
        { './_hide': 174 },
      ],
      204: [
        function(require, module, exports) {
          module.exports = require('./_hide')
        },
        { './_hide': 174 },
      ],
      205: [
        function(require, module, exports) {
          // Works with __proto__ only. Old v8 can't work with null proto objects.
          /* eslint-disable no-proto */
          var isObject = require('./_is-object'),
            anObject = require('./_an-object')
          var check = function(O, proto) {
            anObject(O)
            if (!isObject(proto) && proto !== null)
              throw TypeError(proto + ": can't set as prototype!")
          }
          module.exports = {
            set:
              Object.setPrototypeOf ||
                ('__proto__' in {} // eslint-disable-line
                  ? (function(test, buggy, set) {
                      try {
                        set = require('./_ctx')(
                          Function.call,
                          require('./_object-gopd').f(
                            Object.prototype,
                            '__proto__'
                          ).set,
                          2
                        )
                        set(test, [])
                        buggy = !(test instanceof Array)
                      } catch (e) {
                        buggy = true
                      }
                      return function setPrototypeOf(O, proto) {
                        check(O, proto)
                        if (buggy) O.__proto__ = proto
                        else set(O, proto)
                        return O
                      }
                    })({}, false)
                  : undefined),
            check: check,
          }
        },
        {
          './_an-object': 150,
          './_ctx': 163,
          './_is-object': 180,
          './_object-gopd': 193,
        },
      ],
      206: [
        function(require, module, exports) {
          'use strict'
          var global = require('./_global'),
            core = require('./_core'),
            dP = require('./_object-dp'),
            DESCRIPTORS = require('./_descriptors'),
            SPECIES = require('./_wks')('species')

          module.exports = function(KEY) {
            var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY]
            if (DESCRIPTORS && C && !C[SPECIES])
              dP.f(C, SPECIES, {
                configurable: true,
                get: function() {
                  return this
                },
              })
          }
        },
        {
          './_core': 162,
          './_descriptors': 165,
          './_global': 172,
          './_object-dp': 191,
          './_wks': 220,
        },
      ],
      207: [
        function(require, module, exports) {
          var def = require('./_object-dp').f,
            has = require('./_has'),
            TAG = require('./_wks')('toStringTag')

          module.exports = function(it, tag, stat) {
            if (it && !has((it = stat ? it : it.prototype), TAG))
              def(it, TAG, { configurable: true, value: tag })
          }
        },
        { './_has': 173, './_object-dp': 191, './_wks': 220 },
      ],
      208: [
        function(require, module, exports) {
          var shared = require('./_shared')('keys'),
            uid = require('./_uid')
          module.exports = function(key) {
            return shared[key] || (shared[key] = uid(key))
          }
        },
        { './_shared': 209, './_uid': 217 },
      ],
      209: [
        function(require, module, exports) {
          var global = require('./_global'),
            SHARED = '__core-js_shared__',
            store = global[SHARED] || (global[SHARED] = {})
          module.exports = function(key) {
            return store[key] || (store[key] = {})
          }
        },
        { './_global': 172 },
      ],
      210: [
        function(require, module, exports) {
          var toInteger = require('./_to-integer'),
            defined = require('./_defined')
          // true  -> String#at
          // false -> String#codePointAt
          module.exports = function(TO_STRING) {
            return function(that, pos) {
              var s = String(defined(that)),
                i = toInteger(pos),
                l = s.length,
                a,
                b
              if (i < 0 || i >= l) return TO_STRING ? '' : undefined
              a = s.charCodeAt(i)
              return a < 0xd800 ||
                a > 0xdbff ||
                i + 1 === l ||
                (b = s.charCodeAt(i + 1)) < 0xdc00 ||
                b > 0xdfff
                ? TO_STRING ? s.charAt(i) : a
                : TO_STRING
                  ? s.slice(i, i + 2)
                  : ((a - 0xd800) << 10) + (b - 0xdc00) + 0x10000
            }
          }
        },
        { './_defined': 164, './_to-integer': 212 },
      ],
      211: [
        function(require, module, exports) {
          var toInteger = require('./_to-integer'),
            max = Math.max,
            min = Math.min
          module.exports = function(index, length) {
            index = toInteger(index)
            return index < 0 ? max(index + length, 0) : min(index, length)
          }
        },
        { './_to-integer': 212 },
      ],
      212: [
        function(require, module, exports) {
          // 7.1.4 ToInteger
          var ceil = Math.ceil,
            floor = Math.floor
          module.exports = function(it) {
            return isNaN((it = +it)) ? 0 : (it > 0 ? floor : ceil)(it)
          }
        },
        {},
      ],
      213: [
        function(require, module, exports) {
          // to indexed object, toObject with fallback for non-array-like ES3 strings
          var IObject = require('./_iobject'),
            defined = require('./_defined')
          module.exports = function(it) {
            return IObject(defined(it))
          }
        },
        { './_defined': 164, './_iobject': 177 },
      ],
      214: [
        function(require, module, exports) {
          // 7.1.15 ToLength
          var toInteger = require('./_to-integer'),
            min = Math.min
          module.exports = function(it) {
            return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0 // pow(2, 53) - 1 == 9007199254740991
          }
        },
        { './_to-integer': 212 },
      ],
      215: [
        function(require, module, exports) {
          // 7.1.13 ToObject(argument)
          var defined = require('./_defined')
          module.exports = function(it) {
            return Object(defined(it))
          }
        },
        { './_defined': 164 },
      ],
      216: [
        function(require, module, exports) {
          // 7.1.1 ToPrimitive(input [, PreferredType])
          var isObject = require('./_is-object')
          // instead of the ES6 spec version, we didn't implement @@toPrimitive case
          // and the second argument - flag - preferred type is a string
          module.exports = function(it, S) {
            if (!isObject(it)) return it
            var fn, val
            if (
              S &&
              typeof (fn = it.toString) == 'function' &&
              !isObject((val = fn.call(it)))
            )
              return val
            if (
              typeof (fn = it.valueOf) == 'function' &&
              !isObject((val = fn.call(it)))
            )
              return val
            if (
              !S &&
              typeof (fn = it.toString) == 'function' &&
              !isObject((val = fn.call(it)))
            )
              return val
            throw TypeError("Can't convert object to primitive value")
          }
        },
        { './_is-object': 180 },
      ],
      217: [
        function(require, module, exports) {
          var id = 0,
            px = Math.random()
          module.exports = function(key) {
            return 'Symbol('.concat(
              key === undefined ? '' : key,
              ')_',
              (++id + px).toString(36)
            )
          }
        },
        {},
      ],
      218: [
        function(require, module, exports) {
          var global = require('./_global'),
            core = require('./_core'),
            LIBRARY = require('./_library'),
            wksExt = require('./_wks-ext'),
            defineProperty = require('./_object-dp').f
          module.exports = function(name) {
            var $Symbol =
              core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {})
            if (name.charAt(0) != '_' && !(name in $Symbol))
              defineProperty($Symbol, name, { value: wksExt.f(name) })
          }
        },
        {
          './_core': 162,
          './_global': 172,
          './_library': 187,
          './_object-dp': 191,
          './_wks-ext': 219,
        },
      ],
      219: [
        function(require, module, exports) {
          exports.f = require('./_wks')
        },
        { './_wks': 220 },
      ],
      220: [
        function(require, module, exports) {
          var store = require('./_shared')('wks'),
            uid = require('./_uid'),
            Symbol = require('./_global').Symbol,
            USE_SYMBOL = typeof Symbol == 'function'

          var $exports = (module.exports = function(name) {
            return (
              store[name] ||
              (store[name] =
                (USE_SYMBOL && Symbol[name]) ||
                (USE_SYMBOL ? Symbol : uid)('Symbol.' + name))
            )
          })

          $exports.store = store
        },
        { './_global': 172, './_shared': 209, './_uid': 217 },
      ],
      221: [
        function(require, module, exports) {
          var classof = require('./_classof'),
            ITERATOR = require('./_wks')('iterator'),
            Iterators = require('./_iterators')
          module.exports = require('./_core').getIteratorMethod = function(it) {
            if (it != undefined)
              return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)]
          }
        },
        {
          './_classof': 156,
          './_core': 162,
          './_iterators': 185,
          './_wks': 220,
        },
      ],
      222: [
        function(require, module, exports) {
          var anObject = require('./_an-object'),
            get = require('./core.get-iterator-method')
          module.exports = require('./_core').getIterator = function(it) {
            var iterFn = get(it)
            if (typeof iterFn != 'function')
              throw TypeError(it + ' is not iterable!')
            return anObject(iterFn.call(it))
          }
        },
        {
          './_an-object': 150,
          './_core': 162,
          './core.get-iterator-method': 221,
        },
      ],
      223: [
        function(require, module, exports) {
          'use strict'
          var addToUnscopables = require('./_add-to-unscopables'),
            step = require('./_iter-step'),
            Iterators = require('./_iterators'),
            toIObject = require('./_to-iobject')

          // 22.1.3.4 Array.prototype.entries()
          // 22.1.3.13 Array.prototype.keys()
          // 22.1.3.29 Array.prototype.values()
          // 22.1.3.30 Array.prototype[@@iterator]()
          module.exports = require('./_iter-define')(
            Array,
            'Array',
            function(iterated, kind) {
              this._t = toIObject(iterated) // target
              this._i = 0 // next index
              this._k = kind // kind
              // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
            },
            function() {
              var O = this._t,
                kind = this._k,
                index = this._i++
              if (!O || index >= O.length) {
                this._t = undefined
                return step(1)
              }
              if (kind == 'keys') return step(0, index)
              if (kind == 'values') return step(0, O[index])
              return step(0, [index, O[index]])
            },
            'values'
          )

          // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
          Iterators.Arguments = Iterators.Array

          addToUnscopables('keys')
          addToUnscopables('values')
          addToUnscopables('entries')
        },
        {
          './_add-to-unscopables': 148,
          './_iter-define': 183,
          './_iter-step': 184,
          './_iterators': 185,
          './_to-iobject': 213,
        },
      ],
      224: [
        function(require, module, exports) {
          'use strict'
          var strong = require('./_collection-strong')

          // 23.1 Map Objects
          module.exports = require('./_collection')(
            'Map',
            function(get) {
              return function Map() {
                return get(
                  this,
                  arguments.length > 0 ? arguments[0] : undefined
                )
              }
            },
            {
              // 23.1.3.6 Map.prototype.get(key)
              get: function get(key) {
                var entry = strong.getEntry(this, key)
                return entry && entry.v
              },
              // 23.1.3.9 Map.prototype.set(key, value)
              set: function set(key, value) {
                return strong.def(this, key === 0 ? 0 : key, value)
              },
            },
            strong,
            true
          )
        },
        { './_collection': 161, './_collection-strong': 158 },
      ],
      225: [
        function(require, module, exports) {
          // 20.1.2.6 Number.MAX_SAFE_INTEGER
          var $export = require('./_export')

          $export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff })
        },
        { './_export': 169 },
      ],
      226: [
        function(require, module, exports) {
          // 19.1.3.1 Object.assign(target, source)
          var $export = require('./_export')

          $export($export.S + $export.F, 'Object', {
            assign: require('./_object-assign'),
          })
        },
        { './_export': 169, './_object-assign': 189 },
      ],
      227: [
        function(require, module, exports) {
          var $export = require('./_export')
          // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
          $export($export.S, 'Object', { create: require('./_object-create') })
        },
        { './_export': 169, './_object-create': 190 },
      ],
      228: [
        function(require, module, exports) {
          // 19.1.2.14 Object.keys(O)
          var toObject = require('./_to-object'),
            $keys = require('./_object-keys')

          require('./_object-sap')('keys', function() {
            return function keys(it) {
              return $keys(toObject(it))
            }
          })
        },
        { './_object-keys': 199, './_object-sap': 201, './_to-object': 215 },
      ],
      229: [
        function(require, module, exports) {
          // 19.1.3.19 Object.setPrototypeOf(O, proto)
          var $export = require('./_export')
          $export($export.S, 'Object', {
            setPrototypeOf: require('./_set-proto').set,
          })
        },
        { './_export': 169, './_set-proto': 205 },
      ],
      230: [
        function(require, module, exports) {
          arguments[4][118][0].apply(exports, arguments)
        },
        { dup: 118 },
      ],
      231: [
        function(require, module, exports) {
          'use strict'
          var $at = require('./_string-at')(true)

          // 21.1.3.27 String.prototype[@@iterator]()
          require('./_iter-define')(
            String,
            'String',
            function(iterated) {
              this._t = String(iterated) // target
              this._i = 0 // next index
              // 21.1.5.2.1 %StringIteratorPrototype%.next()
            },
            function() {
              var O = this._t,
                index = this._i,
                point
              if (index >= O.length) return { value: undefined, done: true }
              point = $at(O, index)
              this._i += point.length
              return { value: point, done: false }
            }
          )
        },
        { './_iter-define': 183, './_string-at': 210 },
      ],
      232: [
        function(require, module, exports) {
          'use strict'
          // ECMAScript 6 symbols shim
          var global = require('./_global'),
            has = require('./_has'),
            DESCRIPTORS = require('./_descriptors'),
            $export = require('./_export'),
            redefine = require('./_redefine'),
            META = require('./_meta').KEY,
            $fails = require('./_fails'),
            shared = require('./_shared'),
            setToStringTag = require('./_set-to-string-tag'),
            uid = require('./_uid'),
            wks = require('./_wks'),
            wksExt = require('./_wks-ext'),
            wksDefine = require('./_wks-define'),
            keyOf = require('./_keyof'),
            enumKeys = require('./_enum-keys'),
            isArray = require('./_is-array'),
            anObject = require('./_an-object'),
            toIObject = require('./_to-iobject'),
            toPrimitive = require('./_to-primitive'),
            createDesc = require('./_property-desc'),
            _create = require('./_object-create'),
            gOPNExt = require('./_object-gopn-ext'),
            $GOPD = require('./_object-gopd'),
            $DP = require('./_object-dp'),
            $keys = require('./_object-keys'),
            gOPD = $GOPD.f,
            dP = $DP.f,
            gOPN = gOPNExt.f,
            $Symbol = global.Symbol,
            $JSON = global.JSON,
            _stringify = $JSON && $JSON.stringify,
            PROTOTYPE = 'prototype',
            HIDDEN = wks('_hidden'),
            TO_PRIMITIVE = wks('toPrimitive'),
            isEnum = {}.propertyIsEnumerable,
            SymbolRegistry = shared('symbol-registry'),
            AllSymbols = shared('symbols'),
            OPSymbols = shared('op-symbols'),
            ObjectProto = Object[PROTOTYPE],
            USE_NATIVE = typeof $Symbol == 'function',
            QObject = global.QObject
          // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
          var setter =
            !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild

          // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
          var setSymbolDesc = DESCRIPTORS &&
            $fails(function() {
              return (
                _create(
                  dP({}, 'a', {
                    get: function() {
                      return dP(this, 'a', { value: 7 }).a
                    },
                  })
                ).a != 7
              )
            })
            ? function(it, key, D) {
                var protoDesc = gOPD(ObjectProto, key)
                if (protoDesc) delete ObjectProto[key]
                dP(it, key, D)
                if (protoDesc && it !== ObjectProto)
                  dP(ObjectProto, key, protoDesc)
              }
            : dP

          var wrap = function(tag) {
            var sym = (AllSymbols[tag] = _create($Symbol[PROTOTYPE]))
            sym._k = tag
            return sym
          }

          var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol'
            ? function(it) {
                return typeof it == 'symbol'
              }
            : function(it) {
                return it instanceof $Symbol
              }

          var $defineProperty = function defineProperty(it, key, D) {
            if (it === ObjectProto) $defineProperty(OPSymbols, key, D)
            anObject(it)
            key = toPrimitive(key, true)
            anObject(D)
            if (has(AllSymbols, key)) {
              if (!D.enumerable) {
                if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}))
                it[HIDDEN][key] = true
              } else {
                if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false
                D = _create(D, { enumerable: createDesc(0, false) })
              }
              return setSymbolDesc(it, key, D)
            }
            return dP(it, key, D)
          }
          var $defineProperties = function defineProperties(it, P) {
            anObject(it)
            var keys = enumKeys((P = toIObject(P))),
              i = 0,
              l = keys.length,
              key
            while (l > i) $defineProperty(it, (key = keys[i++]), P[key])
            return it
          }
          var $create = function create(it, P) {
            return P === undefined
              ? _create(it)
              : $defineProperties(_create(it), P)
          }
          var $propertyIsEnumerable = function propertyIsEnumerable(key) {
            var E = isEnum.call(this, (key = toPrimitive(key, true)))
            if (
              this === ObjectProto &&
              has(AllSymbols, key) &&
              !has(OPSymbols, key)
            )
              return false
            return E ||
              !has(this, key) ||
              !has(AllSymbols, key) ||
              (has(this, HIDDEN) && this[HIDDEN][key])
              ? E
              : true
          }
          var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(
            it,
            key
          ) {
            it = toIObject(it)
            key = toPrimitive(key, true)
            if (
              it === ObjectProto &&
              has(AllSymbols, key) &&
              !has(OPSymbols, key)
            )
              return
            var D = gOPD(it, key)
            if (
              D &&
              has(AllSymbols, key) &&
              !(has(it, HIDDEN) && it[HIDDEN][key])
            )
              D.enumerable = true
            return D
          }
          var $getOwnPropertyNames = function getOwnPropertyNames(it) {
            var names = gOPN(toIObject(it)),
              result = [],
              i = 0,
              key
            while (names.length > i) {
              if (
                !has(AllSymbols, (key = names[i++])) &&
                key != HIDDEN &&
                key != META
              )
                result.push(key)
            }
            return result
          }
          var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
            var IS_OP = it === ObjectProto,
              names = gOPN(IS_OP ? OPSymbols : toIObject(it)),
              result = [],
              i = 0,
              key
            while (names.length > i) {
              if (
                has(AllSymbols, (key = names[i++])) &&
                (IS_OP ? has(ObjectProto, key) : true)
              )
                result.push(AllSymbols[key])
            }
            return result
          }

          // 19.4.1.1 Symbol([description])
          if (!USE_NATIVE) {
            $Symbol = function Symbol() {
              if (this instanceof $Symbol)
                throw TypeError('Symbol is not a constructor!')
              var tag = uid(arguments.length > 0 ? arguments[0] : undefined)
              var $set = function(value) {
                if (this === ObjectProto) $set.call(OPSymbols, value)
                if (has(this, HIDDEN) && has(this[HIDDEN], tag))
                  this[HIDDEN][tag] = false
                setSymbolDesc(this, tag, createDesc(1, value))
              }
              if (DESCRIPTORS && setter)
                setSymbolDesc(ObjectProto, tag, {
                  configurable: true,
                  set: $set,
                })
              return wrap(tag)
            }
            redefine($Symbol[PROTOTYPE], 'toString', function toString() {
              return this._k
            })

            $GOPD.f = $getOwnPropertyDescriptor
            $DP.f = $defineProperty
            require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames
            require('./_object-pie').f = $propertyIsEnumerable
            require('./_object-gops').f = $getOwnPropertySymbols

            if (DESCRIPTORS && !require('./_library')) {
              redefine(
                ObjectProto,
                'propertyIsEnumerable',
                $propertyIsEnumerable,
                true
              )
            }

            wksExt.f = function(name) {
              return wrap(wks(name))
            }
          }

          $export($export.G + $export.W + $export.F * !USE_NATIVE, {
            Symbol: $Symbol,
          })

          for (
            var symbols = 'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'.split(
              // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
              ','
            ),
              i = 0;
            symbols.length > i;

          )
            wks(symbols[i++])

          for (var symbols = $keys(wks.store), i = 0; symbols.length > i; )
            wksDefine(symbols[i++])

          $export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
            // 19.4.2.1 Symbol.for(key)
            for: function(key) {
              return has(SymbolRegistry, (key += ''))
                ? SymbolRegistry[key]
                : (SymbolRegistry[key] = $Symbol(key))
            },
            // 19.4.2.5 Symbol.keyFor(sym)
            keyFor: function keyFor(key) {
              if (isSymbol(key)) return keyOf(SymbolRegistry, key)
              throw TypeError(key + ' is not a symbol!')
            },
            useSetter: function() {
              setter = true
            },
            useSimple: function() {
              setter = false
            },
          })

          $export($export.S + $export.F * !USE_NATIVE, 'Object', {
            // 19.1.2.2 Object.create(O [, Properties])
            create: $create,
            // 19.1.2.4 Object.defineProperty(O, P, Attributes)
            defineProperty: $defineProperty,
            // 19.1.2.3 Object.defineProperties(O, Properties)
            defineProperties: $defineProperties,
            // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
            getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
            // 19.1.2.7 Object.getOwnPropertyNames(O)
            getOwnPropertyNames: $getOwnPropertyNames,
            // 19.1.2.8 Object.getOwnPropertySymbols(O)
            getOwnPropertySymbols: $getOwnPropertySymbols,
          })

          // 24.3.2 JSON.stringify(value [, replacer [, space]])
          $JSON &&
            $export(
              $export.S +
                $export.F *
                  (!USE_NATIVE ||
                    $fails(function() {
                      var S = $Symbol()
                      // MS Edge converts symbol values to JSON as {}
                      // WebKit converts symbol values to JSON as null
                      // V8 throws on boxed symbols
                      return (
                        _stringify([S]) != '[null]' ||
                        _stringify({ a: S }) != '{}' ||
                        _stringify(Object(S)) != '{}'
                      )
                    })),
              'JSON',
              {
                stringify: function stringify(it) {
                  if (it === undefined || isSymbol(it)) return // IE8 returns string on undefined
                  var args = [it],
                    i = 1,
                    replacer,
                    $replacer
                  while (arguments.length > i) args.push(arguments[i++])
                  replacer = args[1]
                  if (typeof replacer == 'function') $replacer = replacer
                  if ($replacer || !isArray(replacer))
                    replacer = function(key, value) {
                      if ($replacer) value = $replacer.call(this, key, value)
                      if (!isSymbol(value)) return value
                    }
                  args[1] = replacer
                  return _stringify.apply($JSON, args)
                },
              }
            )

          // 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
          $Symbol[PROTOTYPE][TO_PRIMITIVE] ||
            require('./_hide')(
              $Symbol[PROTOTYPE],
              TO_PRIMITIVE,
              $Symbol[PROTOTYPE].valueOf
            )
          // 19.4.3.5 Symbol.prototype[@@toStringTag]
          setToStringTag($Symbol, 'Symbol')
          // 20.2.1.9 Math[@@toStringTag]
          setToStringTag(Math, 'Math', true)
          // 24.3.3 JSON[@@toStringTag]
          setToStringTag(global.JSON, 'JSON', true)
        },
        {
          './_an-object': 150,
          './_descriptors': 165,
          './_enum-keys': 168,
          './_export': 169,
          './_fails': 170,
          './_global': 172,
          './_has': 173,
          './_hide': 174,
          './_is-array': 179,
          './_keyof': 186,
          './_library': 187,
          './_meta': 188,
          './_object-create': 190,
          './_object-dp': 191,
          './_object-gopd': 193,
          './_object-gopn': 195,
          './_object-gopn-ext': 194,
          './_object-gops': 196,
          './_object-keys': 199,
          './_object-pie': 200,
          './_property-desc': 202,
          './_redefine': 204,
          './_set-to-string-tag': 207,
          './_shared': 209,
          './_to-iobject': 213,
          './_to-primitive': 216,
          './_uid': 217,
          './_wks': 220,
          './_wks-define': 218,
          './_wks-ext': 219,
        },
      ],
      233: [
        function(require, module, exports) {
          'use strict'
          var each = require('./_array-methods')(0),
            redefine = require('./_redefine'),
            meta = require('./_meta'),
            assign = require('./_object-assign'),
            weak = require('./_collection-weak'),
            isObject = require('./_is-object'),
            getWeak = meta.getWeak,
            isExtensible = Object.isExtensible,
            uncaughtFrozenStore = weak.ufstore,
            tmp = {},
            InternalMap

          var wrapper = function(get) {
            return function WeakMap() {
              return get(this, arguments.length > 0 ? arguments[0] : undefined)
            }
          }

          var methods = {
            // 23.3.3.3 WeakMap.prototype.get(key)
            get: function get(key) {
              if (isObject(key)) {
                var data = getWeak(key)
                if (data === true) return uncaughtFrozenStore(this).get(key)
                return data ? data[this._i] : undefined
              }
            },
            // 23.3.3.5 WeakMap.prototype.set(key, value)
            set: function set(key, value) {
              return weak.def(this, key, value)
            },
          }

          // 23.3 WeakMap Objects
          var $WeakMap = (module.exports = require('./_collection')(
            'WeakMap',
            wrapper,
            methods,
            weak,
            true,
            true
          ))

          // IE11 WeakMap frozen keys fix
          if (
            new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7
          ) {
            InternalMap = weak.getConstructor(wrapper)
            assign(InternalMap.prototype, methods)
            meta.NEED = true
            each(['delete', 'has', 'get', 'set'], function(key) {
              var proto = $WeakMap.prototype,
                method = proto[key]
              redefine(proto, key, function(a, b) {
                // store frozen objects on internal weakmap shim
                if (isObject(a) && !isExtensible(a)) {
                  if (!this._f) this._f = new InternalMap()
                  var result = this._f[key](a, b)
                  return key == 'set' ? this : result
                  // store all the rest on native weakmap
                }
                return method.call(this, a, b)
              })
            })
          }
        },
        {
          './_array-methods': 153,
          './_collection': 161,
          './_collection-weak': 160,
          './_is-object': 180,
          './_meta': 188,
          './_object-assign': 189,
          './_redefine': 204,
        },
      ],
      234: [
        function(require, module, exports) {
          'use strict'
          var weak = require('./_collection-weak')

          // 23.4 WeakSet Objects
          require('./_collection')(
            'WeakSet',
            function(get) {
              return function WeakSet() {
                return get(
                  this,
                  arguments.length > 0 ? arguments[0] : undefined
                )
              }
            },
            {
              // 23.4.3.1 WeakSet.prototype.add(value)
              add: function add(value) {
                return weak.def(this, value, true)
              },
            },
            weak,
            false,
            true
          )
        },
        { './_collection': 161, './_collection-weak': 160 },
      ],
      235: [
        function(require, module, exports) {
          // https://github.com/DavidBruant/Map-Set.prototype.toJSON
          var $export = require('./_export')

          $export($export.P + $export.R, 'Map', {
            toJSON: require('./_collection-to-json')('Map'),
          })
        },
        { './_collection-to-json': 159, './_export': 169 },
      ],
      236: [
        function(require, module, exports) {
          require('./_wks-define')('asyncIterator')
        },
        { './_wks-define': 218 },
      ],
      237: [
        function(require, module, exports) {
          require('./_wks-define')('observable')
        },
        { './_wks-define': 218 },
      ],
      238: [
        function(require, module, exports) {
          require('./es6.array.iterator')
          var global = require('./_global'),
            hide = require('./_hide'),
            Iterators = require('./_iterators'),
            TO_STRING_TAG = require('./_wks')('toStringTag')

          for (
            var collections = [
              'NodeList',
              'DOMTokenList',
              'MediaList',
              'StyleSheetList',
              'CSSRuleList',
            ],
              i = 0;
            i < 5;
            i++
          ) {
            var NAME = collections[i],
              Collection = global[NAME],
              proto = Collection && Collection.prototype
            if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME)
            Iterators[NAME] = Iterators.Array
          }
        },
        {
          './_global': 172,
          './_hide': 174,
          './_iterators': 185,
          './_wks': 220,
          './es6.array.iterator': 223,
        },
      ],
      239: [
        function(require, module, exports) {
          module.exports = {
            aliceblue: '#f0f8ff',
            antiquewhite: '#faebd7',
            aqua: '#00ffff',
            aquamarine: '#7fffd4',
            azure: '#f0ffff',
            beige: '#f5f5dc',
            bisque: '#ffe4c4',
            black: '#000000',
            blanchedalmond: '#ffebcd',
            blue: '#0000ff',
            blueviolet: '#8a2be2',
            brown: '#a52a2a',
            burlywood: '#deb887',
            cadetblue: '#5f9ea0',
            chartreuse: '#7fff00',
            chocolate: '#d2691e',
            coral: '#ff7f50',
            cornflowerblue: '#6495ed',
            cornsilk: '#fff8dc',
            crimson: '#dc143c',
            cyan: '#00ffff',
            darkblue: '#00008b',
            darkcyan: '#008b8b',
            darkgoldenrod: '#b8860b',
            darkgray: '#a9a9a9',
            darkgreen: '#006400',
            darkgrey: '#a9a9a9',
            darkkhaki: '#bdb76b',
            darkmagenta: '#8b008b',
            darkolivegreen: '#556b2f',
            darkorange: '#ff8c00',
            darkorchid: '#9932cc',
            darkred: '#8b0000',
            darksalmon: '#e9967a',
            darkseagreen: '#8fbc8f',
            darkslateblue: '#483d8b',
            darkslategray: '#2f4f4f',
            darkslategrey: '#2f4f4f',
            darkturquoise: '#00ced1',
            darkviolet: '#9400d3',
            deeppink: '#ff1493',
            deepskyblue: '#00bfff',
            dimgray: '#696969',
            dimgrey: '#696969',
            dodgerblue: '#1e90ff',
            firebrick: '#b22222',
            floralwhite: '#fffaf0',
            forestgreen: '#228b22',
            fuchsia: '#ff00ff',
            gainsboro: '#dcdcdc',
            ghostwhite: '#f8f8ff',
            gold: '#ffd700',
            goldenrod: '#daa520',
            gray: '#808080',
            green: '#008000',
            greenyellow: '#adff2f',
            grey: '#808080',
            honeydew: '#f0fff0',
            hotpink: '#ff69b4',
            indianred: '#cd5c5c',
            indigo: '#4b0082',
            ivory: '#fffff0',
            khaki: '#f0e68c',
            lavender: '#e6e6fa',
            lavenderblush: '#fff0f5',
            lawngreen: '#7cfc00',
            lemonchiffon: '#fffacd',
            lightblue: '#add8e6',
            lightcoral: '#f08080',
            lightcyan: '#e0ffff',
            lightgoldenrodyellow: '#fafad2',
            lightgray: '#d3d3d3',
            lightgreen: '#90ee90',
            lightgrey: '#d3d3d3',
            lightpink: '#ffb6c1',
            lightsalmon: '#ffa07a',
            lightseagreen: '#20b2aa',
            lightskyblue: '#87cefa',
            lightslategray: '#778899',
            lightslategrey: '#778899',
            lightsteelblue: '#b0c4de',
            lightyellow: '#ffffe0',
            lime: '#00ff00',
            limegreen: '#32cd32',
            linen: '#faf0e6',
            magenta: '#ff00ff',
            maroon: '#800000',
            mediumaquamarine: '#66cdaa',
            mediumblue: '#0000cd',
            mediumorchid: '#ba55d3',
            mediumpurple: '#9370db',
            mediumseagreen: '#3cb371',
            mediumslateblue: '#7b68ee',
            mediumspringgreen: '#00fa9a',
            mediumturquoise: '#48d1cc',
            mediumvioletred: '#c71585',
            midnightblue: '#191970',
            mintcream: '#f5fffa',
            mistyrose: '#ffe4e1',
            moccasin: '#ffe4b5',
            navajowhite: '#ffdead',
            navy: '#000080',
            oldlace: '#fdf5e6',
            olive: '#808000',
            olivedrab: '#6b8e23',
            orange: '#ffa500',
            orangered: '#ff4500',
            orchid: '#da70d6',
            palegoldenrod: '#eee8aa',
            palegreen: '#98fb98',
            paleturquoise: '#afeeee',
            palevioletred: '#db7093',
            papayawhip: '#ffefd5',
            peachpuff: '#ffdab9',
            peru: '#cd853f',
            pink: '#ffc0cb',
            plum: '#dda0dd',
            powderblue: '#b0e0e6',
            purple: '#800080',
            rebeccapurple: '#663399',
            red: '#ff0000',
            rosybrown: '#bc8f8f',
            royalblue: '#4169e1',
            saddlebrown: '#8b4513',
            salmon: '#fa8072',
            sandybrown: '#f4a460',
            seagreen: '#2e8b57',
            seashell: '#fff5ee',
            sienna: '#a0522d',
            silver: '#c0c0c0',
            skyblue: '#87ceeb',
            slateblue: '#6a5acd',
            slategray: '#708090',
            slategrey: '#708090',
            snow: '#fffafa',
            springgreen: '#00ff7f',
            steelblue: '#4682b4',
            tan: '#d2b48c',
            teal: '#008080',
            thistle: '#d8bfd8',
            tomato: '#ff6347',
            turquoise: '#40e0d0',
            violet: '#ee82ee',
            wheat: '#f5deb3',
            white: '#ffffff',
            whitesmoke: '#f5f5f5',
            yellow: '#ffff00',
            yellowgreen: '#9acd32',
          }
        },
        {},
      ],
      240: [
        function(require, module, exports) {
          'use strict'
          module.exports = require('./w3c-css-properties')
        },
        { './w3c-css-properties': 241 },
      ],
      241: [
        function(require, module, exports) {
          module.exports = [
            'align-content',
            'align-items',
            'align-self',
            'all',
            'animation',
            'animation-delay',
            'animation-direction',
            'animation-duration',
            'animation-fill-mode',
            'animation-iteration-count',
            'animation-name',
            'animation-play-state',
            'animation-timing-function',
            'backface-visibility',
            'background',
            'background-attachment',
            'background-blend-mode',
            'background-clip',
            'background-color',
            'background-image',
            'background-origin',
            'background-position',
            'background-repeat',
            'background-size',
            'border',
            'border-bottom',
            'border-bottom-color',
            'border-bottom-left-radius',
            'border-bottom-right-radius',
            'border-bottom-style',
            'border-bottom-width',
            'border-collapse',
            'border-color',
            'border-image',
            'border-image-outset',
            'border-image-repeat',
            'border-image-slice',
            'border-image-source',
            'border-image-width',
            'border-left',
            'border-left-color',
            'border-left-style',
            'border-left-width',
            'border-radius',
            'border-right',
            'border-right-color',
            'border-right-style',
            'border-right-width',
            'border-spacing',
            'border-style',
            'border-top',
            'border-top-color',
            'border-top-left-radius',
            'border-top-right-radius',
            'border-top-style',
            'border-top-width',
            'border-width',
            'bottom',
            'box-shadow',
            'box-sizing',
            'caption-side',
            'clear',
            'clip',
            'color',
            'column-count',
            'column-fill',
            'column-gap',
            'column-rule',
            'column-rule-color',
            'column-rule-style',
            'column-rule-width',
            'column-span',
            'column-width',
            'columns',
            'content',
            'counter-increment',
            'counter-reset',
            'cursor',
            'direction',
            'display',
            'empty-cells',
            'filter',
            'flex',
            'flex-basis',
            'flex-direction',
            'flex-flow',
            'flex-grow',
            'flex-shrink',
            'flex-wrap',
            'float',
            'font',
            '@font-face',
            'font-family',
            'font-size',
            'font-size-adjust',
            'font-stretch',
            'font-style',
            'font-variant',
            'font-weight',
            'hanging-punctuation',
            'height',
            'justify-content',
            '@keyframes',
            'left',
            'letter-spacing',
            'line-height',
            'list-style',
            'list-style-image',
            'list-style-position',
            'list-style-type',
            'margin',
            'margin-bottom',
            'margin-left',
            'margin-right',
            'margin-top',
            'max-height',
            'max-width',
            '@media',
            'min-height',
            'min-width',
            'nav-down',
            'nav-index',
            'nav-left',
            'nav-right',
            'nav-up',
            'opacity',
            'order',
            'outline',
            'outline-color',
            'outline-offset',
            'outline-style',
            'outline-width',
            'overflow',
            'overflow-x',
            'overflow-y',
            'padding',
            'padding-bottom',
            'padding-left',
            'padding-right',
            'padding-top',
            'page-break-after',
            'page-break-before',
            'page-break-inside',
            'perspective',
            'perspective-origin',
            'position',
            'quotes',
            'resize',
            'right',
            'tab-size',
            'table-layout',
            'text-align',
            'text-align-last',
            'text-decoration',
            'text-decoration-color',
            'text-decoration-line',
            'text-decoration-style',
            'text-indent',
            'text-justify',
            'text-overflow',
            'text-shadow',
            'text-transform',
            'top',
            'transform',
            'transform-origin',
            'transform-style',
            'transition',
            'transition-delay',
            'transition-duration',
            'transition-property',
            'transition-timing-function',
            'unicode-bidi',
            'vertical-align',
            'visibility',
            'white-space',
            'width',
            'word-break',
            'word-spacing',
            'word-wrap',
            'z-index',
          ]
        },
        {},
      ],
      242: [
        function(require, module, exports) {
          module.exports = require('./src/node')
        },
        { './src/node': 245 },
      ],
      243: [
        function(require, module, exports) {
          ;(function(process) {
            /**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

            exports = module.exports = require('./debug')
            exports.log = log
            exports.formatArgs = formatArgs
            exports.save = save
            exports.load = load
            exports.useColors = useColors
            exports.storage = 'undefined' != typeof chrome &&
              'undefined' != typeof chrome.storage
              ? chrome.storage.local
              : localstorage()

            /**
 * Colors.
 */

            exports.colors = [
              'lightseagreen',
              'forestgreen',
              'goldenrod',
              'dodgerblue',
              'darkorchid',
              'crimson',
            ]

            /**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

            function useColors() {
              // NB: In an Electron preload script, document will be defined but not fully
              // initialized. Since we know we're in Chrome, we'll just detect this case
              // explicitly
              if (
                typeof window !== 'undefined' &&
                window &&
                typeof window.process !== 'undefined' &&
                window.process.type === 'renderer'
              ) {
                return true
              }

              // is webkit? http://stackoverflow.com/a/16459606/376773
              // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
              return (
                (typeof document !== 'undefined' &&
                  document &&
                  'WebkitAppearance' in document.documentElement.style) ||
                // is firebug? http://stackoverflow.com/a/398120/376773
                (typeof window !== 'undefined' &&
                  window &&
                  window.console &&
                  (console.firebug || (console.exception && console.table))) ||
                // is firefox >= v31?
                // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
                (typeof navigator !== 'undefined' &&
                  navigator &&
                  navigator.userAgent &&
                  navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) &&
                  parseInt(RegExp.$1, 10) >= 31) ||
                // double check webkit in userAgent just in case we are in a worker
                (typeof navigator !== 'undefined' &&
                  navigator &&
                  navigator.userAgent &&
                  navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
              )
            }

            /**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

            exports.formatters.j = function(v) {
              try {
                return JSON.stringify(v)
              } catch (err) {
                return '[UnexpectedJSONParseError]: ' + err.message
              }
            }

            /**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

            function formatArgs(args) {
              var useColors = this.useColors

              args[0] =
                (useColors ? '%c' : '') +
                this.namespace +
                (useColors ? ' %c' : ' ') +
                args[0] +
                (useColors ? '%c ' : ' ') +
                '+' +
                exports.humanize(this.diff)

              if (!useColors) return

              var c = 'color: ' + this.color
              args.splice(1, 0, c, 'color: inherit')

              // the final "%c" is somewhat tricky, because there could be other
              // arguments passed either before or after the %c, so we need to
              // figure out the correct index to insert the CSS into
              var index = 0
              var lastC = 0
              args[0].replace(/%[a-zA-Z%]/g, function(match) {
                if ('%%' === match) return
                index++
                if ('%c' === match) {
                  // we only are interested in the *last* %c
                  // (the user may have provided their own)
                  lastC = index
                }
              })

              args.splice(lastC, 0, c)
            }

            /**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

            function log() {
              // this hackery is required for IE8/9, where
              // the `console.log` function doesn't have 'apply'
              return (
                'object' === typeof console &&
                console.log &&
                Function.prototype.apply.call(console.log, console, arguments)
              )
            }

            /**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

            function save(namespaces) {
              try {
                if (null == namespaces) {
                  exports.storage.removeItem('debug')
                } else {
                  exports.storage.debug = namespaces
                }
              } catch (e) {}
            }

            /**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

            function load() {
              var r
              try {
                r = exports.storage.debug
              } catch (e) {}

              // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
              if (!r && typeof process !== 'undefined' && 'env' in process) {
                r = process.env.DEBUG
              }

              return r
            }

            /**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

            exports.enable(load())

            /**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

            function localstorage() {
              try {
                return window.localStorage
              } catch (e) {}
            }
          }.call(this, require('_process')))
        },
        { './debug': 244, _process: 507 },
      ],
      244: [
        function(require, module, exports) {
          /**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

          exports = module.exports = createDebug.debug = createDebug[
            'default'
          ] = createDebug
          exports.coerce = coerce
          exports.disable = disable
          exports.enable = enable
          exports.enabled = enabled
          exports.humanize = require('ms')

          /**
 * The currently active debug mode names, and names to skip.
 */

          exports.names = []
          exports.skips = []

          /**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

          exports.formatters = {}

          /**
 * Previous log timestamp.
 */

          var prevTime

          /**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

          function selectColor(namespace) {
            var hash = 0,
              i

            for (i in namespace) {
              hash = (hash << 5) - hash + namespace.charCodeAt(i)
              hash |= 0 // Convert to 32bit integer
            }

            return exports.colors[Math.abs(hash) % exports.colors.length]
          }

          /**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

          function createDebug(namespace) {
            function debug() {
              // disabled?
              if (!debug.enabled) return

              var self = debug

              // set `diff` timestamp
              var curr = +new Date()
              var ms = curr - (prevTime || curr)
              self.diff = ms
              self.prev = prevTime
              self.curr = curr
              prevTime = curr

              // turn the `arguments` into a proper Array
              var args = new Array(arguments.length)
              for (var i = 0; i < args.length; i++) {
                args[i] = arguments[i]
              }

              args[0] = exports.coerce(args[0])

              if ('string' !== typeof args[0]) {
                // anything else let's inspect with %O
                args.unshift('%O')
              }

              // apply any `formatters` transformations
              var index = 0
              args[0] = args[0].replace(/%([a-zA-Z%])/g, function(
                match,
                format
              ) {
                // if we encounter an escaped % then don't increase the array index
                if (match === '%%') return match
                index++
                var formatter = exports.formatters[format]
                if ('function' === typeof formatter) {
                  var val = args[index]
                  match = formatter.call(self, val)

                  // now we need to remove `args[index]` since it's inlined in the `format`
                  args.splice(index, 1)
                  index--
                }
                return match
              })

              // apply env-specific formatting (colors, etc.)
              exports.formatArgs.call(self, args)

              var logFn = debug.log || exports.log || console.log.bind(console)
              logFn.apply(self, args)
            }

            debug.namespace = namespace
            debug.enabled = exports.enabled(namespace)
            debug.useColors = exports.useColors()
            debug.color = selectColor(namespace)

            // env-specific initialization logic for debug instances
            if ('function' === typeof exports.init) {
              exports.init(debug)
            }

            return debug
          }

          /**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

          function enable(namespaces) {
            exports.save(namespaces)

            exports.names = []
            exports.skips = []

            var split = (typeof namespaces === 'string'
              ? namespaces
              : '').split(/[\s,]+/)
            var len = split.length

            for (var i = 0; i < len; i++) {
              if (!split[i]) continue // ignore empty strings
              namespaces = split[i].replace(/\*/g, '.*?')
              if (namespaces[0] === '-') {
                exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'))
              } else {
                exports.names.push(new RegExp('^' + namespaces + '$'))
              }
            }
          }

          /**
 * Disable debug output.
 *
 * @api public
 */

          function disable() {
            exports.enable('')
          }

          /**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

          function enabled(name) {
            var i, len
            for (i = 0, len = exports.skips.length; i < len; i++) {
              if (exports.skips[i].test(name)) {
                return false
              }
            }
            for (i = 0, len = exports.names.length; i < len; i++) {
              if (exports.names[i].test(name)) {
                return true
              }
            }
            return false
          }

          /**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

          function coerce(val) {
            if (val instanceof Error) return val.stack || val.message
            return val
          }
        },
        { ms: 503 },
      ],
      245: [
        function(require, module, exports) {
          ;(function(process) {
            /**
 * Module dependencies.
 */

            var tty = require('tty')
            var util = require('util')

            /**
 * This is the Node.js implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

            exports = module.exports = require('./debug')
            exports.init = init
            exports.log = log
            exports.formatArgs = formatArgs
            exports.save = save
            exports.load = load
            exports.useColors = useColors

            /**
 * Colors.
 */

            exports.colors = [6, 2, 3, 4, 5, 1]

            /**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

            exports.inspectOpts = Object.keys(process.env)
              .filter(function(key) {
                return /^debug_/i.test(key)
              })
              .reduce(function(obj, key) {
                // camel-case
                var prop = key
                  .substring(6)
                  .toLowerCase()
                  .replace(/_([a-z])/g, function(_, k) {
                    return k.toUpperCase()
                  })

                // coerce string value into JS value
                var val = process.env[key]
                if (/^(yes|on|true|enabled)$/i.test(val)) val = true
                else if (/^(no|off|false|disabled)$/i.test(val)) val = false
                else if (val === 'null') val = null
                else val = Number(val)

                obj[prop] = val
                return obj
              }, {})

            /**
 * The file descriptor to write the `debug()` calls to.
 * Set the `DEBUG_FD` env variable to override with another value. i.e.:
 *
 *   $ DEBUG_FD=3 node script.js 3>debug.log
 */

            var fd = parseInt(process.env.DEBUG_FD, 10) || 2

            if (1 !== fd && 2 !== fd) {
              util.deprecate(
                function() {},
                'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)'
              )()
            }

            var stream = 1 === fd
              ? process.stdout
              : 2 === fd ? process.stderr : createWritableStdioStream(fd)

            /**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

            function useColors() {
              return 'colors' in exports.inspectOpts
                ? Boolean(exports.inspectOpts.colors)
                : tty.isatty(fd)
            }

            /**
 * Map %o to `util.inspect()`, all on a single line.
 */

            exports.formatters.o = function(v) {
              this.inspectOpts.colors = this.useColors
              return util.inspect(v, this.inspectOpts).replace(/\s*\n\s*/g, ' ')
            }

            /**
 * Map %o to `util.inspect()`, allowing multiple lines if needed.
 */

            exports.formatters.O = function(v) {
              this.inspectOpts.colors = this.useColors
              return util.inspect(v, this.inspectOpts)
            }

            /**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

            function formatArgs(args) {
              var name = this.namespace
              var useColors = this.useColors

              if (useColors) {
                var c = this.color
                var prefix = '  \u001b[3' + c + ';1m' + name + ' ' + '\u001b[0m'

                args[0] = prefix + args[0].split('\n').join('\n' + prefix)
                args.push(
                  '\u001b[3' +
                    c +
                    'm+' +
                    exports.humanize(this.diff) +
                    '\u001b[0m'
                )
              } else {
                args[0] = new Date().toUTCString() + ' ' + name + ' ' + args[0]
              }
            }

            /**
 * Invokes `util.format()` with the specified arguments and writes to `stream`.
 */

            function log() {
              return stream.write(util.format.apply(util, arguments) + '\n')
            }

            /**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

            function save(namespaces) {
              if (null == namespaces) {
                // If you set a process.env field to null or undefined, it gets cast to the
                // string 'null' or 'undefined'. Just delete instead.
                delete process.env.DEBUG
              } else {
                process.env.DEBUG = namespaces
              }
            }

            /**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

            function load() {
              return process.env.DEBUG
            }

            /**
 * Copied from `node/src/node.js`.
 *
 * XXX: It's lame that node doesn't expose this API out-of-the-box. It also
 * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
 */

            function createWritableStdioStream(fd) {
              var stream
              var tty_wrap = process.binding('tty_wrap')

              // Note stream._type is used for test-module-load-list.js

              switch (tty_wrap.guessHandleType(fd)) {
                case 'TTY':
                  stream = new tty.WriteStream(fd)
                  stream._type = 'tty'

                  // Hack to have stream not keep the event loop alive.
                  // See https://github.com/joyent/node/issues/1726
                  if (stream._handle && stream._handle.unref) {
                    stream._handle.unref()
                  }
                  break

                case 'FILE':
                  var fs = require('fs')
                  stream = new fs.SyncWriteStream(fd, { autoClose: false })
                  stream._type = 'fs'
                  break

                case 'PIPE':
                case 'TCP':
                  var net = require('net')
                  stream = new net.Socket({
                    fd: fd,
                    readable: false,
                    writable: true,
                  })

                  // FIXME Should probably have an option in net.Socket to create a
                  // stream from an existing fd which is writable only. But for now
                  // we'll just add this hack and set the `readable` member to false.
                  // Test: ./node test/fixtures/echo.js < /etc/passwd
                  stream.readable = false
                  stream.read = null
                  stream._type = 'pipe'

                  // FIXME Hack to have stream not keep the event loop alive.
                  // See https://github.com/joyent/node/issues/1726
                  if (stream._handle && stream._handle.unref) {
                    stream._handle.unref()
                  }
                  break

                default:
                  // Probably an error on in uv_guess_handle()
                  throw new Error('Implement me. Unknown stream file type!')
              }

              // For supporting legacy API we put the FD here.
              stream.fd = fd

              stream._isStdio = true

              return stream
            }

            /**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

            function init(debug) {
              debug.inspectOpts = util._extend({}, exports.inspectOpts)
            }

            /**
 * Enable namespaces listed in `process.env.DEBUG` initially.
 */

            exports.enable(load())
          }.call(this, require('_process')))
        },
        {
          './debug': 244,
          _process: 507,
          fs: 118,
          net: 118,
          tty: 565,
          util: 568,
        },
      ],
      246: [
        function(require, module, exports) {
          /* eslint-disable guard-for-in */
          'use strict'
          var repeating = require('repeating')

          // detect either spaces or tabs but not both to properly handle tabs
          // for indentation and spaces for alignment
          var INDENT_RE = /^(?:( )+|\t+)/

          function getMostUsed(indents) {
            var result = 0
            var maxUsed = 0
            var maxWeight = 0

            for (var n in indents) {
              var indent = indents[n]
              var u = indent[0]
              var w = indent[1]

              if (u > maxUsed || (u === maxUsed && w > maxWeight)) {
                maxUsed = u
                maxWeight = w
                result = Number(n)
              }
            }

            return result
          }

          module.exports = function(str) {
            if (typeof str !== 'string') {
              throw new TypeError('Expected a string')
            }

            // used to see if tabs or spaces are the most used
            var tabs = 0
            var spaces = 0

            // remember the size of previous line's indentation
            var prev = 0

            // remember how many indents/unindents as occurred for a given size
            // and how much lines follow a given indentation
            //
            // indents = {
            //    3: [1, 0],
            //    4: [1, 5],
            //    5: [1, 0],
            //   12: [1, 0],
            // }
            var indents = {}

            // pointer to the array of last used indent
            var current

            // whether the last action was an indent (opposed to an unindent)
            var isIndent

            str.split(/\n/g).forEach(function(line) {
              if (!line) {
                // ignore empty lines
                return
              }

              var indent
              var matches = line.match(INDENT_RE)

              if (!matches) {
                indent = 0
              } else {
                indent = matches[0].length

                if (matches[1]) {
                  spaces++
                } else {
                  tabs++
                }
              }

              var diff = indent - prev
              prev = indent

              if (diff) {
                // an indent or unindent has been detected

                isIndent = diff > 0

                current = indents[isIndent ? diff : -diff]

                if (current) {
                  current[0]++
                } else {
                  current = indents[diff] = [1, 0]
                }
              } else if (current) {
                // if the last action was an indent, increment the weight
                current[1] += Number(isIndent)
              }
            })

            var amount = getMostUsed(indents)

            var type
            var actual
            if (!amount) {
              type = null
              actual = ''
            } else if (spaces >= tabs) {
              type = 'space'
              actual = repeating(' ', amount)
            } else {
              type = 'tab'
              actual = repeating('\t', amount)
            }

            return {
              amount: amount,
              type: type,
              indent: actual,
            }
          }
        },
        { repeating: 513 },
      ],
      247: [
        function(require, module, exports) {
          'use strict'
          var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g

          module.exports = function(str) {
            if (typeof str !== 'string') {
              throw new TypeError('Expected a string')
            }

            return str.replace(matchOperatorsRe, '\\$&')
          }
        },
        {},
      ],
      248: [
        function(require, module, exports) {
          /*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

          ;(function() {
            'use strict'
            function isExpression(node) {
              if (node == null) {
                return false
              }
              switch (node.type) {
                case 'ArrayExpression':
                case 'AssignmentExpression':
                case 'BinaryExpression':
                case 'CallExpression':
                case 'ConditionalExpression':
                case 'FunctionExpression':
                case 'Identifier':
                case 'Literal':
                case 'LogicalExpression':
                case 'MemberExpression':
                case 'NewExpression':
                case 'ObjectExpression':
                case 'SequenceExpression':
                case 'ThisExpression':
                case 'UnaryExpression':
                case 'UpdateExpression':
                  return true
              }
              return false
            }

            function isIterationStatement(node) {
              if (node == null) {
                return false
              }
              switch (node.type) {
                case 'DoWhileStatement':
                case 'ForInStatement':
                case 'ForStatement':
                case 'WhileStatement':
                  return true
              }
              return false
            }

            function isStatement(node) {
              if (node == null) {
                return false
              }
              switch (node.type) {
                case 'BlockStatement':
                case 'BreakStatement':
                case 'ContinueStatement':
                case 'DebuggerStatement':
                case 'DoWhileStatement':
                case 'EmptyStatement':
                case 'ExpressionStatement':
                case 'ForInStatement':
                case 'ForStatement':
                case 'IfStatement':
                case 'LabeledStatement':
                case 'ReturnStatement':
                case 'SwitchStatement':
                case 'ThrowStatement':
                case 'TryStatement':
                case 'VariableDeclaration':
                case 'WhileStatement':
                case 'WithStatement':
                  return true
              }
              return false
            }

            function isSourceElement(node) {
              return (
                isStatement(node) ||
                (node != null && node.type === 'FunctionDeclaration')
              )
            }

            function trailingStatement(node) {
              switch (node.type) {
                case 'IfStatement':
                  if (node.alternate != null) {
                    return node.alternate
                  }
                  return node.consequent

                case 'LabeledStatement':
                case 'ForStatement':
                case 'ForInStatement':
                case 'WhileStatement':
                case 'WithStatement':
                  return node.body
              }
              return null
            }

            function isProblematicIfStatement(node) {
              var current

              if (node.type !== 'IfStatement') {
                return false
              }
              if (node.alternate == null) {
                return false
              }
              current = node.consequent
              do {
                if (current.type === 'IfStatement') {
                  if (current.alternate == null) {
                    return true
                  }
                }
                current = trailingStatement(current)
              } while (current)

              return false
            }

            module.exports = {
              isExpression: isExpression,
              isStatement: isStatement,
              isIterationStatement: isIterationStatement,
              isSourceElement: isSourceElement,
              isProblematicIfStatement: isProblematicIfStatement,

              trailingStatement: trailingStatement,
            }
          })()
          /* vim: set sw=4 ts=4 et tw=80 : */
        },
        {},
      ],
      249: [
        function(require, module, exports) {
          /*
  Copyright (C) 2013-2014 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

          ;(function() {
            'use strict'
            var ES6Regex,
              ES5Regex,
              NON_ASCII_WHITESPACES,
              IDENTIFIER_START,
              IDENTIFIER_PART,
              ch

            // See `tools/generate-identifier-regex.js`.
            ES5Regex = {
              // ECMAScript 5.1/Unicode v7.0.0 NonAsciiIdentifierStart:
              NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
              // ECMAScript 5.1/Unicode v7.0.0 NonAsciiIdentifierPart:
              NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
            }

            ES6Regex = {
              // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierStart:
              NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/,
              // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierPart:
              NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDD0-\uDDDA\uDE00-\uDE11\uDE13-\uDE37\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF01-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/,
            }

            function isDecimalDigit(ch) {
              return 0x30 <= ch && ch <= 0x39 // 0..9
            }

            function isHexDigit(ch) {
              return (
                (0x30 <= ch && ch <= 0x39) || // 0..9
                (0x61 <= ch && ch <= 0x66) || // a..f
                (0x41 <= ch && ch <= 0x46)
              ) // A..F
            }

            function isOctalDigit(ch) {
              return ch >= 0x30 && ch <= 0x37 // 0..7
            }

            // 7.2 White Space

            NON_ASCII_WHITESPACES = [
              0x1680,
              0x180e,
              0x2000,
              0x2001,
              0x2002,
              0x2003,
              0x2004,
              0x2005,
              0x2006,
              0x2007,
              0x2008,
              0x2009,
              0x200a,
              0x202f,
              0x205f,
              0x3000,
              0xfeff,
            ]

            function isWhiteSpace(ch) {
              return (
                ch === 0x20 ||
                ch === 0x09 ||
                ch === 0x0b ||
                ch === 0x0c ||
                ch === 0xa0 ||
                (ch >= 0x1680 && NON_ASCII_WHITESPACES.indexOf(ch) >= 0)
              )
            }

            // 7.3 Line Terminators

            function isLineTerminator(ch) {
              return (
                ch === 0x0a || ch === 0x0d || ch === 0x2028 || ch === 0x2029
              )
            }

            // 7.6 Identifier Names and Identifiers

            function fromCodePoint(cp) {
              if (cp <= 0xffff) {
                return String.fromCharCode(cp)
              }
              var cu1 = String.fromCharCode(
                Math.floor((cp - 0x10000) / 0x400) + 0xd800
              )
              var cu2 = String.fromCharCode((cp - 0x10000) % 0x400 + 0xdc00)
              return cu1 + cu2
            }

            IDENTIFIER_START = new Array(0x80)
            for (ch = 0; ch < 0x80; ++ch) {
              IDENTIFIER_START[ch] =
                (ch >= 0x61 && ch <= 0x7a) || // a..z
                (ch >= 0x41 && ch <= 0x5a) || // A..Z
                ch === 0x24 ||
                ch === 0x5f // $ (dollar) and _ (underscore)
            }

            IDENTIFIER_PART = new Array(0x80)
            for (ch = 0; ch < 0x80; ++ch) {
              IDENTIFIER_PART[ch] =
                (ch >= 0x61 && ch <= 0x7a) || // a..z
                (ch >= 0x41 && ch <= 0x5a) || // A..Z
                (ch >= 0x30 && ch <= 0x39) || // 0..9
                ch === 0x24 ||
                ch === 0x5f // $ (dollar) and _ (underscore)
            }

            function isIdentifierStartES5(ch) {
              return ch < 0x80
                ? IDENTIFIER_START[ch]
                : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch))
            }

            function isIdentifierPartES5(ch) {
              return ch < 0x80
                ? IDENTIFIER_PART[ch]
                : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch))
            }

            function isIdentifierStartES6(ch) {
              return ch < 0x80
                ? IDENTIFIER_START[ch]
                : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch))
            }

            function isIdentifierPartES6(ch) {
              return ch < 0x80
                ? IDENTIFIER_PART[ch]
                : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch))
            }

            module.exports = {
              isDecimalDigit: isDecimalDigit,
              isHexDigit: isHexDigit,
              isOctalDigit: isOctalDigit,
              isWhiteSpace: isWhiteSpace,
              isLineTerminator: isLineTerminator,
              isIdentifierStartES5: isIdentifierStartES5,
              isIdentifierPartES5: isIdentifierPartES5,
              isIdentifierStartES6: isIdentifierStartES6,
              isIdentifierPartES6: isIdentifierPartES6,
            }
          })()
          /* vim: set sw=4 ts=4 et tw=80 : */
        },
        {},
      ],
      250: [
        function(require, module, exports) {
          /*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

          ;(function() {
            'use strict'
            var code = require('./code')

            function isStrictModeReservedWordES6(id) {
              switch (id) {
                case 'implements':
                case 'interface':
                case 'package':
                case 'private':
                case 'protected':
                case 'public':
                case 'static':
                case 'let':
                  return true
                default:
                  return false
              }
            }

            function isKeywordES5(id, strict) {
              // yield should not be treated as keyword under non-strict mode.
              if (!strict && id === 'yield') {
                return false
              }
              return isKeywordES6(id, strict)
            }

            function isKeywordES6(id, strict) {
              if (strict && isStrictModeReservedWordES6(id)) {
                return true
              }

              switch (id.length) {
                case 2:
                  return id === 'if' || id === 'in' || id === 'do'
                case 3:
                  return (
                    id === 'var' || id === 'for' || id === 'new' || id === 'try'
                  )
                case 4:
                  return (
                    id === 'this' ||
                    id === 'else' ||
                    id === 'case' ||
                    id === 'void' ||
                    id === 'with' ||
                    id === 'enum'
                  )
                case 5:
                  return (
                    id === 'while' ||
                    id === 'break' ||
                    id === 'catch' ||
                    id === 'throw' ||
                    id === 'const' ||
                    id === 'yield' ||
                    id === 'class' ||
                    id === 'super'
                  )
                case 6:
                  return (
                    id === 'return' ||
                    id === 'typeof' ||
                    id === 'delete' ||
                    id === 'switch' ||
                    id === 'export' ||
                    id === 'import'
                  )
                case 7:
                  return (
                    id === 'default' || id === 'finally' || id === 'extends'
                  )
                case 8:
                  return (
                    id === 'function' || id === 'continue' || id === 'debugger'
                  )
                case 10:
                  return id === 'instanceof'
                default:
                  return false
              }
            }

            function isReservedWordES5(id, strict) {
              return (
                id === 'null' ||
                id === 'true' ||
                id === 'false' ||
                isKeywordES5(id, strict)
              )
            }

            function isReservedWordES6(id, strict) {
              return (
                id === 'null' ||
                id === 'true' ||
                id === 'false' ||
                isKeywordES6(id, strict)
              )
            }

            function isRestrictedWord(id) {
              return id === 'eval' || id === 'arguments'
            }

            function isIdentifierNameES5(id) {
              var i, iz, ch

              if (id.length === 0) {
                return false
              }

              ch = id.charCodeAt(0)
              if (!code.isIdentifierStartES5(ch)) {
                return false
              }

              for (i = 1, iz = id.length; i < iz; ++i) {
                ch = id.charCodeAt(i)
                if (!code.isIdentifierPartES5(ch)) {
                  return false
                }
              }
              return true
            }

            function decodeUtf16(lead, trail) {
              return (lead - 0xd800) * 0x400 + (trail - 0xdc00) + 0x10000
            }

            function isIdentifierNameES6(id) {
              var i, iz, ch, lowCh, check

              if (id.length === 0) {
                return false
              }

              check = code.isIdentifierStartES6
              for (i = 0, iz = id.length; i < iz; ++i) {
                ch = id.charCodeAt(i)
                if (0xd800 <= ch && ch <= 0xdbff) {
                  ++i
                  if (i >= iz) {
                    return false
                  }
                  lowCh = id.charCodeAt(i)
                  if (!(0xdc00 <= lowCh && lowCh <= 0xdfff)) {
                    return false
                  }
                  ch = decodeUtf16(ch, lowCh)
                }
                if (!check(ch)) {
                  return false
                }
                check = code.isIdentifierPartES6
              }
              return true
            }

            function isIdentifierES5(id, strict) {
              return isIdentifierNameES5(id) && !isReservedWordES5(id, strict)
            }

            function isIdentifierES6(id, strict) {
              return isIdentifierNameES6(id) && !isReservedWordES6(id, strict)
            }

            module.exports = {
              isKeywordES5: isKeywordES5,
              isKeywordES6: isKeywordES6,
              isReservedWordES5: isReservedWordES5,
              isReservedWordES6: isReservedWordES6,
              isRestrictedWord: isRestrictedWord,
              isIdentifierNameES5: isIdentifierNameES5,
              isIdentifierNameES6: isIdentifierNameES6,
              isIdentifierES5: isIdentifierES5,
              isIdentifierES6: isIdentifierES6,
            }
          })()
          /* vim: set sw=4 ts=4 et tw=80 : */
        },
        { './code': 249 },
      ],
      251: [
        function(require, module, exports) {
          /*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

          ;(function() {
            'use strict'
            exports.ast = require('./ast')
            exports.code = require('./code')
            exports.keyword = require('./keyword')
          })()
          /* vim: set sw=4 ts=4 et tw=80 : */
        },
        { './ast': 248, './code': 249, './keyword': 250 },
      ],
      252: [
        function(require, module, exports) {
          'use strict'
          /**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

          var _hyphenPattern = /-(.)/g

          /**
 * Camelcases a hyphenated string, for example:
 *
 *   > camelize('background-color')
 *   < "backgroundColor"
 *
 * @param {string} string
 * @return {string}
 */
          function camelize(string) {
            return string.replace(_hyphenPattern, function(_, character) {
              return character.toUpperCase()
            })
          }

          module.exports = camelize
        },
        {},
      ],
      253: [
        function(require, module, exports) {
          /**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

          'use strict'
          var camelize = require('./camelize')

          var msPattern = /^-ms-/

          /**
 * Camelcases a hyphenated CSS property name, for example:
 *
 *   > camelizeStyleName('background-color')
 *   < "backgroundColor"
 *   > camelizeStyleName('-moz-transition')
 *   < "MozTransition"
 *   > camelizeStyleName('-ms-transition')
 *   < "msTransition"
 *
 * As Andi Smith suggests
 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
 * is converted to lowercase `ms`.
 *
 * @param {string} string
 * @return {string}
 */
          function camelizeStyleName(string) {
            return camelize(string.replace(msPattern, 'ms-'))
          }

          module.exports = camelizeStyleName
        },
        { './camelize': 252 },
      ],
      254: [
        function(require, module, exports) {
          'use strict'
          /**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

          function makeEmptyFunction(arg) {
            return function() {
              return arg
            }
          }

          /**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
          var emptyFunction = function emptyFunction() {}

          emptyFunction.thatReturns = makeEmptyFunction
          emptyFunction.thatReturnsFalse = makeEmptyFunction(false)
          emptyFunction.thatReturnsTrue = makeEmptyFunction(true)
          emptyFunction.thatReturnsNull = makeEmptyFunction(null)
          emptyFunction.thatReturnsThis = function() {
            return this
          }
          emptyFunction.thatReturnsArgument = function(arg) {
            return arg
          }

          module.exports = emptyFunction
        },
        {},
      ],
      255: [
        function(require, module, exports) {
          'use strict'
          /**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

          var _uppercasePattern = /([A-Z])/g

          /**
 * Hyphenates a camelcased string, for example:
 *
 *   > hyphenate('backgroundColor')
 *   < "background-color"
 *
 * For CSS style names, use `hyphenateStyleName` instead which works properly
 * with all vendor prefixes, including `ms`.
 *
 * @param {string} string
 * @return {string}
 */
          function hyphenate(string) {
            return string.replace(_uppercasePattern, '-$1').toLowerCase()
          }

          module.exports = hyphenate
        },
        {},
      ],
      256: [
        function(require, module, exports) {
          /**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

          'use strict'
          var hyphenate = require('./hyphenate')

          var msPattern = /^ms-/

          /**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 *
 * @param {string} string
 * @return {string}
 */
          function hyphenateStyleName(string) {
            return hyphenate(string).replace(msPattern, '-ms-')
          }

          module.exports = hyphenateStyleName
        },
        { './hyphenate': 255 },
      ],
      257: [
        function(require, module, exports) {
          ;(function(process) {
            /**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

            'use strict'
            /**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

            var validateFormat = function validateFormat(format) {}

            if (process.env.NODE_ENV !== 'production') {
              validateFormat = function validateFormat(format) {
                if (format === undefined) {
                  throw new Error(
                    'invariant requires an error message argument'
                  )
                }
              }
            }

            function invariant(condition, format, a, b, c, d, e, f) {
              validateFormat(format)

              if (!condition) {
                var error
                if (format === undefined) {
                  error = new Error(
                    'Minified exception occurred; use the non-minified dev environment ' +
                      'for the full error message and additional helpful warnings.'
                  )
                } else {
                  var args = [a, b, c, d, e, f]
                  var argIndex = 0
                  error = new Error(
                    format.replace(/%s/g, function() {
                      return args[argIndex++]
                    })
                  )
                  error.name = 'Invariant Violation'
                }

                error.framesToPop = 1 // we don't care about invariant's own frame
                throw error
              }
            }

            module.exports = invariant
          }.call(this, require('_process')))
        },
        { _process: 507 },
      ],
      258: [
        function(require, module, exports) {
          ;(function(process) {
            /**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

            'use strict'
            var emptyFunction = require('./emptyFunction')

            /**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

            var warning = emptyFunction

            if (process.env.NODE_ENV !== 'production') {
              ;(function() {
                var printWarning = function printWarning(format) {
                  for (
                    var _len = arguments.length,
                      args = Array(_len > 1 ? _len - 1 : 0),
                      _key = 1;
                    _key < _len;
                    _key++
                  ) {
                    args[_key - 1] = arguments[_key]
                  }

                  var argIndex = 0
                  var message =
                    'Warning: ' +
                    format.replace(/%s/g, function() {
                      return args[argIndex++]
                    })
                  if (typeof console !== 'undefined') {
                    console.error(message)
                  }
                  try {
                    // --- Welcome to debugging React ---
                    // This error was thrown as a convenience so that you can use this stack
                    // to find the callsite that caused this warning to fire.
                    throw new Error(message)
                  } catch (x) {}
                }

                warning = function warning(condition, format) {
                  if (format === undefined) {
                    throw new Error(
                      '`warning(condition, format, ...args)` requires a warning ' +
                        'message argument'
                    )
                  }

                  if (format.indexOf('Failed Composite propType: ') === 0) {
                    return // Ignore CompositeComponent proptype check.
                  }

                  if (!condition) {
                    for (
                      var _len2 = arguments.length,
                        args = Array(_len2 > 2 ? _len2 - 2 : 0),
                        _key2 = 2;
                      _key2 < _len2;
                      _key2++
                    ) {
                      args[_key2 - 2] = arguments[_key2]
                    }

                    printWarning.apply(undefined, [format].concat(args))
                  }
                }
              })()
            }

            module.exports = warning
          }.call(this, require('_process')))
        },
        { './emptyFunction': 254, _process: 507 },
      ],
      259: [
        function(require, module, exports) {
          module.exports = require('./lib/babel')
        },
        { './lib/babel': 260 },
      ],
      260: [
        function(require, module, exports) {
          'use strict'
          var _parseCSS = require('./parseCSS')

          var _parseCSS2 = _interopRequireDefault(_parseCSS)

          var _babylon = require('babylon')

          var babylon = _interopRequireWildcard(_babylon)

          var _touch = require('touch')

          var _touch2 = _interopRequireDefault(_touch)

          var _fs = require('fs')

          var _fs2 = _interopRequireDefault(_fs)

          var _hash4 = require('./hash')

          var _hash5 = _interopRequireDefault(_hash4)

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj
            } else {
              var newObj = {}
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key]
                }
              }
              newObj.default = obj
              return newObj
            }
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          function _toConsumableArray(arr) {
            if (Array.isArray(arr)) {
              for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
                arr2[i] = arr[i]
              }
              return arr2
            } else {
              return Array.from(arr)
            }
          }

          function getName(str) {
            var regex = /name\s*:\s*([A-Za-z0-9\-_]+)\s*/gm
            var match = regex.exec(str)
            if (match) {
              return match[1]
            }
          }

          function parser(path) {
            var code = path.hub.file.code
            var strs = path.node.quasi.quasis.map(function(x) {
              return x.value.cooked
            })
            var hash = (0, _hash5.default)([].concat(_toConsumableArray(strs))) // todo - add current filename?
            var name = getName(strs.join('xxx')) || 'css'

            var stubs = path.node.quasi.expressions.map(function(x) {
              return code.substring(x.start, x.end)
            })
            var ctr = 0

            var src = strs
              .reduce(function(arr, str, i) {
                arr.push(str)
                if (i !== stubs.length) {
                  // todo - test for preceding @apply
                  var applyMatch = /@apply\s*$/gm.exec(str)
                  if (applyMatch) {
                    arr.push('--' + name + '-' + hash + '-' + i)
                  } else arr.push('var(--' + name + '-' + hash + '-' + i + ')')
                }
                return arr
              }, [])
              .join('')
              .trim()
            var rules = (0, _parseCSS2.default)(
              '.' + name + '-' + hash + ' { ' + src + ' }'
            )
            var parsed = rules.join('\n')

            return { hash: hash, parsed: parsed, stubs: stubs, name: name }
          }

          function inline(path) {
            var code = path.hub.file.code
            var strs = path.node.quasi.quasis.map(function(x) {
              return x.value.cooked
            })
            var hash = (0, _hash5.default)([].concat(_toConsumableArray(strs))) // todo - add current filename?
            var name = getName(strs.join('xxx')) || 'css'

            var stubs = path.node.quasi.expressions.map(function(x) {
              return code.substring(x.start, x.end)
            })
            var ctr = 0

            var src = strs
              .reduce(function(arr, str, i) {
                arr.push(str)
                if (i !== stubs.length) {
                  // todo - test for preceding @apply
                  var applyMatch = /@apply\s*$/gm.exec(str)
                  if (applyMatch) {
                    arr.push('--' + name + '-' + hash + '-' + i)
                  } else arr.push('var(--' + name + '-' + hash + '-' + i + ')')
                }
                return arr
              }, [])
              .join('')
              .trim()

            var rules = (0, _parseCSS2.default)(
              '.' + name + '-' + hash + ' { ' + src + ' }'
            )
            rules = rules.map(function(rule) {
              return rule.replace(
                /@apply\s+--[A-Za-z0-9-_]+-([0-9]+)/gm,
                function(match, p1) {
                  return '${x' + p1 + '}'
                }
              )
            })
            rules = rules.map(function(rule) {
              return rule.replace(
                /var\(--[A-Za-z0-9-_]+-([0-9]+)\)/gm,
                function(match, p1) {
                  return '${x' + p1 + '}'
                }
              )
            })

            var parsed =
              '(' +
              stubs
                .map(function(x, i) {
                  return 'x' + i
                })
                .join(', ') +
              ') => [' +
              rules
                .map(function(x) {
                  return '`' + x + '`'
                })
                .join(',\n') +
              ']'
            return { hash: hash, parsed: parsed, stubs: stubs, name: name }
          }

          function fragment(path) {
            var code = path.hub.file.code
            var strs = path.node.quasi.quasis.map(function(x) {
              return x.value.cooked
            })
            var hash = (0, _hash5.default)([].concat(_toConsumableArray(strs))) // todo - add current filename?
            var name = getName(strs.join('xxx')) || 'frag'

            var stubs = path.node.quasi.expressions.map(function(x) {
              return code.substring(x.start, x.end)
            })
            var ctr = 0

            var src = strs
              .reduce(function(arr, str, i) {
                arr.push(str)
                if (i !== stubs.length) {
                  // todo - test for preceding @apply
                  var applyMatch = /@apply\s*$/gm.exec(str)
                  if (applyMatch) {
                    arr.push('--' + name + '-' + hash + '-' + i)
                  } else {
                    arr.push('var(--' + name + '-' + hash + '-' + i + ')')
                  }
                }
                return arr
              }, [])
              .join('')
              .trim()
            var rules = (0, _parseCSS2.default)(
              '.' +
                name +
                '-' +
                hash +
                ' { --' +
                name +
                '-' +
                hash +
                ': { ' +
                src +
                ' }; }',
              { nested: false }
            )
            var parsed = rules.join('\n')

            return { hash: hash, parsed: parsed, stubs: stubs, name: name }
          }

          function fragmentinline(path) {
            var code = path.hub.file.code
            var strs = path.node.quasi.quasis.map(function(x) {
              return x.value.cooked
            })
            var hash = (0, _hash5.default)([].concat(_toConsumableArray(strs))) // todo - add current filename?
            var name = getName(strs.join('xxx')) || 'frag'

            var stubs = path.node.quasi.expressions.map(function(x) {
              return code.substring(x.start, x.end)
            })
            var ctr = 0

            var src = strs
              .reduce(function(arr, str, i) {
                arr.push(str)
                if (i !== stubs.length) {
                  // todo - test for preceding @apply
                  var applyMatch = /@apply\s*$/gm.exec(str)
                  if (applyMatch) {
                    arr.push('--' + name + '-' + hash + '-' + i)
                  } else arr.push('var(--' + name + '-' + hash + '-' + i + ')')
                }
                return arr
              }, [])
              .join('')
              .trim()

            var rules = (0, _parseCSS2.default)(
              '.' + name + '-' + hash + ' { ' + src + ' }'
            )
            rules = rules.map(function(rule) {
              return rule.replace(
                /@apply\s+--[A-Za-z0-9-_]+-([0-9]+)/gm,
                function(match, p1) {
                  return '${x' + p1 + '}'
                }
              )
            })
            rules = rules.map(function(rule) {
              return rule.replace(
                /var\(--[A-Za-z0-9-_]+-([0-9]+)\)/gm,
                function(match, p1) {
                  return '${x' + p1 + '}'
                }
              )
            })

            var parsed =
              '(' +
              stubs
                .map(function(x, i) {
                  return 'x' + i
                })
                .join(', ') +
              ') => [' +
              rules
                .map(function(x) {
                  return '`' + x + '`'
                })
                .join(',\n') +
              ']'
            return { hash: hash, parsed: parsed, stubs: stubs, name: name }
          }

          module.exports = function(_ref) {
            var t = _ref.types

            return {
              visitor: {
                Program: {
                  enter: function enter(path, state) {
                    state.injected = false
                    var inserted = {}
                    state.toInsert = []
                    var file = path.hub.file.opts.filename
                    state.inject = function() {
                      if (!state.injected) {
                        state.injected = true

                        state.toInsert.push('/* do not edit this file */')

                        // let src = (state.opts.sync && !state.opts.inline) ?
                        //   `import './${require('path').basename(file) + '.css'}';` :
                        //   `import('./${require('path').basename(file) + '.css'}');`
                        // if(!state.opts.inline){
                        //   let impNode = babylon.parse(src, {sourceType: 'module', plugins: ['*']}).program.body[0]
                        //   path.node.body.unshift(impNode)
                        // }
                      }
                    }
                    state.insert = function(hash, css) {
                      if (!inserted[hash]) {
                        inserted[hash] = true
                        state.toInsert.push(css)
                      }
                    }
                  },
                  exit: function exit(path, state) {
                    var file = path.hub.file.opts.filename

                    var toWrite = state.toInsert.join('\n').trim()
                    if (
                      !state.opts.inline &&
                      state.injected &&
                      (_fs2.default.existsSync(file + '.css')
                        ? _fs2.default.readFileSync(file + '.css', 'utf8') !==
                            toWrite
                        : true)
                    ) {
                      if (!_fs2.default.existsSync(file + '.css')) {
                        _touch2.default.sync(file + '.css')
                      }

                      _fs2.default.writeFileSync(file + '.css', toWrite)
                    }
                  },
                },
                TaggedTemplateExpression: function TaggedTemplateExpression(
                  path,
                  state
                ) {
                  var tag = path.node.tag

                  var code = path.hub.file.code

                  if (tag.name === 'css') {
                    state.inject()

                    var newSrc = void 0

                    if (state.opts.inline) {
                      var _inline = inline(path),
                        hash = _inline.hash,
                        parsed = _inline.parsed,
                        stubs = _inline.stubs,
                        name = _inline.name

                      var cls = "'" + name + '-' + hash + "'"
                      var vars = '[' + stubs.join(', ') + ']'
                      newSrc = 'css(' + cls + ', ' + vars + ', ' + parsed + ')'
                    } else {
                      var _parser = parser(path),
                        _hash = _parser.hash,
                        _parsed = _parser.parsed,
                        _stubs = _parser.stubs,
                        _name = _parser.name

                      state.insert(_hash, _parsed)
                      var _cls = "'" + _name + '-' + _hash + "'"
                      var _vars = '[' + _stubs.join(', ') + ']'
                      newSrc = _stubs.length > 0
                        ? 'css(' + _cls + ', ' + _vars + ')'
                        : 'css(' + _cls + ')'
                    }

                    path.replaceWith(
                      babylon.parse(newSrc, { plugins: ['*'] }).program.body[0]
                        .expression
                    )
                  }
                  if (tag.name === 'fragment') {
                    state.inject()
                    var _newSrc = void 0
                    // fragment('frag-[hash]', vars, () => [``])
                    if (state.opts.inline) {
                      var _fragmentinline = fragmentinline(path),
                        _hash2 = _fragmentinline.hash,
                        _parsed2 = _fragmentinline.parsed,
                        _stubs2 = _fragmentinline.stubs,
                        _name2 = _fragmentinline.name

                      var _cls2 = "'" + _name2 + '-' + _hash2 + "'"
                      var _vars2 = '[' + _stubs2.join(', ') + ']'
                      _newSrc =
                        'fragment(' +
                        _cls2 +
                        ', ' +
                        _vars2 +
                        ', ' +
                        _parsed2 +
                        ')'
                    } else {
                      var _fragment = fragment(path, { name: 'frag' }),
                        _hash3 = _fragment.hash,
                        _parsed3 = _fragment.parsed,
                        _stubs3 = _fragment.stubs,
                        _name3 = _fragment.name

                      state.insert(_hash3, _parsed3)
                      var _cls3 = "'" + _name3 + '-' + _hash3 + "'"
                      var _vars3 = '[' + _stubs3.join(', ') + ']'
                      _newSrc = _stubs3.length > 0
                        ? 'fragment(' + _cls3 + ', ' + _vars3 + ')'
                        : 'fragment(' + _cls3 + ')'
                    }

                    path.replaceWith(
                      babylon.parse(_newSrc, { plugins: ['*'] }).program.body[0]
                        .expression
                    )
                  }
                },
              },
            }
          }
        },
        { './hash': 261, './parseCSS': 262, babylon: 114, fs: 118, touch: 563 },
      ],
      261: [
        function(require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', {
            value: true,
          })
          exports.default = hashArray
          exports.murmur2 = murmur2
          // murmurhash2 via https://gist.github.com/raycmorgan/588423

          function hashArray(arr) {
            var str = arr.join(',')
            return murmur2(str, str.length).toString(36)
          }

          function murmur2(str, seed) {
            var m = 0x5bd1e995
            var r = 24
            var h = seed ^ str.length
            var length = str.length
            var currentIndex = 0

            while (length >= 4) {
              var k = UInt32(str, currentIndex)

              k = Umul32(k, m)
              k ^= k >>> r
              k = Umul32(k, m)

              h = Umul32(h, m)
              h ^= k

              currentIndex += 4
              length -= 4
            }

            switch (length) {
              case 3:
                h ^= UInt16(str, currentIndex)
                h ^= str.charCodeAt(currentIndex + 2) << 16
                h = Umul32(h, m)
                break

              case 2:
                h ^= UInt16(str, currentIndex)
                h = Umul32(h, m)
                break

              case 1:
                h ^= str.charCodeAt(currentIndex)
                h = Umul32(h, m)
                break
            }

            h ^= h >>> 13
            h = Umul32(h, m)
            h ^= h >>> 15

            return h >>> 0
          }

          function UInt32(str, pos) {
            return (
              str.charCodeAt(pos++) +
              (str.charCodeAt(pos++) << 8) +
              (str.charCodeAt(pos++) << 16) +
              (str.charCodeAt(pos) << 24)
            )
          }

          function UInt16(str, pos) {
            return str.charCodeAt(pos++) + (str.charCodeAt(pos++) << 8)
          }

          function Umul32(n, m) {
            n = n | 0
            m = m | 0
            var nlo = n & 0xffff
            var nhi = n >>> 16
            var res = (nlo * m + (((nhi * m) & 0xffff) << 16)) | 0
            return res
          }
        },
        {},
      ],
      262: [
        function(require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', {
            value: true,
          })
          exports.default = parser

          var _parse = require('styled-components/lib/vendor/postcss-safe-parser/parse')

          var _parse2 = _interopRequireDefault(_parse)

          var _postcssNested = require('styled-components/lib/vendor/postcss-nested')

          var _postcssNested2 = _interopRequireDefault(_postcssNested)

          var _stringify = require('styled-components/lib/vendor/postcss/stringify')

          var _stringify2 = _interopRequireDefault(_stringify)

          var _autoprefix = require('styled-components/lib/utils/autoprefix')

          var _autoprefix2 = _interopRequireDefault(_autoprefix)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          function parser(css) {
            var options = arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : {}

            // todo - handle errors
            var root = (0, _parse2.default)(css)
            if (options.nested !== false) (0, _postcssNested2.default)(root)
            ;(0, _autoprefix2.default)(root)

            return root.nodes.map(function(node, i) {
              var str = ''
              ;(0, _stringify2.default)(node, function(x) {
                str += x
              })
              return str
            })
          }

          // todo -
          // select from http://cssnext.io/

          // import { parse } from 'postcss'
        },
        {
          'styled-components/lib/utils/autoprefix': 528,
          'styled-components/lib/vendor/postcss-nested': 529,
          'styled-components/lib/vendor/postcss-safe-parser/parse': 530,
          'styled-components/lib/vendor/postcss/stringify': 548,
        },
      ],
      263: [
        function(require, module, exports) {
          module.exports = {
            builtin: {
              Array: false,
              ArrayBuffer: false,
              Boolean: false,
              constructor: false,
              DataView: false,
              Date: false,
              decodeURI: false,
              decodeURIComponent: false,
              encodeURI: false,
              encodeURIComponent: false,
              Error: false,
              escape: false,
              eval: false,
              EvalError: false,
              Float32Array: false,
              Float64Array: false,
              Function: false,
              hasOwnProperty: false,
              Infinity: false,
              Int16Array: false,
              Int32Array: false,
              Int8Array: false,
              isFinite: false,
              isNaN: false,
              isPrototypeOf: false,
              JSON: false,
              Map: false,
              Math: false,
              NaN: false,
              Number: false,
              Object: false,
              parseFloat: false,
              parseInt: false,
              Promise: false,
              propertyIsEnumerable: false,
              Proxy: false,
              RangeError: false,
              ReferenceError: false,
              Reflect: false,
              RegExp: false,
              Set: false,
              String: false,
              Symbol: false,
              SyntaxError: false,
              System: false,
              toLocaleString: false,
              toString: false,
              TypeError: false,
              Uint16Array: false,
              Uint32Array: false,
              Uint8Array: false,
              Uint8ClampedArray: false,
              undefined: false,
              unescape: false,
              URIError: false,
              valueOf: false,
              WeakMap: false,
              WeakSet: false,
            },
            es5: {
              Array: false,
              Boolean: false,
              constructor: false,
              Date: false,
              decodeURI: false,
              decodeURIComponent: false,
              encodeURI: false,
              encodeURIComponent: false,
              Error: false,
              escape: false,
              eval: false,
              EvalError: false,
              Function: false,
              hasOwnProperty: false,
              Infinity: false,
              isFinite: false,
              isNaN: false,
              isPrototypeOf: false,
              JSON: false,
              Math: false,
              NaN: false,
              Number: false,
              Object: false,
              parseFloat: false,
              parseInt: false,
              propertyIsEnumerable: false,
              RangeError: false,
              ReferenceError: false,
              RegExp: false,
              String: false,
              SyntaxError: false,
              toLocaleString: false,
              toString: false,
              TypeError: false,
              undefined: false,
              unescape: false,
              URIError: false,
              valueOf: false,
            },
            es6: {
              Array: false,
              ArrayBuffer: false,
              Boolean: false,
              constructor: false,
              DataView: false,
              Date: false,
              decodeURI: false,
              decodeURIComponent: false,
              encodeURI: false,
              encodeURIComponent: false,
              Error: false,
              escape: false,
              eval: false,
              EvalError: false,
              Float32Array: false,
              Float64Array: false,
              Function: false,
              hasOwnProperty: false,
              Infinity: false,
              Int16Array: false,
              Int32Array: false,
              Int8Array: false,
              isFinite: false,
              isNaN: false,
              isPrototypeOf: false,
              JSON: false,
              Map: false,
              Math: false,
              NaN: false,
              Number: false,
              Object: false,
              parseFloat: false,
              parseInt: false,
              Promise: false,
              propertyIsEnumerable: false,
              Proxy: false,
              RangeError: false,
              ReferenceError: false,
              Reflect: false,
              RegExp: false,
              Set: false,
              String: false,
              Symbol: false,
              SyntaxError: false,
              System: false,
              toLocaleString: false,
              toString: false,
              TypeError: false,
              Uint16Array: false,
              Uint32Array: false,
              Uint8Array: false,
              Uint8ClampedArray: false,
              undefined: false,
              unescape: false,
              URIError: false,
              valueOf: false,
              WeakMap: false,
              WeakSet: false,
            },
            browser: {
              addEventListener: false,
              alert: false,
              AnalyserNode: false,
              Animation: false,
              AnimationEffectReadOnly: false,
              AnimationEffectTiming: false,
              AnimationEffectTimingReadOnly: false,
              AnimationEvent: false,
              AnimationPlaybackEvent: false,
              AnimationTimeline: false,
              applicationCache: false,
              ApplicationCache: false,
              ApplicationCacheErrorEvent: false,
              atob: false,
              Attr: false,
              Audio: false,
              AudioBuffer: false,
              AudioBufferSourceNode: false,
              AudioContext: false,
              AudioDestinationNode: false,
              AudioListener: false,
              AudioNode: false,
              AudioParam: false,
              AudioProcessingEvent: false,
              AutocompleteErrorEvent: false,
              BarProp: false,
              BatteryManager: false,
              BeforeUnloadEvent: false,
              BiquadFilterNode: false,
              Blob: false,
              blur: false,
              btoa: false,
              Cache: false,
              caches: false,
              CacheStorage: false,
              cancelAnimationFrame: false,
              CanvasGradient: false,
              CanvasPattern: false,
              CanvasRenderingContext2D: false,
              CDATASection: false,
              ChannelMergerNode: false,
              ChannelSplitterNode: false,
              CharacterData: false,
              clearInterval: false,
              clearTimeout: false,
              clientInformation: false,
              ClientRect: false,
              ClientRectList: false,
              ClipboardEvent: false,
              close: false,
              closed: false,
              CloseEvent: false,
              Comment: false,
              CompositionEvent: false,
              confirm: false,
              console: false,
              ConvolverNode: false,
              Credential: false,
              CredentialsContainer: false,
              crypto: false,
              Crypto: false,
              CryptoKey: false,
              CSS: false,
              CSSAnimation: false,
              CSSFontFaceRule: false,
              CSSImportRule: false,
              CSSKeyframeRule: false,
              CSSKeyframesRule: false,
              CSSMediaRule: false,
              CSSPageRule: false,
              CSSRule: false,
              CSSRuleList: false,
              CSSStyleDeclaration: false,
              CSSStyleRule: false,
              CSSStyleSheet: false,
              CSSSupportsRule: false,
              CSSTransition: false,
              CSSUnknownRule: false,
              CSSViewportRule: false,
              customElements: false,
              CustomEvent: false,
              DataTransfer: false,
              DataTransferItem: false,
              DataTransferItemList: false,
              Debug: false,
              defaultStatus: false,
              defaultstatus: false,
              DelayNode: false,
              DeviceMotionEvent: false,
              DeviceOrientationEvent: false,
              devicePixelRatio: false,
              dispatchEvent: false,
              document: false,
              Document: false,
              DocumentFragment: false,
              DocumentTimeline: false,
              DocumentType: false,
              DOMError: false,
              DOMException: false,
              DOMImplementation: false,
              DOMParser: false,
              DOMSettableTokenList: false,
              DOMStringList: false,
              DOMStringMap: false,
              DOMTokenList: false,
              DragEvent: false,
              DynamicsCompressorNode: false,
              Element: false,
              ElementTimeControl: false,
              ErrorEvent: false,
              event: false,
              Event: false,
              EventSource: false,
              EventTarget: false,
              external: false,
              FederatedCredential: false,
              fetch: false,
              File: false,
              FileError: false,
              FileList: false,
              FileReader: false,
              find: false,
              focus: false,
              FocusEvent: false,
              FontFace: false,
              FormData: false,
              frameElement: false,
              frames: false,
              GainNode: false,
              Gamepad: false,
              GamepadButton: false,
              GamepadEvent: false,
              getComputedStyle: false,
              getSelection: false,
              HashChangeEvent: false,
              Headers: false,
              history: false,
              History: false,
              HTMLAllCollection: false,
              HTMLAnchorElement: false,
              HTMLAppletElement: false,
              HTMLAreaElement: false,
              HTMLAudioElement: false,
              HTMLBaseElement: false,
              HTMLBlockquoteElement: false,
              HTMLBodyElement: false,
              HTMLBRElement: false,
              HTMLButtonElement: false,
              HTMLCanvasElement: false,
              HTMLCollection: false,
              HTMLContentElement: false,
              HTMLDataListElement: false,
              HTMLDetailsElement: false,
              HTMLDialogElement: false,
              HTMLDirectoryElement: false,
              HTMLDivElement: false,
              HTMLDListElement: false,
              HTMLDocument: false,
              HTMLElement: false,
              HTMLEmbedElement: false,
              HTMLFieldSetElement: false,
              HTMLFontElement: false,
              HTMLFormControlsCollection: false,
              HTMLFormElement: false,
              HTMLFrameElement: false,
              HTMLFrameSetElement: false,
              HTMLHeadElement: false,
              HTMLHeadingElement: false,
              HTMLHRElement: false,
              HTMLHtmlElement: false,
              HTMLIFrameElement: false,
              HTMLImageElement: false,
              HTMLInputElement: false,
              HTMLIsIndexElement: false,
              HTMLKeygenElement: false,
              HTMLLabelElement: false,
              HTMLLayerElement: false,
              HTMLLegendElement: false,
              HTMLLIElement: false,
              HTMLLinkElement: false,
              HTMLMapElement: false,
              HTMLMarqueeElement: false,
              HTMLMediaElement: false,
              HTMLMenuElement: false,
              HTMLMetaElement: false,
              HTMLMeterElement: false,
              HTMLModElement: false,
              HTMLObjectElement: false,
              HTMLOListElement: false,
              HTMLOptGroupElement: false,
              HTMLOptionElement: false,
              HTMLOptionsCollection: false,
              HTMLOutputElement: false,
              HTMLParagraphElement: false,
              HTMLParamElement: false,
              HTMLPictureElement: false,
              HTMLPreElement: false,
              HTMLProgressElement: false,
              HTMLQuoteElement: false,
              HTMLScriptElement: false,
              HTMLSelectElement: false,
              HTMLShadowElement: false,
              HTMLSourceElement: false,
              HTMLSpanElement: false,
              HTMLStyleElement: false,
              HTMLTableCaptionElement: false,
              HTMLTableCellElement: false,
              HTMLTableColElement: false,
              HTMLTableElement: false,
              HTMLTableRowElement: false,
              HTMLTableSectionElement: false,
              HTMLTemplateElement: false,
              HTMLTextAreaElement: false,
              HTMLTitleElement: false,
              HTMLTrackElement: false,
              HTMLUListElement: false,
              HTMLUnknownElement: false,
              HTMLVideoElement: false,
              IDBCursor: false,
              IDBCursorWithValue: false,
              IDBDatabase: false,
              IDBEnvironment: false,
              IDBFactory: false,
              IDBIndex: false,
              IDBKeyRange: false,
              IDBObjectStore: false,
              IDBOpenDBRequest: false,
              IDBRequest: false,
              IDBTransaction: false,
              IDBVersionChangeEvent: false,
              Image: false,
              ImageBitmap: false,
              ImageData: false,
              indexedDB: false,
              innerHeight: false,
              innerWidth: false,
              InputEvent: false,
              InputMethodContext: false,
              IntersectionObserver: false,
              IntersectionObserverEntry: false,
              Intl: false,
              KeyboardEvent: false,
              KeyframeEffect: false,
              KeyframeEffectReadOnly: false,
              length: false,
              localStorage: false,
              location: false,
              Location: false,
              locationbar: false,
              matchMedia: false,
              MediaElementAudioSourceNode: false,
              MediaEncryptedEvent: false,
              MediaError: false,
              MediaKeyError: false,
              MediaKeyEvent: false,
              MediaKeyMessageEvent: false,
              MediaKeys: false,
              MediaKeySession: false,
              MediaKeyStatusMap: false,
              MediaKeySystemAccess: false,
              MediaList: false,
              MediaQueryList: false,
              MediaQueryListEvent: false,
              MediaSource: false,
              MediaRecorder: false,
              MediaStream: false,
              MediaStreamAudioDestinationNode: false,
              MediaStreamAudioSourceNode: false,
              MediaStreamEvent: false,
              MediaStreamTrack: false,
              menubar: false,
              MessageChannel: false,
              MessageEvent: false,
              MessagePort: false,
              MIDIAccess: false,
              MIDIConnectionEvent: false,
              MIDIInput: false,
              MIDIInputMap: false,
              MIDIMessageEvent: false,
              MIDIOutput: false,
              MIDIOutputMap: false,
              MIDIPort: false,
              MimeType: false,
              MimeTypeArray: false,
              MouseEvent: false,
              moveBy: false,
              moveTo: false,
              MutationEvent: false,
              MutationObserver: false,
              MutationRecord: false,
              name: false,
              NamedNodeMap: false,
              navigator: false,
              Navigator: false,
              Node: false,
              NodeFilter: false,
              NodeIterator: false,
              NodeList: false,
              Notification: false,
              OfflineAudioCompletionEvent: false,
              OfflineAudioContext: false,
              offscreenBuffering: false,
              onbeforeunload: true,
              onblur: true,
              onerror: true,
              onfocus: true,
              onload: true,
              onresize: true,
              onunload: true,
              open: false,
              openDatabase: false,
              opener: false,
              opera: false,
              Option: false,
              OscillatorNode: false,
              outerHeight: false,
              outerWidth: false,
              PageTransitionEvent: false,
              pageXOffset: false,
              pageYOffset: false,
              parent: false,
              PasswordCredential: false,
              Path2D: false,
              performance: false,
              Performance: false,
              PerformanceEntry: false,
              PerformanceMark: false,
              PerformanceMeasure: false,
              PerformanceNavigation: false,
              PerformanceResourceTiming: false,
              PerformanceTiming: false,
              PeriodicWave: false,
              Permissions: false,
              PermissionStatus: false,
              personalbar: false,
              Plugin: false,
              PluginArray: false,
              PopStateEvent: false,
              postMessage: false,
              print: false,
              ProcessingInstruction: false,
              ProgressEvent: false,
              PromiseRejectionEvent: false,
              prompt: false,
              PushManager: false,
              PushSubscription: false,
              RadioNodeList: false,
              Range: false,
              ReadableByteStream: false,
              ReadableStream: false,
              removeEventListener: false,
              Request: false,
              requestAnimationFrame: false,
              requestIdleCallback: false,
              resizeBy: false,
              resizeTo: false,
              Response: false,
              RTCIceCandidate: false,
              RTCSessionDescription: false,
              RTCPeerConnection: false,
              screen: false,
              Screen: false,
              screenLeft: false,
              ScreenOrientation: false,
              screenTop: false,
              screenX: false,
              screenY: false,
              ScriptProcessorNode: false,
              scroll: false,
              scrollbars: false,
              scrollBy: false,
              scrollTo: false,
              scrollX: false,
              scrollY: false,
              SecurityPolicyViolationEvent: false,
              Selection: false,
              self: false,
              ServiceWorker: false,
              ServiceWorkerContainer: false,
              ServiceWorkerRegistration: false,
              sessionStorage: false,
              setInterval: false,
              setTimeout: false,
              ShadowRoot: false,
              SharedKeyframeList: false,
              SharedWorker: false,
              showModalDialog: false,
              SiteBoundCredential: false,
              speechSynthesis: false,
              SpeechSynthesisEvent: false,
              SpeechSynthesisUtterance: false,
              status: false,
              statusbar: false,
              stop: false,
              Storage: false,
              StorageEvent: false,
              styleMedia: false,
              StyleSheet: false,
              StyleSheetList: false,
              SubtleCrypto: false,
              SVGAElement: false,
              SVGAltGlyphDefElement: false,
              SVGAltGlyphElement: false,
              SVGAltGlyphItemElement: false,
              SVGAngle: false,
              SVGAnimateColorElement: false,
              SVGAnimatedAngle: false,
              SVGAnimatedBoolean: false,
              SVGAnimatedEnumeration: false,
              SVGAnimatedInteger: false,
              SVGAnimatedLength: false,
              SVGAnimatedLengthList: false,
              SVGAnimatedNumber: false,
              SVGAnimatedNumberList: false,
              SVGAnimatedPathData: false,
              SVGAnimatedPoints: false,
              SVGAnimatedPreserveAspectRatio: false,
              SVGAnimatedRect: false,
              SVGAnimatedString: false,
              SVGAnimatedTransformList: false,
              SVGAnimateElement: false,
              SVGAnimateMotionElement: false,
              SVGAnimateTransformElement: false,
              SVGAnimationElement: false,
              SVGCircleElement: false,
              SVGClipPathElement: false,
              SVGColor: false,
              SVGColorProfileElement: false,
              SVGColorProfileRule: false,
              SVGComponentTransferFunctionElement: false,
              SVGCSSRule: false,
              SVGCursorElement: false,
              SVGDefsElement: false,
              SVGDescElement: false,
              SVGDiscardElement: false,
              SVGDocument: false,
              SVGElement: false,
              SVGElementInstance: false,
              SVGElementInstanceList: false,
              SVGEllipseElement: false,
              SVGEvent: false,
              SVGExternalResourcesRequired: false,
              SVGFEBlendElement: false,
              SVGFEColorMatrixElement: false,
              SVGFEComponentTransferElement: false,
              SVGFECompositeElement: false,
              SVGFEConvolveMatrixElement: false,
              SVGFEDiffuseLightingElement: false,
              SVGFEDisplacementMapElement: false,
              SVGFEDistantLightElement: false,
              SVGFEDropShadowElement: false,
              SVGFEFloodElement: false,
              SVGFEFuncAElement: false,
              SVGFEFuncBElement: false,
              SVGFEFuncGElement: false,
              SVGFEFuncRElement: false,
              SVGFEGaussianBlurElement: false,
              SVGFEImageElement: false,
              SVGFEMergeElement: false,
              SVGFEMergeNodeElement: false,
              SVGFEMorphologyElement: false,
              SVGFEOffsetElement: false,
              SVGFEPointLightElement: false,
              SVGFESpecularLightingElement: false,
              SVGFESpotLightElement: false,
              SVGFETileElement: false,
              SVGFETurbulenceElement: false,
              SVGFilterElement: false,
              SVGFilterPrimitiveStandardAttributes: false,
              SVGFitToViewBox: false,
              SVGFontElement: false,
              SVGFontFaceElement: false,
              SVGFontFaceFormatElement: false,
              SVGFontFaceNameElement: false,
              SVGFontFaceSrcElement: false,
              SVGFontFaceUriElement: false,
              SVGForeignObjectElement: false,
              SVGGElement: false,
              SVGGeometryElement: false,
              SVGGlyphElement: false,
              SVGGlyphRefElement: false,
              SVGGradientElement: false,
              SVGGraphicsElement: false,
              SVGHKernElement: false,
              SVGICCColor: false,
              SVGImageElement: false,
              SVGLangSpace: false,
              SVGLength: false,
              SVGLengthList: false,
              SVGLinearGradientElement: false,
              SVGLineElement: false,
              SVGLocatable: false,
              SVGMarkerElement: false,
              SVGMaskElement: false,
              SVGMatrix: false,
              SVGMetadataElement: false,
              SVGMissingGlyphElement: false,
              SVGMPathElement: false,
              SVGNumber: false,
              SVGNumberList: false,
              SVGPaint: false,
              SVGPathElement: false,
              SVGPathSeg: false,
              SVGPathSegArcAbs: false,
              SVGPathSegArcRel: false,
              SVGPathSegClosePath: false,
              SVGPathSegCurvetoCubicAbs: false,
              SVGPathSegCurvetoCubicRel: false,
              SVGPathSegCurvetoCubicSmoothAbs: false,
              SVGPathSegCurvetoCubicSmoothRel: false,
              SVGPathSegCurvetoQuadraticAbs: false,
              SVGPathSegCurvetoQuadraticRel: false,
              SVGPathSegCurvetoQuadraticSmoothAbs: false,
              SVGPathSegCurvetoQuadraticSmoothRel: false,
              SVGPathSegLinetoAbs: false,
              SVGPathSegLinetoHorizontalAbs: false,
              SVGPathSegLinetoHorizontalRel: false,
              SVGPathSegLinetoRel: false,
              SVGPathSegLinetoVerticalAbs: false,
              SVGPathSegLinetoVerticalRel: false,
              SVGPathSegList: false,
              SVGPathSegMovetoAbs: false,
              SVGPathSegMovetoRel: false,
              SVGPatternElement: false,
              SVGPoint: false,
              SVGPointList: false,
              SVGPolygonElement: false,
              SVGPolylineElement: false,
              SVGPreserveAspectRatio: false,
              SVGRadialGradientElement: false,
              SVGRect: false,
              SVGRectElement: false,
              SVGRenderingIntent: false,
              SVGScriptElement: false,
              SVGSetElement: false,
              SVGStopElement: false,
              SVGStringList: false,
              SVGStylable: false,
              SVGStyleElement: false,
              SVGSVGElement: false,
              SVGSwitchElement: false,
              SVGSymbolElement: false,
              SVGTests: false,
              SVGTextContentElement: false,
              SVGTextElement: false,
              SVGTextPathElement: false,
              SVGTextPositioningElement: false,
              SVGTitleElement: false,
              SVGTransform: false,
              SVGTransformable: false,
              SVGTransformList: false,
              SVGTRefElement: false,
              SVGTSpanElement: false,
              SVGUnitTypes: false,
              SVGURIReference: false,
              SVGUseElement: false,
              SVGViewElement: false,
              SVGViewSpec: false,
              SVGVKernElement: false,
              SVGZoomAndPan: false,
              SVGZoomEvent: false,
              Text: false,
              TextDecoder: false,
              TextEncoder: false,
              TextEvent: false,
              TextMetrics: false,
              TextTrack: false,
              TextTrackCue: false,
              TextTrackCueList: false,
              TextTrackList: false,
              TimeEvent: false,
              TimeRanges: false,
              toolbar: false,
              top: false,
              Touch: false,
              TouchEvent: false,
              TouchList: false,
              TrackEvent: false,
              TransitionEvent: false,
              TreeWalker: false,
              UIEvent: false,
              URL: false,
              URLSearchParams: false,
              ValidityState: false,
              VTTCue: false,
              WaveShaperNode: false,
              WebGLActiveInfo: false,
              WebGLBuffer: false,
              WebGLContextEvent: false,
              WebGLFramebuffer: false,
              WebGLProgram: false,
              WebGLRenderbuffer: false,
              WebGLRenderingContext: false,
              WebGLShader: false,
              WebGLShaderPrecisionFormat: false,
              WebGLTexture: false,
              WebGLUniformLocation: false,
              WebSocket: false,
              WheelEvent: false,
              window: false,
              Window: false,
              Worker: false,
              XDomainRequest: false,
              XMLDocument: false,
              XMLHttpRequest: false,
              XMLHttpRequestEventTarget: false,
              XMLHttpRequestProgressEvent: false,
              XMLHttpRequestUpload: false,
              XMLSerializer: false,
              XPathEvaluator: false,
              XPathException: false,
              XPathExpression: false,
              XPathNamespace: false,
              XPathNSResolver: false,
              XPathResult: false,
              XSLTProcessor: false,
            },
            worker: {
              applicationCache: false,
              atob: false,
              Blob: false,
              BroadcastChannel: false,
              btoa: false,
              Cache: false,
              caches: false,
              clearInterval: false,
              clearTimeout: false,
              close: true,
              console: false,
              fetch: false,
              FileReaderSync: false,
              FormData: false,
              Headers: false,
              IDBCursor: false,
              IDBCursorWithValue: false,
              IDBDatabase: false,
              IDBFactory: false,
              IDBIndex: false,
              IDBKeyRange: false,
              IDBObjectStore: false,
              IDBOpenDBRequest: false,
              IDBRequest: false,
              IDBTransaction: false,
              IDBVersionChangeEvent: false,
              ImageData: false,
              importScripts: true,
              indexedDB: false,
              location: false,
              MessageChannel: false,
              MessagePort: false,
              name: false,
              navigator: false,
              Notification: false,
              onclose: true,
              onconnect: true,
              onerror: true,
              onlanguagechange: true,
              onmessage: true,
              onoffline: true,
              ononline: true,
              onrejectionhandled: true,
              onunhandledrejection: true,
              performance: false,
              Performance: false,
              PerformanceEntry: false,
              PerformanceMark: false,
              PerformanceMeasure: false,
              PerformanceNavigation: false,
              PerformanceResourceTiming: false,
              PerformanceTiming: false,
              postMessage: true,
              Promise: false,
              Request: false,
              Response: false,
              self: true,
              ServiceWorkerRegistration: false,
              setInterval: false,
              setTimeout: false,
              TextDecoder: false,
              TextEncoder: false,
              URL: false,
              URLSearchParams: false,
              WebSocket: false,
              Worker: false,
              XMLHttpRequest: false,
            },
            node: {
              __dirname: false,
              __filename: false,
              arguments: false,
              Buffer: false,
              clearImmediate: false,
              clearInterval: false,
              clearTimeout: false,
              console: false,
              exports: true,
              GLOBAL: false,
              global: false,
              Intl: false,
              module: false,
              process: false,
              require: false,
              root: false,
              setImmediate: false,
              setInterval: false,
              setTimeout: false,
            },
            commonjs: {
              exports: true,
              module: false,
              require: false,
              global: false,
            },
            amd: {
              define: false,
              require: false,
            },
            mocha: {
              after: false,
              afterEach: false,
              before: false,
              beforeEach: false,
              context: false,
              describe: false,
              it: false,
              mocha: false,
              run: false,
              setup: false,
              specify: false,
              suite: false,
              suiteSetup: false,
              suiteTeardown: false,
              teardown: false,
              test: false,
              xcontext: false,
              xdescribe: false,
              xit: false,
              xspecify: false,
            },
            jasmine: {
              afterAll: false,
              afterEach: false,
              beforeAll: false,
              beforeEach: false,
              describe: false,
              expect: false,
              fail: false,
              fdescribe: false,
              fit: false,
              it: false,
              jasmine: false,
              pending: false,
              runs: false,
              spyOn: false,
              waits: false,
              waitsFor: false,
              xdescribe: false,
              xit: false,
            },
            jest: {
              afterAll: false,
              afterEach: false,
              beforeAll: false,
              beforeEach: false,
              check: false,
              describe: false,
              expect: false,
              gen: false,
              it: false,
              fdescribe: false,
              fit: false,
              jest: false,
              pit: false,
              require: false,
              test: false,
              xdescribe: false,
              xit: false,
              xtest: false,
            },
            qunit: {
              asyncTest: false,
              deepEqual: false,
              equal: false,
              expect: false,
              module: false,
              notDeepEqual: false,
              notEqual: false,
              notOk: false,
              notPropEqual: false,
              notStrictEqual: false,
              ok: false,
              propEqual: false,
              QUnit: false,
              raises: false,
              start: false,
              stop: false,
              strictEqual: false,
              test: false,
              throws: false,
            },
            phantomjs: {
              console: true,
              exports: true,
              phantom: true,
              require: true,
              WebPage: true,
            },
            couch: {
              emit: false,
              exports: false,
              getRow: false,
              log: false,
              module: false,
              provides: false,
              require: false,
              respond: false,
              send: false,
              start: false,
              sum: false,
            },
            rhino: {
              defineClass: false,
              deserialize: false,
              gc: false,
              help: false,
              importClass: false,
              importPackage: false,
              java: false,
              load: false,
              loadClass: false,
              Packages: false,
              print: false,
              quit: false,
              readFile: false,
              readUrl: false,
              runCommand: false,
              seal: false,
              serialize: false,
              spawn: false,
              sync: false,
              toint32: false,
              version: false,
            },
            nashorn: {
              __DIR__: false,
              __FILE__: false,
              __LINE__: false,
              com: false,
              edu: false,
              exit: false,
              Java: false,
              java: false,
              javafx: false,
              JavaImporter: false,
              javax: false,
              JSAdapter: false,
              load: false,
              loadWithNewGlobal: false,
              org: false,
              Packages: false,
              print: false,
              quit: false,
            },
            wsh: {
              ActiveXObject: true,
              Enumerator: true,
              GetObject: true,
              ScriptEngine: true,
              ScriptEngineBuildVersion: true,
              ScriptEngineMajorVersion: true,
              ScriptEngineMinorVersion: true,
              VBArray: true,
              WScript: true,
              WSH: true,
              XDomainRequest: true,
            },
            jquery: {
              $: false,
              jQuery: false,
            },
            yui: {
              Y: false,
              YUI: false,
              YUI_config: false,
            },
            shelljs: {
              cat: false,
              cd: false,
              chmod: false,
              config: false,
              cp: false,
              dirs: false,
              echo: false,
              env: false,
              error: false,
              exec: false,
              exit: false,
              find: false,
              grep: false,
              ls: false,
              ln: false,
              mkdir: false,
              mv: false,
              popd: false,
              pushd: false,
              pwd: false,
              rm: false,
              sed: false,
              set: false,
              target: false,
              tempdir: false,
              test: false,
              touch: false,
              which: false,
            },
            prototypejs: {
              $: false,
              $$: false,
              $A: false,
              $break: false,
              $continue: false,
              $F: false,
              $H: false,
              $R: false,
              $w: false,
              Abstract: false,
              Ajax: false,
              Autocompleter: false,
              Builder: false,
              Class: false,
              Control: false,
              Draggable: false,
              Draggables: false,
              Droppables: false,
              Effect: false,
              Element: false,
              Enumerable: false,
              Event: false,
              Field: false,
              Form: false,
              Hash: false,
              Insertion: false,
              ObjectRange: false,
              PeriodicalExecuter: false,
              Position: false,
              Prototype: false,
              Scriptaculous: false,
              Selector: false,
              Sortable: false,
              SortableObserver: false,
              Sound: false,
              Template: false,
              Toggle: false,
              Try: false,
            },
            meteor: {
              $: false,
              _: false,
              Accounts: false,
              AccountsClient: false,
              AccountsServer: false,
              AccountsCommon: false,
              App: false,
              Assets: false,
              Blaze: false,
              check: false,
              Cordova: false,
              DDP: false,
              DDPServer: false,
              DDPRateLimiter: false,
              Deps: false,
              EJSON: false,
              Email: false,
              HTTP: false,
              Log: false,
              Match: false,
              Meteor: false,
              Mongo: false,
              MongoInternals: false,
              Npm: false,
              Package: false,
              Plugin: false,
              process: false,
              Random: false,
              ReactiveDict: false,
              ReactiveVar: false,
              Router: false,
              ServiceConfiguration: false,
              Session: false,
              share: false,
              Spacebars: false,
              Template: false,
              Tinytest: false,
              Tracker: false,
              UI: false,
              Utils: false,
              WebApp: false,
              WebAppInternals: false,
            },
            mongo: {
              _isWindows: false,
              _rand: false,
              BulkWriteResult: false,
              cat: false,
              cd: false,
              connect: false,
              db: false,
              getHostName: false,
              getMemInfo: false,
              hostname: false,
              ISODate: false,
              listFiles: false,
              load: false,
              ls: false,
              md5sumFile: false,
              mkdir: false,
              Mongo: false,
              NumberInt: false,
              NumberLong: false,
              ObjectId: false,
              PlanCache: false,
              print: false,
              printjson: false,
              pwd: false,
              quit: false,
              removeFile: false,
              rs: false,
              sh: false,
              UUID: false,
              version: false,
              WriteResult: false,
            },
            applescript: {
              $: false,
              Application: false,
              Automation: false,
              console: false,
              delay: false,
              Library: false,
              ObjC: false,
              ObjectSpecifier: false,
              Path: false,
              Progress: false,
              Ref: false,
            },
            serviceworker: {
              caches: false,
              Cache: false,
              CacheStorage: false,
              Client: false,
              clients: false,
              Clients: false,
              ExtendableEvent: false,
              ExtendableMessageEvent: false,
              FetchEvent: false,
              importScripts: false,
              registration: false,
              self: false,
              ServiceWorker: false,
              ServiceWorkerContainer: false,
              ServiceWorkerGlobalScope: false,
              ServiceWorkerMessageEvent: false,
              ServiceWorkerRegistration: false,
              skipWaiting: false,
              WindowClient: false,
            },
            atomtest: {
              advanceClock: false,
              fakeClearInterval: false,
              fakeClearTimeout: false,
              fakeSetInterval: false,
              fakeSetTimeout: false,
              resetTimeouts: false,
              waitsForPromise: false,
            },
            embertest: {
              andThen: false,
              click: false,
              currentPath: false,
              currentRouteName: false,
              currentURL: false,
              fillIn: false,
              find: false,
              findWithAssert: false,
              keyEvent: false,
              pauseTest: false,
              resumeTest: false,
              triggerEvent: false,
              visit: false,
            },
            protractor: {
              $: false,
              $$: false,
              browser: false,
              By: false,
              by: false,
              DartObject: false,
              element: false,
              protractor: false,
            },
            'shared-node-browser': {
              clearInterval: false,
              clearTimeout: false,
              console: false,
              setInterval: false,
              setTimeout: false,
            },
            webextensions: {
              browser: false,
              chrome: false,
              opr: false,
            },
            greasemonkey: {
              GM_addStyle: false,
              GM_deleteValue: false,
              GM_getResourceText: false,
              GM_getResourceURL: false,
              GM_getValue: false,
              GM_info: false,
              GM_listValues: false,
              GM_log: false,
              GM_openInTab: false,
              GM_registerMenuCommand: false,
              GM_setClipboard: false,
              GM_setValue: false,
              GM_xmlhttpRequest: false,
              unsafeWindow: false,
            },
          }
        },
        {},
      ],
      264: [
        function(require, module, exports) {
          module.exports = require('./globals.json')
        },
        { './globals.json': 263 },
      ],
      265: [
        function(require, module, exports) {
          'use strict'
          var ansiRegex = require('ansi-regex')
          var re = new RegExp(ansiRegex().source) // remove the `g` flag
          module.exports = re.test.bind(re)
        },
        { 'ansi-regex': 2 },
      ],
      266: [
        function(require, module, exports) {
          'use strict'
          var uppercasePattern = /[A-Z]/g
          var msPattern = /^ms-/
          var cache = {}

          function hyphenateStyleName(string) {
            return string in cache
              ? cache[string]
              : (cache[string] = string
                  .replace(uppercasePattern, '-$&')
                  .toLowerCase()
                  .replace(msPattern, '-ms-'))
          }

          module.exports = hyphenateStyleName
        },
        {},
      ],
      267: [
        function(require, module, exports) {
          exports.read = function(buffer, offset, isLE, mLen, nBytes) {
            var e, m
            var eLen = nBytes * 8 - mLen - 1
            var eMax = (1 << eLen) - 1
            var eBias = eMax >> 1
            var nBits = -7
            var i = isLE ? nBytes - 1 : 0
            var d = isLE ? -1 : 1
            var s = buffer[offset + i]

            i += d

            e = s & ((1 << -nBits) - 1)
            s >>= -nBits
            nBits += eLen
            for (
              ;
              nBits > 0;
              e = e * 256 + buffer[offset + i], i += d, nBits -= 8
            ) {}

            m = e & ((1 << -nBits) - 1)
            e >>= -nBits
            nBits += mLen
            for (
              ;
              nBits > 0;
              m = m * 256 + buffer[offset + i], i += d, nBits -= 8
            ) {}

            if (e === 0) {
              e = 1 - eBias
            } else if (e === eMax) {
              return m ? NaN : (s ? -1 : 1) * Infinity
            } else {
              m = m + Math.pow(2, mLen)
              e = e - eBias
            }
            return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
          }

          exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
            var e, m, c
            var eLen = nBytes * 8 - mLen - 1
            var eMax = (1 << eLen) - 1
            var eBias = eMax >> 1
            var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0
            var i = isLE ? 0 : nBytes - 1
            var d = isLE ? 1 : -1
            var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

            value = Math.abs(value)

            if (isNaN(value) || value === Infinity) {
              m = isNaN(value) ? 1 : 0
              e = eMax
            } else {
              e = Math.floor(Math.log(value) / Math.LN2)
              if (value * (c = Math.pow(2, -e)) < 1) {
                e--
                c *= 2
              }
              if (e + eBias >= 1) {
                value += rt / c
              } else {
                value += rt * Math.pow(2, 1 - eBias)
              }
              if (value * c >= 2) {
                e++
                c /= 2
              }

              if (e + eBias >= eMax) {
                m = 0
                e = eMax
              } else if (e + eBias >= 1) {
                m = (value * c - 1) * Math.pow(2, mLen)
                e = e + eBias
              } else {
                m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
                e = 0
              }
            }

            for (
              ;
              mLen >= 8;
              buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8
            ) {}

            e = (e << mLen) | m
            eLen += mLen
            for (
              ;
              eLen > 0;
              buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8
            ) {}

            buffer[offset + i - d] |= s * 128
          }
        },
        {},
      ],
      268: [
        function(require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', {
            value: true,
          })
          exports.default = calc

          var _joinPrefixedValue = require('../../utils/joinPrefixedValue')

          var _joinPrefixedValue2 = _interopRequireDefault(_joinPrefixedValue)

          var _isPrefixedValue = require('../../utils/isPrefixedValue')

          var _isPrefixedValue2 = _interopRequireDefault(_isPrefixedValue)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          function calc(property, value) {
            if (
              typeof value === 'string' &&
              !(0, _isPrefixedValue2.default)(value) &&
              value.indexOf('calc(') > -1
            ) {
              return (0, _joinPrefixedValue2.default)(property, value, function(
                prefix,
                value
              ) {
                return value.replace(/calc\(/g, prefix + 'calc(')
              })
            }
          }
          module.exports = exports['default']
        },
        {
          '../../utils/isPrefixedValue': 281,
          '../../utils/joinPrefixedValue': 282,
        },
      ],
      269: [
        function(require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', {
            value: true,
          })
          exports.default = cursor

          var _joinPrefixedValue = require('../../utils/joinPrefixedValue')

          var _joinPrefixedValue2 = _interopRequireDefault(_joinPrefixedValue)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          var values = {
            'zoom-in': true,
            'zoom-out': true,
            grab: true,
            grabbing: true,
          }

          function cursor(property, value) {
            if (property === 'cursor' && values[value]) {
              return (0, _joinPrefixedValue2.default)(property, value)
            }
          }
          module.exports = exports['default']
        },
        { '../../utils/joinPrefixedValue': 282 },
      ],
      270: [
        function(require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', {
            value: true,
          })
          exports.default = flex
          var values = { flex: true, 'inline-flex': true }

          function flex(property, value) {
            if (property === 'display' && values[value]) {
              return {
                display: [
                  '-webkit-box',
                  '-moz-box',
                  '-ms-' + value + 'box',
                  '-webkit-' + value,
                  value,
                ],
              }
            }
          }
          module.exports = exports['default']
        },
        {},
      ],
      271: [
        function(require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', {
            value: true,
          })
          exports.default = flexboxIE

          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true,
              })
            } else {
              obj[key] = value
            }
            return obj
          }

          var alternativeValues = {
            'space-around': 'distribute',
            'space-between': 'justify',
            'flex-start': 'start',
            'flex-end': 'end',
          }
          var alternativeProps = {
            alignContent: 'msFlexLinePack',
            alignSelf: 'msFlexItemAlign',
            alignItems: 'msFlexAlign',
            justifyContent: 'msFlexPack',
            order: 'msFlexOrder',
            flexGrow: 'msFlexPositive',
            flexShrink: 'msFlexNegative',
            flexBasis: 'msPreferredSize',
          }

          function flexboxIE(property, value) {
            if (alternativeProps[property]) {
              return _defineProperty(
                {},
                alternativeProps[property],
                alternativeValues[value] || value
              )
            }
          }
          module.exports = exports['default']
        },
        {},
      ],
      272: [
        function(require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', {
            value: true,
          })
          exports.default = flexboxOld

          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true,
              })
            } else {
              obj[key] = value
            }
            return obj
          }

          var alternativeValues = {
            'space-around': 'justify',
            'space-between': 'justify',
            'flex-start': 'start',
            'flex-end': 'end',
            'wrap-reverse': 'multiple',
            wrap: 'multiple',
          }

          var alternativeProps = {
            alignItems: 'WebkitBoxAlign',
            justifyContent: 'WebkitBoxPack',
            flexWrap: 'WebkitBoxLines',
          }

          function flexboxOld(property, value) {
            if (property === 'flexDirection' && typeof value === 'string') {
              return {
                WebkitBoxOrient: value.indexOf('column') > -1
                  ? 'vertical'
                  : 'horizontal',
                WebkitBoxDirection: value.indexOf('reverse') > -1
                  ? 'reverse'
                  : 'normal',
              }
            }
            if (alternativeProps[property]) {
              return _defineProperty(
                {},
                alternativeProps[property],
                alternativeValues[value] || value
              )
            }
          }
          module.exports = exports['default']
        },
        {},
      ],
      273: [
        function(require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', {
            value: true,
          })
          exports.default = gradient

          var _joinPrefixedValue = require('../../utils/joinPrefixedValue')

          var _joinPrefixedValue2 = _interopRequireDefault(_joinPrefixedValue)

          var _isPrefixedValue = require('../../utils/isPrefixedValue')

          var _isPrefixedValue2 = _interopRequireDefault(_isPrefixedValue)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          var values = /linear-gradient|radial-gradient|repeating-linear-gradient|repeating-radial-gradient/

          function gradient(property, value) {
            if (
              typeof value === 'string' &&
              !(0, _isPrefixedValue2.default)(value) &&
              value.match(values) !== null
            ) {
              return (0, _joinPrefixedValue2.default)(property, value)
            }
          }
          module.exports = exports['default']
        },
        {
          '../../utils/isPrefixedValue': 281,
          '../../utils/joinPrefixedValue': 282,
        },
      ],
      274: [
        function(require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', {
            value: true,
          })
          exports.default = position
          function position(property, value) {
            if (property === 'position' && value === 'sticky') {
              return { position: ['-webkit-sticky', 'sticky'] }
            }
          }
          module.exports = exports['default']
        },
        {},
      ],
      275: [
        function(require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', {
            value: true,
          })
          exports.default = sizing

          var _joinPrefixedValue = require('../../utils/joinPrefixedValue')

          var _joinPrefixedValue2 = _interopRequireDefault(_joinPrefixedValue)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          var properties = {
            maxHeight: true,
            maxWidth: true,
            width: true,
            height: true,
            columnWidth: true,
            minWidth: true,
            minHeight: true,
          }
          var values = {
            'min-content': true,
            'max-content': true,
            'fill-available': true,
            'fit-content': true,
            'contain-floats': true,
          }

          function sizing(property, value) {
            if (properties[property] && values[value]) {
              return (0, _joinPrefixedValue2.default)(property, value)
            }
          }
          module.exports = exports['default']
        },
        { '../../utils/joinPrefixedValue': 282 },
      ],
      276: [
        function(require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', {
            value: true,
          })
          exports.default = transition

          var _hyphenateStyleName = require('hyphenate-style-name')

          var _hyphenateStyleName2 = _interopRequireDefault(_hyphenateStyleName)

          var _capitalizeString = require('../../utils/capitalizeString')

          var _capitalizeString2 = _interopRequireDefault(_capitalizeString)

          var _isPrefixedValue = require('../../utils/isPrefixedValue')

          var _isPrefixedValue2 = _interopRequireDefault(_isPrefixedValue)

          var _prefixProps = require('../prefixProps')

          var _prefixProps2 = _interopRequireDefault(_prefixProps)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true,
              })
            } else {
              obj[key] = value
            }
            return obj
          }

          var properties = {
            transition: true,
            transitionProperty: true,
            WebkitTransition: true,
            WebkitTransitionProperty: true,
          }

          function transition(property, value) {
            // also check for already prefixed transitions
            if (typeof value === 'string' && properties[property]) {
              var _ref2

              var outputValue = prefixValue(value)
              var webkitOutput = outputValue
                .split(/,(?![^()]*(?:\([^()]*\))?\))/g)
                .filter(function(value) {
                  return value.match(/-moz-|-ms-/) === null
                })
                .join(',')

              // if the property is already prefixed
              if (property.indexOf('Webkit') > -1) {
                return _defineProperty({}, property, webkitOutput)
              }

              return (_ref2 = {}), _defineProperty(
                _ref2,
                'Webkit' + (0, _capitalizeString2.default)(property),
                webkitOutput
              ), _defineProperty(_ref2, property, outputValue), _ref2
            }
          }

          function prefixValue(value) {
            if ((0, _isPrefixedValue2.default)(value)) {
              return value
            }

            // only split multi values, not cubic beziers
            var multipleValues = value.split(/,(?![^()]*(?:\([^()]*\))?\))/g)

            // iterate each single value and check for transitioned properties
            // that need to be prefixed as well
            multipleValues.forEach(function(val, index) {
              multipleValues[index] = Object.keys(
                _prefixProps2.default
              ).reduce(function(out, prefix) {
                var dashCasePrefix = '-' + prefix.toLowerCase() + '-'

                Object.keys(_prefixProps2.default[prefix]).forEach(function(
                  prop
                ) {
                  var dashCaseProperty = (0, _hyphenateStyleName2.default)(prop)

                  if (
                    val.indexOf(dashCaseProperty) > -1 &&
                    dashCaseProperty !== 'order'
                  ) {
                    // join all prefixes and create a new value
                    out =
                      val.replace(
                        dashCaseProperty,
                        dashCasePrefix + dashCaseProperty
                      ) +
                      ',' +
                      out
                  }
                })
                return out
              }, val)
            })

            return multipleValues.join(',')
          }
          module.exports = exports['default']
        },
        {
          '../../utils/capitalizeString': 279,
          '../../utils/isPrefixedValue': 281,
          '../prefixProps': 278,
          'hyphenate-style-name': 266,
        },
      ],
      277: [
        function(require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', {
            value: true,
          })
          exports.default = prefixAll

          var _prefixProps = require('./prefixProps')

          var _prefixProps2 = _interopRequireDefault(_prefixProps)

          var _capitalizeString = require('../utils/capitalizeString')

          var _capitalizeString2 = _interopRequireDefault(_capitalizeString)

          var _sortPrefixedStyle = require('../utils/sortPrefixedStyle')

          var _sortPrefixedStyle2 = _interopRequireDefault(_sortPrefixedStyle)

          var _position = require('./plugins/position')

          var _position2 = _interopRequireDefault(_position)

          var _calc = require('./plugins/calc')

          var _calc2 = _interopRequireDefault(_calc)

          var _cursor = require('./plugins/cursor')

          var _cursor2 = _interopRequireDefault(_cursor)

          var _flex = require('./plugins/flex')

          var _flex2 = _interopRequireDefault(_flex)

          var _sizing = require('./plugins/sizing')

          var _sizing2 = _interopRequireDefault(_sizing)

          var _gradient = require('./plugins/gradient')

          var _gradient2 = _interopRequireDefault(_gradient)

          var _transition = require('./plugins/transition')

          var _transition2 = _interopRequireDefault(_transition)

          var _flexboxIE = require('./plugins/flexboxIE')

          var _flexboxIE2 = _interopRequireDefault(_flexboxIE)

          var _flexboxOld = require('./plugins/flexboxOld')

          var _flexboxOld2 = _interopRequireDefault(_flexboxOld)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          // special flexbox specifications

          var plugins = [
            _position2.default,
            _calc2.default,
            _cursor2.default,
            _sizing2.default,
            _gradient2.default,
            _transition2.default,
            _flexboxIE2.default,
            _flexboxOld2.default,
            _flex2.default,
          ]

          /**
 * Returns a prefixed version of the style object using all vendor prefixes
 * @param {Object} styles - Style object that gets prefixed properties added
 * @returns {Object} - Style object with prefixed properties and values
 */
          function prefixAll(styles) {
            Object.keys(styles).forEach(function(property) {
              var value = styles[property]
              if (value instanceof Object && !Array.isArray(value)) {
                // recurse through nested style objects
                styles[property] = prefixAll(value)
              } else {
                Object.keys(_prefixProps2.default).forEach(function(prefix) {
                  var properties = _prefixProps2.default[prefix]
                  // add prefixes if needed
                  if (properties[property]) {
                    styles[
                      prefix + (0, _capitalizeString2.default)(property)
                    ] = value
                  }
                })
              }
            })

            Object.keys(styles).forEach(function(property) {
              ;[].concat(styles[property]).forEach(function(value, index) {
                // resolve every special plugins
                plugins.forEach(function(plugin) {
                  return assignStyles(styles, plugin(property, value))
                })
              })
            })

            return (0, _sortPrefixedStyle2.default)(styles)
          }

          function assignStyles(base) {
            var extend = arguments.length <= 1 || arguments[1] === undefined
              ? {}
              : arguments[1]

            Object.keys(extend).forEach(function(property) {
              var baseValue = base[property]
              if (Array.isArray(baseValue)) {
                ;[].concat(extend[property]).forEach(function(value) {
                  var valueIndex = baseValue.indexOf(value)
                  if (valueIndex > -1) {
                    base[property].splice(valueIndex, 1)
                  }
                  base[property].push(value)
                })
              } else {
                base[property] = extend[property]
              }
            })
          }
          module.exports = exports['default']
        },
        {
          '../utils/capitalizeString': 279,
          '../utils/sortPrefixedStyle': 283,
          './plugins/calc': 268,
          './plugins/cursor': 269,
          './plugins/flex': 270,
          './plugins/flexboxIE': 271,
          './plugins/flexboxOld': 272,
          './plugins/gradient': 273,
          './plugins/position': 274,
          './plugins/sizing': 275,
          './plugins/transition': 276,
          './prefixProps': 278,
        },
      ],
      278: [
        function(require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', {
            value: true,
          })
          exports.default = {
            Webkit: {
              transform: true,
              transformOrigin: true,
              transformOriginX: true,
              transformOriginY: true,
              backfaceVisibility: true,
              perspective: true,
              perspectiveOrigin: true,
              transformStyle: true,
              transformOriginZ: true,
              animation: true,
              animationDelay: true,
              animationDirection: true,
              animationFillMode: true,
              animationDuration: true,
              animationIterationCount: true,
              animationName: true,
              animationPlayState: true,
              animationTimingFunction: true,
              appearance: true,
              userSelect: true,
              fontKerning: true,
              textEmphasisPosition: true,
              textEmphasis: true,
              textEmphasisStyle: true,
              textEmphasisColor: true,
              boxDecorationBreak: true,
              clipPath: true,
              maskImage: true,
              maskMode: true,
              maskRepeat: true,
              maskPosition: true,
              maskClip: true,
              maskOrigin: true,
              maskSize: true,
              maskComposite: true,
              mask: true,
              maskBorderSource: true,
              maskBorderMode: true,
              maskBorderSlice: true,
              maskBorderWidth: true,
              maskBorderOutset: true,
              maskBorderRepeat: true,
              maskBorder: true,
              maskType: true,
              textDecorationStyle: true,
              textDecorationSkip: true,
              textDecorationLine: true,
              textDecorationColor: true,
              filter: true,
              fontFeatureSettings: true,
              breakAfter: true,
              breakBefore: true,
              breakInside: true,
              columnCount: true,
              columnFill: true,
              columnGap: true,
              columnRule: true,
              columnRuleColor: true,
              columnRuleStyle: true,
              columnRuleWidth: true,
              columns: true,
              columnSpan: true,
              columnWidth: true,
              flex: true,
              flexBasis: true,
              flexDirection: true,
              flexGrow: true,
              flexFlow: true,
              flexShrink: true,
              flexWrap: true,
              alignContent: true,
              alignItems: true,
              alignSelf: true,
              justifyContent: true,
              order: true,
              transition: true,
              transitionDelay: true,
              transitionDuration: true,
              transitionProperty: true,
              transitionTimingFunction: true,
              backdropFilter: true,
              scrollSnapType: true,
              scrollSnapPointsX: true,
              scrollSnapPointsY: true,
              scrollSnapDestination: true,
              scrollSnapCoordinate: true,
              shapeImageThreshold: true,
              shapeImageMargin: true,
              shapeImageOutside: true,
              hyphens: true,
              flowInto: true,
              flowFrom: true,
              regionFragment: true,
              textSizeAdjust: true,
            },
            Moz: {
              appearance: true,
              userSelect: true,
              boxSizing: true,
              textAlignLast: true,
              textDecorationStyle: true,
              textDecorationSkip: true,
              textDecorationLine: true,
              textDecorationColor: true,
              tabSize: true,
              hyphens: true,
              fontFeatureSettings: true,
              breakAfter: true,
              breakBefore: true,
              breakInside: true,
              columnCount: true,
              columnFill: true,
              columnGap: true,
              columnRule: true,
              columnRuleColor: true,
              columnRuleStyle: true,
              columnRuleWidth: true,
              columns: true,
              columnSpan: true,
              columnWidth: true,
            },
            ms: {
              flex: true,
              flexBasis: false,
              flexDirection: true,
              flexGrow: false,
              flexFlow: true,
              flexShrink: false,
              flexWrap: true,
              alignContent: false,
              alignItems: false,
              alignSelf: false,
              justifyContent: false,
              order: false,
              transform: true,
              transformOrigin: true,
              transformOriginX: true,
              transformOriginY: true,
              userSelect: true,
              wrapFlow: true,
              wrapThrough: true,
              wrapMargin: true,
              scrollSnapType: true,
              scrollSnapPointsX: true,
              scrollSnapPointsY: true,
              scrollSnapDestination: true,
              scrollSnapCoordinate: true,
              touchAction: true,
              hyphens: true,
              flowInto: true,
              flowFrom: true,
              breakBefore: true,
              breakAfter: true,
              breakInside: true,
              regionFragment: true,
              gridTemplateColumns: true,
              gridTemplateRows: true,
              gridTemplateAreas: true,
              gridTemplate: true,
              gridAutoColumns: true,
              gridAutoRows: true,
              gridAutoFlow: true,
              grid: true,
              gridRowStart: true,
              gridColumnStart: true,
              gridRowEnd: true,
              gridRow: true,
              gridColumn: true,
              gridColumnEnd: true,
              gridColumnGap: true,
              gridRowGap: true,
              gridArea: true,
              gridGap: true,
              textSizeAdjust: true,
            },
          }
          module.exports = exports['default']
        },
        {},
      ],
      279: [
        function(require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', {
            value: true,
          })
          // helper to capitalize strings

          exports.default = function(str) {
            return str.charAt(0).toUpperCase() + str.slice(1)
          }

          module.exports = exports['default']
        },
        {},
      ],
      280: [
        function(require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', {
            value: true,
          })

          exports.default = function(property) {
            return property.match(/^(Webkit|Moz|O|ms)/) !== null
          }

          module.exports = exports['default']
        },
        {},
      ],
      281: [
        function(require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', {
            value: true,
          })

          exports.default = function(value) {
            if (Array.isArray(value)) value = value.join(',')

            return value.match(/-webkit-|-moz-|-ms-/) !== null
          }

          module.exports = exports['default']
        },
        {},
      ],
      282: [
        function(require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', {
            value: true,
          })

          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true,
              })
            } else {
              obj[key] = value
            }
            return obj
          }

          // returns a style object with a single concated prefixed value string

          exports.default = function(property, value) {
            var replacer = arguments.length <= 2 || arguments[2] === undefined
              ? function(prefix, value) {
                  return prefix + value
                }
              : arguments[2]
            return _defineProperty(
              {},
              property,
              ['-webkit-', '-moz-', ''].map(function(prefix) {
                return replacer(prefix, value)
              })
            )
          }

          module.exports = exports['default']
        },
        {},
      ],
      283: [
        function(require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', {
            value: true,
          })
          exports.default = sortPrefixedStyle

          var _isPrefixedProperty = require('./isPrefixedProperty')

          var _isPrefixedProperty2 = _interopRequireDefault(_isPrefixedProperty)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          function sortPrefixedStyle(style) {
            return Object.keys(style)
              .sort(function(left, right) {
                if (
                  (0, _isPrefixedProperty2.default)(left) &&
                  !(0, _isPrefixedProperty2.default)(right)
                ) {
                  return -1
                } else if (
                  !(0, _isPrefixedProperty2.default)(left) &&
                  (0, _isPrefixedProperty2.default)(right)
                ) {
                  return 1
                }
                return 0
              })
              .reduce(function(sortedStyle, prop) {
                sortedStyle[prop] = style[prop]
                return sortedStyle
              }, {})
          }
          module.exports = exports['default']
        },
        { './isPrefixedProperty': 280 },
      ],
      284: [
        function(require, module, exports) {
          module.exports = require('./lib/static/prefixAll')
        },
        { './lib/static/prefixAll': 277 },
      ],
      285: [
        function(require, module, exports) {
          ;(function(process) {
            /**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

            'use strict'
            /**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

            var invariant = function(condition, format, a, b, c, d, e, f) {
              if (process.env.NODE_ENV !== 'production') {
                if (format === undefined) {
                  throw new Error(
                    'invariant requires an error message argument'
                  )
                }
              }

              if (!condition) {
                var error
                if (format === undefined) {
                  error = new Error(
                    'Minified exception occurred; use the non-minified dev environment ' +
                      'for the full error message and additional helpful warnings.'
                  )
                } else {
                  var args = [a, b, c, d, e, f]
                  var argIndex = 0
                  error = new Error(
                    format.replace(/%s/g, function() {
                      return args[argIndex++]
                    })
                  )
                  error.name = 'Invariant Violation'
                }

                error.framesToPop = 1 // we don't care about invariant's own frame
                throw error
              }
            }

            module.exports = invariant
          }.call(this, require('_process')))
        },
        { _process: 507 },
      ],
      286: [
        function(require, module, exports) {
          'use strict'
          module.exports = function isArrayish(obj) {
            if (!obj || typeof obj === 'string') {
              return false
            }

            return (
              obj instanceof Array ||
              Array.isArray(obj) ||
              (obj.length >= 0 &&
                (obj.splice instanceof Function ||
                  (Object.getOwnPropertyDescriptor(obj, obj.length - 1) &&
                    obj.constructor.name !== 'String')))
            )
          }
        },
        {},
      ],
      287: [
        function(require, module, exports) {
          'use strict'
          var numberIsNan = require('number-is-nan')

          module.exports =
            Number.isFinite ||
            function(val) {
              return !(
                typeof val !== 'number' ||
                numberIsNan(val) ||
                val === Infinity ||
                val === -Infinity
              )
            }
        },
        { 'number-is-nan': 504 },
      ],
      288: [
        function(require, module, exports) {
          // Copyright 2014, 2015, 2016, 2017 Simon Lydell
          // License: MIT. (See LICENSE.)

          Object.defineProperty(exports, '__esModule', {
            value: true,
          })

          // This regex comes from regex.coffee, and is inserted here by generate-index.js
          // (run `npm run build`).
          exports.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyu]{1,5}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g

          exports.matchToToken = function(match) {
            var token = { type: 'invalid', value: match[0] }
            if (match[1])
              (token.type = 'string'), (token.closed = !!(match[3] || match[4]))
            else if (match[5]) token.type = 'comment'
            else if (match[6])
              (token.type = 'comment'), (token.closed = !!match[7])
            else if (match[8]) token.type = 'regex'
            else if (match[9]) token.type = 'number'
            else if (match[10]) token.type = 'name'
            else if (match[11]) token.type = 'punctuator'
            else if (match[12]) token.type = 'whitespace'
            return token
          }
        },
        {},
      ],
      289: [
        function(require, module, exports) {
          ;(function(global) {
            /*! https://mths.be/jsesc v1.3.0 by @mathias */
            ;(function(root) {
              // Detect free variables `exports`
              var freeExports = typeof exports == 'object' && exports

              // Detect free variable `module`
              var freeModule =
                typeof module == 'object' &&
                module &&
                module.exports == freeExports &&
                module

              // Detect free variable `global`, from Node.js or Browserified code,
              // and use it as `root`
              var freeGlobal = typeof global == 'object' && global
              if (
                freeGlobal.global === freeGlobal ||
                freeGlobal.window === freeGlobal
              ) {
                root = freeGlobal
              }

              /*--------------------------------------------------------------------------*/

              var object = {}
              var hasOwnProperty = object.hasOwnProperty
              var forOwn = function(object, callback) {
                var key
                for (key in object) {
                  if (hasOwnProperty.call(object, key)) {
                    callback(key, object[key])
                  }
                }
              }

              var extend = function(destination, source) {
                if (!source) {
                  return destination
                }
                forOwn(source, function(key, value) {
                  destination[key] = value
                })
                return destination
              }

              var forEach = function(array, callback) {
                var length = array.length
                var index = -1
                while (++index < length) {
                  callback(array[index])
                }
              }

              var toString = object.toString
              var isArray = function(value) {
                return toString.call(value) == '[object Array]'
              }
              var isObject = function(value) {
                // This is a very simple check, but its good enough for what we need.
                return toString.call(value) == '[object Object]'
              }
              var isString = function(value) {
                return (
                  typeof value == 'string' ||
                  toString.call(value) == '[object String]'
                )
              }
              var isNumber = function(value) {
                return (
                  typeof value == 'number' ||
                  toString.call(value) == '[object Number]'
                )
              }
              var isFunction = function(value) {
                // In a perfect world, the `typeof` check would be sufficient. However,
                // in Chrome 112, `typeof /x/ == 'object'`, and in IE 68
                // `typeof alert == 'object'` and similar for other host objects.
                return (
                  typeof value == 'function' ||
                  toString.call(value) == '[object Function]'
                )
              }
              var isMap = function(value) {
                return toString.call(value) == '[object Map]'
              }
              var isSet = function(value) {
                return toString.call(value) == '[object Set]'
              }

              /*--------------------------------------------------------------------------*/

              // https://mathiasbynens.be/notes/javascript-escapes#single
              var singleEscapes = {
                '"': '\\"',
                "'": "\\'",
                '\\': '\\\\',
                '\b': '\\b',
                '\f': '\\f',
                '\n': '\\n',
                '\r': '\\r',
                '\t': '\\t',
                // `\v` is omitted intentionally, because in IE < 9, '\v' == 'v'.
                // '\v': '\\x0B'
              }
              var regexSingleEscape = /["'\\\b\f\n\r\t]/

              var regexDigit = /[0-9]/
              var regexWhitelist = /[ !#-&\(-\[\]-~]/

              var jsesc = function(argument, options) {
                // Handle options
                var defaults = {
                  escapeEverything: false,
                  escapeEtago: false,
                  quotes: 'single',
                  wrap: false,
                  es6: false,
                  json: false,
                  compact: true,
                  lowercaseHex: false,
                  numbers: 'decimal',
                  indent: '\t',
                  __indent__: '',
                  __inline1__: false,
                  __inline2__: false,
                }
                var json = options && options.json
                if (json) {
                  defaults.quotes = 'double'
                  defaults.wrap = true
                }
                options = extend(defaults, options)
                if (options.quotes != 'single' && options.quotes != 'double') {
                  options.quotes = 'single'
                }
                var quote = options.quotes == 'double' ? '"' : "'"
                var compact = options.compact
                var indent = options.indent
                var lowercaseHex = options.lowercaseHex
                var oldIndent = ''
                var inline1 = options.__inline1__
                var inline2 = options.__inline2__
                var newLine = compact ? '' : '\n'
                var result
                var isEmpty = true
                var useBinNumbers = options.numbers == 'binary'
                var useOctNumbers = options.numbers == 'octal'
                var useDecNumbers = options.numbers == 'decimal'
                var useHexNumbers = options.numbers == 'hexadecimal'

                if (json && argument && isFunction(argument.toJSON)) {
                  argument = argument.toJSON()
                }

                if (!isString(argument)) {
                  if (isMap(argument)) {
                    if (argument.size == 0) {
                      return 'new Map()'
                    }
                    if (!compact) {
                      options.__inline1__ = true
                    }
                    return (
                      'new Map(' + jsesc(Array.from(argument), options) + ')'
                    )
                  }
                  if (isSet(argument)) {
                    if (argument.size == 0) {
                      return 'new Set()'
                    }
                    return (
                      'new Set(' + jsesc(Array.from(argument), options) + ')'
                    )
                  }
                  if (isArray(argument)) {
                    result = []
                    options.wrap = true
                    if (inline1) {
                      options.__inline1__ = false
                      options.__inline2__ = true
                    } else {
                      oldIndent = options.__indent__
                      indent += oldIndent
                      options.__indent__ = indent
                    }
                    forEach(argument, function(value) {
                      isEmpty = false
                      if (inline2) {
                        options.__inline2__ = false
                      }
                      result.push(
                        (compact || inline2 ? '' : indent) +
                          jsesc(value, options)
                      )
                    })
                    if (isEmpty) {
                      return '[]'
                    }
                    if (inline2) {
                      return '[' + result.join(', ') + ']'
                    }
                    return (
                      '[' +
                      newLine +
                      result.join(',' + newLine) +
                      newLine +
                      (compact ? '' : oldIndent) +
                      ']'
                    )
                  } else if (isNumber(argument)) {
                    if (json) {
                      // Some number values (e.g. `Infinity`) cannot be represented in JSON.
                      return JSON.stringify(argument)
                    }
                    if (useDecNumbers) {
                      return String(argument)
                    }
                    if (useHexNumbers) {
                      var tmp = argument.toString(16)
                      if (!lowercaseHex) {
                        tmp = tmp.toUpperCase()
                      }
                      return '0x' + tmp
                    }
                    if (useBinNumbers) {
                      return '0b' + argument.toString(2)
                    }
                    if (useOctNumbers) {
                      return '0o' + argument.toString(8)
                    }
                  } else if (!isObject(argument)) {
                    if (json) {
                      // For some values (e.g. `undefined`, `function` objects),
                      // `JSON.stringify(value)` returns `undefined` (which isnt valid
                      // JSON) instead of `'null'`.
                      return JSON.stringify(argument) || 'null'
                    }
                    return String(argument)
                  } else {
                    // its an object
                    result = []
                    options.wrap = true
                    oldIndent = options.__indent__
                    indent += oldIndent
                    options.__indent__ = indent
                    forOwn(argument, function(key, value) {
                      isEmpty = false
                      result.push(
                        (compact ? '' : indent) +
                          jsesc(key, options) +
                          ':' +
                          (compact ? '' : ' ') +
                          jsesc(value, options)
                      )
                    })
                    if (isEmpty) {
                      return '{}'
                    }
                    return (
                      '{' +
                      newLine +
                      result.join(',' + newLine) +
                      newLine +
                      (compact ? '' : oldIndent) +
                      '}'
                    )
                  }
                }

                var string = argument
                // Loop over each code unit in the string and escape it
                var index = -1
                var length = string.length
                var first
                var second
                var codePoint
                result = ''
                while (++index < length) {
                  var character = string.charAt(index)
                  if (options.es6) {
                    first = string.charCodeAt(index)
                    if (
                      // check if its the start of a surrogate pair
                      first >= 0xd800 &&
                      first <= 0xdbff && // high surrogate
                      length > index + 1 // there is a next code unit
                    ) {
                      second = string.charCodeAt(index + 1)
                      if (second >= 0xdc00 && second <= 0xdfff) {
                        // low surrogate
                        // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
                        codePoint =
                          (first - 0xd800) * 0x400 + second - 0xdc00 + 0x10000
                        var hexadecimal = codePoint.toString(16)
                        if (!lowercaseHex) {
                          hexadecimal = hexadecimal.toUpperCase()
                        }
                        result += '\\u{' + hexadecimal + '}'
                        index++
                        continue
                      }
                    }
                  }
                  if (!options.escapeEverything) {
                    if (regexWhitelist.test(character)) {
                      // Its a printable ASCII character that is not `"`, `'` or `\`,
                      // so dont escape it.
                      result += character
                      continue
                    }
                    if (character == '"') {
                      result += quote == character ? '\\"' : character
                      continue
                    }
                    if (character == "'") {
                      result += quote == character ? "\\'" : character
                      continue
                    }
                  }
                  if (
                    character == '\0' &&
                    !json &&
                    !regexDigit.test(string.charAt(index + 1))
                  ) {
                    result += '\\0'
                    continue
                  }
                  if (regexSingleEscape.test(character)) {
                    // no need for a `hasOwnProperty` check here
                    result += singleEscapes[character]
                    continue
                  }
                  var charCode = character.charCodeAt(0)
                  var hexadecimal = charCode.toString(16)
                  if (!lowercaseHex) {
                    hexadecimal = hexadecimal.toUpperCase()
                  }
                  var longhand = hexadecimal.length > 2 || json
                  var escaped =
                    '\\' +
                    (longhand ? 'u' : 'x') +
                    ('0000' + hexadecimal).slice(longhand ? -4 : -2)
                  result += escaped
                  continue
                }
                if (options.wrap) {
                  result = quote + result + quote
                }
                if (options.escapeEtago) {
                  // https://mathiasbynens.be/notes/etago
                  return result.replace(/<\/(script|style)/gi, '<\\/$1')
                }
                return result
              }

              jsesc.version = '1.3.0'

              /*--------------------------------------------------------------------------*/

              // Some AMD build optimizers, like r.js, check for specific condition patterns
              // like the following:
              if (
                typeof define == 'function' &&
                typeof define.amd == 'object' &&
                define.amd
              ) {
                define(function() {
                  return jsesc
                })
              } else if (freeExports && !freeExports.nodeType) {
                if (freeModule) {
                  // in Node.js or RingoJS v0.8.0+
                  freeModule.exports = jsesc
                } else {
                  // in Narwhal or RingoJS v0.7.0-
                  freeExports.jsesc = jsesc
                }
              } else {
                // in Rhino or a web browser
                root.jsesc = jsesc
              }
            })(this)
          }.call(
            this,
            typeof global !== 'undefined'
              ? global
              : typeof self !== 'undefined'
                ? self
                : typeof window !== 'undefined' ? window : {}
          ))
        },
        {},
      ],
      290: [
        function(require, module, exports) {
          // json5.js
          // Modern JSON. See README.md for details.
          //
          // This file is based directly off of Douglas Crockford's json_parse.js:
          // https://github.com/douglascrockford/JSON-js/blob/master/json_parse.js

          var JSON5 = typeof exports === 'object' ? exports : {}

          JSON5.parse = (function() {
            'use strict'
            // This is a function that can parse a JSON5 text, producing a JavaScript
            // data structure. It is a simple, recursive descent parser. It does not use
            // eval or regular expressions, so it can be used as a model for implementing
            // a JSON5 parser in other languages.

            // We are defining the function inside of another function to avoid creating
            // global variables.

            var at, // The index of the current character
              lineNumber, // The current line number
              columnNumber, // The current column number
              ch, // The current character
              escapee = {
                "'": "'",
                '"': '"',
                '\\': '\\',
                '/': '/',
                '\n': '', // Replace escaped newlines in strings w/ empty string
                b: '\b',
                f: '\f',
                n: '\n',
                r: '\r',
                t: '\t',
              },
              ws = [' ', '\t', '\r', '\n', '\v', '\f', '\xA0', '\uFEFF'],
              text,
              renderChar = function(chr) {
                return chr === '' ? 'EOF' : "'" + chr + "'"
              },
              error = function(m) {
                // Call error when something is wrong.

                var error = new SyntaxError()
                // beginning of message suffix to agree with that provided by Gecko - see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse
                error.message =
                  m +
                  ' at line ' +
                  lineNumber +
                  ' column ' +
                  columnNumber +
                  ' of the JSON5 data. Still to read: ' +
                  JSON.stringify(text.substring(at - 1, at + 19))
                error.at = at
                // These two property names have been chosen to agree with the ones in Gecko, the only popular
                // environment which seems to supply this info on JSON.parse
                error.lineNumber = lineNumber
                error.columnNumber = columnNumber
                throw error
              },
              next = function(c) {
                // If a c parameter is provided, verify that it matches the current character.

                if (c && c !== ch) {
                  error(
                    'Expected ' +
                      renderChar(c) +
                      ' instead of ' +
                      renderChar(ch)
                  )
                }

                // Get the next character. When there are no more characters,
                // return the empty string.

                ch = text.charAt(at)
                at++
                columnNumber++
                if (ch === '\n' || (ch === '\r' && peek() !== '\n')) {
                  lineNumber++
                  columnNumber = 0
                }
                return ch
              },
              peek = function() {
                // Get the next character without consuming it or
                // assigning it to the ch varaible.

                return text.charAt(at)
              },
              identifier = function() {
                // Parse an identifier. Normally, reserved words are disallowed here, but we
                // only use this for unquoted object keys, where reserved words are allowed,
                // so we don't check for those here. References:
                // - http://es5.github.com/#x7.6
                // - https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Core_Language_Features#Variables
                // - http://docstore.mik.ua/orelly/webprog/jscript/ch02_07.htm
                // TODO Identifiers can have Unicode "letters" in them; add support for those.

                var key = ch

                // Identifiers must start with a letter, _ or $.
                if (
                  ch !== '_' &&
                  ch !== '$' &&
                  (ch < 'a' || ch > 'z') &&
                  (ch < 'A' || ch > 'Z')
                ) {
                  error('Bad identifier as unquoted key')
                }

                // Subsequent characters can contain digits.
                while (
                  next() &&
                  (ch === '_' ||
                    ch === '$' ||
                    (ch >= 'a' && ch <= 'z') ||
                    (ch >= 'A' && ch <= 'Z') ||
                    (ch >= '0' && ch <= '9'))
                ) {
                  key += ch
                }

                return key
              },
              number = function() {
                // Parse a number value.

                var number,
                  sign = '',
                  string = '',
                  base = 10

                if (ch === '-' || ch === '+') {
                  sign = ch
                  next(ch)
                }

                // support for Infinity (could tweak to allow other words):
                if (ch === 'I') {
                  number = word()
                  if (typeof number !== 'number' || isNaN(number)) {
                    error('Unexpected word for number')
                  }
                  return sign === '-' ? -number : number
                }

                // support for NaN
                if (ch === 'N') {
                  number = word()
                  if (!isNaN(number)) {
                    error('expected word to be NaN')
                  }
                  // ignore sign as -NaN also is NaN
                  return number
                }

                if (ch === '0') {
                  string += ch
                  next()
                  if (ch === 'x' || ch === 'X') {
                    string += ch
                    next()
                    base = 16
                  } else if (ch >= '0' && ch <= '9') {
                    error('Octal literal')
                  }
                }

                switch (base) {
                  case 10:
                    while (ch >= '0' && ch <= '9') {
                      string += ch
                      next()
                    }
                    if (ch === '.') {
                      string += '.'
                      while (next() && ch >= '0' && ch <= '9') {
                        string += ch
                      }
                    }
                    if (ch === 'e' || ch === 'E') {
                      string += ch
                      next()
                      if (ch === '-' || ch === '+') {
                        string += ch
                        next()
                      }
                      while (ch >= '0' && ch <= '9') {
                        string += ch
                        next()
                      }
                    }
                    break
                  case 16:
                    while (
                      (ch >= '0' && ch <= '9') ||
                      (ch >= 'A' && ch <= 'F') ||
                      (ch >= 'a' && ch <= 'f')
                    ) {
                      string += ch
                      next()
                    }
                    break
                }

                if (sign === '-') {
                  number = -string
                } else {
                  number = +string
                }

                if (!isFinite(number)) {
                  error('Bad number')
                } else {
                  return number
                }
              },
              string = function() {
                // Parse a string value.

                var hex,
                  i,
                  string = '',
                  delim, // double quote or single quote
                  uffff

                // When parsing for string values, we must look for ' or " and \ characters.

                if (ch === '"' || ch === "'") {
                  delim = ch
                  while (next()) {
                    if (ch === delim) {
                      next()
                      return string
                    } else if (ch === '\\') {
                      next()
                      if (ch === 'u') {
                        uffff = 0
                        for (i = 0; i < 4; i += 1) {
                          hex = parseInt(next(), 16)
                          if (!isFinite(hex)) {
                            break
                          }
                          uffff = uffff * 16 + hex
                        }
                        string += String.fromCharCode(uffff)
                      } else if (ch === '\r') {
                        if (peek() === '\n') {
                          next()
                        }
                      } else if (typeof escapee[ch] === 'string') {
                        string += escapee[ch]
                      } else {
                        break
                      }
                    } else if (ch === '\n') {
                      // unescaped newlines are invalid; see:
                      // https://github.com/aseemk/json5/issues/24
                      // TODO this feels special-cased; are there other
                      // invalid unescaped chars?
                      break
                    } else {
                      string += ch
                    }
                  }
                }
                error('Bad string')
              },
              inlineComment = function() {
                // Skip an inline comment, assuming this is one. The current character should
                // be the second / character in the // pair that begins this inline comment.
                // To finish the inline comment, we look for a newline or the end of the text.

                if (ch !== '/') {
                  error('Not an inline comment')
                }

                do {
                  next()
                  if (ch === '\n' || ch === '\r') {
                    next()
                    return
                  }
                } while (ch)
              },
              blockComment = function() {
                // Skip a block comment, assuming this is one. The current character should be
                // the * character in the /* pair that begins this block comment.
                // To finish the block comment, we look for an ending */ pair of characters,
                // but we also watch for the end of text before the comment is terminated.

                if (ch !== '*') {
                  error('Not a block comment')
                }

                do {
                  next()
                  while (ch === '*') {
                    next('*')
                    if (ch === '/') {
                      next('/')
                      return
                    }
                  }
                } while (ch)

                error('Unterminated block comment')
              },
              comment = function() {
                // Skip a comment, whether inline or block-level, assuming this is one.
                // Comments always begin with a / character.

                if (ch !== '/') {
                  error('Not a comment')
                }

                next('/')

                if (ch === '/') {
                  inlineComment()
                } else if (ch === '*') {
                  blockComment()
                } else {
                  error('Unrecognized comment')
                }
              },
              white = function() {
                // Skip whitespace and comments.
                // Note that we're detecting comments by only a single / character.
                // This works since regular expressions are not valid JSON(5), but this will
                // break if there are other valid values that begin with a / character!

                while (ch) {
                  if (ch === '/') {
                    comment()
                  } else if (ws.indexOf(ch) >= 0) {
                    next()
                  } else {
                    return
                  }
                }
              },
              word = function() {
                // true, false, or null.

                switch (ch) {
                  case 't':
                    next('t')
                    next('r')
                    next('u')
                    next('e')
                    return true
                  case 'f':
                    next('f')
                    next('a')
                    next('l')
                    next('s')
                    next('e')
                    return false
                  case 'n':
                    next('n')
                    next('u')
                    next('l')
                    next('l')
                    return null
                  case 'I':
                    next('I')
                    next('n')
                    next('f')
                    next('i')
                    next('n')
                    next('i')
                    next('t')
                    next('y')
                    return Infinity
                  case 'N':
                    next('N')
                    next('a')
                    next('N')
                    return NaN
                }
                error('Unexpected ' + renderChar(ch))
              },
              value, // Place holder for the value function.
              array = function() {
                // Parse an array value.

                var array = []

                if (ch === '[') {
                  next('[')
                  white()
                  while (ch) {
                    if (ch === ']') {
                      next(']')
                      return array // Potentially empty array
                    }
                    // ES5 allows omitting elements in arrays, e.g. [,] and
                    // [,null]. We don't allow this in JSON5.
                    if (ch === ',') {
                      error('Missing array element')
                    } else {
                      array.push(value())
                    }
                    white()
                    // If there's no comma after this value, this needs to
                    // be the end of the array.
                    if (ch !== ',') {
                      next(']')
                      return array
                    }
                    next(',')
                    white()
                  }
                }
                error('Bad array')
              },
              object = function() {
                // Parse an object value.

                var key,
                  object = {}

                if (ch === '{') {
                  next('{')
                  white()
                  while (ch) {
                    if (ch === '}') {
                      next('}')
                      return object // Potentially empty object
                    }

                    // Keys can be unquoted. If they are, they need to be
                    // valid JS identifiers.
                    if (ch === '"' || ch === "'") {
                      key = string()
                    } else {
                      key = identifier()
                    }

                    white()
                    next(':')
                    object[key] = value()
                    white()
                    // If there's no comma after this pair, this needs to be
                    // the end of the object.
                    if (ch !== ',') {
                      next('}')
                      return object
                    }
                    next(',')
                    white()
                  }
                }
                error('Bad object')
              }

            value = function() {
              // Parse a JSON value. It could be an object, an array, a string, a number,
              // or a word.

              white()
              switch (ch) {
                case '{':
                  return object()
                case '[':
                  return array()
                case '"':
                case "'":
                  return string()
                case '-':
                case '+':
                case '.':
                  return number()
                default:
                  return ch >= '0' && ch <= '9' ? number() : word()
              }
            }

            // Return the json_parse function. It will have access to all of the above
            // functions and variables.

            return function(source, reviver) {
              var result

              text = String(source)
              at = 0
              lineNumber = 1
              columnNumber = 1
              ch = ' '
              result = value()
              white()
              if (ch) {
                error('Syntax error')
              }

              // If there is a reviver function, we recursively walk the new structure,
              // passing each name/value pair to the reviver function for possible
              // transformation, starting with a temporary root object that holds the result
              // in an empty key. If there is not a reviver function, we simply return the
              // result.

              return typeof reviver === 'function'
                ? (function walk(holder, key) {
                    var k,
                      v,
                      value = holder[key]
                    if (value && typeof value === 'object') {
                      for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                          v = walk(value, k)
                          if (v !== undefined) {
                            value[k] = v
                          } else {
                            delete value[k]
                          }
                        }
                      }
                    }
                    return reviver.call(holder, key, value)
                  })({ '': result }, '')
                : result
            }
          })()

          // JSON5 stringify will not quote keys where appropriate
          JSON5.stringify = function(obj, replacer, space) {
            if (
              replacer &&
              (typeof replacer !== 'function' && !isArray(replacer))
            ) {
              throw new Error('Replacer must be a function or an array')
            }
            var getReplacedValueOrUndefined = function(
              holder,
              key,
              isTopLevel
            ) {
              var value = holder[key]

              // Replace the value with its toJSON value first, if possible
              if (value && value.toJSON && typeof value.toJSON === 'function') {
                value = value.toJSON()
              }

              // If the user-supplied replacer if a function, call it. If it's an array, check objects' string keys for
              // presence in the array (removing the key/value pair from the resulting JSON if the key is missing).
              if (typeof replacer === 'function') {
                return replacer.call(holder, key, value)
              } else if (replacer) {
                if (
                  isTopLevel ||
                  isArray(holder) ||
                  replacer.indexOf(key) >= 0
                ) {
                  return value
                } else {
                  return undefined
                }
              } else {
                return value
              }
            }

            function isWordChar(c) {
              return (
                (c >= 'a' && c <= 'z') ||
                (c >= 'A' && c <= 'Z') ||
                (c >= '0' && c <= '9') ||
                c === '_' ||
                c === '$'
              )
            }

            function isWordStart(c) {
              return (
                (c >= 'a' && c <= 'z') ||
                (c >= 'A' && c <= 'Z') ||
                c === '_' ||
                c === '$'
              )
            }

            function isWord(key) {
              if (typeof key !== 'string') {
                return false
              }
              if (!isWordStart(key[0])) {
                return false
              }
              var i = 1,
                length = key.length
              while (i < length) {
                if (!isWordChar(key[i])) {
                  return false
                }
                i++
              }
              return true
            }

            // export for use in tests
            JSON5.isWord = isWord

            // polyfills
            function isArray(obj) {
              if (Array.isArray) {
                return Array.isArray(obj)
              } else {
                return Object.prototype.toString.call(obj) === '[object Array]'
              }
            }

            function isDate(obj) {
              return Object.prototype.toString.call(obj) === '[object Date]'
            }

            var objStack = []
            function checkForCircular(obj) {
              for (var i = 0; i < objStack.length; i++) {
                if (objStack[i] === obj) {
                  throw new TypeError('Converting circular structure to JSON')
                }
              }
            }

            function makeIndent(str, num, noNewLine) {
              if (!str) {
                return ''
              }
              // indentation no more than 10 chars
              if (str.length > 10) {
                str = str.substring(0, 10)
              }

              var indent = noNewLine ? '' : '\n'
              for (var i = 0; i < num; i++) {
                indent += str
              }

              return indent
            }

            var indentStr
            if (space) {
              if (typeof space === 'string') {
                indentStr = space
              } else if (typeof space === 'number' && space >= 0) {
                indentStr = makeIndent(' ', space, true)
              } else {
                // ignore space parameter
              }
            }

            // Copied from Crokford's implementation of JSON
            // See https://github.com/douglascrockford/JSON-js/blob/e39db4b7e6249f04a195e7dd0840e610cc9e941e/json2.js#L195
            // Begin
            var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
              escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
              meta = {
                // table of character substitutions
                '\b': '\\b',
                '\t': '\\t',
                '\n': '\\n',
                '\f': '\\f',
                '\r': '\\r',
                '"': '\\"',
                '\\': '\\\\',
              }
            function escapeString(string) {
              // If the string contains no control characters, no quote characters, and no
              // backslash characters, then we can safely slap some quotes around it.
              // Otherwise we must also replace the offending characters with safe escape
              // sequences.
              escapable.lastIndex = 0
              return escapable.test(string)
                ? '"' +
                    string.replace(escapable, function(a) {
                      var c = meta[a]
                      return typeof c === 'string'
                        ? c
                        : '\\u' +
                            ('0000' + a.charCodeAt(0).toString(16)).slice(-4)
                    }) +
                    '"'
                : '"' + string + '"'
            }
            // End

            function internalStringify(holder, key, isTopLevel) {
              var buffer, res

              // Replace the value, if necessary
              var obj_part = getReplacedValueOrUndefined(
                holder,
                key,
                isTopLevel
              )

              if (obj_part && !isDate(obj_part)) {
                // unbox objects
                // don't unbox dates, since will turn it into number
                obj_part = obj_part.valueOf()
              }
              switch (typeof obj_part) {
                case 'boolean':
                  return obj_part.toString()

                case 'number':
                  if (isNaN(obj_part) || !isFinite(obj_part)) {
                    return 'null'
                  }
                  return obj_part.toString()

                case 'string':
                  return escapeString(obj_part.toString())

                case 'object':
                  if (obj_part === null) {
                    return 'null'
                  } else if (isArray(obj_part)) {
                    checkForCircular(obj_part)
                    buffer = '['
                    objStack.push(obj_part)

                    for (var i = 0; i < obj_part.length; i++) {
                      res = internalStringify(obj_part, i, false)
                      buffer += makeIndent(indentStr, objStack.length)
                      if (res === null || typeof res === 'undefined') {
                        buffer += 'null'
                      } else {
                        buffer += res
                      }
                      if (i < obj_part.length - 1) {
                        buffer += ','
                      } else if (indentStr) {
                        buffer += '\n'
                      }
                    }
                    objStack.pop()
                    if (obj_part.length) {
                      buffer += makeIndent(indentStr, objStack.length, true)
                    }
                    buffer += ']'
                  } else {
                    checkForCircular(obj_part)
                    buffer = '{'
                    var nonEmpty = false
                    objStack.push(obj_part)
                    for (var prop in obj_part) {
                      if (obj_part.hasOwnProperty(prop)) {
                        var value = internalStringify(obj_part, prop, false)
                        isTopLevel = false
                        if (typeof value !== 'undefined' && value !== null) {
                          buffer += makeIndent(indentStr, objStack.length)
                          nonEmpty = true
                          key = isWord(prop) ? prop : escapeString(prop)
                          buffer +=
                            key + ':' + (indentStr ? ' ' : '') + value + ','
                        }
                      }
                    }
                    objStack.pop()
                    if (nonEmpty) {
                      buffer =
                        buffer.substring(0, buffer.length - 1) +
                        makeIndent(indentStr, objStack.length) +
                        '}'
                    } else {
                      buffer = '{}'
                    }
                  }
                  return buffer
                default:
                  // functions and undefined should be ignored
                  return undefined
              }
            }

            // special case...when undefined is used inside of
            // a compound object/array, return null.
            // but when top-level, return undefined
            var topLevelHolder = { '': obj }
            if (obj === undefined) {
              return getReplacedValueOrUndefined(topLevelHolder, '', true)
            }
            return internalStringify(topLevelHolder, '', true)
          }
        },
        {},
      ],
      291: [
        function(require, module, exports) {
          var getNative = require('./_getNative'),
            root = require('./_root')

          /* Built-in method references that are verified to be native. */
          var DataView = getNative(root, 'DataView')

          module.exports = DataView
        },
        { './_getNative': 391, './_root': 434 },
      ],
      292: [
        function(require, module, exports) {
          var hashClear = require('./_hashClear'),
            hashDelete = require('./_hashDelete'),
            hashGet = require('./_hashGet'),
            hashHas = require('./_hashHas'),
            hashSet = require('./_hashSet')

          /**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
          function Hash(entries) {
            var index = -1,
              length = entries == null ? 0 : entries.length

            this.clear()
            while (++index < length) {
              var entry = entries[index]
              this.set(entry[0], entry[1])
            }
          }

          // Add methods to `Hash`.
          Hash.prototype.clear = hashClear
          Hash.prototype['delete'] = hashDelete
          Hash.prototype.get = hashGet
          Hash.prototype.has = hashHas
          Hash.prototype.set = hashSet

          module.exports = Hash
        },
        {
          './_hashClear': 398,
          './_hashDelete': 399,
          './_hashGet': 400,
          './_hashHas': 401,
          './_hashSet': 402,
        },
      ],
      293: [
        function(require, module, exports) {
          var listCacheClear = require('./_listCacheClear'),
            listCacheDelete = require('./_listCacheDelete'),
            listCacheGet = require('./_listCacheGet'),
            listCacheHas = require('./_listCacheHas'),
            listCacheSet = require('./_listCacheSet')

          /**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
          function ListCache(entries) {
            var index = -1,
              length = entries == null ? 0 : entries.length

            this.clear()
            while (++index < length) {
              var entry = entries[index]
              this.set(entry[0], entry[1])
            }
          }

          // Add methods to `ListCache`.
          ListCache.prototype.clear = listCacheClear
          ListCache.prototype['delete'] = listCacheDelete
          ListCache.prototype.get = listCacheGet
          ListCache.prototype.has = listCacheHas
          ListCache.prototype.set = listCacheSet

          module.exports = ListCache
        },
        {
          './_listCacheClear': 414,
          './_listCacheDelete': 415,
          './_listCacheGet': 416,
          './_listCacheHas': 417,
          './_listCacheSet': 418,
        },
      ],
      294: [
        function(require, module, exports) {
          var getNative = require('./_getNative'),
            root = require('./_root')

          /* Built-in method references that are verified to be native. */
          var Map = getNative(root, 'Map')

          module.exports = Map
        },
        { './_getNative': 391, './_root': 434 },
      ],
      295: [
        function(require, module, exports) {
          var mapCacheClear = require('./_mapCacheClear'),
            mapCacheDelete = require('./_mapCacheDelete'),
            mapCacheGet = require('./_mapCacheGet'),
            mapCacheHas = require('./_mapCacheHas'),
            mapCacheSet = require('./_mapCacheSet')

          /**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
          function MapCache(entries) {
            var index = -1,
              length = entries == null ? 0 : entries.length

            this.clear()
            while (++index < length) {
              var entry = entries[index]
              this.set(entry[0], entry[1])
            }
          }

          // Add methods to `MapCache`.
          MapCache.prototype.clear = mapCacheClear
          MapCache.prototype['delete'] = mapCacheDelete
          MapCache.prototype.get = mapCacheGet
          MapCache.prototype.has = mapCacheHas
          MapCache.prototype.set = mapCacheSet

          module.exports = MapCache
        },
        {
          './_mapCacheClear': 419,
          './_mapCacheDelete': 420,
          './_mapCacheGet': 421,
          './_mapCacheHas': 422,
          './_mapCacheSet': 423,
        },
      ],
      296: [
        function(require, module, exports) {
          var getNative = require('./_getNative'),
            root = require('./_root')

          /* Built-in method references that are verified to be native. */
          var Promise = getNative(root, 'Promise')

          module.exports = Promise
        },
        { './_getNative': 391, './_root': 434 },
      ],
      297: [
        function(require, module, exports) {
          var getNative = require('./_getNative'),
            root = require('./_root')

          /* Built-in method references that are verified to be native. */
          var Set = getNative(root, 'Set')

          module.exports = Set
        },
        { './_getNative': 391, './_root': 434 },
      ],
      298: [
        function(require, module, exports) {
          var MapCache = require('./_MapCache'),
            setCacheAdd = require('./_setCacheAdd'),
            setCacheHas = require('./_setCacheHas')

          /**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
          function SetCache(values) {
            var index = -1,
              length = values == null ? 0 : values.length

            this.__data__ = new MapCache()
            while (++index < length) {
              this.add(values[index])
            }
          }

          // Add methods to `SetCache`.
          SetCache.prototype.add = SetCache.prototype.push = setCacheAdd
          SetCache.prototype.has = setCacheHas

          module.exports = SetCache
        },
        { './_MapCache': 295, './_setCacheAdd': 435, './_setCacheHas': 436 },
      ],
      299: [
        function(require, module, exports) {
          var ListCache = require('./_ListCache'),
            stackClear = require('./_stackClear'),
            stackDelete = require('./_stackDelete'),
            stackGet = require('./_stackGet'),
            stackHas = require('./_stackHas'),
            stackSet = require('./_stackSet')

          /**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
          function Stack(entries) {
            var data = (this.__data__ = new ListCache(entries))
            this.size = data.size
          }

          // Add methods to `Stack`.
          Stack.prototype.clear = stackClear
          Stack.prototype['delete'] = stackDelete
          Stack.prototype.get = stackGet
          Stack.prototype.has = stackHas
          Stack.prototype.set = stackSet

          module.exports = Stack
        },
        {
          './_ListCache': 293,
          './_stackClear': 440,
          './_stackDelete': 441,
          './_stackGet': 442,
          './_stackHas': 443,
          './_stackSet': 444,
        },
      ],
      300: [
        function(require, module, exports) {
          var root = require('./_root')

          /** Built-in value references. */
          var Symbol = root.Symbol

          module.exports = Symbol
        },
        { './_root': 434 },
      ],
      301: [
        function(require, module, exports) {
          var root = require('./_root')

          /** Built-in value references. */
          var Uint8Array = root.Uint8Array

          module.exports = Uint8Array
        },
        { './_root': 434 },
      ],
      302: [
        function(require, module, exports) {
          var getNative = require('./_getNative'),
            root = require('./_root')

          /* Built-in method references that are verified to be native. */
          var WeakMap = getNative(root, 'WeakMap')

          module.exports = WeakMap
        },
        { './_getNative': 391, './_root': 434 },
      ],
      303: [
        function(require, module, exports) {
          /**
 * Adds the key-value `pair` to `map`.
 *
 * @private
 * @param {Object} map The map to modify.
 * @param {Array} pair The key-value pair to add.
 * @returns {Object} Returns `map`.
 */
          function addMapEntry(map, pair) {
            // Don't return `map.set` because it's not chainable in IE 11.
            map.set(pair[0], pair[1])
            return map
          }

          module.exports = addMapEntry
        },
        {},
      ],
      304: [
        function(require, module, exports) {
          /**
 * Adds `value` to `set`.
 *
 * @private
 * @param {Object} set The set to modify.
 * @param {*} value The value to add.
 * @returns {Object} Returns `set`.
 */
          function addSetEntry(set, value) {
            // Don't return `set.add` because it's not chainable in IE 11.
            set.add(value)
            return set
          }

          module.exports = addSetEntry
        },
        {},
      ],
      305: [
        function(require, module, exports) {
          /**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
          function apply(func, thisArg, args) {
            switch (args.length) {
              case 0:
                return func.call(thisArg)
              case 1:
                return func.call(thisArg, args[0])
              case 2:
                return func.call(thisArg, args[0], args[1])
              case 3:
                return func.call(thisArg, args[0], args[1], args[2])
            }
            return func.apply(thisArg, args)
          }

          module.exports = apply
        },
        {},
      ],
      306: [
        function(require, module, exports) {
          /**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
          function arrayEach(array, iteratee) {
            var index = -1,
              length = array == null ? 0 : array.length

            while (++index < length) {
              if (iteratee(array[index], index, array) === false) {
                break
              }
            }
            return array
          }

          module.exports = arrayEach
        },
        {},
      ],
      307: [
        function(require, module, exports) {
          var baseIndexOf = require('./_baseIndexOf')

          /**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
          function arrayIncludes(array, value) {
            var length = array == null ? 0 : array.length
            return !!length && baseIndexOf(array, value, 0) > -1
          }

          module.exports = arrayIncludes
        },
        { './_baseIndexOf': 333 },
      ],
      308: [
        function(require, module, exports) {
          /**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
          function arrayIncludesWith(array, value, comparator) {
            var index = -1,
              length = array == null ? 0 : array.length

            while (++index < length) {
              if (comparator(value, array[index])) {
                return true
              }
            }
            return false
          }

          module.exports = arrayIncludesWith
        },
        {},
      ],
      309: [
        function(require, module, exports) {
          var baseTimes = require('./_baseTimes'),
            isArguments = require('./isArguments'),
            isArray = require('./isArray'),
            isBuffer = require('./isBuffer'),
            isIndex = require('./_isIndex'),
            isTypedArray = require('./isTypedArray')

          /** Used for built-in method references. */
          var objectProto = Object.prototype

          /** Used to check objects for own properties. */
          var hasOwnProperty = objectProto.hasOwnProperty

          /**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
          function arrayLikeKeys(value, inherited) {
            var isArr = isArray(value),
              isArg = !isArr && isArguments(value),
              isBuff = !isArr && !isArg && isBuffer(value),
              isType = !isArr && !isArg && !isBuff && isTypedArray(value),
              skipIndexes = isArr || isArg || isBuff || isType,
              result = skipIndexes ? baseTimes(value.length, String) : [],
              length = result.length

            for (var key in value) {
              if (
                (inherited || hasOwnProperty.call(value, key)) &&
                !(
                  skipIndexes &&
                  // Safari 9 has enumerable `arguments.length` in strict mode.
                  (key == 'length' ||
                    // Node.js 0.10 has enumerable non-index properties on buffers.
                    (isBuff && (key == 'offset' || key == 'parent')) ||
                    // PhantomJS 2 has enumerable non-index properties on typed arrays.
                    (isType &&
                      (key == 'buffer' ||
                        key == 'byteLength' ||
                        key == 'byteOffset')) ||
                    // Skip index properties.
                    isIndex(key, length))
                )
              ) {
                result.push(key)
              }
            }
            return result
          }

          module.exports = arrayLikeKeys
        },
        {
          './_baseTimes': 357,
          './_isIndex': 407,
          './isArguments': 467,
          './isArray': 468,
          './isBuffer': 471,
          './isTypedArray': 481,
        },
      ],
      310: [
        function(require, module, exports) {
          /**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
          function arrayMap(array, iteratee) {
            var index = -1,
              length = array == null ? 0 : array.length,
              result = Array(length)

            while (++index < length) {
              result[index] = iteratee(array[index], index, array)
            }
            return result
          }

          module.exports = arrayMap
        },
        {},
      ],
      311: [
        function(require, module, exports) {
          /**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
          function arrayPush(array, values) {
            var index = -1,
              length = values.length,
              offset = array.length

            while (++index < length) {
              array[offset + index] = values[index]
            }
            return array
          }

          module.exports = arrayPush
        },
        {},
      ],
      312: [
        function(require, module, exports) {
          /**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
          function arrayReduce(array, iteratee, accumulator, initAccum) {
            var index = -1,
              length = array == null ? 0 : array.length

            if (initAccum && length) {
              accumulator = array[++index]
            }
            while (++index < length) {
              accumulator = iteratee(accumulator, array[index], index, array)
            }
            return accumulator
          }

          module.exports = arrayReduce
        },
        {},
      ],
      313: [
        function(require, module, exports) {
          /**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
          function arraySome(array, predicate) {
            var index = -1,
              length = array == null ? 0 : array.length

            while (++index < length) {
              if (predicate(array[index], index, array)) {
                return true
              }
            }
            return false
          }

          module.exports = arraySome
        },
        {},
      ],
      314: [
        function(require, module, exports) {
          var eq = require('./eq')

          /** Used for built-in method references. */
          var objectProto = Object.prototype

          /** Used to check objects for own properties. */
          var hasOwnProperty = objectProto.hasOwnProperty

          /**
 * Used by `_.defaults` to customize its `_.assignIn` use.
 *
 * @private
 * @param {*} objValue The destination value.
 * @param {*} srcValue The source value.
 * @param {string} key The key of the property to assign.
 * @param {Object} object The parent object of `objValue`.
 * @returns {*} Returns the value to assign.
 */
          function assignInDefaults(objValue, srcValue, key, object) {
            if (
              objValue === undefined ||
              (eq(objValue, objectProto[key]) &&
                !hasOwnProperty.call(object, key))
            ) {
              return srcValue
            }
            return objValue
          }

          module.exports = assignInDefaults
        },
        { './eq': 456 },
      ],
      315: [
        function(require, module, exports) {
          var baseAssignValue = require('./_baseAssignValue'),
            eq = require('./eq')

          /**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
          function assignMergeValue(object, key, value) {
            if (
              (value !== undefined && !eq(object[key], value)) ||
              (value === undefined && !(key in object))
            ) {
              baseAssignValue(object, key, value)
            }
          }

          module.exports = assignMergeValue
        },
        { './_baseAssignValue': 319, './eq': 456 },
      ],
      316: [
        function(require, module, exports) {
          var baseAssignValue = require('./_baseAssignValue'),
            eq = require('./eq')

          /** Used for built-in method references. */
          var objectProto = Object.prototype

          /** Used to check objects for own properties. */
          var hasOwnProperty = objectProto.hasOwnProperty

          /**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
          function assignValue(object, key, value) {
            var objValue = object[key]
            if (
              !(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
              (value === undefined && !(key in object))
            ) {
              baseAssignValue(object, key, value)
            }
          }

          module.exports = assignValue
        },
        { './_baseAssignValue': 319, './eq': 456 },
      ],
      317: [
        function(require, module, exports) {
          var eq = require('./eq')

          /**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
          function assocIndexOf(array, key) {
            var length = array.length
            while (length--) {
              if (eq(array[length][0], key)) {
                return length
              }
            }
            return -1
          }

          module.exports = assocIndexOf
        },
        { './eq': 456 },
      ],
      318: [
        function(require, module, exports) {
          var copyObject = require('./_copyObject'),
            keys = require('./keys')

          /**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
          function baseAssign(object, source) {
            return object && copyObject(source, keys(source), object)
          }

          module.exports = baseAssign
        },
        { './_copyObject': 375, './keys': 482 },
      ],
      319: [
        function(require, module, exports) {
          var defineProperty = require('./_defineProperty')

          /**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
          function baseAssignValue(object, key, value) {
            if (key == '__proto__' && defineProperty) {
              defineProperty(object, key, {
                configurable: true,
                enumerable: true,
                value: value,
                writable: true,
              })
            } else {
              object[key] = value
            }
          }

          module.exports = baseAssignValue
        },
        { './_defineProperty': 383 },
      ],
      320: [
        function(require, module, exports) {
          /**
 * The base implementation of `_.clamp` which doesn't coerce arguments.
 *
 * @private
 * @param {number} number The number to clamp.
 * @param {number} [lower] The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the clamped number.
 */
          function baseClamp(number, lower, upper) {
            if (number === number) {
              if (upper !== undefined) {
                number = number <= upper ? number : upper
              }
              if (lower !== undefined) {
                number = number >= lower ? number : lower
              }
            }
            return number
          }

          module.exports = baseClamp
        },
        {},
      ],
      321: [
        function(require, module, exports) {
          var Stack = require('./_Stack'),
            arrayEach = require('./_arrayEach'),
            assignValue = require('./_assignValue'),
            baseAssign = require('./_baseAssign'),
            cloneBuffer = require('./_cloneBuffer'),
            copyArray = require('./_copyArray'),
            copySymbols = require('./_copySymbols'),
            getAllKeys = require('./_getAllKeys'),
            getTag = require('./_getTag'),
            initCloneArray = require('./_initCloneArray'),
            initCloneByTag = require('./_initCloneByTag'),
            initCloneObject = require('./_initCloneObject'),
            isArray = require('./isArray'),
            isBuffer = require('./isBuffer'),
            isObject = require('./isObject'),
            keys = require('./keys')

          /** `Object#toString` result references. */
          var argsTag = '[object Arguments]',
            arrayTag = '[object Array]',
            boolTag = '[object Boolean]',
            dateTag = '[object Date]',
            errorTag = '[object Error]',
            funcTag = '[object Function]',
            genTag = '[object GeneratorFunction]',
            mapTag = '[object Map]',
            numberTag = '[object Number]',
            objectTag = '[object Object]',
            regexpTag = '[object RegExp]',
            setTag = '[object Set]',
            stringTag = '[object String]',
            symbolTag = '[object Symbol]',
            weakMapTag = '[object WeakMap]'

          var arrayBufferTag = '[object ArrayBuffer]',
            dataViewTag = '[object DataView]',
            float32Tag = '[object Float32Array]',
            float64Tag = '[object Float64Array]',
            int8Tag = '[object Int8Array]',
            int16Tag = '[object Int16Array]',
            int32Tag = '[object Int32Array]',
            uint8Tag = '[object Uint8Array]',
            uint8ClampedTag = '[object Uint8ClampedArray]',
            uint16Tag = '[object Uint16Array]',
            uint32Tag = '[object Uint32Array]'

          /** Used to identify `toStringTag` values supported by `_.clone`. */
          var cloneableTags = {}
          cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[
            arrayBufferTag
          ] = cloneableTags[dataViewTag] = cloneableTags[
            boolTag
          ] = cloneableTags[dateTag] = cloneableTags[
            float32Tag
          ] = cloneableTags[float64Tag] = cloneableTags[
            int8Tag
          ] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[
            mapTag
          ] = cloneableTags[numberTag] = cloneableTags[
            objectTag
          ] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[
            stringTag
          ] = cloneableTags[symbolTag] = cloneableTags[
            uint8Tag
          ] = cloneableTags[uint8ClampedTag] = cloneableTags[
            uint16Tag
          ] = cloneableTags[uint32Tag] = true
          cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[
            weakMapTag
          ] = false

          /**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @param {boolean} [isFull] Specify a clone including symbols.
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
          function baseClone(
            value,
            isDeep,
            isFull,
            customizer,
            key,
            object,
            stack
          ) {
            var result
            if (customizer) {
              result = object
                ? customizer(value, key, object, stack)
                : customizer(value)
            }
            if (result !== undefined) {
              return result
            }
            if (!isObject(value)) {
              return value
            }
            var isArr = isArray(value)
            if (isArr) {
              result = initCloneArray(value)
              if (!isDeep) {
                return copyArray(value, result)
              }
            } else {
              var tag = getTag(value),
                isFunc = tag == funcTag || tag == genTag

              if (isBuffer(value)) {
                return cloneBuffer(value, isDeep)
              }
              if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
                result = initCloneObject(isFunc ? {} : value)
                if (!isDeep) {
                  return copySymbols(value, baseAssign(result, value))
                }
              } else {
                if (!cloneableTags[tag]) {
                  return object ? value : {}
                }
                result = initCloneByTag(value, tag, baseClone, isDeep)
              }
            }
            // Check for circular references and return its corresponding clone.
            stack || (stack = new Stack())
            var stacked = stack.get(value)
            if (stacked) {
              return stacked
            }
            stack.set(value, result)

            var props = isArr ? undefined : (isFull ? getAllKeys : keys)(value)
            arrayEach(props || value, function(subValue, key) {
              if (props) {
                key = subValue
                subValue = value[key]
              }
              // Recursively populate clone (susceptible to call stack limits).
              assignValue(
                result,
                key,
                baseClone(
                  subValue,
                  isDeep,
                  isFull,
                  customizer,
                  key,
                  value,
                  stack
                )
              )
            })
            return result
          }

          module.exports = baseClone
        },
        {
          './_Stack': 299,
          './_arrayEach': 306,
          './_assignValue': 316,
          './_baseAssign': 318,
          './_cloneBuffer': 365,
          './_copyArray': 374,
          './_copySymbols': 376,
          './_getAllKeys': 388,
          './_getTag': 395,
          './_initCloneArray': 403,
          './_initCloneByTag': 404,
          './_initCloneObject': 405,
          './isArray': 468,
          './isBuffer': 471,
          './isObject': 475,
          './keys': 482,
        },
      ],
      322: [
        function(require, module, exports) {
          var isObject = require('./isObject')

          /** Built-in value references. */
          var objectCreate = Object.create

          /**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
          var baseCreate = (function() {
            function object() {}
            return function(proto) {
              if (!isObject(proto)) {
                return {}
              }
              if (objectCreate) {
                return objectCreate(proto)
              }
              object.prototype = proto
              var result = new object()
              object.prototype = undefined
              return result
            }
          })()

          module.exports = baseCreate
        },
        { './isObject': 475 },
      ],
      323: [
        function(require, module, exports) {
          var baseForOwn = require('./_baseForOwn'),
            createBaseEach = require('./_createBaseEach')

          /**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
          var baseEach = createBaseEach(baseForOwn)

          module.exports = baseEach
        },
        { './_baseForOwn': 327, './_createBaseEach': 379 },
      ],
      324: [
        function(require, module, exports) {
          /**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
          function baseFindIndex(array, predicate, fromIndex, fromRight) {
            var length = array.length,
              index = fromIndex + (fromRight ? 1 : -1)

            while (fromRight ? index-- : ++index < length) {
              if (predicate(array[index], index, array)) {
                return index
              }
            }
            return -1
          }

          module.exports = baseFindIndex
        },
        {},
      ],
      325: [
        function(require, module, exports) {
          var arrayPush = require('./_arrayPush'),
            isFlattenable = require('./_isFlattenable')

          /**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
          function baseFlatten(array, depth, predicate, isStrict, result) {
            var index = -1,
              length = array.length

            predicate || (predicate = isFlattenable)
            result || (result = [])

            while (++index < length) {
              var value = array[index]
              if (depth > 0 && predicate(value)) {
                if (depth > 1) {
                  // Recursively flatten arrays (susceptible to call stack limits).
                  baseFlatten(value, depth - 1, predicate, isStrict, result)
                } else {
                  arrayPush(result, value)
                }
              } else if (!isStrict) {
                result[result.length] = value
              }
            }
            return result
          }

          module.exports = baseFlatten
        },
        { './_arrayPush': 311, './_isFlattenable': 406 },
      ],
      326: [
        function(require, module, exports) {
          var createBaseFor = require('./_createBaseFor')

          /**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
          var baseFor = createBaseFor()

          module.exports = baseFor
        },
        { './_createBaseFor': 380 },
      ],
      327: [
        function(require, module, exports) {
          var baseFor = require('./_baseFor'),
            keys = require('./keys')

          /**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
          function baseForOwn(object, iteratee) {
            return object && baseFor(object, iteratee, keys)
          }

          module.exports = baseForOwn
        },
        { './_baseFor': 326, './keys': 482 },
      ],
      328: [
        function(require, module, exports) {
          var castPath = require('./_castPath'),
            isKey = require('./_isKey'),
            toKey = require('./_toKey')

          /**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
          function baseGet(object, path) {
            path = isKey(path, object) ? [path] : castPath(path)

            var index = 0,
              length = path.length

            while (object != null && index < length) {
              object = object[toKey(path[index++])]
            }
            return index && index == length ? object : undefined
          }

          module.exports = baseGet
        },
        { './_castPath': 363, './_isKey': 409, './_toKey': 447 },
      ],
      329: [
        function(require, module, exports) {
          var arrayPush = require('./_arrayPush'),
            isArray = require('./isArray')

          /**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
          function baseGetAllKeys(object, keysFunc, symbolsFunc) {
            var result = keysFunc(object)
            return isArray(object)
              ? result
              : arrayPush(result, symbolsFunc(object))
          }

          module.exports = baseGetAllKeys
        },
        { './_arrayPush': 311, './isArray': 468 },
      ],
      330: [
        function(require, module, exports) {
          var Symbol = require('./_Symbol'),
            getRawTag = require('./_getRawTag'),
            objectToString = require('./_objectToString')

          /** `Object#toString` result references. */
          var nullTag = '[object Null]',
            undefinedTag = '[object Undefined]'

          /** Built-in value references. */
          var symToStringTag = Symbol ? Symbol.toStringTag : undefined

          /**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
          function baseGetTag(value) {
            if (value == null) {
              return value === undefined ? undefinedTag : nullTag
            }
            value = Object(value)
            return symToStringTag && symToStringTag in value
              ? getRawTag(value)
              : objectToString(value)
          }

          module.exports = baseGetTag
        },
        { './_Symbol': 300, './_getRawTag': 393, './_objectToString': 431 },
      ],
      331: [
        function(require, module, exports) {
          /** Used for built-in method references. */
          var objectProto = Object.prototype

          /** Used to check objects for own properties. */
          var hasOwnProperty = objectProto.hasOwnProperty

          /**
 * The base implementation of `_.has` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
          function baseHas(object, key) {
            return object != null && hasOwnProperty.call(object, key)
          }

          module.exports = baseHas
        },
        {},
      ],
      332: [
        function(require, module, exports) {
          /**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
          function baseHasIn(object, key) {
            return object != null && key in Object(object)
          }

          module.exports = baseHasIn
        },
        {},
      ],
      333: [
        function(require, module, exports) {
          var baseFindIndex = require('./_baseFindIndex'),
            baseIsNaN = require('./_baseIsNaN'),
            strictIndexOf = require('./_strictIndexOf')

          /**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
          function baseIndexOf(array, value, fromIndex) {
            return value === value
              ? strictIndexOf(array, value, fromIndex)
              : baseFindIndex(array, baseIsNaN, fromIndex)
          }

          module.exports = baseIndexOf
        },
        {
          './_baseFindIndex': 324,
          './_baseIsNaN': 338,
          './_strictIndexOf': 445,
        },
      ],
      334: [
        function(require, module, exports) {
          var baseGetTag = require('./_baseGetTag'),
            isObjectLike = require('./isObjectLike')

          /** `Object#toString` result references. */
          var argsTag = '[object Arguments]'

          /**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
          function baseIsArguments(value) {
            return isObjectLike(value) && baseGetTag(value) == argsTag
          }

          module.exports = baseIsArguments
        },
        { './_baseGetTag': 330, './isObjectLike': 476 },
      ],
      335: [
        function(require, module, exports) {
          var baseIsEqualDeep = require('./_baseIsEqualDeep'),
            isObject = require('./isObject'),
            isObjectLike = require('./isObjectLike')

          /**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {boolean} [bitmask] The bitmask of comparison flags.
 *  The bitmask may be composed of the following flags:
 *     1 - Unordered comparison
 *     2 - Partial comparison
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
          function baseIsEqual(value, other, customizer, bitmask, stack) {
            if (value === other) {
              return true
            }
            if (
              value == null ||
              other == null ||
              (!isObject(value) && !isObjectLike(other))
            ) {
              return value !== value && other !== other
            }
            return baseIsEqualDeep(
              value,
              other,
              baseIsEqual,
              customizer,
              bitmask,
              stack
            )
          }

          module.exports = baseIsEqual
        },
        { './_baseIsEqualDeep': 336, './isObject': 475, './isObjectLike': 476 },
      ],
      336: [
        function(require, module, exports) {
          var Stack = require('./_Stack'),
            equalArrays = require('./_equalArrays'),
            equalByTag = require('./_equalByTag'),
            equalObjects = require('./_equalObjects'),
            getTag = require('./_getTag'),
            isArray = require('./isArray'),
            isBuffer = require('./isBuffer'),
            isTypedArray = require('./isTypedArray')

          /** Used to compose bitmasks for comparison styles. */
          var PARTIAL_COMPARE_FLAG = 2

          /** `Object#toString` result references. */
          var argsTag = '[object Arguments]',
            arrayTag = '[object Array]',
            objectTag = '[object Object]'

          /** Used for built-in method references. */
          var objectProto = Object.prototype

          /** Used to check objects for own properties. */
          var hasOwnProperty = objectProto.hasOwnProperty

          /**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
          function baseIsEqualDeep(
            object,
            other,
            equalFunc,
            customizer,
            bitmask,
            stack
          ) {
            var objIsArr = isArray(object),
              othIsArr = isArray(other),
              objTag = arrayTag,
              othTag = arrayTag

            if (!objIsArr) {
              objTag = getTag(object)
              objTag = objTag == argsTag ? objectTag : objTag
            }
            if (!othIsArr) {
              othTag = getTag(other)
              othTag = othTag == argsTag ? objectTag : othTag
            }
            var objIsObj = objTag == objectTag,
              othIsObj = othTag == objectTag,
              isSameTag = objTag == othTag

            if (isSameTag && isBuffer(object)) {
              if (!isBuffer(other)) {
                return false
              }
              objIsArr = true
              objIsObj = false
            }
            if (isSameTag && !objIsObj) {
              stack || (stack = new Stack())
              return objIsArr || isTypedArray(object)
                ? equalArrays(
                    object,
                    other,
                    equalFunc,
                    customizer,
                    bitmask,
                    stack
                  )
                : equalByTag(
                    object,
                    other,
                    objTag,
                    equalFunc,
                    customizer,
                    bitmask,
                    stack
                  )
            }
            if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
              var objIsWrapped =
                objIsObj && hasOwnProperty.call(object, '__wrapped__'),
                othIsWrapped =
                  othIsObj && hasOwnProperty.call(other, '__wrapped__')

              if (objIsWrapped || othIsWrapped) {
                var objUnwrapped = objIsWrapped ? object.value() : object,
                  othUnwrapped = othIsWrapped ? other.value() : other

                stack || (stack = new Stack())
                return equalFunc(
                  objUnwrapped,
                  othUnwrapped,
                  customizer,
                  bitmask,
                  stack
                )
              }
            }
            if (!isSameTag) {
              return false
            }
            stack || (stack = new Stack())
            return equalObjects(
              object,
              other,
              equalFunc,
              customizer,
              bitmask,
              stack
            )
          }

          module.exports = baseIsEqualDeep
        },
        {
          './_Stack': 299,
          './_equalArrays': 384,
          './_equalByTag': 385,
          './_equalObjects': 386,
          './_getTag': 395,
          './isArray': 468,
          './isBuffer': 471,
          './isTypedArray': 481,
        },
      ],
      337: [
        function(require, module, exports) {
          var Stack = require('./_Stack'),
            baseIsEqual = require('./_baseIsEqual')

          /** Used to compose bitmasks for comparison styles. */
          var UNORDERED_COMPARE_FLAG = 1,
            PARTIAL_COMPARE_FLAG = 2

          /**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
          function baseIsMatch(object, source, matchData, customizer) {
            var index = matchData.length,
              length = index,
              noCustomizer = !customizer

            if (object == null) {
              return !length
            }
            object = Object(object)
            while (index--) {
              var data = matchData[index]
              if (
                noCustomizer && data[2]
                  ? data[1] !== object[data[0]]
                  : !(data[0] in object)
              ) {
                return false
              }
            }
            while (++index < length) {
              data = matchData[index]
              var key = data[0],
                objValue = object[key],
                srcValue = data[1]

              if (noCustomizer && data[2]) {
                if (objValue === undefined && !(key in object)) {
                  return false
                }
              } else {
                var stack = new Stack()
                if (customizer) {
                  var result = customizer(
                    objValue,
                    srcValue,
                    key,
                    object,
                    source,
                    stack
                  )
                }
                if (
                  !(result === undefined
                    ? baseIsEqual(
                        srcValue,
                        objValue,
                        customizer,
                        UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG,
                        stack
                      )
                    : result)
                ) {
                  return false
                }
              }
            }
            return true
          }

          module.exports = baseIsMatch
        },
        { './_Stack': 299, './_baseIsEqual': 335 },
      ],
      338: [
        function(require, module, exports) {
          /**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
          function baseIsNaN(value) {
            return value !== value
          }

          module.exports = baseIsNaN
        },
        {},
      ],
      339: [
        function(require, module, exports) {
          var isFunction = require('./isFunction'),
            isMasked = require('./_isMasked'),
            isObject = require('./isObject'),
            toSource = require('./_toSource')

          /**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
          var reRegExpChar = /[\\^$.*+?()[\]{}|]/g

          /** Used to detect host constructors (Safari). */
          var reIsHostCtor = /^\[object .+?Constructor\]$/

          /** Used for built-in method references. */
          var funcProto = Function.prototype,
            objectProto = Object.prototype

          /** Used to resolve the decompiled source of functions. */
          var funcToString = funcProto.toString

          /** Used to check objects for own properties. */
          var hasOwnProperty = objectProto.hasOwnProperty

          /** Used to detect if a method is native. */
          var reIsNative = RegExp(
            '^' +
              funcToString
                .call(hasOwnProperty)
                .replace(reRegExpChar, '\\$&')
                .replace(
                  /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                  '$1.*?'
                ) +
              '$'
          )

          /**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
          function baseIsNative(value) {
            if (!isObject(value) || isMasked(value)) {
              return false
            }
            var pattern = isFunction(value) ? reIsNative : reIsHostCtor
            return pattern.test(toSource(value))
          }

          module.exports = baseIsNative
        },
        {
          './_isMasked': 411,
          './_toSource': 448,
          './isFunction': 472,
          './isObject': 475,
        },
      ],
      340: [
        function(require, module, exports) {
          var baseGetTag = require('./_baseGetTag'),
            isObjectLike = require('./isObjectLike')

          /** `Object#toString` result references. */
          var regexpTag = '[object RegExp]'

          /**
 * The base implementation of `_.isRegExp` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
 */
          function baseIsRegExp(value) {
            return isObjectLike(value) && baseGetTag(value) == regexpTag
          }

          module.exports = baseIsRegExp
        },
        { './_baseGetTag': 330, './isObjectLike': 476 },
      ],
      341: [
        function(require, module, exports) {
          var baseGetTag = require('./_baseGetTag'),
            isLength = require('./isLength'),
            isObjectLike = require('./isObjectLike')

          /** `Object#toString` result references. */
          var argsTag = '[object Arguments]',
            arrayTag = '[object Array]',
            boolTag = '[object Boolean]',
            dateTag = '[object Date]',
            errorTag = '[object Error]',
            funcTag = '[object Function]',
            mapTag = '[object Map]',
            numberTag = '[object Number]',
            objectTag = '[object Object]',
            regexpTag = '[object RegExp]',
            setTag = '[object Set]',
            stringTag = '[object String]',
            weakMapTag = '[object WeakMap]'

          var arrayBufferTag = '[object ArrayBuffer]',
            dataViewTag = '[object DataView]',
            float32Tag = '[object Float32Array]',
            float64Tag = '[object Float64Array]',
            int8Tag = '[object Int8Array]',
            int16Tag = '[object Int16Array]',
            int32Tag = '[object Int32Array]',
            uint8Tag = '[object Uint8Array]',
            uint8ClampedTag = '[object Uint8ClampedArray]',
            uint16Tag = '[object Uint16Array]',
            uint32Tag = '[object Uint32Array]'

          /** Used to identify `toStringTag` values of typed arrays. */
          var typedArrayTags = {}
          typedArrayTags[float32Tag] = typedArrayTags[
            float64Tag
          ] = typedArrayTags[int8Tag] = typedArrayTags[
            int16Tag
          ] = typedArrayTags[int32Tag] = typedArrayTags[
            uint8Tag
          ] = typedArrayTags[uint8ClampedTag] = typedArrayTags[
            uint16Tag
          ] = typedArrayTags[uint32Tag] = true
          typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[
            arrayBufferTag
          ] = typedArrayTags[boolTag] = typedArrayTags[
            dataViewTag
          ] = typedArrayTags[dateTag] = typedArrayTags[
            errorTag
          ] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[
            numberTag
          ] = typedArrayTags[objectTag] = typedArrayTags[
            regexpTag
          ] = typedArrayTags[setTag] = typedArrayTags[
            stringTag
          ] = typedArrayTags[weakMapTag] = false

          /**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
          function baseIsTypedArray(value) {
            return (
              isObjectLike(value) &&
              isLength(value.length) &&
              !!typedArrayTags[baseGetTag(value)]
            )
          }

          module.exports = baseIsTypedArray
        },
        { './_baseGetTag': 330, './isLength': 474, './isObjectLike': 476 },
      ],
      342: [
        function(require, module, exports) {
          var baseMatches = require('./_baseMatches'),
            baseMatchesProperty = require('./_baseMatchesProperty'),
            identity = require('./identity'),
            isArray = require('./isArray'),
            property = require('./property')

          /**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
          function baseIteratee(value) {
            // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
            // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
            if (typeof value == 'function') {
              return value
            }
            if (value == null) {
              return identity
            }
            if (typeof value == 'object') {
              return isArray(value)
                ? baseMatchesProperty(value[0], value[1])
                : baseMatches(value)
            }
            return property(value)
          }

          module.exports = baseIteratee
        },
        {
          './_baseMatches': 346,
          './_baseMatchesProperty': 347,
          './identity': 465,
          './isArray': 468,
          './property': 488,
        },
      ],
      343: [
        function(require, module, exports) {
          var isPrototype = require('./_isPrototype'),
            nativeKeys = require('./_nativeKeys')

          /** Used for built-in method references. */
          var objectProto = Object.prototype

          /** Used to check objects for own properties. */
          var hasOwnProperty = objectProto.hasOwnProperty

          /**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
          function baseKeys(object) {
            if (!isPrototype(object)) {
              return nativeKeys(object)
            }
            var result = []
            for (var key in Object(object)) {
              if (hasOwnProperty.call(object, key) && key != 'constructor') {
                result.push(key)
              }
            }
            return result
          }

          module.exports = baseKeys
        },
        { './_isPrototype': 412, './_nativeKeys': 428 },
      ],
      344: [
        function(require, module, exports) {
          var isObject = require('./isObject'),
            isPrototype = require('./_isPrototype'),
            nativeKeysIn = require('./_nativeKeysIn')

          /** Used for built-in method references. */
          var objectProto = Object.prototype

          /** Used to check objects for own properties. */
          var hasOwnProperty = objectProto.hasOwnProperty

          /**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
          function baseKeysIn(object) {
            if (!isObject(object)) {
              return nativeKeysIn(object)
            }
            var isProto = isPrototype(object),
              result = []

            for (var key in object) {
              if (
                !(
                  key == 'constructor' &&
                  (isProto || !hasOwnProperty.call(object, key))
                )
              ) {
                result.push(key)
              }
            }
            return result
          }

          module.exports = baseKeysIn
        },
        { './_isPrototype': 412, './_nativeKeysIn': 429, './isObject': 475 },
      ],
      345: [
        function(require, module, exports) {
          var baseEach = require('./_baseEach'),
            isArrayLike = require('./isArrayLike')

          /**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
          function baseMap(collection, iteratee) {
            var index = -1,
              result = isArrayLike(collection) ? Array(collection.length) : []

            baseEach(collection, function(value, key, collection) {
              result[++index] = iteratee(value, key, collection)
            })
            return result
          }

          module.exports = baseMap
        },
        { './_baseEach': 323, './isArrayLike': 469 },
      ],
      346: [
        function(require, module, exports) {
          var baseIsMatch = require('./_baseIsMatch'),
            getMatchData = require('./_getMatchData'),
            matchesStrictComparable = require('./_matchesStrictComparable')

          /**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
          function baseMatches(source) {
            var matchData = getMatchData(source)
            if (matchData.length == 1 && matchData[0][2]) {
              return matchesStrictComparable(matchData[0][0], matchData[0][1])
            }
            return function(object) {
              return object === source || baseIsMatch(object, source, matchData)
            }
          }

          module.exports = baseMatches
        },
        {
          './_baseIsMatch': 337,
          './_getMatchData': 390,
          './_matchesStrictComparable': 425,
        },
      ],
      347: [
        function(require, module, exports) {
          var baseIsEqual = require('./_baseIsEqual'),
            get = require('./get'),
            hasIn = require('./hasIn'),
            isKey = require('./_isKey'),
            isStrictComparable = require('./_isStrictComparable'),
            matchesStrictComparable = require('./_matchesStrictComparable'),
            toKey = require('./_toKey')

          /** Used to compose bitmasks for comparison styles. */
          var UNORDERED_COMPARE_FLAG = 1,
            PARTIAL_COMPARE_FLAG = 2

          /**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
          function baseMatchesProperty(path, srcValue) {
            if (isKey(path) && isStrictComparable(srcValue)) {
              return matchesStrictComparable(toKey(path), srcValue)
            }
            return function(object) {
              var objValue = get(object, path)
              return objValue === undefined && objValue === srcValue
                ? hasIn(object, path)
                : baseIsEqual(
                    srcValue,
                    objValue,
                    undefined,
                    UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG
                  )
            }
          }

          module.exports = baseMatchesProperty
        },
        {
          './_baseIsEqual': 335,
          './_isKey': 409,
          './_isStrictComparable': 413,
          './_matchesStrictComparable': 425,
          './_toKey': 447,
          './get': 462,
          './hasIn': 464,
        },
      ],
      348: [
        function(require, module, exports) {
          var Stack = require('./_Stack'),
            assignMergeValue = require('./_assignMergeValue'),
            baseFor = require('./_baseFor'),
            baseMergeDeep = require('./_baseMergeDeep'),
            isObject = require('./isObject'),
            keysIn = require('./keysIn')

          /**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
          function baseMerge(object, source, srcIndex, customizer, stack) {
            if (object === source) {
              return
            }
            baseFor(
              source,
              function(srcValue, key) {
                if (isObject(srcValue)) {
                  stack || (stack = new Stack())
                  baseMergeDeep(
                    object,
                    source,
                    key,
                    srcIndex,
                    baseMerge,
                    customizer,
                    stack
                  )
                } else {
                  var newValue = customizer
                    ? customizer(
                        object[key],
                        srcValue,
                        key + '',
                        object,
                        source,
                        stack
                      )
                    : undefined

                  if (newValue === undefined) {
                    newValue = srcValue
                  }
                  assignMergeValue(object, key, newValue)
                }
              },
              keysIn
            )
          }

          module.exports = baseMerge
        },
        {
          './_Stack': 299,
          './_assignMergeValue': 315,
          './_baseFor': 326,
          './_baseMergeDeep': 349,
          './isObject': 475,
          './keysIn': 483,
        },
      ],
      349: [
        function(require, module, exports) {
          var assignMergeValue = require('./_assignMergeValue'),
            cloneBuffer = require('./_cloneBuffer'),
            cloneTypedArray = require('./_cloneTypedArray'),
            copyArray = require('./_copyArray'),
            initCloneObject = require('./_initCloneObject'),
            isArguments = require('./isArguments'),
            isArray = require('./isArray'),
            isArrayLikeObject = require('./isArrayLikeObject'),
            isBuffer = require('./isBuffer'),
            isFunction = require('./isFunction'),
            isObject = require('./isObject'),
            isPlainObject = require('./isPlainObject'),
            isTypedArray = require('./isTypedArray'),
            toPlainObject = require('./toPlainObject')

          /**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
          function baseMergeDeep(
            object,
            source,
            key,
            srcIndex,
            mergeFunc,
            customizer,
            stack
          ) {
            var objValue = object[key],
              srcValue = source[key],
              stacked = stack.get(srcValue)

            if (stacked) {
              assignMergeValue(object, key, stacked)
              return
            }
            var newValue = customizer
              ? customizer(objValue, srcValue, key + '', object, source, stack)
              : undefined

            var isCommon = newValue === undefined

            if (isCommon) {
              var isArr = isArray(srcValue),
                isBuff = !isArr && isBuffer(srcValue),
                isTyped = !isArr && !isBuff && isTypedArray(srcValue)

              newValue = srcValue
              if (isArr || isBuff || isTyped) {
                if (isArray(objValue)) {
                  newValue = objValue
                } else if (isArrayLikeObject(objValue)) {
                  newValue = copyArray(objValue)
                } else if (isBuff) {
                  isCommon = false
                  newValue = cloneBuffer(srcValue, true)
                } else if (isTyped) {
                  isCommon = false
                  newValue = cloneTypedArray(srcValue, true)
                } else {
                  newValue = []
                }
              } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                newValue = objValue
                if (isArguments(objValue)) {
                  newValue = toPlainObject(objValue)
                } else if (
                  !isObject(objValue) ||
                  (srcIndex && isFunction(objValue))
                ) {
                  newValue = initCloneObject(srcValue)
                }
              } else {
                isCommon = false
              }
            }
            if (isCommon) {
              // Recursively merge objects and arrays (susceptible to call stack limits).
              stack.set(srcValue, newValue)
              mergeFunc(newValue, srcValue, srcIndex, customizer, stack)
              stack['delete'](srcValue)
            }
            assignMergeValue(object, key, newValue)
          }

          module.exports = baseMergeDeep
        },
        {
          './_assignMergeValue': 315,
          './_cloneBuffer': 365,
          './_cloneTypedArray': 371,
          './_copyArray': 374,
          './_initCloneObject': 405,
          './isArguments': 467,
          './isArray': 468,
          './isArrayLikeObject': 470,
          './isBuffer': 471,
          './isFunction': 472,
          './isObject': 475,
          './isPlainObject': 477,
          './isTypedArray': 481,
          './toPlainObject': 497,
        },
      ],
      350: [
        function(require, module, exports) {
          var arrayMap = require('./_arrayMap'),
            baseIteratee = require('./_baseIteratee'),
            baseMap = require('./_baseMap'),
            baseSortBy = require('./_baseSortBy'),
            baseUnary = require('./_baseUnary'),
            compareMultiple = require('./_compareMultiple'),
            identity = require('./identity')

          /**
 * The base implementation of `_.orderBy` without param guards.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
 * @param {string[]} orders The sort orders of `iteratees`.
 * @returns {Array} Returns the new sorted array.
 */
          function baseOrderBy(collection, iteratees, orders) {
            var index = -1
            iteratees = arrayMap(
              iteratees.length ? iteratees : [identity],
              baseUnary(baseIteratee)
            )

            var result = baseMap(collection, function(value, key, collection) {
              var criteria = arrayMap(iteratees, function(iteratee) {
                return iteratee(value)
              })
              return { criteria: criteria, index: ++index, value: value }
            })

            return baseSortBy(result, function(object, other) {
              return compareMultiple(object, other, orders)
            })
          }

          module.exports = baseOrderBy
        },
        {
          './_arrayMap': 310,
          './_baseIteratee': 342,
          './_baseMap': 345,
          './_baseSortBy': 356,
          './_baseUnary': 359,
          './_compareMultiple': 373,
          './identity': 465,
        },
      ],
      351: [
        function(require, module, exports) {
          /**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
          function baseProperty(key) {
            return function(object) {
              return object == null ? undefined : object[key]
            }
          }

          module.exports = baseProperty
        },
        {},
      ],
      352: [
        function(require, module, exports) {
          var baseGet = require('./_baseGet')

          /**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
          function basePropertyDeep(path) {
            return function(object) {
              return baseGet(object, path)
            }
          }

          module.exports = basePropertyDeep
        },
        { './_baseGet': 328 },
      ],
      353: [
        function(require, module, exports) {
          /** Used as references for various `Number` constants. */
          var MAX_SAFE_INTEGER = 9007199254740991

          /* Built-in method references for those with the same name as other `lodash` methods. */
          var nativeFloor = Math.floor

          /**
 * The base implementation of `_.repeat` which doesn't coerce arguments.
 *
 * @private
 * @param {string} string The string to repeat.
 * @param {number} n The number of times to repeat the string.
 * @returns {string} Returns the repeated string.
 */
          function baseRepeat(string, n) {
            var result = ''
            if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
              return result
            }
            // Leverage the exponentiation by squaring algorithm for a faster repeat.
            // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
            do {
              if (n % 2) {
                result += string
              }
              n = nativeFloor(n / 2)
              if (n) {
                string += string
              }
            } while (n)

            return result
          }

          module.exports = baseRepeat
        },
        {},
      ],
      354: [
        function(require, module, exports) {
          var identity = require('./identity'),
            overRest = require('./_overRest'),
            setToString = require('./_setToString')

          /**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
          function baseRest(func, start) {
            return setToString(overRest(func, start, identity), func + '')
          }

          module.exports = baseRest
        },
        { './_overRest': 433, './_setToString': 438, './identity': 465 },
      ],
      355: [
        function(require, module, exports) {
          var constant = require('./constant'),
            defineProperty = require('./_defineProperty'),
            identity = require('./identity')

          /**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
          var baseSetToString = !defineProperty
            ? identity
            : function(func, string) {
                return defineProperty(func, 'toString', {
                  configurable: true,
                  enumerable: false,
                  value: constant(string),
                  writable: true,
                })
              }

          module.exports = baseSetToString
        },
        { './_defineProperty': 383, './constant': 454, './identity': 465 },
      ],
      356: [
        function(require, module, exports) {
          /**
 * The base implementation of `_.sortBy` which uses `comparer` to define the
 * sort order of `array` and replaces criteria objects with their corresponding
 * values.
 *
 * @private
 * @param {Array} array The array to sort.
 * @param {Function} comparer The function to define sort order.
 * @returns {Array} Returns `array`.
 */
          function baseSortBy(array, comparer) {
            var length = array.length

            array.sort(comparer)
            while (length--) {
              array[length] = array[length].value
            }
            return array
          }

          module.exports = baseSortBy
        },
        {},
      ],
      357: [
        function(require, module, exports) {
          /**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
          function baseTimes(n, iteratee) {
            var index = -1,
              result = Array(n)

            while (++index < n) {
              result[index] = iteratee(index)
            }
            return result
          }

          module.exports = baseTimes
        },
        {},
      ],
      358: [
        function(require, module, exports) {
          var Symbol = require('./_Symbol'),
            arrayMap = require('./_arrayMap'),
            isArray = require('./isArray'),
            isSymbol = require('./isSymbol')

          /** Used as references for various `Number` constants. */
          var INFINITY = 1 / 0

          /** Used to convert symbols to primitives and strings. */
          var symbolProto = Symbol ? Symbol.prototype : undefined,
            symbolToString = symbolProto ? symbolProto.toString : undefined

          /**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
          function baseToString(value) {
            // Exit early for strings to avoid a performance hit in some environments.
            if (typeof value == 'string') {
              return value
            }
            if (isArray(value)) {
              // Recursively convert values (susceptible to call stack limits).
              return arrayMap(value, baseToString) + ''
            }
            if (isSymbol(value)) {
              return symbolToString ? symbolToString.call(value) : ''
            }
            var result = value + ''
            return result == '0' && 1 / value == -INFINITY ? '-0' : result
          }

          module.exports = baseToString
        },
        {
          './_Symbol': 300,
          './_arrayMap': 310,
          './isArray': 468,
          './isSymbol': 480,
        },
      ],
      359: [
        function(require, module, exports) {
          /**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
          function baseUnary(func) {
            return function(value) {
              return func(value)
            }
          }

          module.exports = baseUnary
        },
        {},
      ],
      360: [
        function(require, module, exports) {
          var SetCache = require('./_SetCache'),
            arrayIncludes = require('./_arrayIncludes'),
            arrayIncludesWith = require('./_arrayIncludesWith'),
            cacheHas = require('./_cacheHas'),
            createSet = require('./_createSet'),
            setToArray = require('./_setToArray')

          /** Used as the size to enable large array optimizations. */
          var LARGE_ARRAY_SIZE = 200

          /**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
          function baseUniq(array, iteratee, comparator) {
            var index = -1,
              includes = arrayIncludes,
              length = array.length,
              isCommon = true,
              result = [],
              seen = result

            if (comparator) {
              isCommon = false
              includes = arrayIncludesWith
            } else if (length >= LARGE_ARRAY_SIZE) {
              var set = iteratee ? null : createSet(array)
              if (set) {
                return setToArray(set)
              }
              isCommon = false
              includes = cacheHas
              seen = new SetCache()
            } else {
              seen = iteratee ? [] : result
            }
            outer: while (++index < length) {
              var value = array[index],
                computed = iteratee ? iteratee(value) : value

              value = comparator || value !== 0 ? value : 0
              if (isCommon && computed === computed) {
                var seenIndex = seen.length
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer
                  }
                }
                if (iteratee) {
                  seen.push(computed)
                }
                result.push(value)
              } else if (!includes(seen, computed, comparator)) {
                if (seen !== result) {
                  seen.push(computed)
                }
                result.push(value)
              }
            }
            return result
          }

          module.exports = baseUniq
        },
        {
          './_SetCache': 298,
          './_arrayIncludes': 307,
          './_arrayIncludesWith': 308,
          './_cacheHas': 362,
          './_createSet': 382,
          './_setToArray': 437,
        },
      ],
      361: [
        function(require, module, exports) {
          var arrayMap = require('./_arrayMap')

          /**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
          function baseValues(object, props) {
            return arrayMap(props, function(key) {
              return object[key]
            })
          }

          module.exports = baseValues
        },
        { './_arrayMap': 310 },
      ],
      362: [
        function(require, module, exports) {
          /**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
          function cacheHas(cache, key) {
            return cache.has(key)
          }

          module.exports = cacheHas
        },
        {},
      ],
      363: [
        function(require, module, exports) {
          var isArray = require('./isArray'),
            stringToPath = require('./_stringToPath')

          /**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array} Returns the cast property path array.
 */
          function castPath(value) {
            return isArray(value) ? value : stringToPath(value)
          }

          module.exports = castPath
        },
        { './_stringToPath': 446, './isArray': 468 },
      ],
      364: [
        function(require, module, exports) {
          var Uint8Array = require('./_Uint8Array')

          /**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
          function cloneArrayBuffer(arrayBuffer) {
            var result = new arrayBuffer.constructor(arrayBuffer.byteLength)
            new Uint8Array(result).set(new Uint8Array(arrayBuffer))
            return result
          }

          module.exports = cloneArrayBuffer
        },
        { './_Uint8Array': 301 },
      ],
      365: [
        function(require, module, exports) {
          var root = require('./_root')

          /** Detect free variable `exports`. */
          var freeExports =
            typeof exports == 'object' &&
            exports &&
            !exports.nodeType &&
            exports

          /** Detect free variable `module`. */
          var freeModule =
            freeExports &&
            typeof module == 'object' &&
            module &&
            !module.nodeType &&
            module

          /** Detect the popular CommonJS extension `module.exports`. */
          var moduleExports = freeModule && freeModule.exports === freeExports

          /** Built-in value references. */
          var Buffer = moduleExports ? root.Buffer : undefined,
            allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined

          /**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
          function cloneBuffer(buffer, isDeep) {
            if (isDeep) {
              return buffer.slice()
            }
            var length = buffer.length,
              result = allocUnsafe
                ? allocUnsafe(length)
                : new buffer.constructor(length)

            buffer.copy(result)
            return result
          }

          module.exports = cloneBuffer
        },
        { './_root': 434 },
      ],
      366: [
        function(require, module, exports) {
          var cloneArrayBuffer = require('./_cloneArrayBuffer')

          /**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
          function cloneDataView(dataView, isDeep) {
            var buffer = isDeep
              ? cloneArrayBuffer(dataView.buffer)
              : dataView.buffer
            return new dataView.constructor(
              buffer,
              dataView.byteOffset,
              dataView.byteLength
            )
          }

          module.exports = cloneDataView
        },
        { './_cloneArrayBuffer': 364 },
      ],
      367: [
        function(require, module, exports) {
          var addMapEntry = require('./_addMapEntry'),
            arrayReduce = require('./_arrayReduce'),
            mapToArray = require('./_mapToArray')

          /**
 * Creates a clone of `map`.
 *
 * @private
 * @param {Object} map The map to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned map.
 */
          function cloneMap(map, isDeep, cloneFunc) {
            var array = isDeep
              ? cloneFunc(mapToArray(map), true)
              : mapToArray(map)
            return arrayReduce(array, addMapEntry, new map.constructor())
          }

          module.exports = cloneMap
        },
        { './_addMapEntry': 303, './_arrayReduce': 312, './_mapToArray': 424 },
      ],
      368: [
        function(require, module, exports) {
          /** Used to match `RegExp` flags from their coerced string values. */
          var reFlags = /\w*$/

          /**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
          function cloneRegExp(regexp) {
            var result = new regexp.constructor(
              regexp.source,
              reFlags.exec(regexp)
            )
            result.lastIndex = regexp.lastIndex
            return result
          }

          module.exports = cloneRegExp
        },
        {},
      ],
      369: [
        function(require, module, exports) {
          var addSetEntry = require('./_addSetEntry'),
            arrayReduce = require('./_arrayReduce'),
            setToArray = require('./_setToArray')

          /**
 * Creates a clone of `set`.
 *
 * @private
 * @param {Object} set The set to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned set.
 */
          function cloneSet(set, isDeep, cloneFunc) {
            var array = isDeep
              ? cloneFunc(setToArray(set), true)
              : setToArray(set)
            return arrayReduce(array, addSetEntry, new set.constructor())
          }

          module.exports = cloneSet
        },
        { './_addSetEntry': 304, './_arrayReduce': 312, './_setToArray': 437 },
      ],
      370: [
        function(require, module, exports) {
          var Symbol = require('./_Symbol')

          /** Used to convert symbols to primitives and strings. */
          var symbolProto = Symbol ? Symbol.prototype : undefined,
            symbolValueOf = symbolProto ? symbolProto.valueOf : undefined

          /**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
          function cloneSymbol(symbol) {
            return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {}
          }

          module.exports = cloneSymbol
        },
        { './_Symbol': 300 },
      ],
      371: [
        function(require, module, exports) {
          var cloneArrayBuffer = require('./_cloneArrayBuffer')

          /**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
          function cloneTypedArray(typedArray, isDeep) {
            var buffer = isDeep
              ? cloneArrayBuffer(typedArray.buffer)
              : typedArray.buffer
            return new typedArray.constructor(
              buffer,
              typedArray.byteOffset,
              typedArray.length
            )
          }

          module.exports = cloneTypedArray
        },
        { './_cloneArrayBuffer': 364 },
      ],
      372: [
        function(require, module, exports) {
          var isSymbol = require('./isSymbol')

          /**
 * Compares values to sort them in ascending order.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {number} Returns the sort order indicator for `value`.
 */
          function compareAscending(value, other) {
            if (value !== other) {
              var valIsDefined = value !== undefined,
                valIsNull = value === null,
                valIsReflexive = value === value,
                valIsSymbol = isSymbol(value)

              var othIsDefined = other !== undefined,
                othIsNull = other === null,
                othIsReflexive = other === other,
                othIsSymbol = isSymbol(other)

              if (
                (!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
                (valIsSymbol &&
                  othIsDefined &&
                  othIsReflexive &&
                  !othIsNull &&
                  !othIsSymbol) ||
                (valIsNull && othIsDefined && othIsReflexive) ||
                (!valIsDefined && othIsReflexive) ||
                !valIsReflexive
              ) {
                return 1
              }
              if (
                (!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
                (othIsSymbol &&
                  valIsDefined &&
                  valIsReflexive &&
                  !valIsNull &&
                  !valIsSymbol) ||
                (othIsNull && valIsDefined && valIsReflexive) ||
                (!othIsDefined && valIsReflexive) ||
                !othIsReflexive
              ) {
                return -1
              }
            }
            return 0
          }

          module.exports = compareAscending
        },
        { './isSymbol': 480 },
      ],
      373: [
        function(require, module, exports) {
          var compareAscending = require('./_compareAscending')

          /**
 * Used by `_.orderBy` to compare multiple properties of a value to another
 * and stable sort them.
 *
 * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
 * specify an order of "desc" for descending or "asc" for ascending sort order
 * of corresponding values.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {boolean[]|string[]} orders The order to sort by for each property.
 * @returns {number} Returns the sort order indicator for `object`.
 */
          function compareMultiple(object, other, orders) {
            var index = -1,
              objCriteria = object.criteria,
              othCriteria = other.criteria,
              length = objCriteria.length,
              ordersLength = orders.length

            while (++index < length) {
              var result = compareAscending(
                objCriteria[index],
                othCriteria[index]
              )
              if (result) {
                if (index >= ordersLength) {
                  return result
                }
                var order = orders[index]
                return result * (order == 'desc' ? -1 : 1)
              }
            }
            // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
            // that causes it, under certain circumstances, to provide the same value for
            // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
            // for more details.
            //
            // This also ensures a stable sort in V8 and other engines.
            // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
            return object.index - other.index
          }

          module.exports = compareMultiple
        },
        { './_compareAscending': 372 },
      ],
      374: [
        function(require, module, exports) {
          /**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
          function copyArray(source, array) {
            var index = -1,
              length = source.length

            array || (array = Array(length))
            while (++index < length) {
              array[index] = source[index]
            }
            return array
          }

          module.exports = copyArray
        },
        {},
      ],
      375: [
        function(require, module, exports) {
          var assignValue = require('./_assignValue'),
            baseAssignValue = require('./_baseAssignValue')

          /**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
          function copyObject(source, props, object, customizer) {
            var isNew = !object
            object || (object = {})

            var index = -1,
              length = props.length

            while (++index < length) {
              var key = props[index]

              var newValue = customizer
                ? customizer(object[key], source[key], key, object, source)
                : undefined

              if (newValue === undefined) {
                newValue = source[key]
              }
              if (isNew) {
                baseAssignValue(object, key, newValue)
              } else {
                assignValue(object, key, newValue)
              }
            }
            return object
          }

          module.exports = copyObject
        },
        { './_assignValue': 316, './_baseAssignValue': 319 },
      ],
      376: [
        function(require, module, exports) {
          var copyObject = require('./_copyObject'),
            getSymbols = require('./_getSymbols')

          /**
 * Copies own symbol properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
          function copySymbols(source, object) {
            return copyObject(source, getSymbols(source), object)
          }

          module.exports = copySymbols
        },
        { './_copyObject': 375, './_getSymbols': 394 },
      ],
      377: [
        function(require, module, exports) {
          var root = require('./_root')

          /** Used to detect overreaching core-js shims. */
          var coreJsData = root['__core-js_shared__']

          module.exports = coreJsData
        },
        { './_root': 434 },
      ],
      378: [
        function(require, module, exports) {
          var baseRest = require('./_baseRest'),
            isIterateeCall = require('./_isIterateeCall')

          /**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
          function createAssigner(assigner) {
            return baseRest(function(object, sources) {
              var index = -1,
                length = sources.length,
                customizer = length > 1 ? sources[length - 1] : undefined,
                guard = length > 2 ? sources[2] : undefined

              customizer = assigner.length > 3 &&
                typeof customizer == 'function'
                ? (length--, customizer)
                : undefined

              if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                customizer = length < 3 ? undefined : customizer
                length = 1
              }
              object = Object(object)
              while (++index < length) {
                var source = sources[index]
                if (source) {
                  assigner(object, source, index, customizer)
                }
              }
              return object
            })
          }

          module.exports = createAssigner
        },
        { './_baseRest': 354, './_isIterateeCall': 408 },
      ],
      379: [
        function(require, module, exports) {
          var isArrayLike = require('./isArrayLike')

          /**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
          function createBaseEach(eachFunc, fromRight) {
            return function(collection, iteratee) {
              if (collection == null) {
                return collection
              }
              if (!isArrayLike(collection)) {
                return eachFunc(collection, iteratee)
              }
              var length = collection.length,
                index = fromRight ? length : -1,
                iterable = Object(collection)

              while (fromRight ? index-- : ++index < length) {
                if (iteratee(iterable[index], index, iterable) === false) {
                  break
                }
              }
              return collection
            }
          }

          module.exports = createBaseEach
        },
        { './isArrayLike': 469 },
      ],
      380: [
        function(require, module, exports) {
          /**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
          function createBaseFor(fromRight) {
            return function(object, iteratee, keysFunc) {
              var index = -1,
                iterable = Object(object),
                props = keysFunc(object),
                length = props.length

              while (length--) {
                var key = props[fromRight ? length : ++index]
                if (iteratee(iterable[key], key, iterable) === false) {
                  break
                }
              }
              return object
            }
          }

          module.exports = createBaseFor
        },
        {},
      ],
      381: [
        function(require, module, exports) {
          var baseIteratee = require('./_baseIteratee'),
            isArrayLike = require('./isArrayLike'),
            keys = require('./keys')

          /**
 * Creates a `_.find` or `_.findLast` function.
 *
 * @private
 * @param {Function} findIndexFunc The function to find the collection index.
 * @returns {Function} Returns the new find function.
 */
          function createFind(findIndexFunc) {
            return function(collection, predicate, fromIndex) {
              var iterable = Object(collection)
              if (!isArrayLike(collection)) {
                var iteratee = baseIteratee(predicate, 3)
                collection = keys(collection)
                predicate = function(key) {
                  return iteratee(iterable[key], key, iterable)
                }
              }
              var index = findIndexFunc(collection, predicate, fromIndex)
              return index > -1
                ? iterable[iteratee ? collection[index] : index]
                : undefined
            }
          }

          module.exports = createFind
        },
        { './_baseIteratee': 342, './isArrayLike': 469, './keys': 482 },
      ],
      382: [
        function(require, module, exports) {
          var Set = require('./_Set'),
            noop = require('./noop'),
            setToArray = require('./_setToArray')

          /** Used as references for various `Number` constants. */
          var INFINITY = 1 / 0

          /**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */
          var createSet = !(
            Set && 1 / setToArray(new Set([, -0]))[1] == INFINITY
          )
            ? noop
            : function(values) {
                return new Set(values)
              }

          module.exports = createSet
        },
        { './_Set': 297, './_setToArray': 437, './noop': 487 },
      ],
      383: [
        function(require, module, exports) {
          var getNative = require('./_getNative')

          var defineProperty = (function() {
            try {
              var func = getNative(Object, 'defineProperty')
              func({}, '', {})
              return func
            } catch (e) {}
          })()

          module.exports = defineProperty
        },
        { './_getNative': 391 },
      ],
      384: [
        function(require, module, exports) {
          var SetCache = require('./_SetCache'),
            arraySome = require('./_arraySome'),
            cacheHas = require('./_cacheHas')

          /** Used to compose bitmasks for comparison styles. */
          var UNORDERED_COMPARE_FLAG = 1,
            PARTIAL_COMPARE_FLAG = 2

          /**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
          function equalArrays(
            array,
            other,
            equalFunc,
            customizer,
            bitmask,
            stack
          ) {
            var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
              arrLength = array.length,
              othLength = other.length

            if (
              arrLength != othLength &&
              !(isPartial && othLength > arrLength)
            ) {
              return false
            }
            // Assume cyclic values are equal.
            var stacked = stack.get(array)
            if (stacked && stack.get(other)) {
              return stacked == other
            }
            var index = -1,
              result = true,
              seen = bitmask & UNORDERED_COMPARE_FLAG
                ? new SetCache()
                : undefined

            stack.set(array, other)
            stack.set(other, array)

            // Ignore non-index properties.
            while (++index < arrLength) {
              var arrValue = array[index],
                othValue = other[index]

              if (customizer) {
                var compared = isPartial
                  ? customizer(othValue, arrValue, index, other, array, stack)
                  : customizer(arrValue, othValue, index, array, other, stack)
              }
              if (compared !== undefined) {
                if (compared) {
                  continue
                }
                result = false
                break
              }
              // Recursively compare arrays (susceptible to call stack limits).
              if (seen) {
                if (
                  !arraySome(other, function(othValue, othIndex) {
                    if (
                      !cacheHas(seen, othIndex) &&
                      (arrValue === othValue ||
                        equalFunc(
                          arrValue,
                          othValue,
                          customizer,
                          bitmask,
                          stack
                        ))
                    ) {
                      return seen.push(othIndex)
                    }
                  })
                ) {
                  result = false
                  break
                }
              } else if (
                !(
                  arrValue === othValue ||
                  equalFunc(arrValue, othValue, customizer, bitmask, stack)
                )
              ) {
                result = false
                break
              }
            }
            stack['delete'](array)
            stack['delete'](other)
            return result
          }

          module.exports = equalArrays
        },
        { './_SetCache': 298, './_arraySome': 313, './_cacheHas': 362 },
      ],
      385: [
        function(require, module, exports) {
          var Symbol = require('./_Symbol'),
            Uint8Array = require('./_Uint8Array'),
            eq = require('./eq'),
            equalArrays = require('./_equalArrays'),
            mapToArray = require('./_mapToArray'),
            setToArray = require('./_setToArray')

          /** Used to compose bitmasks for comparison styles. */
          var UNORDERED_COMPARE_FLAG = 1,
            PARTIAL_COMPARE_FLAG = 2

          /** `Object#toString` result references. */
          var boolTag = '[object Boolean]',
            dateTag = '[object Date]',
            errorTag = '[object Error]',
            mapTag = '[object Map]',
            numberTag = '[object Number]',
            regexpTag = '[object RegExp]',
            setTag = '[object Set]',
            stringTag = '[object String]',
            symbolTag = '[object Symbol]'

          var arrayBufferTag = '[object ArrayBuffer]',
            dataViewTag = '[object DataView]'

          /** Used to convert symbols to primitives and strings. */
          var symbolProto = Symbol ? Symbol.prototype : undefined,
            symbolValueOf = symbolProto ? symbolProto.valueOf : undefined

          /**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
          function equalByTag(
            object,
            other,
            tag,
            equalFunc,
            customizer,
            bitmask,
            stack
          ) {
            switch (tag) {
              case dataViewTag:
                if (
                  object.byteLength != other.byteLength ||
                  object.byteOffset != other.byteOffset
                ) {
                  return false
                }
                object = object.buffer
                other = other.buffer

              case arrayBufferTag:
                if (
                  object.byteLength != other.byteLength ||
                  !equalFunc(new Uint8Array(object), new Uint8Array(other))
                ) {
                  return false
                }
                return true

              case boolTag:
              case dateTag:
              case numberTag:
                // Coerce booleans to `1` or `0` and dates to milliseconds.
                // Invalid dates are coerced to `NaN`.
                return eq(+object, +other)

              case errorTag:
                return (
                  object.name == other.name && object.message == other.message
                )

              case regexpTag:
              case stringTag:
                // Coerce regexes to strings and treat strings, primitives and objects,
                // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
                // for more details.
                return object == other + ''

              case mapTag:
                var convert = mapToArray

              case setTag:
                var isPartial = bitmask & PARTIAL_COMPARE_FLAG
                convert || (convert = setToArray)

                if (object.size != other.size && !isPartial) {
                  return false
                }
                // Assume cyclic values are equal.
                var stacked = stack.get(object)
                if (stacked) {
                  return stacked == other
                }
                bitmask |= UNORDERED_COMPARE_FLAG

                // Recursively compare objects (susceptible to call stack limits).
                stack.set(object, other)
                var result = equalArrays(
                  convert(object),
                  convert(other),
                  equalFunc,
                  customizer,
                  bitmask,
                  stack
                )
                stack['delete'](object)
                return result

              case symbolTag:
                if (symbolValueOf) {
                  return symbolValueOf.call(object) == symbolValueOf.call(other)
                }
            }
            return false
          }

          module.exports = equalByTag
        },
        {
          './_Symbol': 300,
          './_Uint8Array': 301,
          './_equalArrays': 384,
          './_mapToArray': 424,
          './_setToArray': 437,
          './eq': 456,
        },
      ],
      386: [
        function(require, module, exports) {
          var keys = require('./keys')

          /** Used to compose bitmasks for comparison styles. */
          var PARTIAL_COMPARE_FLAG = 2

          /** Used for built-in method references. */
          var objectProto = Object.prototype

          /** Used to check objects for own properties. */
          var hasOwnProperty = objectProto.hasOwnProperty

          /**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
          function equalObjects(
            object,
            other,
            equalFunc,
            customizer,
            bitmask,
            stack
          ) {
            var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
              objProps = keys(object),
              objLength = objProps.length,
              othProps = keys(other),
              othLength = othProps.length

            if (objLength != othLength && !isPartial) {
              return false
            }
            var index = objLength
            while (index--) {
              var key = objProps[index]
              if (
                !(isPartial ? key in other : hasOwnProperty.call(other, key))
              ) {
                return false
              }
            }
            // Assume cyclic values are equal.
            var stacked = stack.get(object)
            if (stacked && stack.get(other)) {
              return stacked == other
            }
            var result = true
            stack.set(object, other)
            stack.set(other, object)

            var skipCtor = isPartial
            while (++index < objLength) {
              key = objProps[index]
              var objValue = object[key],
                othValue = other[key]

              if (customizer) {
                var compared = isPartial
                  ? customizer(othValue, objValue, key, other, object, stack)
                  : customizer(objValue, othValue, key, object, other, stack)
              }
              // Recursively compare objects (susceptible to call stack limits).
              if (
                !(compared === undefined
                  ? objValue === othValue ||
                      equalFunc(objValue, othValue, customizer, bitmask, stack)
                  : compared)
              ) {
                result = false
                break
              }
              skipCtor || (skipCtor = key == 'constructor')
            }
            if (result && !skipCtor) {
              var objCtor = object.constructor,
                othCtor = other.constructor

              // Non `Object` object instances with different constructors are not equal.
              if (
                objCtor != othCtor &&
                ('constructor' in object && 'constructor' in other) &&
                !(
                  typeof objCtor == 'function' &&
                  objCtor instanceof objCtor &&
                  typeof othCtor == 'function' &&
                  othCtor instanceof othCtor
                )
              ) {
                result = false
              }
            }
            stack['delete'](object)
            stack['delete'](other)
            return result
          }

          module.exports = equalObjects
        },
        { './keys': 482 },
      ],
      387: [
        function(require, module, exports) {
          ;(function(global) {
            /** Detect free variable `global` from Node.js. */
            var freeGlobal =
              typeof global == 'object' &&
              global &&
              global.Object === Object &&
              global

            module.exports = freeGlobal
          }.call(
            this,
            typeof global !== 'undefined'
              ? global
              : typeof self !== 'undefined'
                ? self
                : typeof window !== 'undefined' ? window : {}
          ))
        },
        {},
      ],
      388: [
        function(require, module, exports) {
          var baseGetAllKeys = require('./_baseGetAllKeys'),
            getSymbols = require('./_getSymbols'),
            keys = require('./keys')

          /**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
          function getAllKeys(object) {
            return baseGetAllKeys(object, keys, getSymbols)
          }

          module.exports = getAllKeys
        },
        { './_baseGetAllKeys': 329, './_getSymbols': 394, './keys': 482 },
      ],
      389: [
        function(require, module, exports) {
          var isKeyable = require('./_isKeyable')

          /**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
          function getMapData(map, key) {
            var data = map.__data__
            return isKeyable(key)
              ? data[typeof key == 'string' ? 'string' : 'hash']
              : data.map
          }

          module.exports = getMapData
        },
        { './_isKeyable': 410 },
      ],
      390: [
        function(require, module, exports) {
          var isStrictComparable = require('./_isStrictComparable'),
            keys = require('./keys')

          /**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
          function getMatchData(object) {
            var result = keys(object),
              length = result.length

            while (length--) {
              var key = result[length],
                value = object[key]

              result[length] = [key, value, isStrictComparable(value)]
            }
            return result
          }

          module.exports = getMatchData
        },
        { './_isStrictComparable': 413, './keys': 482 },
      ],
      391: [
        function(require, module, exports) {
          var baseIsNative = require('./_baseIsNative'),
            getValue = require('./_getValue')

          /**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
          function getNative(object, key) {
            var value = getValue(object, key)
            return baseIsNative(value) ? value : undefined
          }

          module.exports = getNative
        },
        { './_baseIsNative': 339, './_getValue': 396 },
      ],
      392: [
        function(require, module, exports) {
          var overArg = require('./_overArg')

          /** Built-in value references. */
          var getPrototype = overArg(Object.getPrototypeOf, Object)

          module.exports = getPrototype
        },
        { './_overArg': 432 },
      ],
      393: [
        function(require, module, exports) {
          var Symbol = require('./_Symbol')

          /** Used for built-in method references. */
          var objectProto = Object.prototype

          /** Used to check objects for own properties. */
          var hasOwnProperty = objectProto.hasOwnProperty

          /**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
          var nativeObjectToString = objectProto.toString

          /** Built-in value references. */
          var symToStringTag = Symbol ? Symbol.toStringTag : undefined

          /**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
          function getRawTag(value) {
            var isOwn = hasOwnProperty.call(value, symToStringTag),
              tag = value[symToStringTag]

            try {
              value[symToStringTag] = undefined
              var unmasked = true
            } catch (e) {}

            var result = nativeObjectToString.call(value)
            if (unmasked) {
              if (isOwn) {
                value[symToStringTag] = tag
              } else {
                delete value[symToStringTag]
              }
            }
            return result
          }

          module.exports = getRawTag
        },
        { './_Symbol': 300 },
      ],
      394: [
        function(require, module, exports) {
          var overArg = require('./_overArg'),
            stubArray = require('./stubArray')

          /* Built-in method references for those with the same name as other `lodash` methods. */
          var nativeGetSymbols = Object.getOwnPropertySymbols

          /**
 * Creates an array of the own enumerable symbol properties of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
          var getSymbols = nativeGetSymbols
            ? overArg(nativeGetSymbols, Object)
            : stubArray

          module.exports = getSymbols
        },
        { './_overArg': 432, './stubArray': 492 },
      ],
      395: [
        function(require, module, exports) {
          var DataView = require('./_DataView'),
            Map = require('./_Map'),
            Promise = require('./_Promise'),
            Set = require('./_Set'),
            WeakMap = require('./_WeakMap'),
            baseGetTag = require('./_baseGetTag'),
            toSource = require('./_toSource')

          /** `Object#toString` result references. */
          var mapTag = '[object Map]',
            objectTag = '[object Object]',
            promiseTag = '[object Promise]',
            setTag = '[object Set]',
            weakMapTag = '[object WeakMap]'

          var dataViewTag = '[object DataView]'

          /** Used to detect maps, sets, and weakmaps. */
          var dataViewCtorString = toSource(DataView),
            mapCtorString = toSource(Map),
            promiseCtorString = toSource(Promise),
            setCtorString = toSource(Set),
            weakMapCtorString = toSource(WeakMap)

          /**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
          var getTag = baseGetTag

          // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
          if (
            (DataView &&
              getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
            (Map && getTag(new Map()) != mapTag) ||
            (Promise && getTag(Promise.resolve()) != promiseTag) ||
            (Set && getTag(new Set()) != setTag) ||
            (WeakMap && getTag(new WeakMap()) != weakMapTag)
          ) {
            getTag = function(value) {
              var result = baseGetTag(value),
                Ctor = result == objectTag ? value.constructor : undefined,
                ctorString = Ctor ? toSource(Ctor) : ''

              if (ctorString) {
                switch (ctorString) {
                  case dataViewCtorString:
                    return dataViewTag
                  case mapCtorString:
                    return mapTag
                  case promiseCtorString:
                    return promiseTag
                  case setCtorString:
                    return setTag
                  case weakMapCtorString:
                    return weakMapTag
                }
              }
              return result
            }
          }

          module.exports = getTag
        },
        {
          './_DataView': 291,
          './_Map': 294,
          './_Promise': 296,
          './_Set': 297,
          './_WeakMap': 302,
          './_baseGetTag': 330,
          './_toSource': 448,
        },
      ],
      396: [
        function(require, module, exports) {
          /**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
          function getValue(object, key) {
            return object == null ? undefined : object[key]
          }

          module.exports = getValue
        },
        {},
      ],
      397: [
        function(require, module, exports) {
          var castPath = require('./_castPath'),
            isArguments = require('./isArguments'),
            isArray = require('./isArray'),
            isIndex = require('./_isIndex'),
            isKey = require('./_isKey'),
            isLength = require('./isLength'),
            toKey = require('./_toKey')

          /**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
          function hasPath(object, path, hasFunc) {
            path = isKey(path, object) ? [path] : castPath(path)

            var index = -1,
              length = path.length,
              result = false

            while (++index < length) {
              var key = toKey(path[index])
              if (!(result = object != null && hasFunc(object, key))) {
                break
              }
              object = object[key]
            }
            if (result || ++index != length) {
              return result
            }
            length = object == null ? 0 : object.length
            return (
              !!length &&
              isLength(length) &&
              isIndex(key, length) &&
              (isArray(object) || isArguments(object))
            )
          }

          module.exports = hasPath
        },
        {
          './_castPath': 363,
          './_isIndex': 407,
          './_isKey': 409,
          './_toKey': 447,
          './isArguments': 467,
          './isArray': 468,
          './isLength': 474,
        },
      ],
      398: [
        function(require, module, exports) {
          var nativeCreate = require('./_nativeCreate')

          /**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
          function hashClear() {
            this.__data__ = nativeCreate ? nativeCreate(null) : {}
            this.size = 0
          }

          module.exports = hashClear
        },
        { './_nativeCreate': 427 },
      ],
      399: [
        function(require, module, exports) {
          /**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
          function hashDelete(key) {
            var result = this.has(key) && delete this.__data__[key]
            this.size -= result ? 1 : 0
            return result
          }

          module.exports = hashDelete
        },
        {},
      ],
      400: [
        function(require, module, exports) {
          var nativeCreate = require('./_nativeCreate')

          /** Used to stand-in for `undefined` hash values. */
          var HASH_UNDEFINED = '__lodash_hash_undefined__'

          /** Used for built-in method references. */
          var objectProto = Object.prototype

          /** Used to check objects for own properties. */
          var hasOwnProperty = objectProto.hasOwnProperty

          /**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
          function hashGet(key) {
            var data = this.__data__
            if (nativeCreate) {
              var result = data[key]
              return result === HASH_UNDEFINED ? undefined : result
            }
            return hasOwnProperty.call(data, key) ? data[key] : undefined
          }

          module.exports = hashGet
        },
        { './_nativeCreate': 427 },
      ],
      401: [
        function(require, module, exports) {
          var nativeCreate = require('./_nativeCreate')

          /** Used for built-in method references. */
          var objectProto = Object.prototype

          /** Used to check objects for own properties. */
          var hasOwnProperty = objectProto.hasOwnProperty

          /**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
          function hashHas(key) {
            var data = this.__data__
            return nativeCreate
              ? data[key] !== undefined
              : hasOwnProperty.call(data, key)
          }

          module.exports = hashHas
        },
        { './_nativeCreate': 427 },
      ],
      402: [
        function(require, module, exports) {
          var nativeCreate = require('./_nativeCreate')

          /** Used to stand-in for `undefined` hash values. */
          var HASH_UNDEFINED = '__lodash_hash_undefined__'

          /**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
          function hashSet(key, value) {
            var data = this.__data__
            this.size += this.has(key) ? 0 : 1
            data[key] = nativeCreate && value === undefined
              ? HASH_UNDEFINED
              : value
            return this
          }

          module.exports = hashSet
        },
        { './_nativeCreate': 427 },
      ],
      403: [
        function(require, module, exports) {
          /** Used for built-in method references. */
          var objectProto = Object.prototype

          /** Used to check objects for own properties. */
          var hasOwnProperty = objectProto.hasOwnProperty

          /**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
          function initCloneArray(array) {
            var length = array.length,
              result = array.constructor(length)

            // Add properties assigned by `RegExp#exec`.
            if (
              length &&
              typeof array[0] == 'string' &&
              hasOwnProperty.call(array, 'index')
            ) {
              result.index = array.index
              result.input = array.input
            }
            return result
          }

          module.exports = initCloneArray
        },
        {},
      ],
      404: [
        function(require, module, exports) {
          var cloneArrayBuffer = require('./_cloneArrayBuffer'),
            cloneDataView = require('./_cloneDataView'),
            cloneMap = require('./_cloneMap'),
            cloneRegExp = require('./_cloneRegExp'),
            cloneSet = require('./_cloneSet'),
            cloneSymbol = require('./_cloneSymbol'),
            cloneTypedArray = require('./_cloneTypedArray')

          /** `Object#toString` result references. */
          var boolTag = '[object Boolean]',
            dateTag = '[object Date]',
            mapTag = '[object Map]',
            numberTag = '[object Number]',
            regexpTag = '[object RegExp]',
            setTag = '[object Set]',
            stringTag = '[object String]',
            symbolTag = '[object Symbol]'

          var arrayBufferTag = '[object ArrayBuffer]',
            dataViewTag = '[object DataView]',
            float32Tag = '[object Float32Array]',
            float64Tag = '[object Float64Array]',
            int8Tag = '[object Int8Array]',
            int16Tag = '[object Int16Array]',
            int32Tag = '[object Int32Array]',
            uint8Tag = '[object Uint8Array]',
            uint8ClampedTag = '[object Uint8ClampedArray]',
            uint16Tag = '[object Uint16Array]',
            uint32Tag = '[object Uint32Array]'

          /**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
          function initCloneByTag(object, tag, cloneFunc, isDeep) {
            var Ctor = object.constructor
            switch (tag) {
              case arrayBufferTag:
                return cloneArrayBuffer(object)

              case boolTag:
              case dateTag:
                return new Ctor(+object)

              case dataViewTag:
                return cloneDataView(object, isDeep)

              case float32Tag:
              case float64Tag:
              case int8Tag:
              case int16Tag:
              case int32Tag:
              case uint8Tag:
              case uint8ClampedTag:
              case uint16Tag:
              case uint32Tag:
                return cloneTypedArray(object, isDeep)

              case mapTag:
                return cloneMap(object, isDeep, cloneFunc)

              case numberTag:
              case stringTag:
                return new Ctor(object)

              case regexpTag:
                return cloneRegExp(object)

              case setTag:
                return cloneSet(object, isDeep, cloneFunc)

              case symbolTag:
                return cloneSymbol(object)
            }
          }

          module.exports = initCloneByTag
        },
        {
          './_cloneArrayBuffer': 364,
          './_cloneDataView': 366,
          './_cloneMap': 367,
          './_cloneRegExp': 368,
          './_cloneSet': 369,
          './_cloneSymbol': 370,
          './_cloneTypedArray': 371,
        },
      ],
      405: [
        function(require, module, exports) {
          var baseCreate = require('./_baseCreate'),
            getPrototype = require('./_getPrototype'),
            isPrototype = require('./_isPrototype')

          /**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
          function initCloneObject(object) {
            return typeof object.constructor == 'function' &&
              !isPrototype(object)
              ? baseCreate(getPrototype(object))
              : {}
          }

          module.exports = initCloneObject
        },
        { './_baseCreate': 322, './_getPrototype': 392, './_isPrototype': 412 },
      ],
      406: [
        function(require, module, exports) {
          var Symbol = require('./_Symbol'),
            isArguments = require('./isArguments'),
            isArray = require('./isArray')

          /** Built-in value references. */
          var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined

          /**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
          function isFlattenable(value) {
            return (
              isArray(value) ||
              isArguments(value) ||
              !!(spreadableSymbol && value && value[spreadableSymbol])
            )
          }

          module.exports = isFlattenable
        },
        { './_Symbol': 300, './isArguments': 467, './isArray': 468 },
      ],
      407: [
        function(require, module, exports) {
          /** Used as references for various `Number` constants. */
          var MAX_SAFE_INTEGER = 9007199254740991

          /** Used to detect unsigned integer values. */
          var reIsUint = /^(?:0|[1-9]\d*)$/

          /**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
          function isIndex(value, length) {
            length = length == null ? MAX_SAFE_INTEGER : length
            return (
              !!length &&
              (typeof value == 'number' || reIsUint.test(value)) &&
              (value > -1 && value % 1 == 0 && value < length)
            )
          }

          module.exports = isIndex
        },
        {},
      ],
      408: [
        function(require, module, exports) {
          var eq = require('./eq'),
            isArrayLike = require('./isArrayLike'),
            isIndex = require('./_isIndex'),
            isObject = require('./isObject')

          /**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
          function isIterateeCall(value, index, object) {
            if (!isObject(object)) {
              return false
            }
            var type = typeof index
            if (
              type == 'number'
                ? isArrayLike(object) && isIndex(index, object.length)
                : type == 'string' && index in object
            ) {
              return eq(object[index], value)
            }
            return false
          }

          module.exports = isIterateeCall
        },
        {
          './_isIndex': 407,
          './eq': 456,
          './isArrayLike': 469,
          './isObject': 475,
        },
      ],
      409: [
        function(require, module, exports) {
          var isArray = require('./isArray'),
            isSymbol = require('./isSymbol')

          /** Used to match property names within property paths. */
          var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
            reIsPlainProp = /^\w*$/

          /**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
          function isKey(value, object) {
            if (isArray(value)) {
              return false
            }
            var type = typeof value
            if (
              type == 'number' ||
              type == 'symbol' ||
              type == 'boolean' ||
              value == null ||
              isSymbol(value)
            ) {
              return true
            }
            return (
              reIsPlainProp.test(value) ||
              !reIsDeepProp.test(value) ||
              (object != null && value in Object(object))
            )
          }

          module.exports = isKey
        },
        { './isArray': 468, './isSymbol': 480 },
      ],
      410: [
        function(require, module, exports) {
          /**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
          function isKeyable(value) {
            var type = typeof value
            return type == 'string' ||
              type == 'number' ||
              type == 'symbol' ||
              type == 'boolean'
              ? value !== '__proto__'
              : value === null
          }

          module.exports = isKeyable
        },
        {},
      ],
      411: [
        function(require, module, exports) {
          var coreJsData = require('./_coreJsData')

          /** Used to detect methods masquerading as native. */
          var maskSrcKey = (function() {
            var uid = /[^.]+$/.exec(
              (coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO) || ''
            )
            return uid ? 'Symbol(src)_1.' + uid : ''
          })()

          /**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
          function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func
          }

          module.exports = isMasked
        },
        { './_coreJsData': 377 },
      ],
      412: [
        function(require, module, exports) {
          /** Used for built-in method references. */
          var objectProto = Object.prototype

          /**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
          function isPrototype(value) {
            var Ctor = value && value.constructor,
              proto =
                (typeof Ctor == 'function' && Ctor.prototype) || objectProto

            return value === proto
          }

          module.exports = isPrototype
        },
        {},
      ],
      413: [
        function(require, module, exports) {
          var isObject = require('./isObject')

          /**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
          function isStrictComparable(value) {
            return value === value && !isObject(value)
          }

          module.exports = isStrictComparable
        },
        { './isObject': 475 },
      ],
      414: [
        function(require, module, exports) {
          /**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
          function listCacheClear() {
            this.__data__ = []
            this.size = 0
          }

          module.exports = listCacheClear
        },
        {},
      ],
      415: [
        function(require, module, exports) {
          var assocIndexOf = require('./_assocIndexOf')

          /** Used for built-in method references. */
          var arrayProto = Array.prototype

          /** Built-in value references. */
          var splice = arrayProto.splice

          /**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
          function listCacheDelete(key) {
            var data = this.__data__,
              index = assocIndexOf(data, key)

            if (index < 0) {
              return false
            }
            var lastIndex = data.length - 1
            if (index == lastIndex) {
              data.pop()
            } else {
              splice.call(data, index, 1)
            }
            --this.size
            return true
          }

          module.exports = listCacheDelete
        },
        { './_assocIndexOf': 317 },
      ],
      416: [
        function(require, module, exports) {
          var assocIndexOf = require('./_assocIndexOf')

          /**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
          function listCacheGet(key) {
            var data = this.__data__,
              index = assocIndexOf(data, key)

            return index < 0 ? undefined : data[index][1]
          }

          module.exports = listCacheGet
        },
        { './_assocIndexOf': 317 },
      ],
      417: [
        function(require, module, exports) {
          var assocIndexOf = require('./_assocIndexOf')

          /**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
          function listCacheHas(key) {
            return assocIndexOf(this.__data__, key) > -1
          }

          module.exports = listCacheHas
        },
        { './_assocIndexOf': 317 },
      ],
      418: [
        function(require, module, exports) {
          var assocIndexOf = require('./_assocIndexOf')

          /**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
          function listCacheSet(key, value) {
            var data = this.__data__,
              index = assocIndexOf(data, key)

            if (index < 0) {
              ++this.size
              data.push([key, value])
            } else {
              data[index][1] = value
            }
            return this
          }

          module.exports = listCacheSet
        },
        { './_assocIndexOf': 317 },
      ],
      419: [
        function(require, module, exports) {
          var Hash = require('./_Hash'),
            ListCache = require('./_ListCache'),
            Map = require('./_Map')

          /**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
          function mapCacheClear() {
            this.size = 0
            this.__data__ = {
              hash: new Hash(),
              map: new (Map || ListCache)(),
              string: new Hash(),
            }
          }

          module.exports = mapCacheClear
        },
        { './_Hash': 292, './_ListCache': 293, './_Map': 294 },
      ],
      420: [
        function(require, module, exports) {
          var getMapData = require('./_getMapData')

          /**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
          function mapCacheDelete(key) {
            var result = getMapData(this, key)['delete'](key)
            this.size -= result ? 1 : 0
            return result
          }

          module.exports = mapCacheDelete
        },
        { './_getMapData': 389 },
      ],
      421: [
        function(require, module, exports) {
          var getMapData = require('./_getMapData')

          /**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
          function mapCacheGet(key) {
            return getMapData(this, key).get(key)
          }

          module.exports = mapCacheGet
        },
        { './_getMapData': 389 },
      ],
      422: [
        function(require, module, exports) {
          var getMapData = require('./_getMapData')

          /**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
          function mapCacheHas(key) {
            return getMapData(this, key).has(key)
          }

          module.exports = mapCacheHas
        },
        { './_getMapData': 389 },
      ],
      423: [
        function(require, module, exports) {
          var getMapData = require('./_getMapData')

          /**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
          function mapCacheSet(key, value) {
            var data = getMapData(this, key),
              size = data.size

            data.set(key, value)
            this.size += data.size == size ? 0 : 1
            return this
          }

          module.exports = mapCacheSet
        },
        { './_getMapData': 389 },
      ],
      424: [
        function(require, module, exports) {
          /**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
          function mapToArray(map) {
            var index = -1,
              result = Array(map.size)

            map.forEach(function(value, key) {
              result[++index] = [key, value]
            })
            return result
          }

          module.exports = mapToArray
        },
        {},
      ],
      425: [
        function(require, module, exports) {
          /**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
          function matchesStrictComparable(key, srcValue) {
            return function(object) {
              if (object == null) {
                return false
              }
              return (
                object[key] === srcValue &&
                (srcValue !== undefined || key in Object(object))
              )
            }
          }

          module.exports = matchesStrictComparable
        },
        {},
      ],
      426: [
        function(require, module, exports) {
          var memoize = require('./memoize')

          /** Used as the maximum memoize cache size. */
          var MAX_MEMOIZE_SIZE = 500

          /**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
          function memoizeCapped(func) {
            var result = memoize(func, function(key) {
              if (cache.size === MAX_MEMOIZE_SIZE) {
                cache.clear()
              }
              return key
            })

            var cache = result.cache
            return result
          }

          module.exports = memoizeCapped
        },
        { './memoize': 485 },
      ],
      427: [
        function(require, module, exports) {
          var getNative = require('./_getNative')

          /* Built-in method references that are verified to be native. */
          var nativeCreate = getNative(Object, 'create')

          module.exports = nativeCreate
        },
        { './_getNative': 391 },
      ],
      428: [
        function(require, module, exports) {
          var overArg = require('./_overArg')

          /* Built-in method references for those with the same name as other `lodash` methods. */
          var nativeKeys = overArg(Object.keys, Object)

          module.exports = nativeKeys
        },
        { './_overArg': 432 },
      ],
      429: [
        function(require, module, exports) {
          /**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
          function nativeKeysIn(object) {
            var result = []
            if (object != null) {
              for (var key in Object(object)) {
                result.push(key)
              }
            }
            return result
          }

          module.exports = nativeKeysIn
        },
        {},
      ],
      430: [
        function(require, module, exports) {
          var freeGlobal = require('./_freeGlobal')

          /** Detect free variable `exports`. */
          var freeExports =
            typeof exports == 'object' &&
            exports &&
            !exports.nodeType &&
            exports

          /** Detect free variable `module`. */
          var freeModule =
            freeExports &&
            typeof module == 'object' &&
            module &&
            !module.nodeType &&
            module

          /** Detect the popular CommonJS extension `module.exports`. */
          var moduleExports = freeModule && freeModule.exports === freeExports

          /** Detect free variable `process` from Node.js. */
          var freeProcess = moduleExports && freeGlobal.process

          /** Used to access faster Node.js helpers. */
          var nodeUtil = (function() {
            try {
              return freeProcess && freeProcess.binding('util')
            } catch (e) {}
          })()

          module.exports = nodeUtil
        },
        { './_freeGlobal': 387 },
      ],
      431: [
        function(require, module, exports) {
          /** Used for built-in method references. */
          var objectProto = Object.prototype

          /**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
          var nativeObjectToString = objectProto.toString

          /**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
          function objectToString(value) {
            return nativeObjectToString.call(value)
          }

          module.exports = objectToString
        },
        {},
      ],
      432: [
        function(require, module, exports) {
          /**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
          function overArg(func, transform) {
            return function(arg) {
              return func(transform(arg))
            }
          }

          module.exports = overArg
        },
        {},
      ],
      433: [
        function(require, module, exports) {
          var apply = require('./_apply')

          /* Built-in method references for those with the same name as other `lodash` methods. */
          var nativeMax = Math.max

          /**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
          function overRest(func, start, transform) {
            start = nativeMax(start === undefined ? func.length - 1 : start, 0)
            return function() {
              var args = arguments,
                index = -1,
                length = nativeMax(args.length - start, 0),
                array = Array(length)

              while (++index < length) {
                array[index] = args[start + index]
              }
              index = -1
              var otherArgs = Array(start + 1)
              while (++index < start) {
                otherArgs[index] = args[index]
              }
              otherArgs[start] = transform(array)
              return apply(func, this, otherArgs)
            }
          }

          module.exports = overRest
        },
        { './_apply': 305 },
      ],
      434: [
        function(require, module, exports) {
          var freeGlobal = require('./_freeGlobal')

          /** Detect free variable `self`. */
          var freeSelf =
            typeof self == 'object' && self && self.Object === Object && self

          /** Used as a reference to the global object. */
          var root = freeGlobal || freeSelf || Function('return this')()

          module.exports = root
        },
        { './_freeGlobal': 387 },
      ],
      435: [
        function(require, module, exports) {
          /** Used to stand-in for `undefined` hash values. */
          var HASH_UNDEFINED = '__lodash_hash_undefined__'

          /**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
          function setCacheAdd(value) {
            this.__data__.set(value, HASH_UNDEFINED)
            return this
          }

          module.exports = setCacheAdd
        },
        {},
      ],
      436: [
        function(require, module, exports) {
          /**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
          function setCacheHas(value) {
            return this.__data__.has(value)
          }

          module.exports = setCacheHas
        },
        {},
      ],
      437: [
        function(require, module, exports) {
          /**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
          function setToArray(set) {
            var index = -1,
              result = Array(set.size)

            set.forEach(function(value) {
              result[++index] = value
            })
            return result
          }

          module.exports = setToArray
        },
        {},
      ],
      438: [
        function(require, module, exports) {
          var baseSetToString = require('./_baseSetToString'),
            shortOut = require('./_shortOut')

          /**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
          var setToString = shortOut(baseSetToString)

          module.exports = setToString
        },
        { './_baseSetToString': 355, './_shortOut': 439 },
      ],
      439: [
        function(require, module, exports) {
          /** Used to detect hot functions by number of calls within a span of milliseconds. */
          var HOT_COUNT = 800,
            HOT_SPAN = 16

          /* Built-in method references for those with the same name as other `lodash` methods. */
          var nativeNow = Date.now

          /**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
          function shortOut(func) {
            var count = 0,
              lastCalled = 0

            return function() {
              var stamp = nativeNow(),
                remaining = HOT_SPAN - (stamp - lastCalled)

              lastCalled = stamp
              if (remaining > 0) {
                if (++count >= HOT_COUNT) {
                  return arguments[0]
                }
              } else {
                count = 0
              }
              return func.apply(undefined, arguments)
            }
          }

          module.exports = shortOut
        },
        {},
      ],
      440: [
        function(require, module, exports) {
          var ListCache = require('./_ListCache')

          /**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
          function stackClear() {
            this.__data__ = new ListCache()
            this.size = 0
          }

          module.exports = stackClear
        },
        { './_ListCache': 293 },
      ],
      441: [
        function(require, module, exports) {
          /**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
          function stackDelete(key) {
            var data = this.__data__,
              result = data['delete'](key)

            this.size = data.size
            return result
          }

          module.exports = stackDelete
        },
        {},
      ],
      442: [
        function(require, module, exports) {
          /**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
          function stackGet(key) {
            return this.__data__.get(key)
          }

          module.exports = stackGet
        },
        {},
      ],
      443: [
        function(require, module, exports) {
          /**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
          function stackHas(key) {
            return this.__data__.has(key)
          }

          module.exports = stackHas
        },
        {},
      ],
      444: [
        function(require, module, exports) {
          var ListCache = require('./_ListCache'),
            Map = require('./_Map'),
            MapCache = require('./_MapCache')

          /** Used as the size to enable large array optimizations. */
          var LARGE_ARRAY_SIZE = 200

          /**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
          function stackSet(key, value) {
            var data = this.__data__
            if (data instanceof ListCache) {
              var pairs = data.__data__
              if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
                pairs.push([key, value])
                this.size = ++data.size
                return this
              }
              data = this.__data__ = new MapCache(pairs)
            }
            data.set(key, value)
            this.size = data.size
            return this
          }

          module.exports = stackSet
        },
        { './_ListCache': 293, './_Map': 294, './_MapCache': 295 },
      ],
      445: [
        function(require, module, exports) {
          /**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
          function strictIndexOf(array, value, fromIndex) {
            var index = fromIndex - 1,
              length = array.length

            while (++index < length) {
              if (array[index] === value) {
                return index
              }
            }
            return -1
          }

          module.exports = strictIndexOf
        },
        {},
      ],
      446: [
        function(require, module, exports) {
          var memoizeCapped = require('./_memoizeCapped'),
            toString = require('./toString')

          /** Used to match property names within property paths. */
          var reLeadingDot = /^\./,
            rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g

          /** Used to match backslashes in property paths. */
          var reEscapeChar = /\\(\\)?/g

          /**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
          var stringToPath = memoizeCapped(function(string) {
            string = toString(string)

            var result = []
            if (reLeadingDot.test(string)) {
              result.push('')
            }
            string.replace(rePropName, function(match, number, quote, string) {
              result.push(
                quote ? string.replace(reEscapeChar, '$1') : number || match
              )
            })
            return result
          })

          module.exports = stringToPath
        },
        { './_memoizeCapped': 426, './toString': 498 },
      ],
      447: [
        function(require, module, exports) {
          var isSymbol = require('./isSymbol')

          /** Used as references for various `Number` constants. */
          var INFINITY = 1 / 0

          /**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
          function toKey(value) {
            if (typeof value == 'string' || isSymbol(value)) {
              return value
            }
            var result = value + ''
            return result == '0' && 1 / value == -INFINITY ? '-0' : result
          }

          module.exports = toKey
        },
        { './isSymbol': 480 },
      ],
      448: [
        function(require, module, exports) {
          /** Used for built-in method references. */
          var funcProto = Function.prototype

          /** Used to resolve the decompiled source of functions. */
          var funcToString = funcProto.toString

          /**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
          function toSource(func) {
            if (func != null) {
              try {
                return funcToString.call(func)
              } catch (e) {}
              try {
                return func + ''
              } catch (e) {}
            }
            return ''
          }

          module.exports = toSource
        },
        {},
      ],
      449: [
        function(require, module, exports) {
          var assignValue = require('./_assignValue'),
            copyObject = require('./_copyObject'),
            createAssigner = require('./_createAssigner'),
            isArrayLike = require('./isArrayLike'),
            isPrototype = require('./_isPrototype'),
            keys = require('./keys')

          /** Used for built-in method references. */
          var objectProto = Object.prototype

          /** Used to check objects for own properties. */
          var hasOwnProperty = objectProto.hasOwnProperty

          /**
 * Assigns own enumerable string keyed properties of source objects to the
 * destination object. Source objects are applied from left to right.
 * Subsequent sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object` and is loosely based on
 * [`Object.assign`](https://mdn.io/Object/assign).
 *
 * @static
 * @memberOf _
 * @since 0.10.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.assignIn
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * function Bar() {
 *   this.c = 3;
 * }
 *
 * Foo.prototype.b = 2;
 * Bar.prototype.d = 4;
 *
 * _.assign({ 'a': 0 }, new Foo, new Bar);
 * // => { 'a': 1, 'c': 3 }
 */
          var assign = createAssigner(function(object, source) {
            if (isPrototype(source) || isArrayLike(source)) {
              copyObject(source, keys(source), object)
              return
            }
            for (var key in source) {
              if (hasOwnProperty.call(source, key)) {
                assignValue(object, key, source[key])
              }
            }
          })

          module.exports = assign
        },
        {
          './_assignValue': 316,
          './_copyObject': 375,
          './_createAssigner': 378,
          './_isPrototype': 412,
          './isArrayLike': 469,
          './keys': 482,
        },
      ],
      450: [
        function(require, module, exports) {
          var copyObject = require('./_copyObject'),
            createAssigner = require('./_createAssigner'),
            keysIn = require('./keysIn')

          /**
 * This method is like `_.assignIn` except that it accepts `customizer`
 * which is invoked to produce the assigned values. If `customizer` returns
 * `undefined`, assignment is handled by the method instead. The `customizer`
 * is invoked with five arguments: (objValue, srcValue, key, object, source).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias extendWith
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} [customizer] The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @see _.assignWith
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   return _.isUndefined(objValue) ? srcValue : objValue;
 * }
 *
 * var defaults = _.partialRight(_.assignInWith, customizer);
 *
 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */
          var assignInWith = createAssigner(function(
            object,
            source,
            srcIndex,
            customizer
          ) {
            copyObject(source, keysIn(source), object, customizer)
          })

          module.exports = assignInWith
        },
        { './_copyObject': 375, './_createAssigner': 378, './keysIn': 483 },
      ],
      451: [
        function(require, module, exports) {
          var baseClone = require('./_baseClone')

          /**
 * Creates a shallow clone of `value`.
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
 * and supports cloning arrays, array buffers, booleans, date objects, maps,
 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
 * arrays. The own enumerable properties of `arguments` objects are cloned
 * as plain objects. An empty object is returned for uncloneable values such
 * as error objects, functions, DOM nodes, and WeakMaps.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to clone.
 * @returns {*} Returns the cloned value.
 * @see _.cloneDeep
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var shallow = _.clone(objects);
 * console.log(shallow[0] === objects[0]);
 * // => true
 */
          function clone(value) {
            return baseClone(value, false, true)
          }

          module.exports = clone
        },
        { './_baseClone': 321 },
      ],
      452: [
        function(require, module, exports) {
          var baseClone = require('./_baseClone')

          /**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
          function cloneDeep(value) {
            return baseClone(value, true, true)
          }

          module.exports = cloneDeep
        },
        { './_baseClone': 321 },
      ],
      453: [
        function(require, module, exports) {
          var baseClone = require('./_baseClone')

          /**
 * This method is like `_.cloneWith` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @param {Function} [customizer] The function to customize cloning.
 * @returns {*} Returns the deep cloned value.
 * @see _.cloneWith
 * @example
 *
 * function customizer(value) {
 *   if (_.isElement(value)) {
 *     return value.cloneNode(true);
 *   }
 * }
 *
 * var el = _.cloneDeepWith(document.body, customizer);
 *
 * console.log(el === document.body);
 * // => false
 * console.log(el.nodeName);
 * // => 'BODY'
 * console.log(el.childNodes.length);
 * // => 20
 */
          function cloneDeepWith(value, customizer) {
            customizer = typeof customizer == 'function'
              ? customizer
              : undefined
            return baseClone(value, true, true, customizer)
          }

          module.exports = cloneDeepWith
        },
        { './_baseClone': 321 },
      ],
      454: [
        function(require, module, exports) {
          /**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
          function constant(value) {
            return function() {
              return value
            }
          }

          module.exports = constant
        },
        {},
      ],
      455: [
        function(require, module, exports) {
          var apply = require('./_apply'),
            assignInDefaults = require('./_assignInDefaults'),
            assignInWith = require('./assignInWith'),
            baseRest = require('./_baseRest')

          /**
 * Assigns own and inherited enumerable string keyed properties of source
 * objects to the destination object for all destination properties that
 * resolve to `undefined`. Source objects are applied from left to right.
 * Once a property is set, additional values of the same property are ignored.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.defaultsDeep
 * @example
 *
 * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */
          var defaults = baseRest(function(args) {
            args.push(undefined, assignInDefaults)
            return apply(assignInWith, undefined, args)
          })

          module.exports = defaults
        },
        {
          './_apply': 305,
          './_assignInDefaults': 314,
          './_baseRest': 354,
          './assignInWith': 450,
        },
      ],
      456: [
        function(require, module, exports) {
          /**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
          function eq(value, other) {
            return value === other || (value !== value && other !== other)
          }

          module.exports = eq
        },
        {},
      ],
      457: [
        function(require, module, exports) {
          var toString = require('./toString')

          /**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
          var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
            reHasRegExpChar = RegExp(reRegExpChar.source)

          /**
 * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
 * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @example
 *
 * _.escapeRegExp('[lodash](https://lodash.com/)');
 * // => '\[lodash\]\(https://lodash\.com/\)'
 */
          function escapeRegExp(string) {
            string = toString(string)
            return string && reHasRegExpChar.test(string)
              ? string.replace(reRegExpChar, '\\$&')
              : string
          }

          module.exports = escapeRegExp
        },
        { './toString': 498 },
      ],
      458: [
        function(require, module, exports) {
          var createFind = require('./_createFind'),
            findIndex = require('./findIndex')

          /**
 * Iterates over elements of `collection`, returning the first element
 * `predicate` returns truthy for. The predicate is invoked with three
 * arguments: (value, index|key, collection).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {*} Returns the matched element, else `undefined`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'age': 36, 'active': true },
 *   { 'user': 'fred',    'age': 40, 'active': false },
 *   { 'user': 'pebbles', 'age': 1,  'active': true }
 * ];
 *
 * _.find(users, function(o) { return o.age < 40; });
 * // => object for 'barney'
 *
 * // The `_.matches` iteratee shorthand.
 * _.find(users, { 'age': 1, 'active': true });
 * // => object for 'pebbles'
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.find(users, ['active', false]);
 * // => object for 'fred'
 *
 * // The `_.property` iteratee shorthand.
 * _.find(users, 'active');
 * // => object for 'barney'
 */
          var find = createFind(findIndex)

          module.exports = find
        },
        { './_createFind': 381, './findIndex': 459 },
      ],
      459: [
        function(require, module, exports) {
          var baseFindIndex = require('./_baseFindIndex'),
            baseIteratee = require('./_baseIteratee'),
            toInteger = require('./toInteger')

          /* Built-in method references for those with the same name as other `lodash` methods. */
          var nativeMax = Math.max

          /**
 * This method is like `_.find` except that it returns the index of the first
 * element `predicate` returns truthy for instead of the element itself.
 *
 * @static
 * @memberOf _
 * @since 1.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {number} Returns the index of the found element, else `-1`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': false },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': true }
 * ];
 *
 * _.findIndex(users, function(o) { return o.user == 'barney'; });
 * // => 0
 *
 * // The `_.matches` iteratee shorthand.
 * _.findIndex(users, { 'user': 'fred', 'active': false });
 * // => 1
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.findIndex(users, ['active', false]);
 * // => 0
 *
 * // The `_.property` iteratee shorthand.
 * _.findIndex(users, 'active');
 * // => 2
 */
          function findIndex(array, predicate, fromIndex) {
            var length = array == null ? 0 : array.length
            if (!length) {
              return -1
            }
            var index = fromIndex == null ? 0 : toInteger(fromIndex)
            if (index < 0) {
              index = nativeMax(length + index, 0)
            }
            return baseFindIndex(array, baseIteratee(predicate, 3), index)
          }

          module.exports = findIndex
        },
        { './_baseFindIndex': 324, './_baseIteratee': 342, './toInteger': 495 },
      ],
      460: [
        function(require, module, exports) {
          var createFind = require('./_createFind'),
            findLastIndex = require('./findLastIndex')

          /**
 * This method is like `_.find` except that it iterates over elements of
 * `collection` from right to left.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=collection.length-1] The index to search from.
 * @returns {*} Returns the matched element, else `undefined`.
 * @example
 *
 * _.findLast([1, 2, 3, 4], function(n) {
 *   return n % 2 == 1;
 * });
 * // => 3
 */
          var findLast = createFind(findLastIndex)

          module.exports = findLast
        },
        { './_createFind': 381, './findLastIndex': 461 },
      ],
      461: [
        function(require, module, exports) {
          var baseFindIndex = require('./_baseFindIndex'),
            baseIteratee = require('./_baseIteratee'),
            toInteger = require('./toInteger')

          /* Built-in method references for those with the same name as other `lodash` methods. */
          var nativeMax = Math.max,
            nativeMin = Math.min

          /**
 * This method is like `_.findIndex` except that it iterates over elements
 * of `collection` from right to left.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=array.length-1] The index to search from.
 * @returns {number} Returns the index of the found element, else `-1`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': true },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': false }
 * ];
 *
 * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
 * // => 2
 *
 * // The `_.matches` iteratee shorthand.
 * _.findLastIndex(users, { 'user': 'barney', 'active': true });
 * // => 0
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.findLastIndex(users, ['active', false]);
 * // => 2
 *
 * // The `_.property` iteratee shorthand.
 * _.findLastIndex(users, 'active');
 * // => 0
 */
          function findLastIndex(array, predicate, fromIndex) {
            var length = array == null ? 0 : array.length
            if (!length) {
              return -1
            }
            var index = length - 1
            if (fromIndex !== undefined) {
              index = toInteger(fromIndex)
              index = fromIndex < 0
                ? nativeMax(length + index, 0)
                : nativeMin(index, length - 1)
            }
            return baseFindIndex(array, baseIteratee(predicate, 3), index, true)
          }

          module.exports = findLastIndex
        },
        { './_baseFindIndex': 324, './_baseIteratee': 342, './toInteger': 495 },
      ],
      462: [
        function(require, module, exports) {
          var baseGet = require('./_baseGet')

          /**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
          function get(object, path, defaultValue) {
            var result = object == null ? undefined : baseGet(object, path)
            return result === undefined ? defaultValue : result
          }

          module.exports = get
        },
        { './_baseGet': 328 },
      ],
      463: [
        function(require, module, exports) {
          var baseHas = require('./_baseHas'),
            hasPath = require('./_hasPath')

          /**
 * Checks if `path` is a direct property of `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = { 'a': { 'b': 2 } };
 * var other = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.has(object, 'a');
 * // => true
 *
 * _.has(object, 'a.b');
 * // => true
 *
 * _.has(object, ['a', 'b']);
 * // => true
 *
 * _.has(other, 'a');
 * // => false
 */
          function has(object, path) {
            return object != null && hasPath(object, path, baseHas)
          }

          module.exports = has
        },
        { './_baseHas': 331, './_hasPath': 397 },
      ],
      464: [
        function(require, module, exports) {
          var baseHasIn = require('./_baseHasIn'),
            hasPath = require('./_hasPath')

          /**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
          function hasIn(object, path) {
            return object != null && hasPath(object, path, baseHasIn)
          }

          module.exports = hasIn
        },
        { './_baseHasIn': 332, './_hasPath': 397 },
      ],
      465: [
        function(require, module, exports) {
          /**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
          function identity(value) {
            return value
          }

          module.exports = identity
        },
        {},
      ],
      466: [
        function(require, module, exports) {
          var baseIndexOf = require('./_baseIndexOf'),
            isArrayLike = require('./isArrayLike'),
            isString = require('./isString'),
            toInteger = require('./toInteger'),
            values = require('./values')

          /* Built-in method references for those with the same name as other `lodash` methods. */
          var nativeMax = Math.max

          /**
 * Checks if `value` is in `collection`. If `collection` is a string, it's
 * checked for a substring of `value`, otherwise
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * is used for equality comparisons. If `fromIndex` is negative, it's used as
 * the offset from the end of `collection`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object|string} collection The collection to inspect.
 * @param {*} value The value to search for.
 * @param {number} [fromIndex=0] The index to search from.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
 * @returns {boolean} Returns `true` if `value` is found, else `false`.
 * @example
 *
 * _.includes([1, 2, 3], 1);
 * // => true
 *
 * _.includes([1, 2, 3], 1, 2);
 * // => false
 *
 * _.includes({ 'a': 1, 'b': 2 }, 1);
 * // => true
 *
 * _.includes('abcd', 'bc');
 * // => true
 */
          function includes(collection, value, fromIndex, guard) {
            collection = isArrayLike(collection)
              ? collection
              : values(collection)
            fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0

            var length = collection.length
            if (fromIndex < 0) {
              fromIndex = nativeMax(length + fromIndex, 0)
            }
            return isString(collection)
              ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1
              : !!length && baseIndexOf(collection, value, fromIndex) > -1
          }

          module.exports = includes
        },
        {
          './_baseIndexOf': 333,
          './isArrayLike': 469,
          './isString': 479,
          './toInteger': 495,
          './values': 500,
        },
      ],
      467: [
        function(require, module, exports) {
          var baseIsArguments = require('./_baseIsArguments'),
            isObjectLike = require('./isObjectLike')

          /** Used for built-in method references. */
          var objectProto = Object.prototype

          /** Used to check objects for own properties. */
          var hasOwnProperty = objectProto.hasOwnProperty

          /** Built-in value references. */
          var propertyIsEnumerable = objectProto.propertyIsEnumerable

          /**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
          var isArguments = baseIsArguments(
            (function() {
              return arguments
            })()
          )
            ? baseIsArguments
            : function(value) {
                return (
                  isObjectLike(value) &&
                  hasOwnProperty.call(value, 'callee') &&
                  !propertyIsEnumerable.call(value, 'callee')
                )
              }

          module.exports = isArguments
        },
        { './_baseIsArguments': 334, './isObjectLike': 476 },
      ],
      468: [
        function(require, module, exports) {
          /**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
          var isArray = Array.isArray

          module.exports = isArray
        },
        {},
      ],
      469: [
        function(require, module, exports) {
          var isFunction = require('./isFunction'),
            isLength = require('./isLength')

          /**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
          function isArrayLike(value) {
            return value != null && isLength(value.length) && !isFunction(value)
          }

          module.exports = isArrayLike
        },
        { './isFunction': 472, './isLength': 474 },
      ],
      470: [
        function(require, module, exports) {
          var isArrayLike = require('./isArrayLike'),
            isObjectLike = require('./isObjectLike')

          /**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
          function isArrayLikeObject(value) {
            return isObjectLike(value) && isArrayLike(value)
          }

          module.exports = isArrayLikeObject
        },
        { './isArrayLike': 469, './isObjectLike': 476 },
      ],
      471: [
        function(require, module, exports) {
          var root = require('./_root'),
            stubFalse = require('./stubFalse')

          /** Detect free variable `exports`. */
          var freeExports =
            typeof exports == 'object' &&
            exports &&
            !exports.nodeType &&
            exports

          /** Detect free variable `module`. */
          var freeModule =
            freeExports &&
            typeof module == 'object' &&
            module &&
            !module.nodeType &&
            module

          /** Detect the popular CommonJS extension `module.exports`. */
          var moduleExports = freeModule && freeModule.exports === freeExports

          /** Built-in value references. */
          var Buffer = moduleExports ? root.Buffer : undefined

          /* Built-in method references for those with the same name as other `lodash` methods. */
          var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined

          /**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
          var isBuffer = nativeIsBuffer || stubFalse

          module.exports = isBuffer
        },
        { './_root': 434, './stubFalse': 493 },
      ],
      472: [
        function(require, module, exports) {
          var baseGetTag = require('./_baseGetTag'),
            isObject = require('./isObject')

          /** `Object#toString` result references. */
          var asyncTag = '[object AsyncFunction]',
            funcTag = '[object Function]',
            genTag = '[object GeneratorFunction]',
            proxyTag = '[object Proxy]'

          /**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
          function isFunction(value) {
            if (!isObject(value)) {
              return false
            }
            // The use of `Object#toString` avoids issues with the `typeof` operator
            // in Safari 9 which returns 'object' for typed arrays and other constructors.
            var tag = baseGetTag(value)
            return (
              tag == funcTag ||
              tag == genTag ||
              tag == asyncTag ||
              tag == proxyTag
            )
          }

          module.exports = isFunction
        },
        { './_baseGetTag': 330, './isObject': 475 },
      ],
      473: [
        function(require, module, exports) {
          var toInteger = require('./toInteger')

          /**
 * Checks if `value` is an integer.
 *
 * **Note:** This method is based on
 * [`Number.isInteger`](https://mdn.io/Number/isInteger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
 * @example
 *
 * _.isInteger(3);
 * // => true
 *
 * _.isInteger(Number.MIN_VALUE);
 * // => false
 *
 * _.isInteger(Infinity);
 * // => false
 *
 * _.isInteger('3');
 * // => false
 */
          function isInteger(value) {
            return typeof value == 'number' && value == toInteger(value)
          }

          module.exports = isInteger
        },
        { './toInteger': 495 },
      ],
      474: [
        function(require, module, exports) {
          /** Used as references for various `Number` constants. */
          var MAX_SAFE_INTEGER = 9007199254740991

          /**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
          function isLength(value) {
            return (
              typeof value == 'number' &&
              value > -1 &&
              value % 1 == 0 &&
              value <= MAX_SAFE_INTEGER
            )
          }

          module.exports = isLength
        },
        {},
      ],
      475: [
        function(require, module, exports) {
          /**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
          function isObject(value) {
            var type = typeof value
            return value != null && (type == 'object' || type == 'function')
          }

          module.exports = isObject
        },
        {},
      ],
      476: [
        function(require, module, exports) {
          /**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
          function isObjectLike(value) {
            return value != null && typeof value == 'object'
          }

          module.exports = isObjectLike
        },
        {},
      ],
      477: [
        function(require, module, exports) {
          var baseGetTag = require('./_baseGetTag'),
            getPrototype = require('./_getPrototype'),
            isObjectLike = require('./isObjectLike')

          /** `Object#toString` result references. */
          var objectTag = '[object Object]'

          /** Used for built-in method references. */
          var funcProto = Function.prototype,
            objectProto = Object.prototype

          /** Used to resolve the decompiled source of functions. */
          var funcToString = funcProto.toString

          /** Used to check objects for own properties. */
          var hasOwnProperty = objectProto.hasOwnProperty

          /** Used to infer the `Object` constructor. */
          var objectCtorString = funcToString.call(Object)

          /**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
          function isPlainObject(value) {
            if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
              return false
            }
            var proto = getPrototype(value)
            if (proto === null) {
              return true
            }
            var Ctor =
              hasOwnProperty.call(proto, 'constructor') && proto.constructor
            return (
              typeof Ctor == 'function' &&
              Ctor instanceof Ctor &&
              funcToString.call(Ctor) == objectCtorString
            )
          }

          module.exports = isPlainObject
        },
        { './_baseGetTag': 330, './_getPrototype': 392, './isObjectLike': 476 },
      ],
      478: [
        function(require, module, exports) {
          var baseIsRegExp = require('./_baseIsRegExp'),
            baseUnary = require('./_baseUnary'),
            nodeUtil = require('./_nodeUtil')

          /* Node.js helper references. */
          var nodeIsRegExp = nodeUtil && nodeUtil.isRegExp

          /**
 * Checks if `value` is classified as a `RegExp` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
 * @example
 *
 * _.isRegExp(/abc/);
 * // => true
 *
 * _.isRegExp('/abc/');
 * // => false
 */
          var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp

          module.exports = isRegExp
        },
        { './_baseIsRegExp': 340, './_baseUnary': 359, './_nodeUtil': 430 },
      ],
      479: [
        function(require, module, exports) {
          var baseGetTag = require('./_baseGetTag'),
            isArray = require('./isArray'),
            isObjectLike = require('./isObjectLike')

          /** `Object#toString` result references. */
          var stringTag = '[object String]'

          /**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
          function isString(value) {
            return (
              typeof value == 'string' ||
              (!isArray(value) &&
                isObjectLike(value) &&
                baseGetTag(value) == stringTag)
            )
          }

          module.exports = isString
        },
        { './_baseGetTag': 330, './isArray': 468, './isObjectLike': 476 },
      ],
      480: [
        function(require, module, exports) {
          var baseGetTag = require('./_baseGetTag'),
            isObjectLike = require('./isObjectLike')

          /** `Object#toString` result references. */
          var symbolTag = '[object Symbol]'

          /**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
          function isSymbol(value) {
            return (
              typeof value == 'symbol' ||
              (isObjectLike(value) && baseGetTag(value) == symbolTag)
            )
          }

          module.exports = isSymbol
        },
        { './_baseGetTag': 330, './isObjectLike': 476 },
      ],
      481: [
        function(require, module, exports) {
          var baseIsTypedArray = require('./_baseIsTypedArray'),
            baseUnary = require('./_baseUnary'),
            nodeUtil = require('./_nodeUtil')

          /* Node.js helper references. */
          var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray

          /**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
          var isTypedArray = nodeIsTypedArray
            ? baseUnary(nodeIsTypedArray)
            : baseIsTypedArray

          module.exports = isTypedArray
        },
        { './_baseIsTypedArray': 341, './_baseUnary': 359, './_nodeUtil': 430 },
      ],
      482: [
        function(require, module, exports) {
          var arrayLikeKeys = require('./_arrayLikeKeys'),
            baseKeys = require('./_baseKeys'),
            isArrayLike = require('./isArrayLike')

          /**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
          function keys(object) {
            return isArrayLike(object)
              ? arrayLikeKeys(object)
              : baseKeys(object)
          }

          module.exports = keys
        },
        { './_arrayLikeKeys': 309, './_baseKeys': 343, './isArrayLike': 469 },
      ],
      483: [
        function(require, module, exports) {
          var arrayLikeKeys = require('./_arrayLikeKeys'),
            baseKeysIn = require('./_baseKeysIn'),
            isArrayLike = require('./isArrayLike')

          /**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
          function keysIn(object) {
            return isArrayLike(object)
              ? arrayLikeKeys(object, true)
              : baseKeysIn(object)
          }

          module.exports = keysIn
        },
        { './_arrayLikeKeys': 309, './_baseKeysIn': 344, './isArrayLike': 469 },
      ],
      484: [
        function(require, module, exports) {
          var arrayMap = require('./_arrayMap'),
            baseIteratee = require('./_baseIteratee'),
            baseMap = require('./_baseMap'),
            isArray = require('./isArray')

          /**
 * Creates an array of values by running each element in `collection` thru
 * `iteratee`. The iteratee is invoked with three arguments:
 * (value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
 *
 * The guarded methods are:
 * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
 * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
 * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
 * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * _.map([4, 8], square);
 * // => [16, 64]
 *
 * _.map({ 'a': 4, 'b': 8 }, square);
 * // => [16, 64] (iteration order is not guaranteed)
 *
 * var users = [
 *   { 'user': 'barney' },
 *   { 'user': 'fred' }
 * ];
 *
 * // The `_.property` iteratee shorthand.
 * _.map(users, 'user');
 * // => ['barney', 'fred']
 */
          function map(collection, iteratee) {
            var func = isArray(collection) ? arrayMap : baseMap
            return func(collection, baseIteratee(iteratee, 3))
          }

          module.exports = map
        },
        {
          './_arrayMap': 310,
          './_baseIteratee': 342,
          './_baseMap': 345,
          './isArray': 468,
        },
      ],
      485: [
        function(require, module, exports) {
          var MapCache = require('./_MapCache')

          /** Error message constants. */
          var FUNC_ERROR_TEXT = 'Expected a function'

          /**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
          function memoize(func, resolver) {
            if (
              typeof func != 'function' ||
              (resolver != null && typeof resolver != 'function')
            ) {
              throw new TypeError(FUNC_ERROR_TEXT)
            }
            var memoized = function() {
              var args = arguments,
                key = resolver ? resolver.apply(this, args) : args[0],
                cache = memoized.cache

              if (cache.has(key)) {
                return cache.get(key)
              }
              var result = func.apply(this, args)
              memoized.cache = cache.set(key, result) || cache
              return result
            }
            memoized.cache = new (memoize.Cache || MapCache)()
            return memoized
          }

          // Expose `MapCache`.
          memoize.Cache = MapCache

          module.exports = memoize
        },
        { './_MapCache': 295 },
      ],
      486: [
        function(require, module, exports) {
          var baseMerge = require('./_baseMerge'),
            createAssigner = require('./_createAssigner')

          /**
 * This method is like `_.merge` except that it accepts `customizer` which
 * is invoked to produce the merged values of the destination and source
 * properties. If `customizer` returns `undefined`, merging is handled by the
 * method instead. The `customizer` is invoked with six arguments:
 * (objValue, srcValue, key, object, source, stack).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} customizer The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   if (_.isArray(objValue)) {
 *     return objValue.concat(srcValue);
 *   }
 * }
 *
 * var object = { 'a': [1], 'b': [2] };
 * var other = { 'a': [3], 'b': [4] };
 *
 * _.mergeWith(object, other, customizer);
 * // => { 'a': [1, 3], 'b': [2, 4] }
 */
          var mergeWith = createAssigner(function(
            object,
            source,
            srcIndex,
            customizer
          ) {
            baseMerge(object, source, srcIndex, customizer)
          })

          module.exports = mergeWith
        },
        { './_baseMerge': 348, './_createAssigner': 378 },
      ],
      487: [
        function(require, module, exports) {
          /**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
          function noop() {
            // No operation performed.
          }

          module.exports = noop
        },
        {},
      ],
      488: [
        function(require, module, exports) {
          var baseProperty = require('./_baseProperty'),
            basePropertyDeep = require('./_basePropertyDeep'),
            isKey = require('./_isKey'),
            toKey = require('./_toKey')

          /**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
          function property(path) {
            return isKey(path)
              ? baseProperty(toKey(path))
              : basePropertyDeep(path)
          }

          module.exports = property
        },
        {
          './_baseProperty': 351,
          './_basePropertyDeep': 352,
          './_isKey': 409,
          './_toKey': 447,
        },
      ],
      489: [
        function(require, module, exports) {
          var baseRepeat = require('./_baseRepeat'),
            isIterateeCall = require('./_isIterateeCall'),
            toInteger = require('./toInteger'),
            toString = require('./toString')

          /**
 * Repeats the given string `n` times.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to repeat.
 * @param {number} [n=1] The number of times to repeat the string.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {string} Returns the repeated string.
 * @example
 *
 * _.repeat('*', 3);
 * // => '***'
 *
 * _.repeat('abc', 2);
 * // => 'abcabc'
 *
 * _.repeat('abc', 0);
 * // => ''
 */
          function repeat(string, n, guard) {
            if (guard ? isIterateeCall(string, n, guard) : n === undefined) {
              n = 1
            } else {
              n = toInteger(n)
            }
            return baseRepeat(toString(string), n)
          }

          module.exports = repeat
        },
        {
          './_baseRepeat': 353,
          './_isIterateeCall': 408,
          './toInteger': 495,
          './toString': 498,
        },
      ],
      490: [
        function(require, module, exports) {
          var baseFlatten = require('./_baseFlatten'),
            baseOrderBy = require('./_baseOrderBy'),
            baseRest = require('./_baseRest'),
            isIterateeCall = require('./_isIterateeCall')

          /**
 * Creates an array of elements, sorted in ascending order by the results of
 * running each element in a collection thru each iteratee. This method
 * performs a stable sort, that is, it preserves the original sort order of
 * equal elements. The iteratees are invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {...(Function|Function[])} [iteratees=[_.identity]]
 *  The iteratees to sort by.
 * @returns {Array} Returns the new sorted array.
 * @example
 *
 * var users = [
 *   { 'user': 'fred',   'age': 48 },
 *   { 'user': 'barney', 'age': 36 },
 *   { 'user': 'fred',   'age': 40 },
 *   { 'user': 'barney', 'age': 34 }
 * ];
 *
 * _.sortBy(users, [function(o) { return o.user; }]);
 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
 *
 * _.sortBy(users, ['user', 'age']);
 * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
 */
          var sortBy = baseRest(function(collection, iteratees) {
            if (collection == null) {
              return []
            }
            var length = iteratees.length
            if (
              length > 1 &&
              isIterateeCall(collection, iteratees[0], iteratees[1])
            ) {
              iteratees = []
            } else if (
              length > 2 &&
              isIterateeCall(iteratees[0], iteratees[1], iteratees[2])
            ) {
              iteratees = [iteratees[0]]
            }
            return baseOrderBy(collection, baseFlatten(iteratees, 1), [])
          })

          module.exports = sortBy
        },
        {
          './_baseFlatten': 325,
          './_baseOrderBy': 350,
          './_baseRest': 354,
          './_isIterateeCall': 408,
        },
      ],
      491: [
        function(require, module, exports) {
          var baseClamp = require('./_baseClamp'),
            baseToString = require('./_baseToString'),
            toInteger = require('./toInteger'),
            toString = require('./toString')

          /**
 * Checks if `string` starts with the given target string.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to inspect.
 * @param {string} [target] The string to search for.
 * @param {number} [position=0] The position to search from.
 * @returns {boolean} Returns `true` if `string` starts with `target`,
 *  else `false`.
 * @example
 *
 * _.startsWith('abc', 'a');
 * // => true
 *
 * _.startsWith('abc', 'b');
 * // => false
 *
 * _.startsWith('abc', 'b', 1);
 * // => true
 */
          function startsWith(string, target, position) {
            string = toString(string)
            position = baseClamp(toInteger(position), 0, string.length)
            target = baseToString(target)
            return string.slice(position, position + target.length) == target
          }

          module.exports = startsWith
        },
        {
          './_baseClamp': 320,
          './_baseToString': 358,
          './toInteger': 495,
          './toString': 498,
        },
      ],
      492: [
        function(require, module, exports) {
          /**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
          function stubArray() {
            return []
          }

          module.exports = stubArray
        },
        {},
      ],
      493: [
        function(require, module, exports) {
          /**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
          function stubFalse() {
            return false
          }

          module.exports = stubFalse
        },
        {},
      ],
      494: [
        function(require, module, exports) {
          var toNumber = require('./toNumber')

          /** Used as references for various `Number` constants. */
          var INFINITY = 1 / 0,
            MAX_INTEGER = 1.7976931348623157e308

          /**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
          function toFinite(value) {
            if (!value) {
              return value === 0 ? value : 0
            }
            value = toNumber(value)
            if (value === INFINITY || value === -INFINITY) {
              var sign = value < 0 ? -1 : 1
              return sign * MAX_INTEGER
            }
            return value === value ? value : 0
          }

          module.exports = toFinite
        },
        { './toNumber': 496 },
      ],
      495: [
        function(require, module, exports) {
          var toFinite = require('./toFinite')

          /**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
          function toInteger(value) {
            var result = toFinite(value),
              remainder = result % 1

            return result === result
              ? remainder ? result - remainder : result
              : 0
          }

          module.exports = toInteger
        },
        { './toFinite': 494 },
      ],
      496: [
        function(require, module, exports) {
          var isObject = require('./isObject'),
            isSymbol = require('./isSymbol')

          /** Used as references for various `Number` constants. */
          var NAN = 0 / 0

          /** Used to match leading and trailing whitespace. */
          var reTrim = /^\s+|\s+$/g

          /** Used to detect bad signed hexadecimal string values. */
          var reIsBadHex = /^[-+]0x[0-9a-f]+$/i

          /** Used to detect binary string values. */
          var reIsBinary = /^0b[01]+$/i

          /** Used to detect octal string values. */
          var reIsOctal = /^0o[0-7]+$/i

          /** Built-in method references without a dependency on `root`. */
          var freeParseInt = parseInt

          /**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
          function toNumber(value) {
            if (typeof value == 'number') {
              return value
            }
            if (isSymbol(value)) {
              return NAN
            }
            if (isObject(value)) {
              var other = typeof value.valueOf == 'function'
                ? value.valueOf()
                : value
              value = isObject(other) ? other + '' : other
            }
            if (typeof value != 'string') {
              return value === 0 ? value : +value
            }
            value = value.replace(reTrim, '')
            var isBinary = reIsBinary.test(value)
            return isBinary || reIsOctal.test(value)
              ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
              : reIsBadHex.test(value) ? NAN : +value
          }

          module.exports = toNumber
        },
        { './isObject': 475, './isSymbol': 480 },
      ],
      497: [
        function(require, module, exports) {
          var copyObject = require('./_copyObject'),
            keysIn = require('./keysIn')

          /**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
          function toPlainObject(value) {
            return copyObject(value, keysIn(value))
          }

          module.exports = toPlainObject
        },
        { './_copyObject': 375, './keysIn': 483 },
      ],
      498: [
        function(require, module, exports) {
          var baseToString = require('./_baseToString')

          /**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
          function toString(value) {
            return value == null ? '' : baseToString(value)
          }

          module.exports = toString
        },
        { './_baseToString': 358 },
      ],
      499: [
        function(require, module, exports) {
          var baseUniq = require('./_baseUniq')

          /**
 * Creates a duplicate-free version of an array, using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons, in which only the first occurrence of each element
 * is kept. The order of result values is determined by the order they occur
 * in the array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniq([2, 1, 2]);
 * // => [2, 1]
 */
          function uniq(array) {
            return array && array.length ? baseUniq(array) : []
          }

          module.exports = uniq
        },
        { './_baseUniq': 360 },
      ],
      500: [
        function(require, module, exports) {
          var baseValues = require('./_baseValues'),
            keys = require('./keys')

          /**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */
          function values(object) {
            return object == null ? [] : baseValues(object, keys(object))
          }

          module.exports = values
        },
        { './_baseValues': 361, './keys': 482 },
      ],
      501: [
        function(require, module, exports) {
          ;(function(Buffer) {
            'use strict'
            var vlq = require('vlq')

            function Chunk(start, end, content) {
              this.start = start
              this.end = end
              this.original = content

              this.intro = ''
              this.outro = ''

              this.content = content
              this.storeName = false
              this.edited = false

              // we make these non-enumerable, for sanity while debugging
              Object.defineProperties(this, {
                previous: { writable: true, value: null },
                next: { writable: true, value: null },
              })
            }

            Chunk.prototype = {
              append: function append(content) {
                this.outro += content
              },

              clone: function clone() {
                var chunk = new Chunk(this.start, this.end, this.original)

                chunk.intro = this.intro
                chunk.outro = this.outro
                chunk.content = this.content
                chunk.storeName = this.storeName
                chunk.edited = this.edited

                return chunk
              },

              contains: function contains(index) {
                return this.start < index && index < this.end
              },

              eachNext: function eachNext(fn) {
                var chunk = this
                while (chunk) {
                  fn(chunk)
                  chunk = chunk.next
                }
              },

              eachPrevious: function eachPrevious(fn) {
                var chunk = this
                while (chunk) {
                  fn(chunk)
                  chunk = chunk.previous
                }
              },

              edit: function edit(content, storeName) {
                this.content = content
                this.storeName = storeName

                this.edited = true

                return this
              },

              prepend: function prepend(content) {
                this.intro = content + this.intro
              },

              split: function split(index) {
                var sliceIndex = index - this.start

                var originalBefore = this.original.slice(0, sliceIndex)
                var originalAfter = this.original.slice(sliceIndex)

                this.original = originalBefore

                var newChunk = new Chunk(index, this.end, originalAfter)
                newChunk.outro = this.outro
                this.outro = ''

                this.end = index

                if (this.edited) {
                  // TODO is this block necessary?...
                  newChunk.edit('', false)
                  this.content = ''
                } else {
                  this.content = originalBefore
                }

                newChunk.next = this.next
                if (newChunk.next) newChunk.next.previous = newChunk
                newChunk.previous = this
                this.next = newChunk

                return newChunk
              },

              toString: function toString() {
                return this.intro + this.content + this.outro
              },

              trimEnd: function trimEnd(rx) {
                this.outro = this.outro.replace(rx, '')
                if (this.outro.length) return true

                var trimmed = this.content.replace(rx, '')

                if (trimmed.length) {
                  if (trimmed !== this.content) {
                    this.split(this.start + trimmed.length).edit('', false)
                  }

                  return true
                } else {
                  this.edit('', false)

                  this.intro = this.intro.replace(rx, '')
                  if (this.intro.length) return true
                }
              },

              trimStart: function trimStart(rx) {
                this.intro = this.intro.replace(rx, '')
                if (this.intro.length) return true

                var trimmed = this.content.replace(rx, '')

                if (trimmed.length) {
                  if (trimmed !== this.content) {
                    this.split(this.end - trimmed.length)
                    this.edit('', false)
                  }

                  return true
                } else {
                  this.edit('', false)

                  this.outro = this.outro.replace(rx, '')
                  if (this.outro.length) return true
                }
              },
            }

            var _btoa

            if (
              typeof window !== 'undefined' &&
              typeof window.btoa === 'function'
            ) {
              _btoa = window.btoa
            } else if (typeof Buffer === 'function') {
              _btoa = function(str) {
                return new Buffer(str).toString('base64')
              }
            } else {
              _btoa = function() {
                throw new Error(
                  'Unsupported environment: `window.btoa` or `Buffer` should be supported.'
                )
              }
            }

            var btoa = _btoa

            function SourceMap(properties) {
              this.version = 3

              this.file = properties.file
              this.sources = properties.sources
              this.sourcesContent = properties.sourcesContent
              this.names = properties.names
              this.mappings = properties.mappings
            }

            SourceMap.prototype = {
              toString: function toString() {
                return JSON.stringify(this)
              },

              toUrl: function toUrl() {
                return (
                  'data:application/json;charset=utf-8;base64,' +
                  btoa(this.toString())
                )
              },
            }

            function guessIndent(code) {
              var lines = code.split('\n')

              var tabbed = lines.filter(function(line) {
                return /^\t+/.test(line)
              })
              var spaced = lines.filter(function(line) {
                return /^ {2,}/.test(line)
              })

              if (tabbed.length === 0 && spaced.length === 0) {
                return null
              }

              // More lines tabbed than spaced? Assume tabs, and
              // default to tabs in the case of a tie (or nothing
              // to go on)
              if (tabbed.length >= spaced.length) {
                return '\t'
              }

              // Otherwise, we need to guess the multiple
              var min = spaced.reduce(function(previous, current) {
                var numSpaces = /^ +/.exec(current)[0].length
                return Math.min(numSpaces, previous)
              }, Infinity)

              return new Array(min + 1).join(' ')
            }

            function getLocator(source) {
              var originalLines = source.split('\n')

              var start = 0
              var lineRanges = originalLines.map(function(line, i) {
                var end = start + line.length + 1
                var range = { start: start, end: end, line: i }

                start = end
                return range
              })

              var i = 0

              function rangeContains(range, index) {
                return range.start <= index && index < range.end
              }

              function getLocation(range, index) {
                return { line: range.line, column: index - range.start }
              }

              return function locate(index) {
                var range = lineRanges[i]

                var d = index >= range.end ? 1 : -1

                while (range) {
                  if (rangeContains(range, index))
                    return getLocation(range, index)

                  i += d
                  range = lineRanges[i]
                }
              }
            }

            function encodeMappings(
              original,
              intro,
              chunk,
              hires,
              sourcemapLocations,
              sourceIndex,
              offsets,
              names
            ) {
              var rawLines = []

              var generatedCodeLine = intro.split('\n').length - 1
              var rawSegments = (rawLines[generatedCodeLine] = [])

              var generatedCodeColumn = 0

              var locate = getLocator(original)

              function addEdit(content, original, loc, nameIndex, i) {
                if (i || content.length) {
                  rawSegments.push({
                    generatedCodeLine: generatedCodeLine,
                    generatedCodeColumn: generatedCodeColumn,
                    sourceCodeLine: loc.line,
                    sourceCodeColumn: loc.column,
                    sourceCodeName: nameIndex,
                    sourceIndex: sourceIndex,
                  })
                }

                var lines = content.split('\n')
                var lastLine = lines.pop()

                if (lines.length) {
                  generatedCodeLine += lines.length
                  rawLines[generatedCodeLine] = rawSegments = []
                  generatedCodeColumn = lastLine.length
                } else {
                  generatedCodeColumn += lastLine.length
                }

                lines = original.split('\n')
                lastLine = lines.pop()

                if (lines.length) {
                  loc.line += lines.length
                  loc.column = lastLine.length
                } else {
                  loc.column += lastLine.length
                }
              }

              function addUneditedChunk(chunk, loc) {
                var originalCharIndex = chunk.start
                var first = true

                while (originalCharIndex < chunk.end) {
                  if (hires || first || sourcemapLocations[originalCharIndex]) {
                    rawSegments.push({
                      generatedCodeLine: generatedCodeLine,
                      generatedCodeColumn: generatedCodeColumn,
                      sourceCodeLine: loc.line,
                      sourceCodeColumn: loc.column,
                      sourceCodeName: -1,
                      sourceIndex: sourceIndex,
                    })
                  }

                  if (original[originalCharIndex] === '\n') {
                    loc.line += 1
                    loc.column = 0
                    generatedCodeLine += 1
                    rawLines[generatedCodeLine] = rawSegments = []
                    generatedCodeColumn = 0
                  } else {
                    loc.column += 1
                    generatedCodeColumn += 1
                  }

                  originalCharIndex += 1
                  first = false
                }
              }

              while (chunk) {
                var loc = locate(chunk.start)

                if (chunk.intro.length) {
                  addEdit(chunk.intro, '', loc, -1, !!chunk.previous)
                }

                if (chunk.edited) {
                  addEdit(
                    chunk.content,
                    chunk.original,
                    loc,
                    chunk.storeName ? names.indexOf(chunk.original) : -1,
                    !!chunk.previous
                  )
                } else {
                  addUneditedChunk(chunk, loc)
                }

                if (chunk.outro.length) {
                  addEdit(chunk.outro, '', loc, -1, !!chunk.previous)
                }

                var nextChunk = chunk.next
                chunk = nextChunk
              }

              offsets.sourceIndex = offsets.sourceIndex || 0
              offsets.sourceCodeLine = offsets.sourceCodeLine || 0
              offsets.sourceCodeColumn = offsets.sourceCodeColumn || 0
              offsets.sourceCodeName = offsets.sourceCodeName || 0

              var encoded = rawLines
                .map(function(segments) {
                  var generatedCodeColumn = 0

                  return segments
                    .map(function(segment) {
                      var arr = [
                        segment.generatedCodeColumn - generatedCodeColumn,
                        segment.sourceIndex - offsets.sourceIndex,
                        segment.sourceCodeLine - offsets.sourceCodeLine,
                        segment.sourceCodeColumn - offsets.sourceCodeColumn,
                      ]

                      generatedCodeColumn = segment.generatedCodeColumn
                      offsets.sourceIndex = segment.sourceIndex
                      offsets.sourceCodeLine = segment.sourceCodeLine
                      offsets.sourceCodeColumn = segment.sourceCodeColumn

                      if (~segment.sourceCodeName) {
                        arr.push(
                          segment.sourceCodeName - offsets.sourceCodeName
                        )
                        offsets.sourceCodeName = segment.sourceCodeName
                      }

                      return vlq.encode(arr)
                    })
                    .join(',')
                })
                .join(';')

              return encoded
            }

            function getRelativePath(from, to) {
              var fromParts = from.split(/[\/\\]/)
              var toParts = to.split(/[\/\\]/)

              fromParts.pop() // get dirname

              while (fromParts[0] === toParts[0]) {
                fromParts.shift()
                toParts.shift()
              }

              if (fromParts.length) {
                var i = fromParts.length
                while (i--) fromParts[i] = '..'
              }

              return fromParts.concat(toParts).join('/')
            }

            var toString = Object.prototype.toString

            function isObject(thing) {
              return toString.call(thing) === '[object Object]'
            }

            function MagicString(string, options) {
              if (options === void 0) options = {}

              var chunk = new Chunk(0, string.length, string)

              Object.defineProperties(this, {
                original: { writable: true, value: string },
                outro: { writable: true, value: '' },
                intro: { writable: true, value: '' },
                firstChunk: { writable: true, value: chunk },
                lastChunk: { writable: true, value: chunk },
                lastSearchedChunk: { writable: true, value: chunk },
                byStart: { writable: true, value: {} },
                byEnd: { writable: true, value: {} },
                filename: { writable: true, value: options.filename },
                indentExclusionRanges: {
                  writable: true,
                  value: options.indentExclusionRanges,
                },
                sourcemapLocations: { writable: true, value: {} },
                storedNames: { writable: true, value: {} },
                indentStr: { writable: true, value: guessIndent(string) },
              })

              if (false) {
              }

              this.byStart[0] = chunk
              this.byEnd[string.length] = chunk
            }

            MagicString.prototype = {
              addSourcemapLocation: function addSourcemapLocation(char) {
                this.sourcemapLocations[char] = true
              },

              append: function append(content) {
                if (typeof content !== 'string')
                  throw new TypeError('outro content must be a string')

                this.outro += content
                return this
              },

              clone: function clone() {
                var cloned = new MagicString(this.original, {
                  filename: this.filename,
                })

                var originalChunk = this.firstChunk
                var clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone())

                while (originalChunk) {
                  cloned.byStart[clonedChunk.start] = clonedChunk
                  cloned.byEnd[clonedChunk.end] = clonedChunk

                  var nextOriginalChunk = originalChunk.next
                  var nextClonedChunk =
                    nextOriginalChunk && nextOriginalChunk.clone()

                  if (nextClonedChunk) {
                    clonedChunk.next = nextClonedChunk
                    nextClonedChunk.previous = clonedChunk

                    clonedChunk = nextClonedChunk
                  }

                  originalChunk = nextOriginalChunk
                }

                cloned.lastChunk = clonedChunk

                if (this.indentExclusionRanges) {
                  cloned.indentExclusionRanges = typeof this
                    .indentExclusionRanges[0] === 'number'
                    ? [
                        this.indentExclusionRanges[0],
                        this.indentExclusionRanges[1],
                      ]
                    : this.indentExclusionRanges.map(function(range) {
                        return [range.start, range.end]
                      })
                }

                Object.keys(this.sourcemapLocations).forEach(function(loc) {
                  cloned.sourcemapLocations[loc] = true
                })

                return cloned
              },

              generateMap: function generateMap(options) {
                options = options || {}

                var names = Object.keys(this.storedNames)

                if (false) {
                }
                var map = new SourceMap({
                  file: options.file
                    ? options.file.split(/[\/\\]/).pop()
                    : null,
                  sources: [
                    options.source
                      ? getRelativePath(options.file || '', options.source)
                      : null,
                  ],
                  sourcesContent: options.includeContent
                    ? [this.original]
                    : [null],
                  names: names,
                  mappings: this.getMappings(options.hires, 0, {}, names),
                })
                if (false) {
                }

                return map
              },

              getIndentString: function getIndentString() {
                return this.indentStr === null ? '\t' : this.indentStr
              },

              getMappings: function getMappings(
                hires,
                sourceIndex,
                offsets,
                names
              ) {
                return encodeMappings(
                  this.original,
                  this.intro,
                  this.firstChunk,
                  hires,
                  this.sourcemapLocations,
                  sourceIndex,
                  offsets,
                  names
                )
              },

              indent: function indent(indentStr, options) {
                var this$1 = this

                var pattern = /^[^\r\n]/gm

                if (isObject(indentStr)) {
                  options = indentStr
                  indentStr = undefined
                }

                indentStr = indentStr !== undefined
                  ? indentStr
                  : this.indentStr || '\t'

                if (indentStr === '') return this // noop

                options = options || {}

                // Process exclusion ranges
                var isExcluded = {}

                if (options.exclude) {
                  var exclusions = typeof options.exclude[0] === 'number'
                    ? [options.exclude]
                    : options.exclude
                  exclusions.forEach(function(exclusion) {
                    for (var i = exclusion[0]; i < exclusion[1]; i += 1) {
                      isExcluded[i] = true
                    }
                  })
                }

                var shouldIndentNextCharacter = options.indentStart !== false
                var replacer = function(match) {
                  if (shouldIndentNextCharacter) return '' + indentStr + match
                  shouldIndentNextCharacter = true
                  return match
                }

                this.intro = this.intro.replace(pattern, replacer)

                var charIndex = 0

                var chunk = this.firstChunk

                while (chunk) {
                  var end = chunk.end

                  if (chunk.edited) {
                    if (!isExcluded[charIndex]) {
                      chunk.content = chunk.content.replace(pattern, replacer)

                      if (chunk.content.length) {
                        shouldIndentNextCharacter =
                          chunk.content[chunk.content.length - 1] === '\n'
                      }
                    }
                  } else {
                    charIndex = chunk.start

                    while (charIndex < end) {
                      if (!isExcluded[charIndex]) {
                        var char = this$1.original[charIndex]

                        if (char === '\n') {
                          shouldIndentNextCharacter = true
                        } else if (char !== '\r' && shouldIndentNextCharacter) {
                          shouldIndentNextCharacter = false

                          if (charIndex === chunk.start) {
                            chunk.prepend(indentStr)
                          } else {
                            var rhs = chunk.split(charIndex)
                            rhs.prepend(indentStr)

                            this$1.byStart[charIndex] = rhs
                            this$1.byEnd[charIndex] = chunk

                            chunk = rhs
                          }
                        }
                      }

                      charIndex += 1
                    }
                  }

                  charIndex = chunk.end
                  chunk = chunk.next
                }

                this.outro = this.outro.replace(pattern, replacer)

                return this
              },

              insert: function insert() {
                throw new Error(
                  'magicString.insert(...) is deprecated. Use insertRight(...) or insertLeft(...)'
                )
              },

              insertLeft: function insertLeft(index, content) {
                if (typeof content !== 'string')
                  throw new TypeError('inserted content must be a string')

                if (false) {
                }

                this._split(index)

                var chunk = this.byEnd[index]

                if (chunk) {
                  chunk.append(content)
                } else {
                  this.intro += content
                }

                if (false) {
                }
                return this
              },

              insertRight: function insertRight(index, content) {
                if (typeof content !== 'string')
                  throw new TypeError('inserted content must be a string')

                if (false) {
                }

                this._split(index)

                var chunk = this.byStart[index]

                if (chunk) {
                  chunk.prepend(content)
                } else {
                  this.outro += content
                }

                if (false) {
                }
                return this
              },

              move: function move(start, end, index) {
                if (index >= start && index <= end)
                  throw new Error('Cannot move a selection inside itself')

                if (false) {
                }

                this._split(start)
                this._split(end)
                this._split(index)

                var first = this.byStart[start]
                var last = this.byEnd[end]

                var oldLeft = first.previous
                var oldRight = last.next

                var newRight = this.byStart[index]
                if (!newRight && last === this.lastChunk) return this
                var newLeft = newRight ? newRight.previous : this.lastChunk

                if (oldLeft) oldLeft.next = oldRight
                if (oldRight) oldRight.previous = oldLeft

                if (newLeft) newLeft.next = first
                if (newRight) newRight.previous = last

                if (!first.previous) this.firstChunk = last.next
                if (!last.next) {
                  this.lastChunk = first.previous
                  this.lastChunk.next = null
                }

                first.previous = newLeft
                last.next = newRight

                if (!newLeft) this.firstChunk = first
                if (!newRight) this.lastChunk = last

                if (false) {
                }
                return this
              },

              overwrite: function overwrite(start, end, content, storeName) {
                var this$1 = this

                if (typeof content !== 'string')
                  throw new TypeError('replacement content must be a string')

                while (start < 0) start += this$1.original.length
                while (end < 0) end += this$1.original.length

                if (end > this.original.length)
                  throw new Error('end is out of bounds')
                if (start === end)
                  throw new Error(
                    'Cannot overwrite a zero-length range  use insertLeft or insertRight instead'
                  )

                if (false) {
                }

                this._split(start)
                this._split(end)

                if (storeName) {
                  var original = this.original.slice(start, end)
                  this.storedNames[original] = true
                }

                var first = this.byStart[start]
                var last = this.byEnd[end]

                if (first) {
                  first.edit(content, storeName)

                  if (first !== last) {
                    first.outro = ''

                    var chunk = first.next
                    while (chunk !== last) {
                      chunk.edit('', false)
                      chunk.intro = chunk.outro = ''
                      chunk = chunk.next
                    }

                    chunk.edit('', false)
                    chunk.intro = ''
                  }
                } else {
                  // must be inserting at the end
                  var newChunk = new Chunk(start, end, '').edit(
                    content,
                    storeName
                  )

                  // TODO last chunk in the array may not be the last chunk, if it's moved...
                  last.next = newChunk
                  newChunk.previous = last
                }

                if (false) {
                }
                return this
              },

              prepend: function prepend(content) {
                if (typeof content !== 'string')
                  throw new TypeError('outro content must be a string')

                this.intro = content + this.intro
                return this
              },

              remove: function remove(start, end) {
                var this$1 = this

                while (start < 0) start += this$1.original.length
                while (end < 0) end += this$1.original.length

                if (start === end) return this

                if (start < 0 || end > this.original.length)
                  throw new Error('Character is out of bounds')
                if (start > end)
                  throw new Error('end must be greater than start')

                return this.overwrite(start, end, '', false)
              },

              slice: function slice(start, end) {
                var this$1 = this
                if (start === void 0) start = 0
                if (end === void 0) end = this.original.length

                while (start < 0) start += this$1.original.length
                while (end < 0) end += this$1.original.length

                var result = ''

                // find start chunk
                var chunk = this.firstChunk
                while (chunk && (chunk.start > start || chunk.end <= start)) {
                  // found end chunk before start
                  if (chunk.start < end && chunk.end >= end) {
                    return result
                  }

                  chunk = chunk.next
                }

                if (chunk && chunk.edited && chunk.start !== start)
                  throw new Error(
                    'Cannot use replaced character ' +
                      start +
                      ' as slice start anchor.'
                  )

                var startChunk = chunk
                while (chunk) {
                  if (
                    chunk.intro &&
                    (startChunk !== chunk || chunk.start === start)
                  ) {
                    result += chunk.intro
                  }

                  var containsEnd = chunk.start < end && chunk.end >= end
                  if (containsEnd && chunk.edited && chunk.end !== end)
                    throw new Error(
                      'Cannot use replaced character ' +
                        end +
                        ' as slice end anchor.'
                    )

                  var sliceStart = startChunk === chunk
                    ? start - chunk.start
                    : 0
                  var sliceEnd = containsEnd
                    ? chunk.content.length + end - chunk.end
                    : chunk.content.length

                  result += chunk.content.slice(sliceStart, sliceEnd)

                  if (chunk.outro && (!containsEnd || chunk.end === end)) {
                    result += chunk.outro
                  }

                  if (containsEnd) {
                    break
                  }

                  chunk = chunk.next
                }

                return result
              },

              // TODO deprecate this? not really very useful
              snip: function snip(start, end) {
                var clone = this.clone()
                clone.remove(0, start)
                clone.remove(end, clone.original.length)

                return clone
              },

              _split: function _split(index) {
                var this$1 = this

                if (this.byStart[index] || this.byEnd[index]) return

                if (false) {
                }

                var chunk = this.lastSearchedChunk
                var searchForward = index > chunk.end

                while (true) {
                  if (chunk.contains(index))
                    return this$1._splitChunk(chunk, index)

                  chunk = searchForward
                    ? this$1.byStart[chunk.end]
                    : this$1.byEnd[chunk.start]
                }
              },

              _splitChunk: function _splitChunk(chunk, index) {
                if (chunk.edited && chunk.content.length) {
                  // zero-length edited chunks are a special case (overlapping replacements)
                  var loc = getLocator(this.original)(index)
                  throw new Error(
                    'Cannot split a chunk that has already been edited (' +
                      loc.line +
                      ':' +
                      loc.column +
                      '  "' +
                      chunk.original +
                      '")'
                  )
                }

                var newChunk = chunk.split(index)

                this.byEnd[index] = chunk
                this.byStart[index] = newChunk
                this.byEnd[newChunk.end] = newChunk

                if (chunk === this.lastChunk) this.lastChunk = newChunk

                this.lastSearchedChunk = chunk
                if (false) {
                }
                return true
              },

              toString: function toString() {
                var str = this.intro

                var chunk = this.firstChunk
                while (chunk) {
                  str += chunk.toString()
                  chunk = chunk.next
                }

                return str + this.outro
              },

              trimLines: function trimLines() {
                return this.trim('[\\r\\n]')
              },

              trim: function trim(charType) {
                return this.trimStart(charType).trimEnd(charType)
              },

              trimEnd: function trimEnd(charType) {
                var this$1 = this

                var rx = new RegExp((charType || '\\s') + '+$')

                this.outro = this.outro.replace(rx, '')
                if (this.outro.length) return this

                var chunk = this.lastChunk

                do {
                  var end = chunk.end
                  var aborted = chunk.trimEnd(rx)

                  // if chunk was trimmed, we have a new lastChunk
                  if (chunk.end !== end) {
                    this$1.lastChunk = chunk.next

                    this$1.byEnd[chunk.end] = chunk
                    this$1.byStart[chunk.next.start] = chunk.next
                  }

                  if (aborted) return this$1
                  chunk = chunk.previous
                } while (chunk)

                return this
              },

              trimStart: function trimStart(charType) {
                var this$1 = this

                var rx = new RegExp('^' + (charType || '\\s') + '+')

                this.intro = this.intro.replace(rx, '')
                if (this.intro.length) return this

                var chunk = this.firstChunk

                do {
                  var end = chunk.end
                  var aborted = chunk.trimStart(rx)

                  if (chunk.end !== end) {
                    // special case...
                    if (chunk === this$1.lastChunk)
                      this$1.lastChunk = chunk.next

                    this$1.byEnd[chunk.end] = chunk
                    this$1.byStart[chunk.next.start] = chunk.next
                  }

                  if (aborted) return this$1
                  chunk = chunk.next
                } while (chunk)

                return this
              },
            }

            var hasOwnProp = Object.prototype.hasOwnProperty

            function Bundle(options) {
              if (options === void 0) options = {}

              this.intro = options.intro || ''
              this.separator = options.separator !== undefined
                ? options.separator
                : '\n'

              this.sources = []

              this.uniqueSources = []
              this.uniqueSourceIndexByFilename = {}
            }

            Bundle.prototype = {
              addSource: function addSource(source) {
                if (source instanceof MagicString) {
                  return this.addSource({
                    content: source,
                    filename: source.filename,
                    separator: this.separator,
                  })
                }

                if (!isObject(source) || !source.content) {
                  throw new Error(
                    'bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`'
                  )
                }

                ;[
                  'filename',
                  'indentExclusionRanges',
                  'separator',
                ].forEach(function(option) {
                  if (!hasOwnProp.call(source, option))
                    source[option] = source.content[option]
                })

                if (source.separator === undefined) {
                  // TODO there's a bunch of this sort of thing, needs cleaning up
                  source.separator = this.separator
                }

                if (source.filename) {
                  if (
                    !hasOwnProp.call(
                      this.uniqueSourceIndexByFilename,
                      source.filename
                    )
                  ) {
                    this.uniqueSourceIndexByFilename[
                      source.filename
                    ] = this.uniqueSources.length
                    this.uniqueSources.push({
                      filename: source.filename,
                      content: source.content.original,
                    })
                  } else {
                    var uniqueSource = this.uniqueSources[
                      this.uniqueSourceIndexByFilename[source.filename]
                    ]
                    if (source.content.original !== uniqueSource.content) {
                      throw new Error(
                        'Illegal source: same filename (' +
                          source.filename +
                          '), different contents'
                      )
                    }
                  }
                }

                this.sources.push(source)
                return this
              },

              append: function append(str, options) {
                this.addSource({
                  content: new MagicString(str),
                  separator: (options && options.separator) || '',
                })

                return this
              },

              clone: function clone() {
                var bundle = new Bundle({
                  intro: this.intro,
                  separator: this.separator,
                })

                this.sources.forEach(function(source) {
                  bundle.addSource({
                    filename: source.filename,
                    content: source.content.clone(),
                    separator: source.separator,
                  })
                })

                return bundle
              },

              generateMap: function generateMap(options) {
                var this$1 = this

                var offsets = {}

                var names = []
                this.sources.forEach(function(source) {
                  Object.keys(source.content.storedNames).forEach(function(
                    name
                  ) {
                    if (!~names.indexOf(name)) names.push(name)
                  })
                })

                var encoded =
                  getSemis(this.intro) +
                  this.sources
                    .map(function(source, i) {
                      var prefix = i > 0
                        ? getSemis(source.separator) || ','
                        : ''
                      var mappings

                      // we don't bother encoding sources without a filename
                      if (!source.filename) {
                        mappings = getSemis(source.content.toString())
                      } else {
                        var sourceIndex =
                          this$1.uniqueSourceIndexByFilename[source.filename]
                        mappings = source.content.getMappings(
                          options.hires,
                          sourceIndex,
                          offsets,
                          names
                        )
                      }

                      return prefix + mappings
                    })
                    .join('')

                return new SourceMap({
                  file: options.file
                    ? options.file.split(/[\/\\]/).pop()
                    : null,
                  sources: this.uniqueSources.map(function(source) {
                    return options.file
                      ? getRelativePath(options.file, source.filename)
                      : source.filename
                  }),
                  sourcesContent: this.uniqueSources.map(function(source) {
                    return options.includeContent ? source.content : null
                  }),
                  names: names,
                  mappings: encoded,
                })
              },

              getIndentString: function getIndentString() {
                var indentStringCounts = {}

                this.sources.forEach(function(source) {
                  var indentStr = source.content.indentStr

                  if (indentStr === null) return

                  if (!indentStringCounts[indentStr])
                    indentStringCounts[indentStr] = 0
                  indentStringCounts[indentStr] += 1
                })

                return (
                  Object.keys(indentStringCounts).sort(function(a, b) {
                    return indentStringCounts[a] - indentStringCounts[b]
                  })[0] || '\t'
                )
              },

              indent: function indent(indentStr) {
                var this$1 = this

                if (!arguments.length) {
                  indentStr = this.getIndentString()
                }

                if (indentStr === '') return this // noop

                var trailingNewline =
                  !this.intro || this.intro.slice(-1) === '\n'

                this.sources.forEach(function(source, i) {
                  var separator = source.separator !== undefined
                    ? source.separator
                    : this$1.separator
                  var indentStart =
                    trailingNewline || (i > 0 && /\r?\n$/.test(separator))

                  source.content.indent(indentStr, {
                    exclude: source.indentExclusionRanges,
                    indentStart: indentStart, //: trailingNewline || /\r?\n$/.test( separator )  //true///\r?\n/.test( separator )
                  })

                  // TODO this is a very slow way to determine this
                  trailingNewline =
                    source.content.toString().slice(0, -1) === '\n'
                })

                if (this.intro) {
                  this.intro =
                    indentStr +
                    this.intro.replace(/^[^\n]/gm, function(match, index) {
                      return index > 0 ? indentStr + match : match
                    })
                }

                return this
              },

              prepend: function prepend(str) {
                this.intro = str + this.intro
                return this
              },

              toString: function toString() {
                var this$1 = this

                var body = this.sources
                  .map(function(source, i) {
                    var separator = source.separator !== undefined
                      ? source.separator
                      : this$1.separator
                    var str =
                      (i > 0 ? separator : '') + source.content.toString()

                    return str
                  })
                  .join('')

                return this.intro + body
              },

              trimLines: function trimLines() {
                return this.trim('[\\r\\n]')
              },

              trim: function trim(charType) {
                return this.trimStart(charType).trimEnd(charType)
              },

              trimStart: function trimStart(charType) {
                var this$1 = this

                var rx = new RegExp('^' + (charType || '\\s') + '+')
                this.intro = this.intro.replace(rx, '')

                if (!this.intro) {
                  var source
                  var i = 0

                  do {
                    source = this$1.sources[i]

                    if (!source) {
                      break
                    }

                    source.content.trimStart(charType)
                    i += 1
                  } while (source.content.toString() === '') // TODO faster way to determine non-empty source?
                }

                return this
              },

              trimEnd: function trimEnd(charType) {
                var this$1 = this

                var rx = new RegExp((charType || '\\s') + '+$')

                var source
                var i = this.sources.length - 1

                do {
                  source = this$1.sources[i]

                  if (!source) {
                    this$1.intro = this$1.intro.replace(rx, '')
                    break
                  }

                  source.content.trimEnd(charType)
                  i -= 1
                } while (source.content.toString() === '') // TODO faster way to determine non-empty source?

                return this
              },
            }

            function getSemis(str) {
              return new Array(str.split('\n').length).join(';')
            }

            MagicString.Bundle = Bundle

            module.exports = MagicString
          }.call(this, require('buffer').Buffer))
        },
        { buffer: 121, vlq: 569 },
      ],
      502: [
        function(require, module, exports) {
          module.exports = minimatch
          minimatch.Minimatch = Minimatch

          var path = { sep: '/' }
          try {
            path = require('path')
          } catch (er) {}

          var GLOBSTAR = (minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {})
          var expand = require('brace-expansion')

          var plTypes = {
            '!': { open: '(?:(?!(?:', close: '))[^/]*?)' },
            '?': { open: '(?:', close: ')?' },
            '+': { open: '(?:', close: ')+' },
            '*': { open: '(?:', close: ')*' },
            '@': { open: '(?:', close: ')' },
          }

          // any single thing other than /
          // don't need to escape / when using new RegExp()
          var qmark = '[^/]'

          // * => any number of characters
          var star = qmark + '*?'

          // ** when dots are allowed.  Anything goes, except .. and .
          // not (^ or / followed by one or two dots followed by $ or /),
          // followed by anything, any number of times.
          var twoStarDot = '(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?'

          // not a ^ or / followed by a dot,
          // followed by anything, any number of times.
          var twoStarNoDot = '(?:(?!(?:\\/|^)\\.).)*?'

          // characters that need to be escaped in RegExp.
          var reSpecials = charSet('().*{}+?[]^$\\!')

          // "abc" -> { a:true, b:true, c:true }
          function charSet(s) {
            return s.split('').reduce(function(set, c) {
              set[c] = true
              return set
            }, {})
          }

          // normalizes slashes.
          var slashSplit = /\/+/

          minimatch.filter = filter
          function filter(pattern, options) {
            options = options || {}
            return function(p, i, list) {
              return minimatch(p, pattern, options)
            }
          }

          function ext(a, b) {
            a = a || {}
            b = b || {}
            var t = {}
            Object.keys(b).forEach(function(k) {
              t[k] = b[k]
            })
            Object.keys(a).forEach(function(k) {
              t[k] = a[k]
            })
            return t
          }

          minimatch.defaults = function(def) {
            if (!def || !Object.keys(def).length) return minimatch

            var orig = minimatch

            var m = function minimatch(p, pattern, options) {
              return orig.minimatch(p, pattern, ext(def, options))
            }

            m.Minimatch = function Minimatch(pattern, options) {
              return new orig.Minimatch(pattern, ext(def, options))
            }

            return m
          }

          Minimatch.defaults = function(def) {
            if (!def || !Object.keys(def).length) return Minimatch
            return minimatch.defaults(def).Minimatch
          }

          function minimatch(p, pattern, options) {
            if (typeof pattern !== 'string') {
              throw new TypeError('glob pattern string required')
            }

            if (!options) options = {}

            // shortcut: comments match nothing.
            if (!options.nocomment && pattern.charAt(0) === '#') {
              return false
            }

            // "" only matches ""
            if (pattern.trim() === '') return p === ''

            return new Minimatch(pattern, options).match(p)
          }

          function Minimatch(pattern, options) {
            if (!(this instanceof Minimatch)) {
              return new Minimatch(pattern, options)
            }

            if (typeof pattern !== 'string') {
              throw new TypeError('glob pattern string required')
            }

            if (!options) options = {}
            pattern = pattern.trim()

            // windows support: need to use /, not \
            if (path.sep !== '/') {
              pattern = pattern.split(path.sep).join('/')
            }

            this.options = options
            this.set = []
            this.pattern = pattern
            this.regexp = null
            this.negate = false
            this.comment = false
            this.empty = false

            // make the set of regexps etc.
            this.make()
          }

          Minimatch.prototype.debug = function() {}

          Minimatch.prototype.make = make
          function make() {
            // don't do it more than once.
            if (this._made) return

            var pattern = this.pattern
            var options = this.options

            // empty patterns and comments match nothing.
            if (!options.nocomment && pattern.charAt(0) === '#') {
              this.comment = true
              return
            }
            if (!pattern) {
              this.empty = true
              return
            }

            // step 1: figure out negation, etc.
            this.parseNegate()

            // step 2: expand braces
            var set = (this.globSet = this.braceExpand())

            if (options.debug) this.debug = console.error

            this.debug(this.pattern, set)

            // step 3: now we have a set, so turn each one into a series of path-portion
            // matching patterns.
            // These will be regexps, except in the case of "**", which is
            // set to the GLOBSTAR object for globstar behavior,
            // and will not contain any / characters
            set = this.globParts = set.map(function(s) {
              return s.split(slashSplit)
            })

            this.debug(this.pattern, set)

            // glob --> regexps
            set = set.map(function(s, si, set) {
              return s.map(this.parse, this)
            }, this)

            this.debug(this.pattern, set)

            // filter out everything that didn't compile properly.
            set = set.filter(function(s) {
              return s.indexOf(false) === -1
            })

            this.debug(this.pattern, set)

            this.set = set
          }

          Minimatch.prototype.parseNegate = parseNegate
          function parseNegate() {
            var pattern = this.pattern
            var negate = false
            var options = this.options
            var negateOffset = 0

            if (options.nonegate) return

            for (
              var i = 0, l = pattern.length;
              i < l && pattern.charAt(i) === '!';
              i++
            ) {
              negate = !negate
              negateOffset++
            }

            if (negateOffset) this.pattern = pattern.substr(negateOffset)
            this.negate = negate
          }

          // Brace expansion:
          // a{b,c}d -> abd acd
          // a{b,}c -> abc ac
          // a{0..3}d -> a0d a1d a2d a3d
          // a{b,c{d,e}f}g -> abg acdfg acefg
          // a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
          //
          // Invalid sets are not expanded.
          // a{2..}b -> a{2..}b
          // a{b}c -> a{b}c
          minimatch.braceExpand = function(pattern, options) {
            return braceExpand(pattern, options)
          }

          Minimatch.prototype.braceExpand = braceExpand

          function braceExpand(pattern, options) {
            if (!options) {
              if (this instanceof Minimatch) {
                options = this.options
              } else {
                options = {}
              }
            }

            pattern = typeof pattern === 'undefined' ? this.pattern : pattern

            if (typeof pattern === 'undefined') {
              throw new TypeError('undefined pattern')
            }

            if (options.nobrace || !pattern.match(/\{.*\}/)) {
              // shortcut. no need to expand.
              return [pattern]
            }

            return expand(pattern)
          }

          // parse a component of the expanded set.
          // At this point, no pattern may contain "/" in it
          // so we're going to return a 2d array, where each entry is the full
          // pattern, split on '/', and then turned into a regular expression.
          // A regexp is made at the end which joins each array with an
          // escaped /, and another full one which joins each regexp with |.
          //
          // Following the lead of Bash 4.1, note that "**" only has special meaning
          // when it is the *only* thing in a path portion.  Otherwise, any series
          // of * is equivalent to a single *.  Globstar behavior is enabled by
          // default, and can be disabled by setting options.noglobstar.
          Minimatch.prototype.parse = parse
          var SUBPARSE = {}
          function parse(pattern, isSub) {
            if (pattern.length > 1024 * 64) {
              throw new TypeError('pattern is too long')
            }

            var options = this.options

            // shortcuts
            if (!options.noglobstar && pattern === '**') return GLOBSTAR
            if (pattern === '') return ''

            var re = ''
            var hasMagic = !!options.nocase
            var escaping = false
            // ? => one single character
            var patternListStack = []
            var negativeLists = []
            var stateChar
            var inClass = false
            var reClassStart = -1
            var classStart = -1
            // . and .. never match anything that doesn't start with .,
            // even when options.dot is set.
            var patternStart = pattern.charAt(0) === '.'
              ? '' // anything
              : // not (start or / followed by . or .. followed by / or end)
                options.dot ? '(?!(?:^|\\/)\\.{1,2}(?:$|\\/))' : '(?!\\.)'
            var self = this

            function clearStateChar() {
              if (stateChar) {
                // we had some state-tracking character
                // that wasn't consumed by this pass.
                switch (stateChar) {
                  case '*':
                    re += star
                    hasMagic = true
                    break
                  case '?':
                    re += qmark
                    hasMagic = true
                    break
                  default:
                    re += '\\' + stateChar
                    break
                }
                self.debug('clearStateChar %j %j', stateChar, re)
                stateChar = false
              }
            }

            for (
              var i = 0, len = pattern.length, c;
              i < len && (c = pattern.charAt(i));
              i++
            ) {
              this.debug('%s\t%s %s %j', pattern, i, re, c)

              // skip over any that are escaped.
              if (escaping && reSpecials[c]) {
                re += '\\' + c
                escaping = false
                continue
              }

              switch (c) {
                case '/':
                  // completely not allowed, even escaped.
                  // Should already be path-split by now.
                  return false

                case '\\':
                  clearStateChar()
                  escaping = true
                  continue

                // the various stateChar values
                // for the "extglob" stuff.
                case '?':
                case '*':
                case '+':
                case '@':
                case '!':
                  this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c)

                  // all of those are literals inside a class, except that
                  // the glob [!a] means [^a] in regexp
                  if (inClass) {
                    this.debug('  in class')
                    if (c === '!' && i === classStart + 1) c = '^'
                    re += c
                    continue
                  }

                  // if we already have a stateChar, then it means
                  // that there was something like ** or +? in there.
                  // Handle the stateChar, then proceed with this one.
                  self.debug('call clearStateChar %j', stateChar)
                  clearStateChar()
                  stateChar = c
                  // if extglob is disabled, then +(asdf|foo) isn't a thing.
                  // just clear the statechar *now*, rather than even diving into
                  // the patternList stuff.
                  if (options.noext) clearStateChar()
                  continue

                case '(':
                  if (inClass) {
                    re += '('
                    continue
                  }

                  if (!stateChar) {
                    re += '\\('
                    continue
                  }

                  patternListStack.push({
                    type: stateChar,
                    start: i - 1,
                    reStart: re.length,
                    open: plTypes[stateChar].open,
                    close: plTypes[stateChar].close,
                  })
                  // negation is (?:(?!js)[^/]*)
                  re += stateChar === '!' ? '(?:(?!(?:' : '(?:'
                  this.debug('plType %j %j', stateChar, re)
                  stateChar = false
                  continue

                case ')':
                  if (inClass || !patternListStack.length) {
                    re += '\\)'
                    continue
                  }

                  clearStateChar()
                  hasMagic = true
                  var pl = patternListStack.pop()
                  // negation is (?:(?!js)[^/]*)
                  // The others are (?:<pattern>)<type>
                  re += pl.close
                  if (pl.type === '!') {
                    negativeLists.push(pl)
                  }
                  pl.reEnd = re.length
                  continue

                case '|':
                  if (inClass || !patternListStack.length || escaping) {
                    re += '\\|'
                    escaping = false
                    continue
                  }

                  clearStateChar()
                  re += '|'
                  continue

                // these are mostly the same in regexp and glob
                case '[':
                  // swallow any state-tracking char before the [
                  clearStateChar()

                  if (inClass) {
                    re += '\\' + c
                    continue
                  }

                  inClass = true
                  classStart = i
                  reClassStart = re.length
                  re += c
                  continue

                case ']':
                  //  a right bracket shall lose its special
                  //  meaning and represent itself in
                  //  a bracket expression if it occurs
                  //  first in the list.  -- POSIX.2 2.8.3.2
                  if (i === classStart + 1 || !inClass) {
                    re += '\\' + c
                    escaping = false
                    continue
                  }

                  // handle the case where we left a class open.
                  // "[z-a]" is valid, equivalent to "\[z-a\]"
                  if (inClass) {
                    // split where the last [ was, make sure we don't have
                    // an invalid re. if so, re-walk the contents of the
                    // would-be class to re-translate any characters that
                    // were passed through as-is
                    // TODO: It would probably be faster to determine this
                    // without a try/catch and a new RegExp, but it's tricky
                    // to do safely.  For now, this is safe and works.
                    var cs = pattern.substring(classStart + 1, i)
                    try {
                      RegExp('[' + cs + ']')
                    } catch (er) {
                      // not a valid class!
                      var sp = this.parse(cs, SUBPARSE)
                      re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]'
                      hasMagic = hasMagic || sp[1]
                      inClass = false
                      continue
                    }
                  }

                  // finish up the class.
                  hasMagic = true
                  inClass = false
                  re += c
                  continue

                default:
                  // swallow any state char that wasn't consumed
                  clearStateChar()

                  if (escaping) {
                    // no need
                    escaping = false
                  } else if (reSpecials[c] && !(c === '^' && inClass)) {
                    re += '\\'
                  }

                  re += c
              } // switch
            } // for

            // handle the case where we left a class open.
            // "[abc" is valid, equivalent to "\[abc"
            if (inClass) {
              // split where the last [ was, and escape it
              // this is a huge pita.  We now have to re-walk
              // the contents of the would-be class to re-translate
              // any characters that were passed through as-is
              cs = pattern.substr(classStart + 1)
              sp = this.parse(cs, SUBPARSE)
              re = re.substr(0, reClassStart) + '\\[' + sp[0]
              hasMagic = hasMagic || sp[1]
            }

            // handle the case where we had a +( thing at the *end*
            // of the pattern.
            // each pattern list stack adds 3 chars, and we need to go through
            // and escape any | chars that were passed through as-is for the regexp.
            // Go through and escape them, taking care not to double-escape any
            // | chars that were already escaped.
            for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
              var tail = re.slice(pl.reStart + pl.open.length)
              this.debug('setting tail', re, pl)
              // maybe some even number of \, then maybe 1 \, followed by a |
              tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(
                _,
                $1,
                $2
              ) {
                if (!$2) {
                  // the | isn't already escaped, so escape it.
                  $2 = '\\'
                }

                // need to escape all those slashes *again*, without escaping the
                // one that we need for escaping the | character.  As it works out,
                // escaping an even number of slashes can be done by simply repeating
                // it exactly after itself.  That's why this trick works.
                //
                // I am sorry that you have to see this.
                return $1 + $1 + $2 + '|'
              })

              this.debug('tail=%j\n   %s', tail, tail, pl, re)
              var t = pl.type === '*'
                ? star
                : pl.type === '?' ? qmark : '\\' + pl.type

              hasMagic = true
              re = re.slice(0, pl.reStart) + t + '\\(' + tail
            }

            // handle trailing things that only matter at the very end.
            clearStateChar()
            if (escaping) {
              // trailing \\
              re += '\\\\'
            }

            // only need to apply the nodot start if the re starts with
            // something that could conceivably capture a dot
            var addPatternStart = false
            switch (re.charAt(0)) {
              case '.':
              case '[':
              case '(':
                addPatternStart = true
            }

            // Hack to work around lack of negative lookbehind in JS
            // A pattern like: *.!(x).!(y|z) needs to ensure that a name
            // like 'a.xyz.yz' doesn't match.  So, the first negative
            // lookahead, has to look ALL the way ahead, to the end of
            // the pattern.
            for (var n = negativeLists.length - 1; n > -1; n--) {
              var nl = negativeLists[n]

              var nlBefore = re.slice(0, nl.reStart)
              var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)
              var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)
              var nlAfter = re.slice(nl.reEnd)

              nlLast += nlAfter

              // Handle nested stuff like *(*.js|!(*.json)), where open parens
              // mean that we should *not* include the ) in the bit that is considered
              // "after" the negated section.
              var openParensBefore = nlBefore.split('(').length - 1
              var cleanAfter = nlAfter
              for (i = 0; i < openParensBefore; i++) {
                cleanAfter = cleanAfter.replace(/\)[+*?]?/, '')
              }
              nlAfter = cleanAfter

              var dollar = ''
              if (nlAfter === '' && isSub !== SUBPARSE) {
                dollar = '$'
              }
              var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast
              re = newRe
            }

            // if the re is not "" at this point, then we need to make sure
            // it doesn't match against an empty path part.
            // Otherwise a/* will match a/, which it should not.
            if (re !== '' && hasMagic) {
              re = '(?=.)' + re
            }

            if (addPatternStart) {
              re = patternStart + re
            }

            // parsing just a piece of a larger pattern.
            if (isSub === SUBPARSE) {
              return [re, hasMagic]
            }

            // skip the regexp for non-magical patterns
            // unescape anything in it, though, so that it'll be
            // an exact match against a file etc.
            if (!hasMagic) {
              return globUnescape(pattern)
            }

            var flags = options.nocase ? 'i' : ''
            try {
              var regExp = new RegExp('^' + re + '$', flags)
            } catch (er) {
              // If it was an invalid regular expression, then it can't match
              // anything.  This trick looks for a character after the end of
              // the string, which is of course impossible, except in multi-line
              // mode, but it's not a /m regex.
              return new RegExp('$.')
            }

            regExp._glob = pattern
            regExp._src = re

            return regExp
          }

          minimatch.makeRe = function(pattern, options) {
            return new Minimatch(pattern, options || {}).makeRe()
          }

          Minimatch.prototype.makeRe = makeRe
          function makeRe() {
            if (this.regexp || this.regexp === false) return this.regexp

            // at this point, this.set is a 2d array of partial
            // pattern strings, or "**".
            //
            // It's better to use .match().  This function shouldn't
            // be used, really, but it's pretty convenient sometimes,
            // when you just want to work with a regex.
            var set = this.set

            if (!set.length) {
              this.regexp = false
              return this.regexp
            }
            var options = this.options

            var twoStar = options.noglobstar
              ? star
              : options.dot ? twoStarDot : twoStarNoDot
            var flags = options.nocase ? 'i' : ''

            var re = set
              .map(function(pattern) {
                return pattern
                  .map(function(p) {
                    return p === GLOBSTAR
                      ? twoStar
                      : typeof p === 'string' ? regExpEscape(p) : p._src
                  })
                  .join('\\/')
              })
              .join('|')

            // must match entire pattern
            // ending in a * or ** will make it less strict.
            re = '^(?:' + re + ')$'

            // can match anything, as long as it's not this.
            if (this.negate) re = '^(?!' + re + ').*$'

            try {
              this.regexp = new RegExp(re, flags)
            } catch (ex) {
              this.regexp = false
            }
            return this.regexp
          }

          minimatch.match = function(list, pattern, options) {
            options = options || {}
            var mm = new Minimatch(pattern, options)
            list = list.filter(function(f) {
              return mm.match(f)
            })
            if (mm.options.nonull && !list.length) {
              list.push(pattern)
            }
            return list
          }

          Minimatch.prototype.match = match
          function match(f, partial) {
            this.debug('match', f, this.pattern)
            // short-circuit in the case of busted things.
            // comments, etc.
            if (this.comment) return false
            if (this.empty) return f === ''

            if (f === '/' && partial) return true

            var options = this.options

            // windows: need to use /, not \
            if (path.sep !== '/') {
              f = f.split(path.sep).join('/')
            }

            // treat the test path as a set of pathparts.
            f = f.split(slashSplit)
            this.debug(this.pattern, 'split', f)

            // just ONE of the pattern sets in this.set needs to match
            // in order for it to be valid.  If negating, then just one
            // match means that we have failed.
            // Either way, return on the first hit.

            var set = this.set
            this.debug(this.pattern, 'set', set)

            // Find the basename of the path by looking for the last non-empty segment
            var filename
            var i
            for (i = f.length - 1; i >= 0; i--) {
              filename = f[i]
              if (filename) break
            }

            for (i = 0; i < set.length; i++) {
              var pattern = set[i]
              var file = f
              if (options.matchBase && pattern.length === 1) {
                file = [filename]
              }
              var hit = this.matchOne(file, pattern, partial)
              if (hit) {
                if (options.flipNegate) return true
                return !this.negate
              }
            }

            // didn't get any hits.  this is success if it's a negative
            // pattern, failure otherwise.
            if (options.flipNegate) return false
            return this.negate
          }

          // set partial to true to test if, for example,
          // "/a/b" matches the start of "/*/b/*/d"
          // Partial means, if you run out of file before you run
          // out of pattern, then that's fine, as long as all
          // the parts match.
          Minimatch.prototype.matchOne = function(file, pattern, partial) {
            var options = this.options

            this.debug('matchOne', { this: this, file: file, pattern: pattern })

            this.debug('matchOne', file.length, pattern.length)

            for (
              var fi = 0, pi = 0, fl = file.length, pl = pattern.length;
              fi < fl && pi < pl;
              fi++, pi++
            ) {
              this.debug('matchOne loop')
              var p = pattern[pi]
              var f = file[fi]

              this.debug(pattern, p, f)

              // should be impossible.
              // some invalid regexp stuff in the set.
              if (p === false) return false

              if (p === GLOBSTAR) {
                this.debug('GLOBSTAR', [pattern, p, f])

                // "**"
                // a/**/b/**/c would match the following:
                // a/b/x/y/z/c
                // a/x/y/z/b/c
                // a/b/x/b/x/c
                // a/b/c
                // To do this, take the rest of the pattern after
                // the **, and see if it would match the file remainder.
                // If so, return success.
                // If not, the ** "swallows" a segment, and try again.
                // This is recursively awful.
                //
                // a/**/b/**/c matching a/b/x/y/z/c
                // - a matches a
                // - doublestar
                //   - matchOne(b/x/y/z/c, b/**/c)
                //     - b matches b
                //     - doublestar
                //       - matchOne(x/y/z/c, c) -> no
                //       - matchOne(y/z/c, c) -> no
                //       - matchOne(z/c, c) -> no
                //       - matchOne(c, c) yes, hit
                var fr = fi
                var pr = pi + 1
                if (pr === pl) {
                  this.debug('** at the end')
                  // a ** at the end will just swallow the rest.
                  // We have found a match.
                  // however, it will not swallow /.x, unless
                  // options.dot is set.
                  // . and .. are *never* matched by **, for explosively
                  // exponential reasons.
                  for (; fi < fl; fi++) {
                    if (
                      file[fi] === '.' ||
                      file[fi] === '..' ||
                      (!options.dot && file[fi].charAt(0) === '.')
                    )
                      return false
                  }
                  return true
                }

                // ok, let's see if we can swallow whatever we can.
                while (fr < fl) {
                  var swallowee = file[fr]

                  this.debug(
                    '\nglobstar while',
                    file,
                    fr,
                    pattern,
                    pr,
                    swallowee
                  )

                  // XXX remove this slice.  Just pass the start index.
                  if (
                    this.matchOne(file.slice(fr), pattern.slice(pr), partial)
                  ) {
                    this.debug('globstar found match!', fr, fl, swallowee)
                    // found a match.
                    return true
                  } else {
                    // can't swallow "." or ".." ever.
                    // can only swallow ".foo" when explicitly asked.
                    if (
                      swallowee === '.' ||
                      swallowee === '..' ||
                      (!options.dot && swallowee.charAt(0) === '.')
                    ) {
                      this.debug('dot detected!', file, fr, pattern, pr)
                      break
                    }

                    // ** swallows a segment, and continue.
                    this.debug('globstar swallow a segment, and continue')
                    fr++
                  }
                }

                // no match was found.
                // However, in partial mode, we can't say this is necessarily over.
                // If there's more *pattern* left, then
                if (partial) {
                  // ran out of file
                  this.debug('\n>>> no match, partial?', file, fr, pattern, pr)
                  if (fr === fl) return true
                }
                return false
              }

              // something other than **
              // non-magic patterns just have to match exactly
              // patterns with magic have been turned into regexps.
              var hit
              if (typeof p === 'string') {
                if (options.nocase) {
                  hit = f.toLowerCase() === p.toLowerCase()
                } else {
                  hit = f === p
                }
                this.debug('string match', p, f, hit)
              } else {
                hit = f.match(p)
                this.debug('pattern match', p, f, hit)
              }

              if (!hit) return false
            }

            // Note: ending in / means that we'll get a final ""
            // at the end of the pattern.  This can only match a
            // corresponding "" at the end of the file.
            // If the file ends in /, then it can only match a
            // a pattern that ends in /, unless the pattern just
            // doesn't have any more for it. But, a/b/ should *not*
            // match "a/b/*", even though "" matches against the
            // [^/]*? pattern, except in partial mode, where it might
            // simply not be reached yet.
            // However, a/b/ should still satisfy a/*

            // now either we fell off the end of the pattern, or we're done.
            if (fi === fl && pi === pl) {
              // ran out of pattern and filename at the same time.
              // an exact hit!
              return true
            } else if (fi === fl) {
              // ran out of file, but still had pattern left.
              // this is ok if we're doing the match as part of
              // a glob fs traversal.
              return partial
            } else if (pi === pl) {
              // ran out of pattern, still have file left.
              // this is only acceptable if we're on the very last
              // empty segment of a file with a trailing slash.
              // a/* should match a/b/
              var emptyFileEnd = fi === fl - 1 && file[fi] === ''
              return emptyFileEnd
            }

            // should be unreachable.
            throw new Error('wtf?')
          }

          // replace stuff like \* with *
          function globUnescape(s) {
            return s.replace(/\\(.)/g, '$1')
          }

          function regExpEscape(s) {
            return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
          }
        },
        { 'brace-expansion': 117, path: 505 },
      ],
      503: [
        function(require, module, exports) {
          /**
 * Helpers.
 */

          var s = 1000
          var m = s * 60
          var h = m * 60
          var d = h * 24
          var y = d * 365.25

          /**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

          module.exports = function(val, options) {
            options = options || {}
            var type = typeof val
            if (type === 'string' && val.length > 0) {
              return parse(val)
            } else if (type === 'number' && isNaN(val) === false) {
              return options.long ? fmtLong(val) : fmtShort(val)
            }
            throw new Error(
              'val is not a non-empty string or a valid number. val=' +
                JSON.stringify(val)
            )
          }

          /**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

          function parse(str) {
            str = String(str)
            if (str.length > 10000) {
              return
            }
            var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
              str
            )
            if (!match) {
              return
            }
            var n = parseFloat(match[1])
            var type = (match[2] || 'ms').toLowerCase()
            switch (type) {
              case 'years':
              case 'year':
              case 'yrs':
              case 'yr':
              case 'y':
                return n * y
              case 'days':
              case 'day':
              case 'd':
                return n * d
              case 'hours':
              case 'hour':
              case 'hrs':
              case 'hr':
              case 'h':
                return n * h
              case 'minutes':
              case 'minute':
              case 'mins':
              case 'min':
              case 'm':
                return n * m
              case 'seconds':
              case 'second':
              case 'secs':
              case 'sec':
              case 's':
                return n * s
              case 'milliseconds':
              case 'millisecond':
              case 'msecs':
              case 'msec':
              case 'ms':
                return n
              default:
                return undefined
            }
          }

          /**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

          function fmtShort(ms) {
            if (ms >= d) {
              return Math.round(ms / d) + 'd'
            }
            if (ms >= h) {
              return Math.round(ms / h) + 'h'
            }
            if (ms >= m) {
              return Math.round(ms / m) + 'm'
            }
            if (ms >= s) {
              return Math.round(ms / s) + 's'
            }
            return ms + 'ms'
          }

          /**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

          function fmtLong(ms) {
            return (
              plural(ms, d, 'day') ||
              plural(ms, h, 'hour') ||
              plural(ms, m, 'minute') ||
              plural(ms, s, 'second') ||
              ms + ' ms'
            )
          }

          /**
 * Pluralization helper.
 */

          function plural(ms, n, name) {
            if (ms < n) {
              return
            }
            if (ms < n * 1.5) {
              return Math.floor(ms / n) + ' ' + name
            }
            return Math.ceil(ms / n) + ' ' + name + 's'
          }
        },
        {},
      ],
      504: [
        function(require, module, exports) {
          'use strict'
          module.exports =
            Number.isNaN ||
            function(x) {
              return x !== x
            }
        },
        {},
      ],
      505: [
        function(require, module, exports) {
          ;(function(process) {
            // Copyright Joyent, Inc. and other Node contributors.
            //
            // Permission is hereby granted, free of charge, to any person obtaining a
            // copy of this software and associated documentation files (the
            // "Software"), to deal in the Software without restriction, including
            // without limitation the rights to use, copy, modify, merge, publish,
            // distribute, sublicense, and/or sell copies of the Software, and to permit
            // persons to whom the Software is furnished to do so, subject to the
            // following conditions:
            //
            // The above copyright notice and this permission notice shall be included
            // in all copies or substantial portions of the Software.
            //
            // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
            // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
            // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
            // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
            // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
            // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
            // USE OR OTHER DEALINGS IN THE SOFTWARE.

            // resolves . and .. elements in a path array with directory names there
            // must be no slashes, empty elements, or device names (c:\) in the array
            // (so also no leading and trailing slashes - it does not distinguish
            // relative and absolute paths)
            function normalizeArray(parts, allowAboveRoot) {
              // if the path tries to go above the root, `up` ends up > 0
              var up = 0
              for (var i = parts.length - 1; i >= 0; i--) {
                var last = parts[i]
                if (last === '.') {
                  parts.splice(i, 1)
                } else if (last === '..') {
                  parts.splice(i, 1)
                  up++
                } else if (up) {
                  parts.splice(i, 1)
                  up--
                }
              }

              // if the path is allowed to go above the root, restore leading ..s
              if (allowAboveRoot) {
                for (; up--; up) {
                  parts.unshift('..')
                }
              }

              return parts
            }

            // Split a filename into [root, dir, basename, ext], unix version
            // 'root' is just a slash, or nothing.
            var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/
            var splitPath = function(filename) {
              return splitPathRe.exec(filename).slice(1)
            }

            // path.resolve([from ...], to)
            // posix version
            exports.resolve = function() {
              var resolvedPath = '',
                resolvedAbsolute = false

              for (
                var i = arguments.length - 1;
                i >= -1 && !resolvedAbsolute;
                i--
              ) {
                var path = i >= 0 ? arguments[i] : process.cwd()

                // Skip empty and invalid entries
                if (typeof path !== 'string') {
                  throw new TypeError(
                    'Arguments to path.resolve must be strings'
                  )
                } else if (!path) {
                  continue
                }

                resolvedPath = path + '/' + resolvedPath
                resolvedAbsolute = path.charAt(0) === '/'
              }

              // At this point the path should be resolved to a full absolute path, but
              // handle relative paths to be safe (might happen when process.cwd() fails)

              // Normalize the path
              resolvedPath = normalizeArray(
                filter(resolvedPath.split('/'), function(p) {
                  return !!p
                }),
                !resolvedAbsolute
              ).join('/')

              return (resolvedAbsolute ? '/' : '') + resolvedPath || '.'
            }

            // path.normalize(path)
            // posix version
            exports.normalize = function(path) {
              var isAbsolute = exports.isAbsolute(path),
                trailingSlash = substr(path, -1) === '/'

              // Normalize the path
              path = normalizeArray(
                filter(path.split('/'), function(p) {
                  return !!p
                }),
                !isAbsolute
              ).join('/')

              if (!path && !isAbsolute) {
                path = '.'
              }
              if (path && trailingSlash) {
                path += '/'
              }

              return (isAbsolute ? '/' : '') + path
            }

            // posix version
            exports.isAbsolute = function(path) {
              return path.charAt(0) === '/'
            }

            // posix version
            exports.join = function() {
              var paths = Array.prototype.slice.call(arguments, 0)
              return exports.normalize(
                filter(paths, function(p, index) {
                  if (typeof p !== 'string') {
                    throw new TypeError(
                      'Arguments to path.join must be strings'
                    )
                  }
                  return p
                }).join('/')
              )
            }

            // path.relative(from, to)
            // posix version
            exports.relative = function(from, to) {
              from = exports.resolve(from).substr(1)
              to = exports.resolve(to).substr(1)

              function trim(arr) {
                var start = 0
                for (; start < arr.length; start++) {
                  if (arr[start] !== '') break
                }

                var end = arr.length - 1
                for (; end >= 0; end--) {
                  if (arr[end] !== '') break
                }

                if (start > end) return []
                return arr.slice(start, end - start + 1)
              }

              var fromParts = trim(from.split('/'))
              var toParts = trim(to.split('/'))

              var length = Math.min(fromParts.length, toParts.length)
              var samePartsLength = length
              for (var i = 0; i < length; i++) {
                if (fromParts[i] !== toParts[i]) {
                  samePartsLength = i
                  break
                }
              }

              var outputParts = []
              for (var i = samePartsLength; i < fromParts.length; i++) {
                outputParts.push('..')
              }

              outputParts = outputParts.concat(toParts.slice(samePartsLength))

              return outputParts.join('/')
            }

            exports.sep = '/'
            exports.delimiter = ':'

            exports.dirname = function(path) {
              var result = splitPath(path),
                root = result[0],
                dir = result[1]

              if (!root && !dir) {
                // No dirname whatsoever
                return '.'
              }

              if (dir) {
                // It has a dirname, strip trailing slash
                dir = dir.substr(0, dir.length - 1)
              }

              return root + dir
            }

            exports.basename = function(path, ext) {
              var f = splitPath(path)[2]
              // TODO: make this comparison case-insensitive on windows?
              if (ext && f.substr(-1 * ext.length) === ext) {
                f = f.substr(0, f.length - ext.length)
              }
              return f
            }

            exports.extname = function(path) {
              return splitPath(path)[3]
            }

            function filter(xs, f) {
              if (xs.filter) return xs.filter(f)
              var res = []
              for (var i = 0; i < xs.length; i++) {
                if (f(xs[i], i, xs)) res.push(xs[i])
              }
              return res
            }

            // String.prototype.substr - negative index don't work in IE8
            var substr = 'ab'.substr(-1) === 'b'
              ? function(str, start, len) {
                  return str.substr(start, len)
                }
              : function(str, start, len) {
                  if (start < 0) start = str.length + start
                  return str.substr(start, len)
                }
          }.call(this, require('_process')))
        },
        { _process: 507 },
      ],
      506: [
        function(require, module, exports) {
          ;(function(process) {
            'use strict'
            function posix(path) {
              return path.charAt(0) === '/'
            }

            function win32(path) {
              // https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56
              var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/
              var result = splitDeviceRe.exec(path)
              var device = result[1] || ''
              var isUnc = Boolean(device && device.charAt(1) !== ':')

              // UNC paths are always absolute
              return Boolean(result[2] || isUnc)
            }

            module.exports = process.platform === 'win32' ? win32 : posix
            module.exports.posix = posix
            module.exports.win32 = win32
          }.call(this, require('_process')))
        },
        { _process: 507 },
      ],
      507: [
        function(require, module, exports) {
          // shim for using process in browser
          var process = (module.exports = {})

          // cached from whatever global is present so that test runners that stub it
          // don't break things.  But we need to wrap it in a try catch in case it is
          // wrapped in strict mode code which doesn't define any globals.  It's inside a
          // function because try/catches deoptimize in certain engines.

          var cachedSetTimeout
          var cachedClearTimeout

          function defaultSetTimout() {
            throw new Error('setTimeout has not been defined')
          }
          function defaultClearTimeout() {
            throw new Error('clearTimeout has not been defined')
          }
          ;(function() {
            try {
              if (typeof setTimeout === 'function') {
                cachedSetTimeout = setTimeout
              } else {
                cachedSetTimeout = defaultSetTimout
              }
            } catch (e) {
              cachedSetTimeout = defaultSetTimout
            }
            try {
              if (typeof clearTimeout === 'function') {
                cachedClearTimeout = clearTimeout
              } else {
                cachedClearTimeout = defaultClearTimeout
              }
            } catch (e) {
              cachedClearTimeout = defaultClearTimeout
            }
          })()
          function runTimeout(fun) {
            if (cachedSetTimeout === setTimeout) {
              //normal enviroments in sane situations
              return setTimeout(fun, 0)
            }
            // if setTimeout wasn't available but was latter defined
            if (
              (cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) &&
              setTimeout
            ) {
              cachedSetTimeout = setTimeout
              return setTimeout(fun, 0)
            }
            try {
              // when when somebody has screwed with setTimeout but no I.E. maddness
              return cachedSetTimeout(fun, 0)
            } catch (e) {
              try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                return cachedSetTimeout.call(null, fun, 0)
              } catch (e) {
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                return cachedSetTimeout.call(this, fun, 0)
              }
            }
          }
          function runClearTimeout(marker) {
            if (cachedClearTimeout === clearTimeout) {
              //normal enviroments in sane situations
              return clearTimeout(marker)
            }
            // if clearTimeout wasn't available but was latter defined
            if (
              (cachedClearTimeout === defaultClearTimeout ||
                !cachedClearTimeout) &&
              clearTimeout
            ) {
              cachedClearTimeout = clearTimeout
              return clearTimeout(marker)
            }
            try {
              // when when somebody has screwed with setTimeout but no I.E. maddness
              return cachedClearTimeout(marker)
            } catch (e) {
              try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                return cachedClearTimeout.call(null, marker)
              } catch (e) {
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                return cachedClearTimeout.call(this, marker)
              }
            }
          }
          var queue = []
          var draining = false
          var currentQueue
          var queueIndex = -1

          function cleanUpNextTick() {
            if (!draining || !currentQueue) {
              return
            }
            draining = false
            if (currentQueue.length) {
              queue = currentQueue.concat(queue)
            } else {
              queueIndex = -1
            }
            if (queue.length) {
              drainQueue()
            }
          }

          function drainQueue() {
            if (draining) {
              return
            }
            var timeout = runTimeout(cleanUpNextTick)
            draining = true

            var len = queue.length
            while (len) {
              currentQueue = queue
              queue = []
              while (++queueIndex < len) {
                if (currentQueue) {
                  currentQueue[queueIndex].run()
                }
              }
              queueIndex = -1
              len = queue.length
            }
            currentQueue = null
            draining = false
            runClearTimeout(timeout)
          }

          process.nextTick = function(fun) {
            var args = new Array(arguments.length - 1)
            if (arguments.length > 1) {
              for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i]
              }
            }
            queue.push(new Item(fun, args))
            if (queue.length === 1 && !draining) {
              runTimeout(drainQueue)
            }
          }

          // v8 likes predictible objects
          function Item(fun, array) {
            this.fun = fun
            this.array = array
          }
          Item.prototype.run = function() {
            this.fun.apply(null, this.array)
          }
          process.title = 'browser'
          process.browser = true
          process.env = {}
          process.argv = []
          process.version = '' // empty string to avoid regexp issues
          process.versions = {}

          function noop() {}

          process.on = noop
          process.addListener = noop
          process.once = noop
          process.off = noop
          process.removeListener = noop
          process.removeAllListeners = noop
          process.emit = noop
          process.prependListener = noop
          process.prependOnceListener = noop

          process.listeners = function(name) {
            return []
          }

          process.binding = function(name) {
            throw new Error('process.binding is not supported')
          }

          process.cwd = function() {
            return '/'
          }
          process.chdir = function(dir) {
            throw new Error('process.chdir is not supported')
          }
          process.umask = function() {
            return 0
          }
        },
        {},
      ],
      508: [
        function(require, module, exports) {
          ;(function(process) {
            /**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

            'use strict'
            if (process.env.NODE_ENV !== 'production') {
              var invariant = require('fbjs/lib/invariant')
              var warning = require('fbjs/lib/warning')
              var ReactPropTypesSecret = require('./lib/ReactPropTypesSecret')
              var loggedTypeFailures = {}
            }

            /**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
            function checkPropTypes(
              typeSpecs,
              values,
              location,
              componentName,
              getStack
            ) {
              if (process.env.NODE_ENV !== 'production') {
                for (var typeSpecName in typeSpecs) {
                  if (typeSpecs.hasOwnProperty(typeSpecName)) {
                    var error
                    // Prop type validation may throw. In case they do, we don't want to
                    // fail the render phase where it didn't fail before. So we log it.
                    // After these have been cleaned up, we'll let them throw.
                    try {
                      // This is intentionally an invariant that gets caught. It's the same
                      // behavior as without this statement except with a better message.
                      invariant(
                        typeof typeSpecs[typeSpecName] === 'function',
                        '%s: %s type `%s` is invalid; it must be a function, usually from ' +
                          'React.PropTypes.',
                        componentName || 'React class',
                        location,
                        typeSpecName
                      )
                      error = typeSpecs[typeSpecName](
                        values,
                        typeSpecName,
                        componentName,
                        location,
                        null,
                        ReactPropTypesSecret
                      )
                    } catch (ex) {
                      error = ex
                    }
                    warning(
                      !error || error instanceof Error,
                      '%s: type specification of %s `%s` is invalid; the type checker ' +
                        'function must return `null` or an `Error` but returned a %s. ' +
                        'You may have forgotten to pass an argument to the type checker ' +
                        'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
                        'shape all require an argument).',
                      componentName || 'React class',
                      location,
                      typeSpecName,
                      typeof error
                    )
                    if (
                      error instanceof Error &&
                      !(error.message in loggedTypeFailures)
                    ) {
                      // Only monitor this failure once because there tends to be a lot of the
                      // same error.
                      loggedTypeFailures[error.message] = true

                      var stack = getStack ? getStack() : ''

                      warning(
                        false,
                        'Failed %s type: %s%s',
                        location,
                        error.message,
                        stack != null ? stack : ''
                      )
                    }
                  }
                }
              }
            }

            module.exports = checkPropTypes
          }.call(this, require('_process')))
        },
        {
          './lib/ReactPropTypesSecret': 512,
          _process: 507,
          'fbjs/lib/invariant': 257,
          'fbjs/lib/warning': 258,
        },
      ],
      509: [
        function(require, module, exports) {
          /**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

          'use strict'
          var emptyFunction = require('fbjs/lib/emptyFunction')
          var invariant = require('fbjs/lib/invariant')
          var ReactPropTypesSecret = require('./lib/ReactPropTypesSecret')

          module.exports = function() {
            function shim(
              props,
              propName,
              componentName,
              location,
              propFullName,
              secret
            ) {
              if (secret === ReactPropTypesSecret) {
                // It is still safe when called from React.
                return
              }
              invariant(
                false,
                'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
                  'Use PropTypes.checkPropTypes() to call them. ' +
                  'Read more at http://fb.me/use-check-prop-types'
              )
            }
            shim.isRequired = shim
            function getShim() {
              return shim
            }
            // Important!
            // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
            var ReactPropTypes = {
              array: shim,
              bool: shim,
              func: shim,
              number: shim,
              object: shim,
              string: shim,
              symbol: shim,

              any: shim,
              arrayOf: getShim,
              element: shim,
              instanceOf: getShim,
              node: shim,
              objectOf: getShim,
              oneOf: getShim,
              oneOfType: getShim,
              shape: getShim,
            }

            ReactPropTypes.checkPropTypes = emptyFunction
            ReactPropTypes.PropTypes = ReactPropTypes

            return ReactPropTypes
          }
        },
        {
          './lib/ReactPropTypesSecret': 512,
          'fbjs/lib/emptyFunction': 254,
          'fbjs/lib/invariant': 257,
        },
      ],
      510: [
        function(require, module, exports) {
          ;(function(process) {
            /**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

            'use strict'
            var emptyFunction = require('fbjs/lib/emptyFunction')
            var invariant = require('fbjs/lib/invariant')
            var warning = require('fbjs/lib/warning')

            var ReactPropTypesSecret = require('./lib/ReactPropTypesSecret')
            var checkPropTypes = require('./checkPropTypes')

            module.exports = function(isValidElement, throwOnDirectAccess) {
              /* global Symbol */
              var ITERATOR_SYMBOL =
                typeof Symbol === 'function' && Symbol.iterator
              var FAUX_ITERATOR_SYMBOL = '@@iterator' // Before Symbol spec.

              /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
              function getIteratorFn(maybeIterable) {
                var iteratorFn =
                  maybeIterable &&
                  ((ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL]) ||
                    maybeIterable[FAUX_ITERATOR_SYMBOL])
                if (typeof iteratorFn === 'function') {
                  return iteratorFn
                }
              }

              /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

              var ANONYMOUS = '<<anonymous>>'

              // Important!
              // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
              var ReactPropTypes = {
                array: createPrimitiveTypeChecker('array'),
                bool: createPrimitiveTypeChecker('boolean'),
                func: createPrimitiveTypeChecker('function'),
                number: createPrimitiveTypeChecker('number'),
                object: createPrimitiveTypeChecker('object'),
                string: createPrimitiveTypeChecker('string'),
                symbol: createPrimitiveTypeChecker('symbol'),

                any: createAnyTypeChecker(),
                arrayOf: createArrayOfTypeChecker,
                element: createElementTypeChecker(),
                instanceOf: createInstanceTypeChecker,
                node: createNodeChecker(),
                objectOf: createObjectOfTypeChecker,
                oneOf: createEnumTypeChecker,
                oneOfType: createUnionTypeChecker,
                shape: createShapeTypeChecker,
              }

              /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
              /*eslint-disable no-self-compare*/
              function is(x, y) {
                // SameValue algorithm
                if (x === y) {
                  // Steps 1-5, 7-10
                  // Steps 6.b-6.e: +0 != -0
                  return x !== 0 || 1 / x === 1 / y
                } else {
                  // Step 6.a: NaN == NaN
                  return x !== x && y !== y
                }
              }
              /*eslint-enable no-self-compare*/

              /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
              function PropTypeError(message) {
                this.message = message
                this.stack = ''
              }
              // Make `instanceof Error` still work for returned errors.
              PropTypeError.prototype = Error.prototype

              function createChainableTypeChecker(validate) {
                if (process.env.NODE_ENV !== 'production') {
                  var manualPropTypeCallCache = {}
                  var manualPropTypeWarningCount = 0
                }
                function checkType(
                  isRequired,
                  props,
                  propName,
                  componentName,
                  location,
                  propFullName,
                  secret
                ) {
                  componentName = componentName || ANONYMOUS
                  propFullName = propFullName || propName

                  if (secret !== ReactPropTypesSecret) {
                    if (throwOnDirectAccess) {
                      // New behavior only for users of `prop-types` package
                      invariant(
                        false,
                        'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
                          'Use `PropTypes.checkPropTypes()` to call them. ' +
                          'Read more at http://fb.me/use-check-prop-types'
                      )
                    } else if (
                      process.env.NODE_ENV !== 'production' &&
                      typeof console !== 'undefined'
                    ) {
                      // Old behavior for people using React.PropTypes
                      var cacheKey = componentName + ':' + propName
                      if (
                        !manualPropTypeCallCache[cacheKey] &&
                        // Avoid spamming the console because they are often not actionable except for lib authors
                        manualPropTypeWarningCount < 3
                      ) {
                        warning(
                          false,
                          'You are manually calling a React.PropTypes validation ' +
                            'function for the `%s` prop on `%s`. This is deprecated ' +
                            'and will throw in the standalone `prop-types` package. ' +
                            'You may be seeing this warning due to a third-party PropTypes ' +
                            'library. See https://fb.me/react-warning-dont-call-proptypes ' +
                            'for details.',
                          propFullName,
                          componentName
                        )
                        manualPropTypeCallCache[cacheKey] = true
                        manualPropTypeWarningCount++
                      }
                    }
                  }
                  if (props[propName] == null) {
                    if (isRequired) {
                      if (props[propName] === null) {
                        return new PropTypeError(
                          'The ' +
                            location +
                            ' `' +
                            propFullName +
                            '` is marked as required ' +
                            ('in `' +
                              componentName +
                              '`, but its value is `null`.')
                        )
                      }
                      return new PropTypeError(
                        'The ' +
                          location +
                          ' `' +
                          propFullName +
                          '` is marked as required in ' +
                          ('`' +
                            componentName +
                            '`, but its value is `undefined`.')
                      )
                    }
                    return null
                  } else {
                    return validate(
                      props,
                      propName,
                      componentName,
                      location,
                      propFullName
                    )
                  }
                }

                var chainedCheckType = checkType.bind(null, false)
                chainedCheckType.isRequired = checkType.bind(null, true)

                return chainedCheckType
              }

              function createPrimitiveTypeChecker(expectedType) {
                function validate(
                  props,
                  propName,
                  componentName,
                  location,
                  propFullName,
                  secret
                ) {
                  var propValue = props[propName]
                  var propType = getPropType(propValue)
                  if (propType !== expectedType) {
                    // `propValue` being instance of, say, date/regexp, pass the 'object'
                    // check, but we can offer a more precise error message here rather than
                    // 'of type `object`'.
                    var preciseType = getPreciseType(propValue)

                    return new PropTypeError(
                      'Invalid ' +
                        location +
                        ' `' +
                        propFullName +
                        '` of type ' +
                        ('`' +
                          preciseType +
                          '` supplied to `' +
                          componentName +
                          '`, expected ') +
                        ('`' + expectedType + '`.')
                    )
                  }
                  return null
                }
                return createChainableTypeChecker(validate)
              }

              function createAnyTypeChecker() {
                return createChainableTypeChecker(emptyFunction.thatReturnsNull)
              }

              function createArrayOfTypeChecker(typeChecker) {
                function validate(
                  props,
                  propName,
                  componentName,
                  location,
                  propFullName
                ) {
                  if (typeof typeChecker !== 'function') {
                    return new PropTypeError(
                      'Property `' +
                        propFullName +
                        '` of component `' +
                        componentName +
                        '` has invalid PropType notation inside arrayOf.'
                    )
                  }
                  var propValue = props[propName]
                  if (!Array.isArray(propValue)) {
                    var propType = getPropType(propValue)
                    return new PropTypeError(
                      'Invalid ' +
                        location +
                        ' `' +
                        propFullName +
                        '` of type ' +
                        ('`' +
                          propType +
                          '` supplied to `' +
                          componentName +
                          '`, expected an array.')
                    )
                  }
                  for (var i = 0; i < propValue.length; i++) {
                    var error = typeChecker(
                      propValue,
                      i,
                      componentName,
                      location,
                      propFullName + '[' + i + ']',
                      ReactPropTypesSecret
                    )
                    if (error instanceof Error) {
                      return error
                    }
                  }
                  return null
                }
                return createChainableTypeChecker(validate)
              }

              function createElementTypeChecker() {
                function validate(
                  props,
                  propName,
                  componentName,
                  location,
                  propFullName
                ) {
                  var propValue = props[propName]
                  if (!isValidElement(propValue)) {
                    var propType = getPropType(propValue)
                    return new PropTypeError(
                      'Invalid ' +
                        location +
                        ' `' +
                        propFullName +
                        '` of type ' +
                        ('`' +
                          propType +
                          '` supplied to `' +
                          componentName +
                          '`, expected a single ReactElement.')
                    )
                  }
                  return null
                }
                return createChainableTypeChecker(validate)
              }

              function createInstanceTypeChecker(expectedClass) {
                function validate(
                  props,
                  propName,
                  componentName,
                  location,
                  propFullName
                ) {
                  if (!(props[propName] instanceof expectedClass)) {
                    var expectedClassName = expectedClass.name || ANONYMOUS
                    var actualClassName = getClassName(props[propName])
                    return new PropTypeError(
                      'Invalid ' +
                        location +
                        ' `' +
                        propFullName +
                        '` of type ' +
                        ('`' +
                          actualClassName +
                          '` supplied to `' +
                          componentName +
                          '`, expected ') +
                        ('instance of `' + expectedClassName + '`.')
                    )
                  }
                  return null
                }
                return createChainableTypeChecker(validate)
              }

              function createEnumTypeChecker(expectedValues) {
                if (!Array.isArray(expectedValues)) {
                  process.env.NODE_ENV !== 'production'
                    ? warning(
                        false,
                        'Invalid argument supplied to oneOf, expected an instance of array.'
                      )
                    : void 0
                  return emptyFunction.thatReturnsNull
                }

                function validate(
                  props,
                  propName,
                  componentName,
                  location,
                  propFullName
                ) {
                  var propValue = props[propName]
                  for (var i = 0; i < expectedValues.length; i++) {
                    if (is(propValue, expectedValues[i])) {
                      return null
                    }
                  }

                  var valuesString = JSON.stringify(expectedValues)
                  return new PropTypeError(
                    'Invalid ' +
                      location +
                      ' `' +
                      propFullName +
                      '` of value `' +
                      propValue +
                      '` ' +
                      ('supplied to `' +
                        componentName +
                        '`, expected one of ' +
                        valuesString +
                        '.')
                  )
                }
                return createChainableTypeChecker(validate)
              }

              function createObjectOfTypeChecker(typeChecker) {
                function validate(
                  props,
                  propName,
                  componentName,
                  location,
                  propFullName
                ) {
                  if (typeof typeChecker !== 'function') {
                    return new PropTypeError(
                      'Property `' +
                        propFullName +
                        '` of component `' +
                        componentName +
                        '` has invalid PropType notation inside objectOf.'
                    )
                  }
                  var propValue = props[propName]
                  var propType = getPropType(propValue)
                  if (propType !== 'object') {
                    return new PropTypeError(
                      'Invalid ' +
                        location +
                        ' `' +
                        propFullName +
                        '` of type ' +
                        ('`' +
                          propType +
                          '` supplied to `' +
                          componentName +
                          '`, expected an object.')
                    )
                  }
                  for (var key in propValue) {
                    if (propValue.hasOwnProperty(key)) {
                      var error = typeChecker(
                        propValue,
                        key,
                        componentName,
                        location,
                        propFullName + '.' + key,
                        ReactPropTypesSecret
                      )
                      if (error instanceof Error) {
                        return error
                      }
                    }
                  }
                  return null
                }
                return createChainableTypeChecker(validate)
              }

              function createUnionTypeChecker(arrayOfTypeCheckers) {
                if (!Array.isArray(arrayOfTypeCheckers)) {
                  process.env.NODE_ENV !== 'production'
                    ? warning(
                        false,
                        'Invalid argument supplied to oneOfType, expected an instance of array.'
                      )
                    : void 0
                  return emptyFunction.thatReturnsNull
                }

                for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
                  var checker = arrayOfTypeCheckers[i]
                  if (typeof checker !== 'function') {
                    warning(
                      false,
                      'Invalid argument supplid to oneOfType. Expected an array of check functions, but ' +
                        'received %s at index %s.',
                      getPostfixForTypeWarning(checker),
                      i
                    )
                    return emptyFunction.thatReturnsNull
                  }
                }

                function validate(
                  props,
                  propName,
                  componentName,
                  location,
                  propFullName
                ) {
                  for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
                    var checker = arrayOfTypeCheckers[i]
                    if (
                      checker(
                        props,
                        propName,
                        componentName,
                        location,
                        propFullName,
                        ReactPropTypesSecret
                      ) == null
                    ) {
                      return null
                    }
                  }

                  return new PropTypeError(
                    'Invalid ' +
                      location +
                      ' `' +
                      propFullName +
                      '` supplied to ' +
                      ('`' + componentName + '`.')
                  )
                }
                return createChainableTypeChecker(validate)
              }

              function createNodeChecker() {
                function validate(
                  props,
                  propName,
                  componentName,
                  location,
                  propFullName
                ) {
                  if (!isNode(props[propName])) {
                    return new PropTypeError(
                      'Invalid ' +
                        location +
                        ' `' +
                        propFullName +
                        '` supplied to ' +
                        ('`' + componentName + '`, expected a ReactNode.')
                    )
                  }
                  return null
                }
                return createChainableTypeChecker(validate)
              }

              function createShapeTypeChecker(shapeTypes) {
                function validate(
                  props,
                  propName,
                  componentName,
                  location,
                  propFullName
                ) {
                  var propValue = props[propName]
                  var propType = getPropType(propValue)
                  if (propType !== 'object') {
                    return new PropTypeError(
                      'Invalid ' +
                        location +
                        ' `' +
                        propFullName +
                        '` of type `' +
                        propType +
                        '` ' +
                        ('supplied to `' +
                          componentName +
                          '`, expected `object`.')
                    )
                  }
                  for (var key in shapeTypes) {
                    var checker = shapeTypes[key]
                    if (!checker) {
                      continue
                    }
                    var error = checker(
                      propValue,
                      key,
                      componentName,
                      location,
                      propFullName + '.' + key,
                      ReactPropTypesSecret
                    )
                    if (error) {
                      return error
                    }
                  }
                  return null
                }
                return createChainableTypeChecker(validate)
              }

              function isNode(propValue) {
                switch (typeof propValue) {
                  case 'number':
                  case 'string':
                  case 'undefined':
                    return true
                  case 'boolean':
                    return !propValue
                  case 'object':
                    if (Array.isArray(propValue)) {
                      return propValue.every(isNode)
                    }
                    if (propValue === null || isValidElement(propValue)) {
                      return true
                    }

                    var iteratorFn = getIteratorFn(propValue)
                    if (iteratorFn) {
                      var iterator = iteratorFn.call(propValue)
                      var step
                      if (iteratorFn !== propValue.entries) {
                        while (!(step = iterator.next()).done) {
                          if (!isNode(step.value)) {
                            return false
                          }
                        }
                      } else {
                        // Iterator will provide entry [k,v] tuples rather than values.
                        while (!(step = iterator.next()).done) {
                          var entry = step.value
                          if (entry) {
                            if (!isNode(entry[1])) {
                              return false
                            }
                          }
                        }
                      }
                    } else {
                      return false
                    }

                    return true
                  default:
                    return false
                }
              }

              function isSymbol(propType, propValue) {
                // Native Symbol.
                if (propType === 'symbol') {
                  return true
                }

                // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
                if (propValue['@@toStringTag'] === 'Symbol') {
                  return true
                }

                // Fallback for non-spec compliant Symbols which are polyfilled.
                if (
                  typeof Symbol === 'function' &&
                  propValue instanceof Symbol
                ) {
                  return true
                }

                return false
              }

              // Equivalent of `typeof` but with special handling for array and regexp.
              function getPropType(propValue) {
                var propType = typeof propValue
                if (Array.isArray(propValue)) {
                  return 'array'
                }
                if (propValue instanceof RegExp) {
                  // Old webkits (at least until Android 4.0) return 'function' rather than
                  // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
                  // passes PropTypes.object.
                  return 'object'
                }
                if (isSymbol(propType, propValue)) {
                  return 'symbol'
                }
                return propType
              }

              // This handles more types than `getPropType`. Only used for error messages.
              // See `createPrimitiveTypeChecker`.
              function getPreciseType(propValue) {
                if (typeof propValue === 'undefined' || propValue === null) {
                  return '' + propValue
                }
                var propType = getPropType(propValue)
                if (propType === 'object') {
                  if (propValue instanceof Date) {
                    return 'date'
                  } else if (propValue instanceof RegExp) {
                    return 'regexp'
                  }
                }
                return propType
              }

              // Returns a string that is postfixed to a warning about an invalid type.
              // For example, "undefined" or "of type array"
              function getPostfixForTypeWarning(value) {
                var type = getPreciseType(value)
                switch (type) {
                  case 'array':
                  case 'object':
                    return 'an ' + type
                  case 'boolean':
                  case 'date':
                  case 'regexp':
                    return 'a ' + type
                  default:
                    return type
                }
              }

              // Returns class name of the object, if any.
              function getClassName(propValue) {
                if (!propValue.constructor || !propValue.constructor.name) {
                  return ANONYMOUS
                }
                return propValue.constructor.name
              }

              ReactPropTypes.checkPropTypes = checkPropTypes
              ReactPropTypes.PropTypes = ReactPropTypes

              return ReactPropTypes
            }
          }.call(this, require('_process')))
        },
        {
          './checkPropTypes': 508,
          './lib/ReactPropTypesSecret': 512,
          _process: 507,
          'fbjs/lib/emptyFunction': 254,
          'fbjs/lib/invariant': 257,
          'fbjs/lib/warning': 258,
        },
      ],
      511: [
        function(require, module, exports) {
          ;(function(process) {
            /**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

            if (process.env.NODE_ENV !== 'production') {
              var REACT_ELEMENT_TYPE =
                (typeof Symbol === 'function' &&
                  Symbol.for &&
                  Symbol.for('react.element')) ||
                0xeac7

              var isValidElement = function(object) {
                return (
                  typeof object === 'object' &&
                  object !== null &&
                  object.$$typeof === REACT_ELEMENT_TYPE
                )
              }

              // By explicitly using `prop-types` you are opting into new development behavior.
              // http://fb.me/prop-types-in-prod
              var throwOnDirectAccess = true
              module.exports = require('./factoryWithTypeCheckers')(
                isValidElement,
                throwOnDirectAccess
              )
            } else {
              // By explicitly using `prop-types` you are opting into new production behavior.
              // http://fb.me/prop-types-in-prod
              module.exports = require('./factoryWithThrowingShims')()
            }
          }.call(this, require('_process')))
        },
        {
          './factoryWithThrowingShims': 509,
          './factoryWithTypeCheckers': 510,
          _process: 507,
        },
      ],
      512: [
        function(require, module, exports) {
          /**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

          'use strict'
          var ReactPropTypesSecret =
            'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED'

          module.exports = ReactPropTypesSecret
        },
        {},
      ],
      513: [
        function(require, module, exports) {
          'use strict'
          var isFinite = require('is-finite')

          module.exports = function(str, n) {
            if (typeof str !== 'string') {
              throw new TypeError('Expected `input` to be a string')
            }

            if (n < 0 || !isFinite(n)) {
              throw new TypeError(
                'Expected `count` to be a positive finite number'
              )
            }

            var ret = ''

            do {
              if (n & 1) {
                ret += str
              }

              str += str
            } while ((n >>= 1))

            return ret
          }
        },
        { 'is-finite': 287 },
      ],
      514: [
        function(require, module, exports) {
          'use strict'
          var isArrayish = require('is-arrayish')

          var concat = Array.prototype.concat
          var slice = Array.prototype.slice

          var swizzle = (module.exports = function swizzle(args) {
            var results = []

            for (var i = 0, len = args.length; i < len; i++) {
              var arg = args[i]

              if (isArrayish(arg)) {
                // http://jsperf.com/javascript-array-concat-vs-push/98
                results = concat.call(results, slice.call(arg))
              } else {
                results.push(arg)
              }
            }

            return results
          })

          swizzle.wrap = function(fn) {
            return function() {
              return fn(swizzle(arguments))
            }
          }
        },
        { 'is-arrayish': 286 },
      ],
      515: [
        function(require, module, exports) {
          'use strict'
          module.exports = function(str) {
            var isExtendedLengthPath = /^\\\\\?\\/.test(str)
            var hasNonAscii = /[^\x00-\x80]+/.test(str)

            if (isExtendedLengthPath || hasNonAscii) {
              return str
            }

            return str.replace(/\\/g, '/')
          }
        },
        {},
      ],
      516: [
        function(require, module, exports) {
          /* -*- Mode: js; js-indent-level: 2; -*- */
          /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

          var util = require('./util')
          var has = Object.prototype.hasOwnProperty

          /**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */
          function ArraySet() {
            this._array = []
            this._set = Object.create(null)
          }

          /**
 * Static method for creating ArraySet instances from an existing array.
 */
          ArraySet.fromArray = function ArraySet_fromArray(
            aArray,
            aAllowDuplicates
          ) {
            var set = new ArraySet()
            for (var i = 0, len = aArray.length; i < len; i++) {
              set.add(aArray[i], aAllowDuplicates)
            }
            return set
          }

          /**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */
          ArraySet.prototype.size = function ArraySet_size() {
            return Object.getOwnPropertyNames(this._set).length
          }

          /**
 * Add the given string to this set.
 *
 * @param String aStr
 */
          ArraySet.prototype.add = function ArraySet_add(
            aStr,
            aAllowDuplicates
          ) {
            var sStr = util.toSetString(aStr)
            var isDuplicate = has.call(this._set, sStr)
            var idx = this._array.length
            if (!isDuplicate || aAllowDuplicates) {
              this._array.push(aStr)
            }
            if (!isDuplicate) {
              this._set[sStr] = idx
            }
          }

          /**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */
          ArraySet.prototype.has = function ArraySet_has(aStr) {
            var sStr = util.toSetString(aStr)
            return has.call(this._set, sStr)
          }

          /**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */
          ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
            var sStr = util.toSetString(aStr)
            if (has.call(this._set, sStr)) {
              return this._set[sStr]
            }
            throw new Error('"' + aStr + '" is not in the set.')
          }

          /**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */
          ArraySet.prototype.at = function ArraySet_at(aIdx) {
            if (aIdx >= 0 && aIdx < this._array.length) {
              return this._array[aIdx]
            }
            throw new Error('No element indexed by ' + aIdx)
          }

          /**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */
          ArraySet.prototype.toArray = function ArraySet_toArray() {
            return this._array.slice()
          }

          exports.ArraySet = ArraySet
        },
        { './util': 525 },
      ],
      517: [
        function(require, module, exports) {
          /* -*- Mode: js; js-indent-level: 2; -*- */
          /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

          var base64 = require('./base64')

          // A single base 64 digit can contain 6 bits of data. For the base 64 variable
          // length quantities we use in the source map spec, the first bit is the sign,
          // the next four bits are the actual value, and the 6th bit is the
          // continuation bit. The continuation bit tells us whether there are more
          // digits in this value following this digit.
          //
          //   Continuation
          //   |    Sign
          //   |    |
          //   V    V
          //   101011

          var VLQ_BASE_SHIFT = 5

          // binary: 100000
          var VLQ_BASE = 1 << VLQ_BASE_SHIFT

          // binary: 011111
          var VLQ_BASE_MASK = VLQ_BASE - 1

          // binary: 100000
          var VLQ_CONTINUATION_BIT = VLQ_BASE

          /**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
          function toVLQSigned(aValue) {
            return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0
          }

          /**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
          function fromVLQSigned(aValue) {
            var isNegative = (aValue & 1) === 1
            var shifted = aValue >> 1
            return isNegative ? -shifted : shifted
          }

          /**
 * Returns the base 64 VLQ encoded value.
 */
          exports.encode = function base64VLQ_encode(aValue) {
            var encoded = ''
            var digit

            var vlq = toVLQSigned(aValue)

            do {
              digit = vlq & VLQ_BASE_MASK
              vlq >>>= VLQ_BASE_SHIFT
              if (vlq > 0) {
                // There are still more digits in this value, so we must make sure the
                // continuation bit is marked.
                digit |= VLQ_CONTINUATION_BIT
              }
              encoded += base64.encode(digit)
            } while (vlq > 0)

            return encoded
          }

          /**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */
          exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
            var strLen = aStr.length
            var result = 0
            var shift = 0
            var continuation, digit

            do {
              if (aIndex >= strLen) {
                throw new Error('Expected more digits in base 64 VLQ value.')
              }

              digit = base64.decode(aStr.charCodeAt(aIndex++))
              if (digit === -1) {
                throw new Error(
                  'Invalid base64 digit: ' + aStr.charAt(aIndex - 1)
                )
              }

              continuation = !!(digit & VLQ_CONTINUATION_BIT)
              digit &= VLQ_BASE_MASK
              result = result + (digit << shift)
              shift += VLQ_BASE_SHIFT
            } while (continuation)

            aOutParam.value = fromVLQSigned(result)
            aOutParam.rest = aIndex
          }
        },
        { './base64': 518 },
      ],
      518: [
        function(require, module, exports) {
          /* -*- Mode: js; js-indent-level: 2; -*- */
          /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

          var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split(
            ''
          )

          /**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
          exports.encode = function(number) {
            if (0 <= number && number < intToCharMap.length) {
              return intToCharMap[number]
            }
            throw new TypeError('Must be between 0 and 63: ' + number)
          }

          /**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */
          exports.decode = function(charCode) {
            var bigA = 65 // 'A'
            var bigZ = 90 // 'Z'

            var littleA = 97 // 'a'
            var littleZ = 122 // 'z'

            var zero = 48 // '0'
            var nine = 57 // '9'

            var plus = 43 // '+'
            var slash = 47 // '/'

            var littleOffset = 26
            var numberOffset = 52

            // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
            if (bigA <= charCode && charCode <= bigZ) {
              return charCode - bigA
            }

            // 26 - 51: abcdefghijklmnopqrstuvwxyz
            if (littleA <= charCode && charCode <= littleZ) {
              return charCode - littleA + littleOffset
            }

            // 52 - 61: 0123456789
            if (zero <= charCode && charCode <= nine) {
              return charCode - zero + numberOffset
            }

            // 62: +
            if (charCode == plus) {
              return 62
            }

            // 63: /
            if (charCode == slash) {
              return 63
            }

            // Invalid base64 digit.
            return -1
          }
        },
        {},
      ],
      519: [
        function(require, module, exports) {
          /* -*- Mode: js; js-indent-level: 2; -*- */
          /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

          exports.GREATEST_LOWER_BOUND = 1
          exports.LEAST_UPPER_BOUND = 2

          /**
 * Recursive implementation of binary search.
 *
 * @param aLow Indices here and lower do not contain the needle.
 * @param aHigh Indices here and higher do not contain the needle.
 * @param aNeedle The element being searched for.
 * @param aHaystack The non-empty array being searched.
 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 */
          function recursiveSearch(
            aLow,
            aHigh,
            aNeedle,
            aHaystack,
            aCompare,
            aBias
          ) {
            // This function terminates when one of the following is true:
            //
            //   1. We find the exact element we are looking for.
            //
            //   2. We did not find the exact element, but we can return the index of
            //      the next-closest element.
            //
            //   3. We did not find the exact element, and there is no next-closest
            //      element than the one we are searching for, so we return -1.
            var mid = Math.floor((aHigh - aLow) / 2) + aLow
            var cmp = aCompare(aNeedle, aHaystack[mid], true)
            if (cmp === 0) {
              // Found the element we are looking for.
              return mid
            } else if (cmp > 0) {
              // Our needle is greater than aHaystack[mid].
              if (aHigh - mid > 1) {
                // The element is in the upper half.
                return recursiveSearch(
                  mid,
                  aHigh,
                  aNeedle,
                  aHaystack,
                  aCompare,
                  aBias
                )
              }

              // The exact needle element was not found in this haystack. Determine if
              // we are in termination case (3) or (2) and return the appropriate thing.
              if (aBias == exports.LEAST_UPPER_BOUND) {
                return aHigh < aHaystack.length ? aHigh : -1
              } else {
                return mid
              }
            } else {
              // Our needle is less than aHaystack[mid].
              if (mid - aLow > 1) {
                // The element is in the lower half.
                return recursiveSearch(
                  aLow,
                  mid,
                  aNeedle,
                  aHaystack,
                  aCompare,
                  aBias
                )
              }

              // we are in termination case (3) or (2) and return the appropriate thing.
              if (aBias == exports.LEAST_UPPER_BOUND) {
                return mid
              } else {
                return aLow < 0 ? -1 : aLow
              }
            }
          }

          /**
 * This is an implementation of binary search which will always try and return
 * the index of the closest element if there is no exact hit. This is because
 * mappings between original and generated line/col pairs are single points,
 * and there is an implicit region between each of them, so a miss just means
 * that you aren't on the very start of a region.
 *
 * @param aNeedle The element you are looking for.
 * @param aHaystack The array that is being searched.
 * @param aCompare A function which takes the needle and an element in the
 *     array and returns -1, 0, or 1 depending on whether the needle is less
 *     than, equal to, or greater than the element, respectively.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
 */
          exports.search = function search(
            aNeedle,
            aHaystack,
            aCompare,
            aBias
          ) {
            if (aHaystack.length === 0) {
              return -1
            }

            var index = recursiveSearch(
              -1,
              aHaystack.length,
              aNeedle,
              aHaystack,
              aCompare,
              aBias || exports.GREATEST_LOWER_BOUND
            )
            if (index < 0) {
              return -1
            }

            // We have found either the exact element, or the next-closest element than
            // the one we are searching for. However, there may be more than one such
            // element. Make sure we always return the smallest of these.
            while (index - 1 >= 0) {
              if (
                aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0
              ) {
                break
              }
              --index
            }

            return index
          }
        },
        {},
      ],
      520: [
        function(require, module, exports) {
          /* -*- Mode: js; js-indent-level: 2; -*- */
          /*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

          var util = require('./util')

          /**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
          function generatedPositionAfter(mappingA, mappingB) {
            // Optimized for most common case
            var lineA = mappingA.generatedLine
            var lineB = mappingB.generatedLine
            var columnA = mappingA.generatedColumn
            var columnB = mappingB.generatedColumn
            return (
              lineB > lineA ||
              (lineB == lineA && columnB >= columnA) ||
              util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0
            )
          }

          /**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
          function MappingList() {
            this._array = []
            this._sorted = true
            // Serves as infimum
            this._last = { generatedLine: -1, generatedColumn: 0 }
          }

          /**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */
          MappingList.prototype.unsortedForEach = function MappingList_forEach(
            aCallback,
            aThisArg
          ) {
            this._array.forEach(aCallback, aThisArg)
          }

          /**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */
          MappingList.prototype.add = function MappingList_add(aMapping) {
            if (generatedPositionAfter(this._last, aMapping)) {
              this._last = aMapping
              this._array.push(aMapping)
            } else {
              this._sorted = false
              this._array.push(aMapping)
            }
          }

          /**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */
          MappingList.prototype.toArray = function MappingList_toArray() {
            if (!this._sorted) {
              this._array.sort(util.compareByGeneratedPositionsInflated)
              this._sorted = true
            }
            return this._array
          }

          exports.MappingList = MappingList
        },
        { './util': 525 },
      ],
      521: [
        function(require, module, exports) {
          /* -*- Mode: js; js-indent-level: 2; -*- */
          /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

          // It turns out that some (most?) JavaScript engines don't self-host
          // `Array.prototype.sort`. This makes sense because C++ will likely remain
          // faster than JS when doing raw CPU-intensive sorting. However, when using a
          // custom comparator function, calling back and forth between the VM's C++ and
          // JIT'd JS is rather slow *and* loses JIT type information, resulting in
          // worse generated code for the comparator function than would be optimal. In
          // fact, when sorting with a comparator, these costs outweigh the benefits of
          // sorting in C++. By using our own JS-implemented Quick Sort (below), we get
          // a ~3500ms mean speed-up in `bench/bench.html`.

          /**
 * Swap the elements indexed by `x` and `y` in the array `ary`.
 *
 * @param {Array} ary
 *        The array.
 * @param {Number} x
 *        The index of the first item.
 * @param {Number} y
 *        The index of the second item.
 */
          function swap(ary, x, y) {
            var temp = ary[x]
            ary[x] = ary[y]
            ary[y] = temp
          }

          /**
 * Returns a random integer within the range `low .. high` inclusive.
 *
 * @param {Number} low
 *        The lower bound on the range.
 * @param {Number} high
 *        The upper bound on the range.
 */
          function randomIntInRange(low, high) {
            return Math.round(low + Math.random() * (high - low))
          }

          /**
 * The Quick Sort algorithm.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 * @param {Number} p
 *        Start index of the array
 * @param {Number} r
 *        End index of the array
 */
          function doQuickSort(ary, comparator, p, r) {
            // If our lower bound is less than our upper bound, we (1) partition the
            // array into two pieces and (2) recurse on each half. If it is not, this is
            // the empty array and our base case.

            if (p < r) {
              // (1) Partitioning.
              //
              // The partitioning chooses a pivot between `p` and `r` and moves all
              // elements that are less than or equal to the pivot to the before it, and
              // all the elements that are greater than it after it. The effect is that
              // once partition is done, the pivot is in the exact place it will be when
              // the array is put in sorted order, and it will not need to be moved
              // again. This runs in O(n) time.

              // Always choose a random pivot so that an input array which is reverse
              // sorted does not cause O(n^2) running time.
              var pivotIndex = randomIntInRange(p, r)
              var i = p - 1

              swap(ary, pivotIndex, r)
              var pivot = ary[r]

              // Immediately after `j` is incremented in this loop, the following hold
              // true:
              //
              //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
              //
              //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
              for (var j = p; j < r; j++) {
                if (comparator(ary[j], pivot) <= 0) {
                  i += 1
                  swap(ary, i, j)
                }
              }

              swap(ary, i + 1, j)
              var q = i + 1

              // (2) Recurse on each half.

              doQuickSort(ary, comparator, p, q - 1)
              doQuickSort(ary, comparator, q + 1, r)
            }
          }

          /**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 */
          exports.quickSort = function(ary, comparator) {
            doQuickSort(ary, comparator, 0, ary.length - 1)
          }
        },
        {},
      ],
      522: [
        function(require, module, exports) {
          /* -*- Mode: js; js-indent-level: 2; -*- */
          /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

          var util = require('./util')
          var binarySearch = require('./binary-search')
          var ArraySet = require('./array-set').ArraySet
          var base64VLQ = require('./base64-vlq')
          var quickSort = require('./quick-sort').quickSort

          function SourceMapConsumer(aSourceMap) {
            var sourceMap = aSourceMap
            if (typeof aSourceMap === 'string') {
              sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''))
            }

            return sourceMap.sections != null
              ? new IndexedSourceMapConsumer(sourceMap)
              : new BasicSourceMapConsumer(sourceMap)
          }

          SourceMapConsumer.fromSourceMap = function(aSourceMap) {
            return BasicSourceMapConsumer.fromSourceMap(aSourceMap)
          }

          /**
 * The version of the source mapping spec that we are consuming.
 */
          SourceMapConsumer.prototype._version = 3

          // `__generatedMappings` and `__originalMappings` are arrays that hold the
          // parsed mapping coordinates from the source map's "mappings" attribute. They
          // are lazily instantiated, accessed via the `_generatedMappings` and
          // `_originalMappings` getters respectively, and we only parse the mappings
          // and create these arrays once queried for a source location. We jump through
          // these hoops because there can be many thousands of mappings, and parsing
          // them is expensive, so we only want to do it if we must.
          //
          // Each object in the arrays is of the form:
          //
          //     {
          //       generatedLine: The line number in the generated code,
          //       generatedColumn: The column number in the generated code,
          //       source: The path to the original source file that generated this
          //               chunk of code,
          //       originalLine: The line number in the original source that
          //                     corresponds to this chunk of generated code,
          //       originalColumn: The column number in the original source that
          //                       corresponds to this chunk of generated code,
          //       name: The name of the original symbol which generated this chunk of
          //             code.
          //     }
          //
          // All properties except for `generatedLine` and `generatedColumn` can be
          // `null`.
          //
          // `_generatedMappings` is ordered by the generated positions.
          //
          // `_originalMappings` is ordered by the original positions.

          SourceMapConsumer.prototype.__generatedMappings = null
          Object.defineProperty(
            SourceMapConsumer.prototype,
            '_generatedMappings',
            {
              get: function() {
                if (!this.__generatedMappings) {
                  this._parseMappings(this._mappings, this.sourceRoot)
                }

                return this.__generatedMappings
              },
            }
          )

          SourceMapConsumer.prototype.__originalMappings = null
          Object.defineProperty(
            SourceMapConsumer.prototype,
            '_originalMappings',
            {
              get: function() {
                if (!this.__originalMappings) {
                  this._parseMappings(this._mappings, this.sourceRoot)
                }

                return this.__originalMappings
              },
            }
          )

          SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(
            aStr,
            index
          ) {
            var c = aStr.charAt(index)
            return c === ';' || c === ','
          }

          /**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
          SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(
            aStr,
            aSourceRoot
          ) {
            throw new Error('Subclasses must implement _parseMappings')
          }

          SourceMapConsumer.GENERATED_ORDER = 1
          SourceMapConsumer.ORIGINAL_ORDER = 2

          SourceMapConsumer.GREATEST_LOWER_BOUND = 1
          SourceMapConsumer.LEAST_UPPER_BOUND = 2

          /**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */
          SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(
            aCallback,
            aContext,
            aOrder
          ) {
            var context = aContext || null
            var order = aOrder || SourceMapConsumer.GENERATED_ORDER

            var mappings
            switch (order) {
              case SourceMapConsumer.GENERATED_ORDER:
                mappings = this._generatedMappings
                break
              case SourceMapConsumer.ORIGINAL_ORDER:
                mappings = this._originalMappings
                break
              default:
                throw new Error('Unknown order of iteration.')
            }

            var sourceRoot = this.sourceRoot
            mappings
              .map(function(mapping) {
                var source = mapping.source === null
                  ? null
                  : this._sources.at(mapping.source)
                if (source != null && sourceRoot != null) {
                  source = util.join(sourceRoot, source)
                }
                return {
                  source: source,
                  generatedLine: mapping.generatedLine,
                  generatedColumn: mapping.generatedColumn,
                  originalLine: mapping.originalLine,
                  originalColumn: mapping.originalColumn,
                  name: mapping.name === null
                    ? null
                    : this._names.at(mapping.name),
                }
              }, this)
              .forEach(aCallback, context)
          }

          /**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: Optional. the column number in the original source.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
          SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(
            aArgs
          ) {
            var line = util.getArg(aArgs, 'line')

            // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
            // returns the index of the closest mapping less than the needle. By
            // setting needle.originalColumn to 0, we thus find the last mapping for
            // the given line, provided such a mapping exists.
            var needle = {
              source: util.getArg(aArgs, 'source'),
              originalLine: line,
              originalColumn: util.getArg(aArgs, 'column', 0),
            }

            if (this.sourceRoot != null) {
              needle.source = util.relative(this.sourceRoot, needle.source)
            }
            if (!this._sources.has(needle.source)) {
              return []
            }
            needle.source = this._sources.indexOf(needle.source)

            var mappings = []

            var index = this._findMapping(
              needle,
              this._originalMappings,
              'originalLine',
              'originalColumn',
              util.compareByOriginalPositions,
              binarySearch.LEAST_UPPER_BOUND
            )
            if (index >= 0) {
              var mapping = this._originalMappings[index]

              if (aArgs.column === undefined) {
                var originalLine = mapping.originalLine

                // Iterate until either we run out of mappings, or we run into
                // a mapping for a different line than the one we found. Since
                // mappings are sorted, this is guaranteed to find all mappings for
                // the line we found.
                while (mapping && mapping.originalLine === originalLine) {
                  mappings.push({
                    line: util.getArg(mapping, 'generatedLine', null),
                    column: util.getArg(mapping, 'generatedColumn', null),
                    lastColumn: util.getArg(
                      mapping,
                      'lastGeneratedColumn',
                      null
                    ),
                  })

                  mapping = this._originalMappings[++index]
                }
              } else {
                var originalColumn = mapping.originalColumn

                // Iterate until either we run out of mappings, or we run into
                // a mapping for a different line than the one we were searching for.
                // Since mappings are sorted, this is guaranteed to find all mappings for
                // the line we are searching for.
                while (
                  mapping &&
                  mapping.originalLine === line &&
                  mapping.originalColumn == originalColumn
                ) {
                  mappings.push({
                    line: util.getArg(mapping, 'generatedLine', null),
                    column: util.getArg(mapping, 'generatedColumn', null),
                    lastColumn: util.getArg(
                      mapping,
                      'lastGeneratedColumn',
                      null
                    ),
                  })

                  mapping = this._originalMappings[++index]
                }
              }
            }

            return mappings
          }

          exports.SourceMapConsumer = SourceMapConsumer

          /**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The only parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */
          function BasicSourceMapConsumer(aSourceMap) {
            var sourceMap = aSourceMap
            if (typeof aSourceMap === 'string') {
              sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''))
            }

            var version = util.getArg(sourceMap, 'version')
            var sources = util.getArg(sourceMap, 'sources')
            // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
            // requires the array) to play nice here.
            var names = util.getArg(sourceMap, 'names', [])
            var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null)
            var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null)
            var mappings = util.getArg(sourceMap, 'mappings')
            var file = util.getArg(sourceMap, 'file', null)

            // Once again, Sass deviates from the spec and supplies the version as a
            // string rather than a number, so we use loose equality checking here.
            if (version != this._version) {
              throw new Error('Unsupported version: ' + version)
            }

            sources = sources
              .map(String)
              // Some source maps produce relative source paths like "./foo.js" instead of
              // "foo.js".  Normalize these first so that future comparisons will succeed.
              // See bugzil.la/1090768.
              .map(util.normalize)
              // Always ensure that absolute sources are internally stored relative to
              // the source root, if the source root is absolute. Not doing this would
              // be particularly problematic when the source root is a prefix of the
              // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
              .map(function(source) {
                return sourceRoot &&
                  util.isAbsolute(sourceRoot) &&
                  util.isAbsolute(source)
                  ? util.relative(sourceRoot, source)
                  : source
              })

            // Pass `true` below to allow duplicate names and sources. While source maps
            // are intended to be compressed and deduplicated, the TypeScript compiler
            // sometimes generates source maps with duplicates in them. See Github issue
            // #72 and bugzil.la/889492.
            this._names = ArraySet.fromArray(names.map(String), true)
            this._sources = ArraySet.fromArray(sources, true)

            this.sourceRoot = sourceRoot
            this.sourcesContent = sourcesContent
            this._mappings = mappings
            this.file = file
          }

          BasicSourceMapConsumer.prototype = Object.create(
            SourceMapConsumer.prototype
          )
          BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer

          /**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @returns BasicSourceMapConsumer
 */
          BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(
            aSourceMap
          ) {
            var smc = Object.create(BasicSourceMapConsumer.prototype)

            var names = (smc._names = ArraySet.fromArray(
              aSourceMap._names.toArray(),
              true
            ))
            var sources = (smc._sources = ArraySet.fromArray(
              aSourceMap._sources.toArray(),
              true
            ))
            smc.sourceRoot = aSourceMap._sourceRoot
            smc.sourcesContent = aSourceMap._generateSourcesContent(
              smc._sources.toArray(),
              smc.sourceRoot
            )
            smc.file = aSourceMap._file

            // Because we are modifying the entries (by converting string sources and
            // names to indices into the sources and names ArraySets), we have to make
            // a copy of the entry or else bad things happen. Shared mutable state
            // strikes again! See github issue #191.

            var generatedMappings = aSourceMap._mappings.toArray().slice()
            var destGeneratedMappings = (smc.__generatedMappings = [])
            var destOriginalMappings = (smc.__originalMappings = [])

            for (
              var i = 0, length = generatedMappings.length;
              i < length;
              i++
            ) {
              var srcMapping = generatedMappings[i]
              var destMapping = new Mapping()
              destMapping.generatedLine = srcMapping.generatedLine
              destMapping.generatedColumn = srcMapping.generatedColumn

              if (srcMapping.source) {
                destMapping.source = sources.indexOf(srcMapping.source)
                destMapping.originalLine = srcMapping.originalLine
                destMapping.originalColumn = srcMapping.originalColumn

                if (srcMapping.name) {
                  destMapping.name = names.indexOf(srcMapping.name)
                }

                destOriginalMappings.push(destMapping)
              }

              destGeneratedMappings.push(destMapping)
            }

            quickSort(smc.__originalMappings, util.compareByOriginalPositions)

            return smc
          }

          /**
 * The version of the source mapping spec that we are consuming.
 */
          BasicSourceMapConsumer.prototype._version = 3

          /**
 * The list of original sources.
 */
          Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
            get: function() {
              return this._sources.toArray().map(function(s) {
                return this.sourceRoot != null
                  ? util.join(this.sourceRoot, s)
                  : s
              }, this)
            },
          })

          /**
 * Provide the JIT with a nice shape / hidden class.
 */
          function Mapping() {
            this.generatedLine = 0
            this.generatedColumn = 0
            this.source = null
            this.originalLine = null
            this.originalColumn = null
            this.name = null
          }

          /**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
          BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(
            aStr,
            aSourceRoot
          ) {
            var generatedLine = 1
            var previousGeneratedColumn = 0
            var previousOriginalLine = 0
            var previousOriginalColumn = 0
            var previousSource = 0
            var previousName = 0
            var length = aStr.length
            var index = 0
            var cachedSegments = {}
            var temp = {}
            var originalMappings = []
            var generatedMappings = []
            var mapping, str, segment, end, value

            while (index < length) {
              if (aStr.charAt(index) === ';') {
                generatedLine++
                index++
                previousGeneratedColumn = 0
              } else if (aStr.charAt(index) === ',') {
                index++
              } else {
                mapping = new Mapping()
                mapping.generatedLine = generatedLine

                // Because each offset is encoded relative to the previous one,
                // many segments often have the same encoding. We can exploit this
                // fact by caching the parsed variable length fields of each segment,
                // allowing us to avoid a second parse if we encounter the same
                // segment again.
                for (end = index; end < length; end++) {
                  if (this._charIsMappingSeparator(aStr, end)) {
                    break
                  }
                }
                str = aStr.slice(index, end)

                segment = cachedSegments[str]
                if (segment) {
                  index += str.length
                } else {
                  segment = []
                  while (index < end) {
                    base64VLQ.decode(aStr, index, temp)
                    value = temp.value
                    index = temp.rest
                    segment.push(value)
                  }

                  if (segment.length === 2) {
                    throw new Error('Found a source, but no line and column')
                  }

                  if (segment.length === 3) {
                    throw new Error('Found a source and line, but no column')
                  }

                  cachedSegments[str] = segment
                }

                // Generated column.
                mapping.generatedColumn = previousGeneratedColumn + segment[0]
                previousGeneratedColumn = mapping.generatedColumn

                if (segment.length > 1) {
                  // Original source.
                  mapping.source = previousSource + segment[1]
                  previousSource += segment[1]

                  // Original line.
                  mapping.originalLine = previousOriginalLine + segment[2]
                  previousOriginalLine = mapping.originalLine
                  // Lines are stored 0-based
                  mapping.originalLine += 1

                  // Original column.
                  mapping.originalColumn = previousOriginalColumn + segment[3]
                  previousOriginalColumn = mapping.originalColumn

                  if (segment.length > 4) {
                    // Original name.
                    mapping.name = previousName + segment[4]
                    previousName += segment[4]
                  }
                }

                generatedMappings.push(mapping)
                if (typeof mapping.originalLine === 'number') {
                  originalMappings.push(mapping)
                }
              }
            }

            quickSort(
              generatedMappings,
              util.compareByGeneratedPositionsDeflated
            )
            this.__generatedMappings = generatedMappings

            quickSort(originalMappings, util.compareByOriginalPositions)
            this.__originalMappings = originalMappings
          }

          /**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */
          BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(
            aNeedle,
            aMappings,
            aLineName,
            aColumnName,
            aComparator,
            aBias
          ) {
            // To return the position we are searching for, we must first find the
            // mapping for the given position and then return the opposite position it
            // points to. Because the mappings are sorted, we can use binary search to
            // find the best mapping.

            if (aNeedle[aLineName] <= 0) {
              throw new TypeError(
                'Line must be greater than or equal to 1, got ' +
                  aNeedle[aLineName]
              )
            }
            if (aNeedle[aColumnName] < 0) {
              throw new TypeError(
                'Column must be greater than or equal to 0, got ' +
                  aNeedle[aColumnName]
              )
            }

            return binarySearch.search(aNeedle, aMappings, aComparator, aBias)
          }

          /**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */
          BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
            for (
              var index = 0;
              index < this._generatedMappings.length;
              ++index
            ) {
              var mapping = this._generatedMappings[index]

              // Mappings do not contain a field for the last generated columnt. We
              // can come up with an optimistic estimate, however, by assuming that
              // mappings are contiguous (i.e. given two consecutive mappings, the
              // first mapping ends where the second one starts).
              if (index + 1 < this._generatedMappings.length) {
                var nextMapping = this._generatedMappings[index + 1]

                if (mapping.generatedLine === nextMapping.generatedLine) {
                  mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1
                  continue
                }
              }

              // The last mapping for each line spans the entire line.
              mapping.lastGeneratedColumn = Infinity
            }
          }

          /**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.
 *   - column: The column number in the generated source.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.
 *   - column: The column number in the original source, or null.
 *   - name: The original identifier, or null.
 */
          BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(
            aArgs
          ) {
            var needle = {
              generatedLine: util.getArg(aArgs, 'line'),
              generatedColumn: util.getArg(aArgs, 'column'),
            }

            var index = this._findMapping(
              needle,
              this._generatedMappings,
              'generatedLine',
              'generatedColumn',
              util.compareByGeneratedPositionsDeflated,
              util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
            )

            if (index >= 0) {
              var mapping = this._generatedMappings[index]

              if (mapping.generatedLine === needle.generatedLine) {
                var source = util.getArg(mapping, 'source', null)
                if (source !== null) {
                  source = this._sources.at(source)
                  if (this.sourceRoot != null) {
                    source = util.join(this.sourceRoot, source)
                  }
                }
                var name = util.getArg(mapping, 'name', null)
                if (name !== null) {
                  name = this._names.at(name)
                }
                return {
                  source: source,
                  line: util.getArg(mapping, 'originalLine', null),
                  column: util.getArg(mapping, 'originalColumn', null),
                  name: name,
                }
              }
            }

            return {
              source: null,
              line: null,
              column: null,
              name: null,
            }
          }

          /**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
          BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
            if (!this.sourcesContent) {
              return false
            }
            return (
              this.sourcesContent.length >= this._sources.size() &&
              !this.sourcesContent.some(function(sc) {
                return sc == null
              })
            )
          }

          /**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
          BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(
            aSource,
            nullOnMissing
          ) {
            if (!this.sourcesContent) {
              return null
            }

            if (this.sourceRoot != null) {
              aSource = util.relative(this.sourceRoot, aSource)
            }

            if (this._sources.has(aSource)) {
              return this.sourcesContent[this._sources.indexOf(aSource)]
            }

            var url
            if (
              this.sourceRoot != null &&
              (url = util.urlParse(this.sourceRoot))
            ) {
              // XXX: file:// URIs and absolute paths lead to unexpected behavior for
              // many users. We can help them out when they expect file:// URIs to
              // behave like it would if they were running a local HTTP server. See
              // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
              var fileUriAbsPath = aSource.replace(/^file:\/\//, '')
              if (url.scheme == 'file' && this._sources.has(fileUriAbsPath)) {
                return this.sourcesContent[
                  this._sources.indexOf(fileUriAbsPath)
                ]
              }

              if (
                (!url.path || url.path == '/') &&
                this._sources.has('/' + aSource)
              ) {
                return this.sourcesContent[this._sources.indexOf('/' + aSource)]
              }
            }

            // This function is used recursively from
            // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
            // don't want to throw if we can't find the source - we just want to
            // return null, so we provide a flag to exit gracefully.
            if (nullOnMissing) {
              return null
            } else {
              throw new Error('"' + aSource + '" is not in the SourceMap.')
            }
          }

          /**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: The column number in the original source.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
          BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(
            aArgs
          ) {
            var source = util.getArg(aArgs, 'source')
            if (this.sourceRoot != null) {
              source = util.relative(this.sourceRoot, source)
            }
            if (!this._sources.has(source)) {
              return {
                line: null,
                column: null,
                lastColumn: null,
              }
            }
            source = this._sources.indexOf(source)

            var needle = {
              source: source,
              originalLine: util.getArg(aArgs, 'line'),
              originalColumn: util.getArg(aArgs, 'column'),
            }

            var index = this._findMapping(
              needle,
              this._originalMappings,
              'originalLine',
              'originalColumn',
              util.compareByOriginalPositions,
              util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
            )

            if (index >= 0) {
              var mapping = this._originalMappings[index]

              if (mapping.source === needle.source) {
                return {
                  line: util.getArg(mapping, 'generatedLine', null),
                  column: util.getArg(mapping, 'generatedColumn', null),
                  lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null),
                }
              }
            }

            return {
              line: null,
              column: null,
              lastColumn: null,
            }
          }

          exports.BasicSourceMapConsumer = BasicSourceMapConsumer

          /**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The only parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */
          function IndexedSourceMapConsumer(aSourceMap) {
            var sourceMap = aSourceMap
            if (typeof aSourceMap === 'string') {
              sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''))
            }

            var version = util.getArg(sourceMap, 'version')
            var sections = util.getArg(sourceMap, 'sections')

            if (version != this._version) {
              throw new Error('Unsupported version: ' + version)
            }

            this._sources = new ArraySet()
            this._names = new ArraySet()

            var lastOffset = {
              line: -1,
              column: 0,
            }
            this._sections = sections.map(function(s) {
              if (s.url) {
                // The url field will require support for asynchronicity.
                // See https://github.com/mozilla/source-map/issues/16
                throw new Error(
                  'Support for url field in sections not implemented.'
                )
              }
              var offset = util.getArg(s, 'offset')
              var offsetLine = util.getArg(offset, 'line')
              var offsetColumn = util.getArg(offset, 'column')

              if (
                offsetLine < lastOffset.line ||
                (offsetLine === lastOffset.line &&
                  offsetColumn < lastOffset.column)
              ) {
                throw new Error(
                  'Section offsets must be ordered and non-overlapping.'
                )
              }
              lastOffset = offset

              return {
                generatedOffset: {
                  // The offset fields are 0-based, but we use 1-based indices when
                  // encoding/decoding from VLQ.
                  generatedLine: offsetLine + 1,
                  generatedColumn: offsetColumn + 1,
                },
                consumer: new SourceMapConsumer(util.getArg(s, 'map')),
              }
            })
          }

          IndexedSourceMapConsumer.prototype = Object.create(
            SourceMapConsumer.prototype
          )
          IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer

          /**
 * The version of the source mapping spec that we are consuming.
 */
          IndexedSourceMapConsumer.prototype._version = 3

          /**
 * The list of original sources.
 */
          Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
            get: function() {
              var sources = []
              for (var i = 0; i < this._sections.length; i++) {
                for (
                  var j = 0;
                  j < this._sections[i].consumer.sources.length;
                  j++
                ) {
                  sources.push(this._sections[i].consumer.sources[j])
                }
              }
              return sources
            },
          })

          /**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.
 *   - column: The column number in the generated source.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.
 *   - column: The column number in the original source, or null.
 *   - name: The original identifier, or null.
 */
          IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(
            aArgs
          ) {
            var needle = {
              generatedLine: util.getArg(aArgs, 'line'),
              generatedColumn: util.getArg(aArgs, 'column'),
            }

            // Find the section containing the generated position we're trying to map
            // to an original position.
            var sectionIndex = binarySearch.search(
              needle,
              this._sections,
              function(needle, section) {
                var cmp =
                  needle.generatedLine - section.generatedOffset.generatedLine
                if (cmp) {
                  return cmp
                }

                return (
                  needle.generatedColumn -
                  section.generatedOffset.generatedColumn
                )
              }
            )
            var section = this._sections[sectionIndex]

            if (!section) {
              return {
                source: null,
                line: null,
                column: null,
                name: null,
              }
            }

            return section.consumer.originalPositionFor({
              line:
                needle.generatedLine -
                  (section.generatedOffset.generatedLine - 1),
              column:
                needle.generatedColumn -
                  (section.generatedOffset.generatedLine ===
                    needle.generatedLine
                    ? section.generatedOffset.generatedColumn - 1
                    : 0),
              bias: aArgs.bias,
            })
          }

          /**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
          IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
            return this._sections.every(function(s) {
              return s.consumer.hasContentsOfAllSources()
            })
          }

          /**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
          IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(
            aSource,
            nullOnMissing
          ) {
            for (var i = 0; i < this._sections.length; i++) {
              var section = this._sections[i]

              var content = section.consumer.sourceContentFor(aSource, true)
              if (content) {
                return content
              }
            }
            if (nullOnMissing) {
              return null
            } else {
              throw new Error('"' + aSource + '" is not in the SourceMap.')
            }
          }

          /**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: The column number in the original source.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
          IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(
            aArgs
          ) {
            for (var i = 0; i < this._sections.length; i++) {
              var section = this._sections[i]

              // Only consider this section if the requested source is in the list of
              // sources of the consumer.
              if (
                section.consumer.sources.indexOf(
                  util.getArg(aArgs, 'source')
                ) === -1
              ) {
                continue
              }
              var generatedPosition = section.consumer.generatedPositionFor(
                aArgs
              )
              if (generatedPosition) {
                var ret = {
                  line:
                    generatedPosition.line +
                      (section.generatedOffset.generatedLine - 1),
                  column:
                    generatedPosition.column +
                      (section.generatedOffset.generatedLine ===
                        generatedPosition.line
                        ? section.generatedOffset.generatedColumn - 1
                        : 0),
                }
                return ret
              }
            }

            return {
              line: null,
              column: null,
            }
          }

          /**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
          IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(
            aStr,
            aSourceRoot
          ) {
            this.__generatedMappings = []
            this.__originalMappings = []
            for (var i = 0; i < this._sections.length; i++) {
              var section = this._sections[i]
              var sectionMappings = section.consumer._generatedMappings
              for (var j = 0; j < sectionMappings.length; j++) {
                var mapping = sectionMappings[j]

                var source = section.consumer._sources.at(mapping.source)
                if (section.consumer.sourceRoot !== null) {
                  source = util.join(section.consumer.sourceRoot, source)
                }
                this._sources.add(source)
                source = this._sources.indexOf(source)

                var name = section.consumer._names.at(mapping.name)
                this._names.add(name)
                name = this._names.indexOf(name)

                // The mappings coming from the consumer for the section have
                // generated positions relative to the start of the section, so we
                // need to offset them to be relative to the start of the concatenated
                // generated file.
                var adjustedMapping = {
                  source: source,
                  generatedLine:
                    mapping.generatedLine +
                      (section.generatedOffset.generatedLine - 1),
                  generatedColumn:
                    mapping.generatedColumn +
                      (section.generatedOffset.generatedLine ===
                        mapping.generatedLine
                        ? section.generatedOffset.generatedColumn - 1
                        : 0),
                  originalLine: mapping.originalLine,
                  originalColumn: mapping.originalColumn,
                  name: name,
                }

                this.__generatedMappings.push(adjustedMapping)
                if (typeof adjustedMapping.originalLine === 'number') {
                  this.__originalMappings.push(adjustedMapping)
                }
              }
            }

            quickSort(
              this.__generatedMappings,
              util.compareByGeneratedPositionsDeflated
            )
            quickSort(this.__originalMappings, util.compareByOriginalPositions)
          }

          exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer
        },
        {
          './array-set': 516,
          './base64-vlq': 517,
          './binary-search': 519,
          './quick-sort': 521,
          './util': 525,
        },
      ],
      523: [
        function(require, module, exports) {
          /* -*- Mode: js; js-indent-level: 2; -*- */
          /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

          var base64VLQ = require('./base64-vlq')
          var util = require('./util')
          var ArraySet = require('./array-set').ArraySet
          var MappingList = require('./mapping-list').MappingList

          /**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */
          function SourceMapGenerator(aArgs) {
            if (!aArgs) {
              aArgs = {}
            }
            this._file = util.getArg(aArgs, 'file', null)
            this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null)
            this._skipValidation = util.getArg(aArgs, 'skipValidation', false)
            this._sources = new ArraySet()
            this._names = new ArraySet()
            this._mappings = new MappingList()
            this._sourcesContents = null
          }

          SourceMapGenerator.prototype._version = 3

          /**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */
          SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(
            aSourceMapConsumer
          ) {
            var sourceRoot = aSourceMapConsumer.sourceRoot
            var generator = new SourceMapGenerator({
              file: aSourceMapConsumer.file,
              sourceRoot: sourceRoot,
            })
            aSourceMapConsumer.eachMapping(function(mapping) {
              var newMapping = {
                generated: {
                  line: mapping.generatedLine,
                  column: mapping.generatedColumn,
                },
              }

              if (mapping.source != null) {
                newMapping.source = mapping.source
                if (sourceRoot != null) {
                  newMapping.source = util.relative(
                    sourceRoot,
                    newMapping.source
                  )
                }

                newMapping.original = {
                  line: mapping.originalLine,
                  column: mapping.originalColumn,
                }

                if (mapping.name != null) {
                  newMapping.name = mapping.name
                }
              }

              generator.addMapping(newMapping)
            })
            aSourceMapConsumer.sources.forEach(function(sourceFile) {
              var content = aSourceMapConsumer.sourceContentFor(sourceFile)
              if (content != null) {
                generator.setSourceContent(sourceFile, content)
              }
            })
            return generator
          }

          /**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */
          SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(
            aArgs
          ) {
            var generated = util.getArg(aArgs, 'generated')
            var original = util.getArg(aArgs, 'original', null)
            var source = util.getArg(aArgs, 'source', null)
            var name = util.getArg(aArgs, 'name', null)

            if (!this._skipValidation) {
              this._validateMapping(generated, original, source, name)
            }

            if (source != null) {
              source = String(source)
              if (!this._sources.has(source)) {
                this._sources.add(source)
              }
            }

            if (name != null) {
              name = String(name)
              if (!this._names.has(name)) {
                this._names.add(name)
              }
            }

            this._mappings.add({
              generatedLine: generated.line,
              generatedColumn: generated.column,
              originalLine: original != null && original.line,
              originalColumn: original != null && original.column,
              source: source,
              name: name,
            })
          }

          /**
 * Set the source content for a source file.
 */
          SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(
            aSourceFile,
            aSourceContent
          ) {
            var source = aSourceFile
            if (this._sourceRoot != null) {
              source = util.relative(this._sourceRoot, source)
            }

            if (aSourceContent != null) {
              // Add the source content to the _sourcesContents map.
              // Create a new _sourcesContents map if the property is null.
              if (!this._sourcesContents) {
                this._sourcesContents = Object.create(null)
              }
              this._sourcesContents[util.toSetString(source)] = aSourceContent
            } else if (this._sourcesContents) {
              // Remove the source file from the _sourcesContents map.
              // If the _sourcesContents map is empty, set the property to null.
              delete this._sourcesContents[util.toSetString(source)]
              if (Object.keys(this._sourcesContents).length === 0) {
                this._sourcesContents = null
              }
            }
          }

          /**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */
          SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(
            aSourceMapConsumer,
            aSourceFile,
            aSourceMapPath
          ) {
            var sourceFile = aSourceFile
            // If aSourceFile is omitted, we will use the file property of the SourceMap
            if (aSourceFile == null) {
              if (aSourceMapConsumer.file == null) {
                throw new Error(
                  'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
                    'or the source map\'s "file" property. Both were omitted.'
                )
              }
              sourceFile = aSourceMapConsumer.file
            }
            var sourceRoot = this._sourceRoot
            // Make "sourceFile" relative if an absolute Url is passed.
            if (sourceRoot != null) {
              sourceFile = util.relative(sourceRoot, sourceFile)
            }
            // Applying the SourceMap can add and remove items from the sources and
            // the names array.
            var newSources = new ArraySet()
            var newNames = new ArraySet()

            // Find mappings for the "sourceFile"
            this._mappings.unsortedForEach(function(mapping) {
              if (
                mapping.source === sourceFile &&
                mapping.originalLine != null
              ) {
                // Check if it can be mapped by the source map, then update the mapping.
                var original = aSourceMapConsumer.originalPositionFor({
                  line: mapping.originalLine,
                  column: mapping.originalColumn,
                })
                if (original.source != null) {
                  // Copy mapping
                  mapping.source = original.source
                  if (aSourceMapPath != null) {
                    mapping.source = util.join(aSourceMapPath, mapping.source)
                  }
                  if (sourceRoot != null) {
                    mapping.source = util.relative(sourceRoot, mapping.source)
                  }
                  mapping.originalLine = original.line
                  mapping.originalColumn = original.column
                  if (original.name != null) {
                    mapping.name = original.name
                  }
                }
              }

              var source = mapping.source
              if (source != null && !newSources.has(source)) {
                newSources.add(source)
              }

              var name = mapping.name
              if (name != null && !newNames.has(name)) {
                newNames.add(name)
              }
            }, this)
            this._sources = newSources
            this._names = newNames

            // Copy sourcesContents of applied map.
            aSourceMapConsumer.sources.forEach(function(sourceFile) {
              var content = aSourceMapConsumer.sourceContentFor(sourceFile)
              if (content != null) {
                if (aSourceMapPath != null) {
                  sourceFile = util.join(aSourceMapPath, sourceFile)
                }
                if (sourceRoot != null) {
                  sourceFile = util.relative(sourceRoot, sourceFile)
                }
                this.setSourceContent(sourceFile, content)
              }
            }, this)
          }

          /**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */
          SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(
            aGenerated,
            aOriginal,
            aSource,
            aName
          ) {
            if (
              aGenerated &&
              'line' in aGenerated &&
              'column' in aGenerated &&
              aGenerated.line > 0 &&
              aGenerated.column >= 0 &&
              !aOriginal &&
              !aSource &&
              !aName
            ) {
              // Case 1.
              return
            } else if (
              aGenerated &&
              'line' in aGenerated &&
              'column' in aGenerated &&
              aOriginal &&
              'line' in aOriginal &&
              'column' in aOriginal &&
              aGenerated.line > 0 &&
              aGenerated.column >= 0 &&
              aOriginal.line > 0 &&
              aOriginal.column >= 0 &&
              aSource
            ) {
              // Cases 2 and 3.
              return
            } else {
              throw new Error(
                'Invalid mapping: ' +
                  JSON.stringify({
                    generated: aGenerated,
                    source: aSource,
                    original: aOriginal,
                    name: aName,
                  })
              )
            }
          }

          /**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */
          SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
            var previousGeneratedColumn = 0
            var previousGeneratedLine = 1
            var previousOriginalColumn = 0
            var previousOriginalLine = 0
            var previousName = 0
            var previousSource = 0
            var result = ''
            var next
            var mapping
            var nameIdx
            var sourceIdx

            var mappings = this._mappings.toArray()
            for (var i = 0, len = mappings.length; i < len; i++) {
              mapping = mappings[i]
              next = ''

              if (mapping.generatedLine !== previousGeneratedLine) {
                previousGeneratedColumn = 0
                while (mapping.generatedLine !== previousGeneratedLine) {
                  next += ';'
                  previousGeneratedLine++
                }
              } else {
                if (i > 0) {
                  if (
                    !util.compareByGeneratedPositionsInflated(
                      mapping,
                      mappings[i - 1]
                    )
                  ) {
                    continue
                  }
                  next += ','
                }
              }

              next += base64VLQ.encode(
                mapping.generatedColumn - previousGeneratedColumn
              )
              previousGeneratedColumn = mapping.generatedColumn

              if (mapping.source != null) {
                sourceIdx = this._sources.indexOf(mapping.source)
                next += base64VLQ.encode(sourceIdx - previousSource)
                previousSource = sourceIdx

                // lines are stored 0-based in SourceMap spec version 3
                next += base64VLQ.encode(
                  mapping.originalLine - 1 - previousOriginalLine
                )
                previousOriginalLine = mapping.originalLine - 1

                next += base64VLQ.encode(
                  mapping.originalColumn - previousOriginalColumn
                )
                previousOriginalColumn = mapping.originalColumn

                if (mapping.name != null) {
                  nameIdx = this._names.indexOf(mapping.name)
                  next += base64VLQ.encode(nameIdx - previousName)
                  previousName = nameIdx
                }
              }

              result += next
            }

            return result
          }

          SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(
            aSources,
            aSourceRoot
          ) {
            return aSources.map(function(source) {
              if (!this._sourcesContents) {
                return null
              }
              if (aSourceRoot != null) {
                source = util.relative(aSourceRoot, source)
              }
              var key = util.toSetString(source)
              return Object.prototype.hasOwnProperty.call(
                this._sourcesContents,
                key
              )
                ? this._sourcesContents[key]
                : null
            }, this)
          }

          /**
 * Externalize the source map.
 */
          SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
            var map = {
              version: this._version,
              sources: this._sources.toArray(),
              names: this._names.toArray(),
              mappings: this._serializeMappings(),
            }
            if (this._file != null) {
              map.file = this._file
            }
            if (this._sourceRoot != null) {
              map.sourceRoot = this._sourceRoot
            }
            if (this._sourcesContents) {
              map.sourcesContent = this._generateSourcesContent(
                map.sources,
                map.sourceRoot
              )
            }

            return map
          }

          /**
 * Render the source map being generated to a string.
 */
          SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
            return JSON.stringify(this.toJSON())
          }

          exports.SourceMapGenerator = SourceMapGenerator
        },
        {
          './array-set': 516,
          './base64-vlq': 517,
          './mapping-list': 520,
          './util': 525,
        },
      ],
      524: [
        function(require, module, exports) {
          /* -*- Mode: js; js-indent-level: 2; -*- */
          /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

          var SourceMapGenerator = require('./source-map-generator')
            .SourceMapGenerator
          var util = require('./util')

          // Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
          // operating systems these days (capturing the result).
          var REGEX_NEWLINE = /(\r?\n)/

          // Newline character code for charCodeAt() comparisons
          var NEWLINE_CODE = 10

          // Private symbol for identifying `SourceNode`s when multiple versions of
          // the source-map library are loaded. This MUST NOT CHANGE across
          // versions!
          var isSourceNode = '$$$isSourceNode$$$'

          /**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */
          function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
            this.children = []
            this.sourceContents = {}
            this.line = aLine == null ? null : aLine
            this.column = aColumn == null ? null : aColumn
            this.source = aSource == null ? null : aSource
            this.name = aName == null ? null : aName
            this[isSourceNode] = true
            if (aChunks != null) this.add(aChunks)
          }

          /**
 * Creates a SourceNode from generated code and a SourceMapConsumer.
 *
 * @param aGeneratedCode The generated code
 * @param aSourceMapConsumer The SourceMap for the generated code
 * @param aRelativePath Optional. The path that relative sources in the
 *        SourceMapConsumer should be relative to.
 */
          SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(
            aGeneratedCode,
            aSourceMapConsumer,
            aRelativePath
          ) {
            // The SourceNode we want to fill with the generated code
            // and the SourceMap
            var node = new SourceNode()

            // All even indices of this array are one line of the generated code,
            // while all odd indices are the newlines between two adjacent lines
            // (since `REGEX_NEWLINE` captures its match).
            // Processed fragments are removed from this array, by calling `shiftNextLine`.
            var remainingLines = aGeneratedCode.split(REGEX_NEWLINE)
            var shiftNextLine = function() {
              var lineContents = remainingLines.shift()
              // The last line of a file might not have a newline.
              var newLine = remainingLines.shift() || ''
              return lineContents + newLine
            }

            // We need to remember the position of "remainingLines"
            var lastGeneratedLine = 1,
              lastGeneratedColumn = 0

            // The generate SourceNodes we need a code range.
            // To extract it current and last mapping is used.
            // Here we store the last mapping.
            var lastMapping = null

            aSourceMapConsumer.eachMapping(function(mapping) {
              if (lastMapping !== null) {
                // We add the code from "lastMapping" to "mapping":
                // First check if there is a new line in between.
                if (lastGeneratedLine < mapping.generatedLine) {
                  // Associate first line with "lastMapping"
                  addMappingWithCode(lastMapping, shiftNextLine())
                  lastGeneratedLine++
                  lastGeneratedColumn = 0
                  // The remaining code is added without mapping
                } else {
                  // There is no new line in between.
                  // Associate the code between "lastGeneratedColumn" and
                  // "mapping.generatedColumn" with "lastMapping"
                  var nextLine = remainingLines[0]
                  var code = nextLine.substr(
                    0,
                    mapping.generatedColumn - lastGeneratedColumn
                  )
                  remainingLines[0] = nextLine.substr(
                    mapping.generatedColumn - lastGeneratedColumn
                  )
                  lastGeneratedColumn = mapping.generatedColumn
                  addMappingWithCode(lastMapping, code)
                  // No more remaining code, continue
                  lastMapping = mapping
                  return
                }
              }
              // We add the generated code until the first mapping
              // to the SourceNode without any mapping.
              // Each line is added as separate string.
              while (lastGeneratedLine < mapping.generatedLine) {
                node.add(shiftNextLine())
                lastGeneratedLine++
              }
              if (lastGeneratedColumn < mapping.generatedColumn) {
                var nextLine = remainingLines[0]
                node.add(nextLine.substr(0, mapping.generatedColumn))
                remainingLines[0] = nextLine.substr(mapping.generatedColumn)
                lastGeneratedColumn = mapping.generatedColumn
              }
              lastMapping = mapping
            }, this)
            // We have processed all mappings.
            if (remainingLines.length > 0) {
              if (lastMapping) {
                // Associate the remaining code in the current line with "lastMapping"
                addMappingWithCode(lastMapping, shiftNextLine())
              }
              // and add the remaining lines without any mapping
              node.add(remainingLines.join(''))
            }

            // Copy sourcesContent into SourceNode
            aSourceMapConsumer.sources.forEach(function(sourceFile) {
              var content = aSourceMapConsumer.sourceContentFor(sourceFile)
              if (content != null) {
                if (aRelativePath != null) {
                  sourceFile = util.join(aRelativePath, sourceFile)
                }
                node.setSourceContent(sourceFile, content)
              }
            })

            return node

            function addMappingWithCode(mapping, code) {
              if (mapping === null || mapping.source === undefined) {
                node.add(code)
              } else {
                var source = aRelativePath
                  ? util.join(aRelativePath, mapping.source)
                  : mapping.source
                node.add(
                  new SourceNode(
                    mapping.originalLine,
                    mapping.originalColumn,
                    source,
                    code,
                    mapping.name
                  )
                )
              }
            }
          }

          /**
 * Add a chunk of generated JS to this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
          SourceNode.prototype.add = function SourceNode_add(aChunk) {
            if (Array.isArray(aChunk)) {
              aChunk.forEach(function(chunk) {
                this.add(chunk)
              }, this)
            } else if (aChunk[isSourceNode] || typeof aChunk === 'string') {
              if (aChunk) {
                this.children.push(aChunk)
              }
            } else {
              throw new TypeError(
                'Expected a SourceNode, string, or an array of SourceNodes and strings. Got ' +
                  aChunk
              )
            }
            return this
          }

          /**
 * Add a chunk of generated JS to the beginning of this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
          SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
            if (Array.isArray(aChunk)) {
              for (var i = aChunk.length - 1; i >= 0; i--) {
                this.prepend(aChunk[i])
              }
            } else if (aChunk[isSourceNode] || typeof aChunk === 'string') {
              this.children.unshift(aChunk)
            } else {
              throw new TypeError(
                'Expected a SourceNode, string, or an array of SourceNodes and strings. Got ' +
                  aChunk
              )
            }
            return this
          }

          /**
 * Walk over the tree of JS snippets in this node and its children. The
 * walking function is called once for each snippet of JS and is passed that
 * snippet and the its original associated source's line/column location.
 *
 * @param aFn The traversal function.
 */
          SourceNode.prototype.walk = function SourceNode_walk(aFn) {
            var chunk
            for (var i = 0, len = this.children.length; i < len; i++) {
              chunk = this.children[i]
              if (chunk[isSourceNode]) {
                chunk.walk(aFn)
              } else {
                if (chunk !== '') {
                  aFn(chunk, {
                    source: this.source,
                    line: this.line,
                    column: this.column,
                    name: this.name,
                  })
                }
              }
            }
          }

          /**
 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
 * each of `this.children`.
 *
 * @param aSep The separator.
 */
          SourceNode.prototype.join = function SourceNode_join(aSep) {
            var newChildren
            var i
            var len = this.children.length
            if (len > 0) {
              newChildren = []
              for (i = 0; i < len - 1; i++) {
                newChildren.push(this.children[i])
                newChildren.push(aSep)
              }
              newChildren.push(this.children[i])
              this.children = newChildren
            }
            return this
          }

          /**
 * Call String.prototype.replace on the very right-most source snippet. Useful
 * for trimming whitespace from the end of a source node, etc.
 *
 * @param aPattern The pattern to replace.
 * @param aReplacement The thing to replace the pattern with.
 */
          SourceNode.prototype.replaceRight = function SourceNode_replaceRight(
            aPattern,
            aReplacement
          ) {
            var lastChild = this.children[this.children.length - 1]
            if (lastChild[isSourceNode]) {
              lastChild.replaceRight(aPattern, aReplacement)
            } else if (typeof lastChild === 'string') {
              this.children[this.children.length - 1] = lastChild.replace(
                aPattern,
                aReplacement
              )
            } else {
              this.children.push(''.replace(aPattern, aReplacement))
            }
            return this
          }

          /**
 * Set the source content for a source file. This will be added to the SourceMapGenerator
 * in the sourcesContent field.
 *
 * @param aSourceFile The filename of the source file
 * @param aSourceContent The content of the source file
 */
          SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(
            aSourceFile,
            aSourceContent
          ) {
            this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent
          }

          /**
 * Walk over the tree of SourceNodes. The walking function is called for each
 * source file content and is passed the filename and source content.
 *
 * @param aFn The traversal function.
 */
          SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(
            aFn
          ) {
            for (var i = 0, len = this.children.length; i < len; i++) {
              if (this.children[i][isSourceNode]) {
                this.children[i].walkSourceContents(aFn)
              }
            }

            var sources = Object.keys(this.sourceContents)
            for (var i = 0, len = sources.length; i < len; i++) {
              aFn(
                util.fromSetString(sources[i]),
                this.sourceContents[sources[i]]
              )
            }
          }

          /**
 * Return the string representation of this source node. Walks over the tree
 * and concatenates all the various snippets together to one string.
 */
          SourceNode.prototype.toString = function SourceNode_toString() {
            var str = ''
            this.walk(function(chunk) {
              str += chunk
            })
            return str
          }

          /**
 * Returns the string representation of this source node along with a source
 * map.
 */
          SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(
            aArgs
          ) {
            var generated = {
              code: '',
              line: 1,
              column: 0,
            }
            var map = new SourceMapGenerator(aArgs)
            var sourceMappingActive = false
            var lastOriginalSource = null
            var lastOriginalLine = null
            var lastOriginalColumn = null
            var lastOriginalName = null
            this.walk(function(chunk, original) {
              generated.code += chunk
              if (
                original.source !== null &&
                original.line !== null &&
                original.column !== null
              ) {
                if (
                  lastOriginalSource !== original.source ||
                  lastOriginalLine !== original.line ||
                  lastOriginalColumn !== original.column ||
                  lastOriginalName !== original.name
                ) {
                  map.addMapping({
                    source: original.source,
                    original: {
                      line: original.line,
                      column: original.column,
                    },
                    generated: {
                      line: generated.line,
                      column: generated.column,
                    },
                    name: original.name,
                  })
                }
                lastOriginalSource = original.source
                lastOriginalLine = original.line
                lastOriginalColumn = original.column
                lastOriginalName = original.name
                sourceMappingActive = true
              } else if (sourceMappingActive) {
                map.addMapping({
                  generated: {
                    line: generated.line,
                    column: generated.column,
                  },
                })
                lastOriginalSource = null
                sourceMappingActive = false
              }
              for (var idx = 0, length = chunk.length; idx < length; idx++) {
                if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
                  generated.line++
                  generated.column = 0
                  // Mappings end at eol
                  if (idx + 1 === length) {
                    lastOriginalSource = null
                    sourceMappingActive = false
                  } else if (sourceMappingActive) {
                    map.addMapping({
                      source: original.source,
                      original: {
                        line: original.line,
                        column: original.column,
                      },
                      generated: {
                        line: generated.line,
                        column: generated.column,
                      },
                      name: original.name,
                    })
                  }
                } else {
                  generated.column++
                }
              }
            })
            this.walkSourceContents(function(sourceFile, sourceContent) {
              map.setSourceContent(sourceFile, sourceContent)
            })

            return { code: generated.code, map: map }
          }

          exports.SourceNode = SourceNode
        },
        { './source-map-generator': 523, './util': 525 },
      ],
      525: [
        function(require, module, exports) {
          /* -*- Mode: js; js-indent-level: 2; -*- */
          /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

          /**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */
          function getArg(aArgs, aName, aDefaultValue) {
            if (aName in aArgs) {
              return aArgs[aName]
            } else if (arguments.length === 3) {
              return aDefaultValue
            } else {
              throw new Error('"' + aName + '" is a required argument.')
            }
          }
          exports.getArg = getArg

          var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/
          var dataUrlRegexp = /^data:.+\,.+$/

          function urlParse(aUrl) {
            var match = aUrl.match(urlRegexp)
            if (!match) {
              return null
            }
            return {
              scheme: match[1],
              auth: match[2],
              host: match[3],
              port: match[4],
              path: match[5],
            }
          }
          exports.urlParse = urlParse

          function urlGenerate(aParsedUrl) {
            var url = ''
            if (aParsedUrl.scheme) {
              url += aParsedUrl.scheme + ':'
            }
            url += '//'
            if (aParsedUrl.auth) {
              url += aParsedUrl.auth + '@'
            }
            if (aParsedUrl.host) {
              url += aParsedUrl.host
            }
            if (aParsedUrl.port) {
              url += ':' + aParsedUrl.port
            }
            if (aParsedUrl.path) {
              url += aParsedUrl.path
            }
            return url
          }
          exports.urlGenerate = urlGenerate

          /**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */
          function normalize(aPath) {
            var path = aPath
            var url = urlParse(aPath)
            if (url) {
              if (!url.path) {
                return aPath
              }
              path = url.path
            }
            var isAbsolute = exports.isAbsolute(path)

            var parts = path.split(/\/+/)
            for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
              part = parts[i]
              if (part === '.') {
                parts.splice(i, 1)
              } else if (part === '..') {
                up++
              } else if (up > 0) {
                if (part === '') {
                  // The first part is blank if the path is absolute. Trying to go
                  // above the root is a no-op. Therefore we can remove all '..' parts
                  // directly after the root.
                  parts.splice(i + 1, up)
                  up = 0
                } else {
                  parts.splice(i, 2)
                  up--
                }
              }
            }
            path = parts.join('/')

            if (path === '') {
              path = isAbsolute ? '/' : '.'
            }

            if (url) {
              url.path = path
              return urlGenerate(url)
            }
            return path
          }
          exports.normalize = normalize

          /**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */
          function join(aRoot, aPath) {
            if (aRoot === '') {
              aRoot = '.'
            }
            if (aPath === '') {
              aPath = '.'
            }
            var aPathUrl = urlParse(aPath)
            var aRootUrl = urlParse(aRoot)
            if (aRootUrl) {
              aRoot = aRootUrl.path || '/'
            }

            // `join(foo, '//www.example.org')`
            if (aPathUrl && !aPathUrl.scheme) {
              if (aRootUrl) {
                aPathUrl.scheme = aRootUrl.scheme
              }
              return urlGenerate(aPathUrl)
            }

            if (aPathUrl || aPath.match(dataUrlRegexp)) {
              return aPath
            }

            // `join('http://', 'www.example.com')`
            if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
              aRootUrl.host = aPath
              return urlGenerate(aRootUrl)
            }

            var joined = aPath.charAt(0) === '/'
              ? aPath
              : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath)

            if (aRootUrl) {
              aRootUrl.path = joined
              return urlGenerate(aRootUrl)
            }
            return joined
          }
          exports.join = join

          exports.isAbsolute = function(aPath) {
            return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp)
          }

          /**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */
          function relative(aRoot, aPath) {
            if (aRoot === '') {
              aRoot = '.'
            }

            aRoot = aRoot.replace(/\/$/, '')

            // It is possible for the path to be above the root. In this case, simply
            // checking whether the root is a prefix of the path won't work. Instead, we
            // need to remove components from the root one by one, until either we find
            // a prefix that fits, or we run out of components to remove.
            var level = 0
            while (aPath.indexOf(aRoot + '/') !== 0) {
              var index = aRoot.lastIndexOf('/')
              if (index < 0) {
                return aPath
              }

              // If the only part of the root that is left is the scheme (i.e. http://,
              // file:///, etc.), one or more slashes (/), or simply nothing at all, we
              // have exhausted all components, so the path is not relative to the root.
              aRoot = aRoot.slice(0, index)
              if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
                return aPath
              }

              ++level
            }

            // Make sure we add a "../" for each component we removed from the root.
            return Array(level + 1).join('../') + aPath.substr(aRoot.length + 1)
          }
          exports.relative = relative

          var supportsNullProto = (function() {
            var obj = Object.create(null)
            return !('__proto__' in obj)
          })()

          function identity(s) {
            return s
          }

          /**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */
          function toSetString(aStr) {
            if (isProtoString(aStr)) {
              return '$' + aStr
            }

            return aStr
          }
          exports.toSetString = supportsNullProto ? identity : toSetString

          function fromSetString(aStr) {
            if (isProtoString(aStr)) {
              return aStr.slice(1)
            }

            return aStr
          }
          exports.fromSetString = supportsNullProto ? identity : fromSetString

          function isProtoString(s) {
            if (!s) {
              return false
            }

            var length = s.length

            if (length < 9 /* "__proto__".length */) {
              return false
            }

            if (
              s.charCodeAt(length - 1) !== 95 /* '_' */ ||
              s.charCodeAt(length - 2) !== 95 /* '_' */ ||
              s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
              s.charCodeAt(length - 4) !== 116 /* 't' */ ||
              s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
              s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
              s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
              s.charCodeAt(length - 8) !== 95 /* '_' */ ||
              s.charCodeAt(length - 9) !== 95 /* '_' */
            ) {
              return false
            }

            for (var i = length - 10; i >= 0; i--) {
              if (s.charCodeAt(i) !== 36 /* '$' */) {
                return false
              }
            }

            return true
          }

          /**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */
          function compareByOriginalPositions(
            mappingA,
            mappingB,
            onlyCompareOriginal
          ) {
            var cmp = mappingA.source - mappingB.source
            if (cmp !== 0) {
              return cmp
            }

            cmp = mappingA.originalLine - mappingB.originalLine
            if (cmp !== 0) {
              return cmp
            }

            cmp = mappingA.originalColumn - mappingB.originalColumn
            if (cmp !== 0 || onlyCompareOriginal) {
              return cmp
            }

            cmp = mappingA.generatedColumn - mappingB.generatedColumn
            if (cmp !== 0) {
              return cmp
            }

            cmp = mappingA.generatedLine - mappingB.generatedLine
            if (cmp !== 0) {
              return cmp
            }

            return mappingA.name - mappingB.name
          }
          exports.compareByOriginalPositions = compareByOriginalPositions

          /**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */
          function compareByGeneratedPositionsDeflated(
            mappingA,
            mappingB,
            onlyCompareGenerated
          ) {
            var cmp = mappingA.generatedLine - mappingB.generatedLine
            if (cmp !== 0) {
              return cmp
            }

            cmp = mappingA.generatedColumn - mappingB.generatedColumn
            if (cmp !== 0 || onlyCompareGenerated) {
              return cmp
            }

            cmp = mappingA.source - mappingB.source
            if (cmp !== 0) {
              return cmp
            }

            cmp = mappingA.originalLine - mappingB.originalLine
            if (cmp !== 0) {
              return cmp
            }

            cmp = mappingA.originalColumn - mappingB.originalColumn
            if (cmp !== 0) {
              return cmp
            }

            return mappingA.name - mappingB.name
          }
          exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated

          function strcmp(aStr1, aStr2) {
            if (aStr1 === aStr2) {
              return 0
            }

            if (aStr1 > aStr2) {
              return 1
            }

            return -1
          }

          /**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */
          function compareByGeneratedPositionsInflated(mappingA, mappingB) {
            var cmp = mappingA.generatedLine - mappingB.generatedLine
            if (cmp !== 0) {
              return cmp
            }

            cmp = mappingA.generatedColumn - mappingB.generatedColumn
            if (cmp !== 0) {
              return cmp
            }

            cmp = strcmp(mappingA.source, mappingB.source)
            if (cmp !== 0) {
              return cmp
            }

            cmp = mappingA.originalLine - mappingB.originalLine
            if (cmp !== 0) {
              return cmp
            }

            cmp = mappingA.originalColumn - mappingB.originalColumn
            if (cmp !== 0) {
              return cmp
            }

            return strcmp(mappingA.name, mappingB.name)
          }
          exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated
        },
        {},
      ],
      526: [
        function(require, module, exports) {
          /*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
          exports.SourceMapGenerator = require('./lib/source-map-generator').SourceMapGenerator
          exports.SourceMapConsumer = require('./lib/source-map-consumer').SourceMapConsumer
          exports.SourceNode = require('./lib/source-node').SourceNode
        },
        {
          './lib/source-map-consumer': 522,
          './lib/source-map-generator': 523,
          './lib/source-node': 524,
        },
      ],
      527: [
        function(require, module, exports) {
          'use strict'
          var ansiRegex = require('ansi-regex')()

          module.exports = function(str) {
            return typeof str === 'string' ? str.replace(ansiRegex, '') : str
          }
        },
        { 'ansi-regex': 2 },
      ],
      528: [
        function(require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', {
            value: true,
          })

          var _camelizeStyleName = require('fbjs/lib/camelizeStyleName')

          var _camelizeStyleName2 = _interopRequireDefault(_camelizeStyleName)

          var _hyphenateStyleName = require('fbjs/lib/hyphenateStyleName')

          var _hyphenateStyleName2 = _interopRequireDefault(_hyphenateStyleName)

          var _static = require('inline-style-prefixer/static')

          var _static2 = _interopRequireDefault(_static)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true,
              })
            } else {
              obj[key] = value
            }
            return obj
          }

          // eslint-disable-next-line

          var babelPluginFlowReactPropTypes_proptype_Container =
            require('../vendor/postcss/container')
              .babelPluginFlowReactPropTypes_proptype_Container ||
            require('prop-types').any

          exports.default = function(root) {
            root.walkDecls(function(decl) {
              /* No point even checking custom props */
              if (/^--/.test(decl.prop)) return

              var objStyle = _defineProperty(
                {},
                (0, _camelizeStyleName2.default)(decl.prop),
                decl.value
              )
              var prefixed = (0, _static2.default)(objStyle)
              Object.keys(prefixed).reverse().forEach(function(newProp) {
                var newVals = prefixed[newProp]
                var newValArray = Array.isArray(newVals) ? newVals : [newVals]
                newValArray.forEach(function(newVal) {
                  decl.cloneBefore({
                    prop: (0, _hyphenateStyleName2.default)(newProp),
                    value: newVal,
                  })
                })
              })
              decl.remove()
            })
          }

          module.exports = exports['default']
        },
        {
          '../vendor/postcss/container': 534,
          'fbjs/lib/camelizeStyleName': 253,
          'fbjs/lib/hyphenateStyleName': 256,
          'inline-style-prefixer/static': 284,
          'prop-types': 511,
        },
      ],
      529: [
        function(require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', {
            value: true,
          })
          function selectors(parent, node) {
            var result = []
            parent.selectors.forEach(function(i) {
              node.selectors.forEach(function(j) {
                if (j.indexOf('&') === -1) {
                  result.push(i + ' ' + j)
                } else {
                  result.push(j.replace(/&/g, i))
                }
              })
            })
            return result
          }

          function pickComment(comment, after) {
            if (comment && comment.type === 'comment') {
              return comment.moveAfter(after)
            } else {
              return after
            }
          }

          function atruleChilds(rule, atrule) {
            var children = []
            atrule.each(function(child) {
              if (child.type === 'comment') {
                children.push(child)
              }
              if (child.type === 'decl') {
                children.push(child)
              } else if (child.type === 'rule') {
                child.selectors = selectors(rule, child)
              } else if (child.type === 'atrule') {
                atruleChilds(rule, child)
              }
            })
            if (children.length) {
              var clone = rule.clone({ nodes: [] })
              for (var i = 0; i < children.length; i++) {
                children[i].moveTo(clone)
              }
              atrule.prepend(clone)
            }
          }

          function processRule(rule, bubble) {
            var unwrapped = false
            var after = rule
            rule.each(function(child) {
              if (child.type === 'rule') {
                unwrapped = true
                child.selectors = selectors(rule, child)
                after = pickComment(child.prev(), after)
                after = child.moveAfter(after)
              } else if (child.type === 'atrule') {
                if (bubble.indexOf(child.name) !== -1) {
                  unwrapped = true
                  atruleChilds(rule, child)
                  after = pickComment(child.prev(), after)
                  after = child.moveAfter(after)
                }
              }
            })
            if (unwrapped) {
              rule.raws.semicolon = true
              if (rule.nodes.length === 0) rule.remove()
            }
          }

          var bubble = ['media', 'supports', 'document']

          var process = function process(node) {
            node.each(function(child) {
              if (child.type === 'rule') {
                processRule(child, bubble)
              } else if (child.type === 'atrule') {
                process(child)
              }
            })
          }

          exports.default = process
          module.exports = exports['default']
        },
        {},
      ],
      530: [
        function(require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', {
            value: true,
          })
          exports.default = safeParse

          var _input = require('../postcss/input')

          var _input2 = _interopRequireDefault(_input)

          var _safeParser = require('./safe-parser')

          var _safeParser2 = _interopRequireDefault(_safeParser)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          function safeParse(css, opts) {
            var input = new _input2.default(css, opts)

            var parser = new _safeParser2.default(input)
            parser.tokenize()
            parser.loop()

            return parser.root
          }
          module.exports = exports['default']
        },
        { '../postcss/input': 537, './safe-parser': 531 },
      ],
      531: [
        function(require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', {
            value: true,
          })

          var _createClass = (function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i]
                descriptor.enumerable = descriptor.enumerable || false
                descriptor.configurable = true
                if ('value' in descriptor) descriptor.writable = true
                Object.defineProperty(target, descriptor.key, descriptor)
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps)
              if (staticProps) defineProperties(Constructor, staticProps)
              return Constructor
            }
          })()

          var _tokenize2 = require('../postcss/tokenize')

          var _tokenize3 = _interopRequireDefault(_tokenize2)

          var _comment = require('../postcss/comment')

          var _comment2 = _interopRequireDefault(_comment)

          var _parser = require('../postcss/parser')

          var _parser2 = _interopRequireDefault(_parser)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function')
            }
          }

          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError(
                "this hasn't been initialised - super() hasn't been called"
              )
            }
            return call &&
              (typeof call === 'object' || typeof call === 'function')
              ? call
              : self
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== 'function' && superClass !== null) {
              throw new TypeError(
                'Super expression must either be null or a function, not ' +
                  typeof superClass
              )
            }
            subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true,
                },
              }
            )
            if (superClass)
              Object.setPrototypeOf
                ? Object.setPrototypeOf(subClass, superClass)
                : (subClass.__proto__ = superClass)
          }

          var SafeParser = (function(_Parser) {
            _inherits(SafeParser, _Parser)

            function SafeParser() {
              _classCallCheck(this, SafeParser)

              return _possibleConstructorReturn(
                this,
                (SafeParser.__proto__ || Object.getPrototypeOf(SafeParser))
                  .apply(this, arguments)
              )
            }

            _createClass(SafeParser, [
              {
                key: 'tokenize',
                value: function tokenize() {
                  this.tokens = (0, _tokenize3.default)(this.input, {
                    ignoreErrors: true,
                  })
                },
              },
              {
                key: 'comment',
                value: function comment(token) {
                  var node = new _comment2.default()
                  this.init(node, token[2], token[3])
                  node.source.end = { line: token[4], column: token[5] }

                  var text = token[1].slice(2)
                  if (text.slice(-2) === '*/') text = text.slice(0, -2)

                  if (/^\s*$/.test(text)) {
                    node.text = ''
                    node.raws.left = text
                    node.raws.right = ''
                  } else {
                    var match = text.match(/^(\s*)([^]*[^\s])(\s*)$/)
                    node.text = match[2]
                    node.raws.left = match[1]
                    node.raws.right = match[3]
                  }
                },
              },
              {
                key: 'unclosedBracket',
                value: function unclosedBracket() {},
              },
              {
                key: 'unknownWord',
                value: function unknownWord(start) {
                  var buffer = this.tokens.slice(start, this.pos + 1)
                  this.spaces += buffer
                    .map(function(i) {
                      return i[1]
                    })
                    .join('')
                },
              },
              {
                key: 'unexpectedClose',
                value: function unexpectedClose() {
                  this.current.raws.after += '}'
                },
              },
              {
                key: 'doubleColon',
                value: function doubleColon() {},
              },
              {
                key: 'unnamedAtrule',
                value: function unnamedAtrule(node) {
                  node.name = ''
                },
              },
              {
                key: 'precheckMissedSemicolon',
                value: function precheckMissedSemicolon(tokens) {
                  var colon = this.colon(tokens)
                  if (colon === false) return

                  var split = void 0
                  for (split = colon - 1; split >= 0; split--) {
                    if (tokens[split][0] === 'word') break
                  }
                  for (split -= 1; split >= 0; split--) {
                    if (tokens[split][0] !== 'space') {
                      split += 1
                      break
                    }
                  }
                  var other = tokens.splice(split, tokens.length - split)
                  this.decl(other)
                },
              },
              {
                key: 'checkMissedSemicolon',
                value: function checkMissedSemicolon() {},
              },
              {
                key: 'endFile',
                value: function endFile() {
                  if (this.current.nodes && this.current.nodes.length) {
                    this.current.raws.semicolon = this.semicolon
                  }
                  this.current.raws.after =
                    (this.current.raws.after || '') + this.spaces

                  while (this.current.parent) {
                    this.current = this.current.parent
                    this.current.raws.after = ''
                  }
                },
              },
            ])

            return SafeParser
          })(_parser2.default)

          exports.default = SafeParser
          module.exports = exports['default']
        },
        {
          '../postcss/comment': 533,
          '../postcss/parser': 542,
          '../postcss/tokenize': 550,
        },
      ],
      532: [
        function(require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', {
            value: true,
          })

          var _createClass = (function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i]
                descriptor.enumerable = descriptor.enumerable || false
                descriptor.configurable = true
                if ('value' in descriptor) descriptor.writable = true
                Object.defineProperty(target, descriptor.key, descriptor)
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps)
              if (staticProps) defineProperties(Constructor, staticProps)
              return Constructor
            }
          })()

          var _get = function get(object, property, receiver) {
            if (object === null) object = Function.prototype
            var desc = Object.getOwnPropertyDescriptor(object, property)
            if (desc === undefined) {
              var parent = Object.getPrototypeOf(object)
              if (parent === null) {
                return undefined
              } else {
                return get(parent, property, receiver)
              }
            } else if ('value' in desc) {
              return desc.value
            } else {
              var getter = desc.get
              if (getter === undefined) {
                return undefined
              }
              return getter.call(receiver)
            }
          }

          var _container = require('./container')

          var _container2 = _interopRequireDefault(_container)

          var _warnOnce = require('./warn-once')

          var _warnOnce2 = _interopRequireDefault(_warnOnce)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function')
            }
          }

          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError(
                "this hasn't been initialised - super() hasn't been called"
              )
            }
            return call &&
              (typeof call === 'object' || typeof call === 'function')
              ? call
              : self
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== 'function' && superClass !== null) {
              throw new TypeError(
                'Super expression must either be null or a function, not ' +
                  typeof superClass
              )
            }
            subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true,
                },
              }
            )
            if (superClass)
              Object.setPrototypeOf
                ? Object.setPrototypeOf(subClass, superClass)
                : (subClass.__proto__ = superClass)
          }

          /**
 * Represents an at-rule.
 *
 * If its followed in the CSS by a {} block, this node will have
 * a nodes property representing its children.
 *
 * @extends Container
 *
 * @example
 * const root = postcss.parse('@charset "UTF-8"; @media print {}');
 *
 * const charset = root.first;
 * charset.type  //=> 'atrule'
 * charset.nodes //=> undefined
 *
 * const media = root.last;
 * media.nodes   //=> []
 */
          var AtRule = (function(_Container) {
            _inherits(AtRule, _Container)

            function AtRule(defaults) {
              _classCallCheck(this, AtRule)

              var _this = _possibleConstructorReturn(
                this,
                (AtRule.__proto__ || Object.getPrototypeOf(AtRule))
                  .call(this, defaults)
              )

              _this.type = 'atrule'
              return _this
            }

            _createClass(AtRule, [
              {
                key: 'append',
                value: function append() {
                  var _get2

                  if (!this.nodes) this.nodes = []

                  for (
                    var _len = arguments.length,
                      children = Array(_len),
                      _key = 0;
                    _key < _len;
                    _key++
                  ) {
                    children[_key] = arguments[_key]
                  }

                  return (_get2 = _get(
                    AtRule.prototype.__proto__ ||
                      Object.getPrototypeOf(AtRule.prototype),
                    'append',
                    this
                  )).call.apply(_get2, [this].concat(children))
                },
              },
              {
                key: 'prepend',
                value: function prepend() {
                  var _get3

                  if (!this.nodes) this.nodes = []

                  for (
                    var _len2 = arguments.length,
                      children = Array(_len2),
                      _key2 = 0;
                    _key2 < _len2;
                    _key2++
                  ) {
                    children[_key2] = arguments[_key2]
                  }

                  return (_get3 = _get(
                    AtRule.prototype.__proto__ ||
                      Object.getPrototypeOf(AtRule.prototype),
                    'prepend',
                    this
                  )).call.apply(_get3, [this].concat(children))
                },
              },
              {
                key: 'afterName',
                get: function get() {
                  ;(0, _warnOnce2.default)(
                    'AtRule#afterName was deprecated. Use AtRule#raws.afterName'
                  )
                  return this.raws.afterName
                },
                set: function set(val) {
                  ;(0, _warnOnce2.default)(
                    'AtRule#afterName was deprecated. Use AtRule#raws.afterName'
                  )
                  this.raws.afterName = val
                },
              },
              {
                key: '_params',
                get: function get() {
                  ;(0, _warnOnce2.default)(
                    'AtRule#_params was deprecated. Use AtRule#raws.params'
                  )
                  return this.raws.params
                },
                set: function set(val) {
                  ;(0, _warnOnce2.default)(
                    'AtRule#_params was deprecated. Use AtRule#raws.params'
                  )
                  this.raws.params = val
                },

                /**
         * @memberof AtRule#
         * @member {string} name - the at-rules name immediately follows the `@`
         *
         * @example
         * const root  = postcss.parse('@media print {}');
         * media.name //=> 'media'
         * const media = root.first;
         */

                /**
         * @memberof AtRule#
         * @member {string} params - the at-rules parameters, the values
         *                           that follow the at-rules name but precede
         *                           any {} block
         *
         * @example
         * const root  = postcss.parse('@media print, screen {}');
         * const media = root.first;
         * media.params //=> 'print, screen'
         */

                /**
         * @memberof AtRule#
         * @member {object} raws - Information to generate byte-to-byte equal
         *                         node string as it was in the origin input.
         *
         * Every parser saves its own properties,
         * but the default CSS parser uses:
         *
         * * `before`: the space symbols before the node. It also stores `*`
         *   and `_` symbols before the declaration (IE hack).
         * * `after`: the space symbols after the last child of the node
         *   to the end of the node.
         * * `between`: the symbols between the property and value
         *   for declarations, selector and `{` for rules, or last parameter
         *   and `{` for at-rules.
         * * `semicolon`: contains true if the last child has
         *   an (optional) semicolon.
         * * `afterName`: the space between the at-rule name and its parameters.
         *
         * PostCSS cleans at-rule parameters from comments and extra spaces,
         * but it stores origin content in raws properties.
         * As such, if you dont change a declarations value,
         * PostCSS will use the raw value with comments.
         *
         * @example
         * const root = postcss.parse('  @media\nprint {\n}')
         * root.first.first.raws //=> { before: '  ',
         *                       //     between: ' ',
         *                       //     afterName: '\n',
         *                       //     after: '\n' }
         */
              },
            ])

            return AtRule
          })(_container2.default)

          exports.default = AtRule
          module.exports = exports['default']
        },
        { './container': 534, './warn-once': 551 },
      ],
      533: [
        function(require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', {
            value: true,
          })

          var _createClass = (function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i]
                descriptor.enumerable = descriptor.enumerable || false
                descriptor.configurable = true
                if ('value' in descriptor) descriptor.writable = true
                Object.defineProperty(target, descriptor.key, descriptor)
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps)
              if (staticProps) defineProperties(Constructor, staticProps)
              return Constructor
            }
          })()

          var _warnOnce = require('./warn-once')

          var _warnOnce2 = _interopRequireDefault(_warnOnce)

          var _node = require('./node')

          var _node2 = _interopRequireDefault(_node)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function')
            }
          }

          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError(
                "this hasn't been initialised - super() hasn't been called"
              )
            }
            return call &&
              (typeof call === 'object' || typeof call === 'function')
              ? call
              : self
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== 'function' && superClass !== null) {
              throw new TypeError(
                'Super expression must either be null or a function, not ' +
                  typeof superClass
              )
            }
            subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true,
                },
              }
            )
            if (superClass)
              Object.setPrototypeOf
                ? Object.setPrototypeOf(subClass, superClass)
                : (subClass.__proto__ = superClass)
          }

          /**
 * Represents a comment between declarations or statements (rule and at-rules).
 *
 * Comments inside selectors, at-rule parameters, or declaration values
 * will be stored in the `raws` properties explained above.
 *
 * @extends Node
 */
          var Comment = (function(_Node) {
            _inherits(Comment, _Node)

            function Comment(defaults) {
              _classCallCheck(this, Comment)

              var _this = _possibleConstructorReturn(
                this,
                (Comment.__proto__ || Object.getPrototypeOf(Comment))
                  .call(this, defaults)
              )

              _this.type = 'comment'
              return _this
            }

            _createClass(Comment, [
              {
                key: 'left',
                get: function get() {
                  ;(0, _warnOnce2.default)(
                    'Comment#left was deprecated. Use Comment#raws.left'
                  )
                  return this.raws.left
                },
                set: function set(val) {
                  ;(0, _warnOnce2.default)(
                    'Comment#left was deprecated. Use Comment#raws.left'
                  )
                  this.raws.left = val
                },
              },
              {
                key: 'right',
                get: function get() {
                  ;(0, _warnOnce2.default)(
                    'Comment#right was deprecated. Use Comment#raws.right'
                  )
                  return this.raws.right
                },
                set: function set(val) {
                  ;(0, _warnOnce2.default)(
                    'Comment#right was deprecated. Use Comment#raws.right'
                  )
                  this.raws.right = val
                },

                /**
         * @memberof Comment#
         * @member {string} text - the comments text
         */

                /**
         * @memberof Comment#
         * @member {object} raws - Information to generate byte-to-byte equal
         *                         node string as it was in the origin input.
         *
         * Every parser saves its own properties,
         * but the default CSS parser uses:
         *
         * * `before`: the space symbols before the node.
         * * `left`: the space symbols between `/*` and the comments text.
         * * `right`: the space symbols between the comments text.
         */
              },
            ])

            return Comment
          })(_node2.default)

          exports.default = Comment
          module.exports = exports['default']
        },
        { './node': 540, './warn-once': 551 },
      ],
      534: [
        function(require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', {
            value: true,
          })

          var _createClass = (function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i]
                descriptor.enumerable = descriptor.enumerable || false
                descriptor.configurable = true
                if ('value' in descriptor) descriptor.writable = true
                Object.defineProperty(target, descriptor.key, descriptor)
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps)
              if (staticProps) defineProperties(Constructor, staticProps)
              return Constructor
            }
          })()

          var _get = function get(object, property, receiver) {
            if (object === null) object = Function.prototype
            var desc = Object.getOwnPropertyDescriptor(object, property)
            if (desc === undefined) {
              var parent = Object.getPrototypeOf(object)
              if (parent === null) {
                return undefined
              } else {
                return get(parent, property, receiver)
              }
            } else if ('value' in desc) {
              return desc.value
            } else {
              var getter = desc.get
              if (getter === undefined) {
                return undefined
              }
              return getter.call(receiver)
            }
          }

          var _parse = require('./parse')

          var _parse2 = _interopRequireDefault(_parse)

          var _root = require('./root')

          var _root2 = _interopRequireDefault(_root)

          var _rule = require('./rule')

          var _rule2 = _interopRequireDefault(_rule)

          var _atRule = require('./at-rule')

          var _atRule2 = _interopRequireDefault(_atRule)

          var _declaration = require('./declaration')

          var _declaration2 = _interopRequireDefault(_declaration)

          var _warnOnce = require('./warn-once')

          var _warnOnce2 = _interopRequireDefault(_warnOnce)

          var _comment = require('./comment')

          var _comment2 = _interopRequireDefault(_comment)

          var _node = require('./node')

          var _node2 = _interopRequireDefault(_node)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function')
            }
          }

          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError(
                "this hasn't been initialised - super() hasn't been called"
              )
            }
            return call &&
              (typeof call === 'object' || typeof call === 'function')
              ? call
              : self
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== 'function' && superClass !== null) {
              throw new TypeError(
                'Super expression must either be null or a function, not ' +
                  typeof superClass
              )
            }
            subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true,
                },
              }
            )
            if (superClass)
              Object.setPrototypeOf
                ? Object.setPrototypeOf(subClass, superClass)
                : (subClass.__proto__ = superClass)
          }

          function cleanSource(nodes) {
            return nodes.map(function(i) {
              if (i.nodes) i.nodes = cleanSource(i.nodes)
              delete i.source
              return i
            })
          }

          /**
 * @callback childCondition
 * @param {Node} node    - container child
 * @param {number} index - child index
 * @param {Node[]} nodes - all container children
 * @return {boolean}
 */

          /**
 * @callback childIterator
 * @param {Node} node    - container child
 * @param {number} index - child index
 * @return {false|undefined} returning `false` will break iteration
 */

          /**
 * The {@link Root}, {@link AtRule}, and {@link Rule} container nodes
 * inherit some common methods to help work with their children.
 *
 * Note that all containers can store any content. If you write a rule inside
 * a rule, PostCSS will parse it.
 *
 * @extends Node
 * @abstract
 */

          var Container = (function(_Node) {
            _inherits(Container, _Node)

            function Container() {
              _classCallCheck(this, Container)

              return _possibleConstructorReturn(
                this,
                (Container.__proto__ || Object.getPrototypeOf(Container))
                  .apply(this, arguments)
              )
            }

            _createClass(Container, [
              {
                key: 'push',
                value: function push(child) {
                  child.parent = this
                  this.nodes.push(child)
                  return this
                },

                /**
         * Iterates through the containers immediate children,
         * calling `callback` for each child.
         *
         * Returning `false` in the callback will break iteration.
         *
         * This method only iterates through the containers immediate children.
         * If you need to recursively iterate through all the containers descendant
         * nodes, use {@link Container#walk}.
         *
         * Unlike the for `{}`-cycle or `Array#forEach` this iterator is safe
         * if you are mutating the array of child nodes during iteration.
         * PostCSS will adjust the current index to match the mutations.
         *
         * @param {childIterator} callback - iterator receives each node and index
         *
         * @return {false|undefined} returns `false` if iteration was broke
         *
         * @example
         * const root = postcss.parse('a { color: black; z-index: 1 }');
         * const rule = root.first;
         *
         * for ( let decl of rule.nodes ) {
         *     decl.cloneBefore({ prop: '-webkit-' + decl.prop });
         *     // Cycle will be infinite, because cloneBefore moves the current node
         *     // to the next index
         * }
         *
         * rule.each(decl => {
         *     decl.cloneBefore({ prop: '-webkit-' + decl.prop });
         *     // Will be executed only for color and z-index
         * });
         */
              },
              {
                key: 'each',
                value: function each(callback) {
                  if (!this.lastEach) this.lastEach = 0
                  if (!this.indexes) this.indexes = {}

                  this.lastEach += 1
                  var id = this.lastEach
                  this.indexes[id] = 0

                  if (!this.nodes) return undefined

                  var index = void 0,
                    result = void 0
                  while (this.indexes[id] < this.nodes.length) {
                    index = this.indexes[id]
                    result = callback(this.nodes[index], index)
                    if (result === false) break

                    this.indexes[id] += 1
                  }

                  delete this.indexes[id]

                  return result
                },

                /**
         * Traverses the containers descendant nodes, calling callback
         * for each node.
         *
         * Like container.each(), this method is safe to use
         * if you are mutating arrays during iteration.
         *
         * If you only need to iterate through the containers immediate children,
         * use {@link Container#each}.
         *
         * @param {childIterator} callback - iterator receives each node and index
         *
         * @return {false|undefined} returns `false` if iteration was broke
         *
         * @example
         * root.walk(node => {
         *   // Traverses all descendant nodes.
         * });
         */
              },
              {
                key: 'walk',
                value: function walk(callback) {
                  return this.each(function(child, i) {
                    var result = callback(child, i)
                    if (result !== false && child.walk) {
                      result = child.walk(callback)
                    }
                    return result
                  })
                },

                /**
         * Traverses the containers descendant nodes, calling callback
         * for each declaration node.
         *
         * If you pass a filter, iteration will only happen over declarations
         * with matching properties.
         *
         * Like {@link Container#each}, this method is safe
         * to use if you are mutating arrays during iteration.
         *
         * @param {string|RegExp} [prop]   - string or regular expression
         *                                   to filter declarations by property name
         * @param {childIterator} callback - iterator receives each node and index
         *
         * @return {false|undefined} returns `false` if iteration was broke
         *
         * @example
         * root.walkDecls(decl => {
         *   checkPropertySupport(decl.prop);
         * });
         *
         * root.walkDecls('border-radius', decl => {
         *   decl.remove();
         * });
         *
         * root.walkDecls(/^background/, decl => {
         *   decl.value = takeFirstColorFromGradient(decl.value);
         * });
         */
              },
              {
                key: 'walkDecls',
                value: function walkDecls(prop, callback) {
                  if (!callback) {
                    callback = prop
                    return this.walk(function(child, i) {
                      if (child.type === 'decl') {
                        return callback(child, i)
                      }
                    })
                  } else if (prop instanceof RegExp) {
                    return this.walk(function(child, i) {
                      if (child.type === 'decl' && prop.test(child.prop)) {
                        return callback(child, i)
                      }
                    })
                  } else {
                    return this.walk(function(child, i) {
                      if (child.type === 'decl' && child.prop === prop) {
                        return callback(child, i)
                      }
                    })
                  }
                },

                /**
         * Traverses the containers descendant nodes, calling callback
         * for each rule node.
         *
         * If you pass a filter, iteration will only happen over rules
         * with matching selectors.
         *
         * Like {@link Container#each}, this method is safe
         * to use if you are mutating arrays during iteration.
         *
         * @param {string|RegExp} [selector] - string or regular expression
         *                                     to filter rules by selector
         * @param {childIterator} callback   - iterator receives each node and index
         *
         * @return {false|undefined} returns `false` if iteration was broke
         *
         * @example
         * const selectors = [];
         * root.walkRules(rule => {
         *   selectors.push(rule.selector);
         * });
         * console.log(`Your CSS uses ${selectors.length} selectors`);
         */
              },
              {
                key: 'walkRules',
                value: function walkRules(selector, callback) {
                  if (!callback) {
                    callback = selector

                    return this.walk(function(child, i) {
                      if (child.type === 'rule') {
                        return callback(child, i)
                      }
                    })
                  } else if (selector instanceof RegExp) {
                    return this.walk(function(child, i) {
                      if (
                        child.type === 'rule' &&
                        selector.test(child.selector)
                      ) {
                        return callback(child, i)
                      }
                    })
                  } else {
                    return this.walk(function(child, i) {
                      if (
                        child.type === 'rule' &&
                        child.selector === selector
                      ) {
                        return callback(child, i)
                      }
                    })
                  }
                },

                /**
         * Traverses the containers descendant nodes, calling callback
         * for each at-rule node.
         *
         * If you pass a filter, iteration will only happen over at-rules
         * that have matching names.
         *
         * Like {@link Container#each}, this method is safe
         * to use if you are mutating arrays during iteration.
         *
         * @param {string|RegExp} [name]   - string or regular expression
         *                                   to filter at-rules by name
         * @param {childIterator} callback - iterator receives each node and index
         *
         * @return {false|undefined} returns `false` if iteration was broke
         *
         * @example
         * root.walkAtRules(rule => {
         *   if ( isOld(rule.name) ) rule.remove();
         * });
         *
         * let first = false;
         * root.walkAtRules('charset', rule => {
         *   if ( !first ) {
         *     first = true;
         *   } else {
         *     rule.remove();
         *   }
         * });
         */
              },
              {
                key: 'walkAtRules',
                value: function walkAtRules(name, callback) {
                  if (!callback) {
                    callback = name
                    return this.walk(function(child, i) {
                      if (child.type === 'atrule') {
                        return callback(child, i)
                      }
                    })
                  } else if (name instanceof RegExp) {
                    return this.walk(function(child, i) {
                      if (child.type === 'atrule' && name.test(child.name)) {
                        return callback(child, i)
                      }
                    })
                  } else {
                    return this.walk(function(child, i) {
                      if (child.type === 'atrule' && child.name === name) {
                        return callback(child, i)
                      }
                    })
                  }
                },

                /**
         * Traverses the containers descendant nodes, calling callback
         * for each comment node.
         *
         * Like {@link Container#each}, this method is safe
         * to use if you are mutating arrays during iteration.
         *
         * @param {childIterator} callback - iterator receives each node and index
         *
         * @return {false|undefined} returns `false` if iteration was broke
         *
         * @example
         * root.walkComments(comment => {
         *   comment.remove();
         * });
         */
              },
              {
                key: 'walkComments',
                value: function walkComments(callback) {
                  return this.walk(function(child, i) {
                    if (child.type === 'comment') {
                      return callback(child, i)
                    }
                  })
                },

                /**
         * Inserts new nodes to the start of the container.
         *
         * @param {...(Node|object|string|Node[])} children - new nodes
         *
         * @return {Node} this node for methods chain
         *
         * @example
         * const decl1 = postcss.decl({ prop: 'color', value: 'black' });
         * const decl2 = postcss.decl({ prop: 'background-color', value: 'white' });
         * rule.append(decl1, decl2);
         *
         * root.append({ name: 'charset', params: '"UTF-8"' });  // at-rule
         * root.append({ selector: 'a' });                       // rule
         * rule.append({ prop: 'color', value: 'black' });       // declaration
         * rule.append({ text: 'Comment' })                      // comment
         *
         * root.append('a {}');
         * root.first.append('color: black; z-index: 1');
         */
              },
              {
                key: 'append',
                value: function append() {
                  var _this2 = this

                  for (
                    var _len = arguments.length,
                      children = Array(_len),
                      _key = 0;
                    _key < _len;
                    _key++
                  ) {
                    children[_key] = arguments[_key]
                  }

                  children.forEach(function(child) {
                    var nodes = _this2.normalize(child, _this2.last)
                    nodes.forEach(function(node) {
                      return _this2.nodes.push(node)
                    })
                  })
                  return this
                },

                /**
         * Inserts new nodes to the end of the container.
         *
         * @param {...(Node|object|string|Node[])} children - new nodes
         *
         * @return {Node} this node for methods chain
         *
         * @example
         * const decl1 = postcss.decl({ prop: 'color', value: 'black' });
         * const decl2 = postcss.decl({ prop: 'background-color', value: 'white' });
         * rule.prepend(decl1, decl2);
         *
         * root.append({ name: 'charset', params: '"UTF-8"' });  // at-rule
         * root.append({ selector: 'a' });                       // rule
         * rule.append({ prop: 'color', value: 'black' });       // declaration
         * rule.append({ text: 'Comment' })                      // comment
         *
         * root.append('a {}');
         * root.first.append('color: black; z-index: 1');
         */
              },
              {
                key: 'prepend',
                value: function prepend() {
                  var _this3 = this

                  for (
                    var _len2 = arguments.length,
                      children = Array(_len2),
                      _key2 = 0;
                    _key2 < _len2;
                    _key2++
                  ) {
                    children[_key2] = arguments[_key2]
                  }

                  children = children.reverse()
                  children.forEach(function(child) {
                    var nodes = _this3
                      .normalize(child, _this3.first, 'prepend')
                      .reverse()
                    nodes.forEach(function(node) {
                      return _this3.nodes.unshift(node)
                    })
                    for (var id in _this3.indexes) {
                      _this3.indexes[id] = _this3.indexes[id] + nodes.length
                    }
                  })
                  return this
                },
              },
              {
                key: 'cleanRaws',
                value: function cleanRaws(keepBetween) {
                  _get(
                    Container.prototype.__proto__ ||
                      Object.getPrototypeOf(Container.prototype),
                    'cleanRaws',
                    this
                  ).call(this, keepBetween)
                  if (this.nodes) {
                    this.nodes.forEach(function(node) {
                      return node.cleanRaws(keepBetween)
                    })
                  }
                },

                /**
         * Insert new node before old node within the container.
         *
         * @param {Node|number} exist             - child or childs index.
         * @param {Node|object|string|Node[]} add - new node
         *
         * @return {Node} this node for methods chain
         *
         * @example
         * rule.insertBefore(decl, decl.clone({ prop: '-webkit-' + decl.prop }));
         */
              },
              {
                key: 'insertBefore',
                value: function insertBefore(exist, add) {
                  var _this4 = this

                  exist = this.index(exist)

                  var type = exist === 0 ? 'prepend' : false
                  var nodes = this.normalize(
                    add,
                    this.nodes[exist],
                    type
                  ).reverse()
                  nodes.forEach(function(node) {
                    return _this4.nodes.splice(exist, 0, node)
                  })

                  var index = void 0
                  for (var id in this.indexes) {
                    index = this.indexes[id]
                    if (exist <= index) {
                      this.indexes[id] = index + nodes.length
                    }
                  }

                  return this
                },

                /**
         * Insert new node after old node within the container.
         *
         * @param {Node|number} exist             - child or childs index
         * @param {Node|object|string|Node[]} add - new node
         *
         * @return {Node} this node for methods chain
         */
              },
              {
                key: 'insertAfter',
                value: function insertAfter(exist, add) {
                  var _this5 = this

                  exist = this.index(exist)

                  var nodes = this.normalize(add, this.nodes[exist]).reverse()
                  nodes.forEach(function(node) {
                    return _this5.nodes.splice(exist + 1, 0, node)
                  })

                  var index = void 0
                  for (var id in this.indexes) {
                    index = this.indexes[id]
                    if (exist < index) {
                      this.indexes[id] = index + nodes.length
                    }
                  }

                  return this
                },
              },
              {
                key: 'remove',
                value: function remove(child) {
                  if (typeof child !== 'undefined') {
                    ;(0, _warnOnce2.default)(
                      'Container#remove is deprecated. ' +
                        'Use Container#removeChild'
                    )
                    this.removeChild(child)
                  } else {
                    _get(
                      Container.prototype.__proto__ ||
                        Object.getPrototypeOf(Container.prototype),
                      'remove',
                      this
                    ).call(this)
                  }
                  return this
                },

                /**
         * Removes node from the container and cleans the parent properties
         * from the node and its children.
         *
         * @param {Node|number} child - child or childs index
         *
         * @return {Node} this node for methods chain
         *
         * @example
         * rule.nodes.length  //=> 5
         * rule.removeChild(decl);
         * rule.nodes.length  //=> 4
         * decl.parent        //=> undefined
         */
              },
              {
                key: 'removeChild',
                value: function removeChild(child) {
                  child = this.index(child)
                  this.nodes[child].parent = undefined
                  this.nodes.splice(child, 1)

                  var index = void 0
                  for (var id in this.indexes) {
                    index = this.indexes[id]
                    if (index >= child) {
                      this.indexes[id] = index - 1
                    }
                  }

                  return this
                },

                /**
         * Removes all children from the container
         * and cleans their parent properties.
         *
         * @return {Node} this node for methods chain
         *
         * @example
         * rule.removeAll();
         * rule.nodes.length //=> 0
         */
              },
              {
                key: 'removeAll',
                value: function removeAll() {
                  this.nodes.forEach(function(node) {
                    return (node.parent = undefined)
                  })
                  this.nodes = []
                  return this
                },

                /**
         * Passes all declaration values within the container that match pattern
         * through callback, replacing those values with the returned result
         * of callback.
         *
         * This method is useful if you are using a custom unit or function
         * and need to iterate through all values.
         *
         * @param {string|RegExp} pattern      - replace pattern
         * @param {object} opts                - options to speed up the search
         * @param {string|string[]} opts.props - an array of property names
         * @param {string} opts.fast           - string thats used
         *                                       to narrow down values and speed up
                                                 the regexp search
         * @param {function|string} callback   - string to replace pattern
         *                                       or callback that returns a new
         *                                       value.
         *                                       The callback will receive
         *                                       the same arguments as those
         *                                       passed to a function parameter
         *                                       of `String#replace`.
         *
         * @return {Node} this node for methods chain
         *
         * @example
         * root.replaceValues(/\d+rem/, { fast: 'rem' }, string => {
         *   return 15 * parseInt(string) + 'px';
         * });
         */
              },
              {
                key: 'replaceValues',
                value: function replaceValues(pattern, opts, callback) {
                  if (!callback) {
                    callback = opts
                    opts = {}
                  }

                  this.walkDecls(function(decl) {
                    if (opts.props && opts.props.indexOf(decl.prop) === -1)
                      return
                    if (opts.fast && decl.value.indexOf(opts.fast) === -1)
                      return

                    decl.value = decl.value.replace(pattern, callback)
                  })

                  return this
                },

                /**
         * Returns `true` if callback returns `true`
         * for all of the containers children.
         *
         * @param {childCondition} condition - iterator returns true or false.
         *
         * @return {boolean} is every child pass condition
         *
         * @example
         * const noPrefixes = rule.every(i => i.prop[0] !== '-');
         */
              },
              {
                key: 'every',
                value: function every(condition) {
                  return this.nodes.every(condition)
                },

                /**
         * Returns `true` if callback returns `true` for (at least) one
         * of the containers children.
         *
         * @param {childCondition} condition - iterator returns true or false.
         *
         * @return {boolean} is some child pass condition
         *
         * @example
         * const hasPrefix = rule.some(i => i.prop[0] === '-');
         */
              },
              {
                key: 'some',
                value: function some(condition) {
                  return this.nodes.some(condition)
                },

                /**
         * Returns a `child`s index within the {@link Container#nodes} array.
         *
         * @param {Node} child - child of the current container.
         *
         * @return {number} child index
         *
         * @example
         * rule.index( rule.nodes[2] ) //=> 2
         */
              },
              {
                key: 'index',
                value: function index(child) {
                  if (typeof child === 'number') {
                    return child
                  } else {
                    return this.nodes.indexOf(child)
                  }
                },

                /**
         * The containers first child.
         *
         * @type {Node}
         *
         * @example
         * rule.first == rules.nodes[0];
         */
              },
              {
                key: 'normalize',
                value: function normalize(nodes, sample) {
                  var _this6 = this

                  if (typeof nodes === 'string') {
                    nodes = cleanSource((0, _parse2.default)(nodes).nodes)
                  } else if (!Array.isArray(nodes)) {
                    if (nodes.type === 'root') {
                      nodes = nodes.nodes
                    } else if (nodes.type) {
                      nodes = [nodes]
                    } else if (nodes.prop) {
                      if (typeof nodes.value === 'undefined') {
                        throw new Error(
                          'Value field is missed in node creation'
                        )
                      } else if (typeof nodes.value !== 'string') {
                        nodes.value = String(nodes.value)
                      }
                      nodes = [new _declaration2.default(nodes)]
                    } else if (nodes.selector) {
                      nodes = [new _rule2.default(nodes)]
                    } else if (nodes.name) {
                      nodes = [new _atRule2.default(nodes)]
                    } else if (nodes.text) {
                      nodes = [new _comment2.default(nodes)]
                    } else {
                      throw new Error('Unknown node type in node creation')
                    }
                  }

                  var processed = nodes.map(function(i) {
                    if (typeof i.raws === 'undefined') i = _this6.rebuild(i)

                    if (i.parent) i = i.clone()
                    if (typeof i.raws.before === 'undefined') {
                      if (sample && typeof sample.raws.before !== 'undefined') {
                        i.raws.before = sample.raws.before.replace(/[^\s]/g, '')
                      }
                    }
                    i.parent = _this6
                    return i
                  })

                  return processed
                },
              },
              {
                key: 'rebuild',
                value: function rebuild(node, parent) {
                  var _this7 = this

                  var fix = void 0
                  if (node.type === 'root') {
                    fix = new _root2.default()
                  } else if (node.type === 'atrule') {
                    fix = new _atRule2.default()
                  } else if (node.type === 'rule') {
                    fix = new _rule2.default()
                  } else if (node.type === 'decl') {
                    fix = new _declaration2.default()
                  } else if (node.type === 'comment') {
                    fix = new _comment2.default()
                  }

                  for (var i in node) {
                    if (i === 'nodes') {
                      fix.nodes = node.nodes.map(function(j) {
                        return _this7.rebuild(j, fix)
                      })
                    } else if (i === 'parent' && parent) {
                      fix.parent = parent
                    } else if (node.hasOwnProperty(i)) {
                      fix[i] = node[i]
                    }
                  }

                  return fix
                },
              },
              {
                key: 'eachInside',
                value: function eachInside(callback) {
                  ;(0, _warnOnce2.default)(
                    'Container#eachInside is deprecated. ' +
                      'Use Container#walk instead.'
                  )
                  return this.walk(callback)
                },
              },
              {
                key: 'eachDecl',
                value: function eachDecl(prop, callback) {
                  ;(0, _warnOnce2.default)(
                    'Container#eachDecl is deprecated. ' +
                      'Use Container#walkDecls instead.'
                  )
                  return this.walkDecls(prop, callback)
                },
              },
              {
                key: 'eachRule',
                value: function eachRule(selector, callback) {
                  ;(0, _warnOnce2.default)(
                    'Container#eachRule is deprecated. ' +
                      'Use Container#walkRules instead.'
                  )
                  return this.walkRules(selector, callback)
                },
              },
              {
                key: 'eachAtRule',
                value: function eachAtRule(name, callback) {
                  ;(0, _warnOnce2.default)(
                    'Container#eachAtRule is deprecated. ' +
                      'Use Container#walkAtRules instead.'
                  )
                  return this.walkAtRules(name, callback)
                },
              },
              {
                key: 'eachComment',
                value: function eachComment(callback) {
                  ;(0, _warnOnce2.default)(
                    'Container#eachComment is deprecated. ' +
                      'Use Container#walkComments instead.'
                  )
                  return this.walkComments(callback)
                },
              },
              {
                key: 'first',
                get: function get() {
                  if (!this.nodes) return undefined
                  return this.nodes[0]
                },

                /**
         * The containers last child.
         *
         * @type {Node}
         *
         * @example
         * rule.last == rule.nodes[rule.nodes.length - 1];
         */
              },
              {
                key: 'last',
                get: function get() {
                  if (!this.nodes) return undefined
                  return this.nodes[this.nodes.length - 1]
                },
              },
              {
                key: 'semicolon',
                get: function get() {
                  ;(0, _warnOnce2.default)(
                    'Node#semicolon is deprecated. Use Node#raws.semicolon'
                  )
                  return this.raws.semicolon
                },
                set: function set(val) {
                  ;(0, _warnOnce2.default)(
                    'Node#semicolon is deprecated. Use Node#raws.semicolon'
                  )
                  this.raws.semicolon = val
                },
              },
              {
                key: 'after',
                get: function get() {
                  ;(0, _warnOnce2.default)(
                    'Node#after is deprecated. Use Node#raws.after'
                  )
                  return this.raws.after
                },
                set: function set(val) {
                  ;(0, _warnOnce2.default)(
                    'Node#after is deprecated. Use Node#raws.after'
                  )
                  this.raws.after = val
                },

                /**
         * @memberof Container#
         * @member {Node[]} nodes - an array containing the containers children
         *
         * @example
         * const root = postcss.parse('a { color: black }');
         * root.nodes.length           //=> 1
         * root.nodes[0].selector      //=> 'a'
         * root.nodes[0].nodes[0].prop //=> 'color'
         */
              },
            ])

            return Container
          })(_node2.default)

          exports.default = Container
          module.exports = exports['default']
        },
        {
          './at-rule': 532,
          './comment': 533,
          './declaration': 536,
          './node': 540,
          './parse': 541,
          './root': 545,
          './rule': 546,
          './warn-once': 551,
        },
      ],
      535: [
        function(require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', {
            value: true,
          })

          var _createClass = (function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i]
                descriptor.enumerable = descriptor.enumerable || false
                descriptor.configurable = true
                if ('value' in descriptor) descriptor.writable = true
                Object.defineProperty(target, descriptor.key, descriptor)
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps)
              if (staticProps) defineProperties(Constructor, staticProps)
              return Constructor
            }
          })()

          var _supportsColor = require('supports-color')

          var _supportsColor2 = _interopRequireDefault(_supportsColor)

          var _terminalHighlight = require('./terminal-highlight')

          var _terminalHighlight2 = _interopRequireDefault(_terminalHighlight)

          var _warnOnce = require('./warn-once')

          var _warnOnce2 = _interopRequireDefault(_warnOnce)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function')
            }
          }

          /**
 * The CSS parser throws this error for broken CSS.
 *
 * Custom parsers can throw this error for broken custom syntax using
 * the {@link Node#error} method.
 *
 * PostCSS will use the input source map to detect the original error location.
 * If you wrote a Sass file, compiled it to CSS and then parsed it with PostCSS,
 * PostCSS will show the original position in the Sass file.
 *
 * If you need the position in the PostCSS input
 * (e.g., to debug the previous compiler), use `error.input.file`.
 *
 * @example
 * // Catching and checking syntax error
 * try {
 *   postcss.parse('a{')
 * } catch (error) {
 *   if ( error.name === 'CssSyntaxError' ) {
 *     error //=> CssSyntaxError
 *   }
 * }
 *
 * @example
 * // Raising error from plugin
 * throw node.error('Unknown variable', { plugin: 'postcss-vars' });
 */
          var CssSyntaxError = (function() {
            /**
     * @param {string} message  - error message
     * @param {number} [line]   - source line of the error
     * @param {number} [column] - source column of the error
     * @param {string} [source] - source code of the broken file
     * @param {string} [file]   - absolute path to the broken file
     * @param {string} [plugin] - PostCSS plugin name, if error came from plugin
     */
            function CssSyntaxError(
              message,
              line,
              column,
              source,
              file,
              plugin
            ) {
              _classCallCheck(this, CssSyntaxError)

              /**
         * @member {string} - Always equal to `'CssSyntaxError'`. You should
         *                    always check error type
         *                    by `error.name === 'CssSyntaxError'` instead of
         *                    `error instanceof CssSyntaxError`, because
         *                    npm could have several PostCSS versions.
         *
         * @example
         * if ( error.name === 'CssSyntaxError' ) {
         *   error //=> CssSyntaxError
         * }
         */
              this.name = 'CssSyntaxError'
              /**
         * @member {string} - Error message.
         *
         * @example
         * error.message //=> 'Unclosed block'
         */
              this.reason = message

              if (file) {
                /**
             * @member {string} - Absolute path to the broken file.
             *
             * @example
             * error.file       //=> 'a.sass'
             * error.input.file //=> 'a.css'
             */
                this.file = file
              }
              if (source) {
                /**
             * @member {string} - Source code of the broken file.
             *
             * @example
             * error.source       //=> 'a { b {} }'
             * error.input.column //=> 'a b { }'
             */
                this.source = source
              }
              if (plugin) {
                /**
             * @member {string} - Plugin name, if error came from plugin.
             *
             * @example
             * error.plugin //=> 'postcss-vars'
             */
                this.plugin = plugin
              }
              if (
                typeof line !== 'undefined' &&
                typeof column !== 'undefined'
              ) {
                /**
             * @member {number} - Source line of the error.
             *
             * @example
             * error.line       //=> 2
             * error.input.line //=> 4
             */
                this.line = line
                /**
             * @member {number} - Source column of the error.
             *
             * @example
             * error.column       //=> 1
             * error.input.column //=> 4
             */
                this.column = column
              }

              this.setMessage()

              if (Error.captureStackTrace) {
                Error.captureStackTrace(this, CssSyntaxError)
              }
            }

            _createClass(CssSyntaxError, [
              {
                key: 'setMessage',
                value: function setMessage() {
                  /**
             * @member {string} - Full error text in the GNU error format
             *                    with plugin, file, line and column.
             *
             * @example
             * error.message //=> 'a.css:1:1: Unclosed block'
             */
                  this.message = this.plugin ? this.plugin + ': ' : ''
                  this.message += this.file ? this.file : '<css input>'
                  if (typeof this.line !== 'undefined') {
                    this.message += ':' + this.line + ':' + this.column
                  }
                  this.message += ': ' + this.reason
                },

                /**
         * Returns a few lines of CSS source that caused the error.
         *
         * If the CSS has an input source map without `sourceContent`,
         * this method will return an empty string.
         *
         * @param {boolean} [color] whether arrow will be colored red by terminal
         *                          color codes. By default, PostCSS will detect
         *                          color support by `process.stdout.isTTY`
         *                          and `process.env.NODE_DISABLE_COLORS`.
         *
         * @example
         * error.showSourceCode() //=> "  4 | }
         *                        //      5 | a {
         *                        //    > 6 |   bad
         *                        //        |   ^
         *                        //      7 | }
         *                        //      8 | b {"
         *
         * @return {string} few lines of CSS source that caused the error
         */
              },
              {
                key: 'showSourceCode',
                value: function showSourceCode(color) {
                  var _this = this

                  if (!this.source) return ''

                  var css = this.source
                  if (typeof color === 'undefined')
                    color = _supportsColor2.default
                  if (color) css = (0, _terminalHighlight2.default)(css)

                  var lines = css.split(/\r?\n/)
                  var start = Math.max(this.line - 3, 0)
                  var end = Math.min(this.line + 2, lines.length)

                  var maxWidth = String(end).length

                  return lines
                    .slice(start, end)
                    .map(function(line, index) {
                      var number = start + 1 + index
                      var padded = (' ' + number).slice(-maxWidth)
                      var gutter = ' ' + padded + ' | '
                      if (number === _this.line) {
                        var spacing =
                          gutter.replace(/\d/g, ' ') +
                          line.slice(0, _this.column - 1).replace(/[^\t]/g, ' ')
                        return '>' + gutter + line + '\n ' + spacing + '^'
                      } else {
                        return ' ' + gutter + line
                      }
                    })
                    .join('\n')
                },

                /**
         * Returns error position, message and source code of the broken part.
         *
         * @example
         * error.toString() //=> "CssSyntaxError: app.css:1:1: Unclosed block
         *                  //    > 1 | a {
         *                  //        | ^"
         *
         * @return {string} error position, message and source code
         */
              },
              {
                key: 'toString',
                value: function toString() {
                  var code = this.showSourceCode()
                  if (code) {
                    code = '\n\n' + code + '\n'
                  }
                  return this.name + ': ' + this.message + code
                },
              },
              {
                key: 'generated',
                get: function get() {
                  ;(0, _warnOnce2.default)(
                    'CssSyntaxError#generated is depreacted. Use input instead.'
                  )
                  return this.input
                },

                /**
         * @memberof CssSyntaxError#
         * @member {Input} input - Input object with PostCSS internal information
         *                         about input file. If input has source map
         *                         from previous tool, PostCSS will use origin
         *                         (for example, Sass) source. You can use this
         *                         object to get PostCSS input source.
         *
         * @example
         * error.input.file //=> 'a.css'
         * error.file       //=> 'a.sass'
         */
              },
            ])

            return CssSyntaxError
          })()

          exports.default = CssSyntaxError
          module.exports = exports['default']
        },
        {
          './terminal-highlight': 549,
          './warn-once': 551,
          'supports-color': 553,
        },
      ],
      536: [
        function(require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', {
            value: true,
          })

          var _createClass = (function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i]
                descriptor.enumerable = descriptor.enumerable || false
                descriptor.configurable = true
                if ('value' in descriptor) descriptor.writable = true
                Object.defineProperty(target, descriptor.key, descriptor)
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps)
              if (staticProps) defineProperties(Constructor, staticProps)
              return Constructor
            }
          })()

          var _warnOnce = require('./warn-once')

          var _warnOnce2 = _interopRequireDefault(_warnOnce)

          var _node = require('./node')

          var _node2 = _interopRequireDefault(_node)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function')
            }
          }

          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError(
                "this hasn't been initialised - super() hasn't been called"
              )
            }
            return call &&
              (typeof call === 'object' || typeof call === 'function')
              ? call
              : self
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== 'function' && superClass !== null) {
              throw new TypeError(
                'Super expression must either be null or a function, not ' +
                  typeof superClass
              )
            }
            subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true,
                },
              }
            )
            if (superClass)
              Object.setPrototypeOf
                ? Object.setPrototypeOf(subClass, superClass)
                : (subClass.__proto__ = superClass)
          }

          /**
 * Represents a CSS declaration.
 *
 * @extends Node
 *
 * @example
 * const root = postcss.parse('a { color: black }');
 * const decl = root.first.first;
 * decl.type       //=> 'decl'
 * decl.toString() //=> ' color: black'
 */
          var Declaration = (function(_Node) {
            _inherits(Declaration, _Node)

            function Declaration(defaults) {
              _classCallCheck(this, Declaration)

              var _this = _possibleConstructorReturn(
                this,
                (Declaration.__proto__ || Object.getPrototypeOf(Declaration))
                  .call(this, defaults)
              )

              _this.type = 'decl'
              return _this
            }

            _createClass(Declaration, [
              {
                key: '_value',
                get: function get() {
                  ;(0, _warnOnce2.default)(
                    'Node#_value was deprecated. Use Node#raws.value'
                  )
                  return this.raws.value
                },
                set: function set(val) {
                  ;(0, _warnOnce2.default)(
                    'Node#_value was deprecated. Use Node#raws.value'
                  )
                  this.raws.value = val
                },
              },
              {
                key: '_important',
                get: function get() {
                  ;(0, _warnOnce2.default)(
                    'Node#_important was deprecated. Use Node#raws.important'
                  )
                  return this.raws.important
                },
                set: function set(val) {
                  ;(0, _warnOnce2.default)(
                    'Node#_important was deprecated. Use Node#raws.important'
                  )
                  this.raws.important = val
                },

                /**
         * @memberof Declaration#
         * @member {string} prop - the declarations property name
         *
         * @example
         * const root = postcss.parse('a { color: black }');
         * const decl = root.first.first;
         * decl.prop //=> 'color'
         */

                /**
         * @memberof Declaration#
         * @member {string} value - the declarations value
         *
         * @example
         * const root = postcss.parse('a { color: black }');
         * const decl = root.first.first;
         * decl.value //=> 'black'
         */

                /**
         * @memberof Declaration#
         * @member {boolean} important - `true` if the declaration
         *                               has an !important annotation.
         *
         * @example
         * const root = postcss.parse('a { color: black !important; color: red }');
         * root.first.first.important //=> true
         * root.first.last.important  //=> undefined
         */

                /**
         * @memberof Declaration#
         * @member {object} raws - Information to generate byte-to-byte equal
         *                         node string as it was in the origin input.
         *
         * Every parser saves its own properties,
         * but the default CSS parser uses:
         *
         * * `before`: the space symbols before the node. It also stores `*`
         *   and `_` symbols before the declaration (IE hack).
         * * `between`: the symbols between the property and value
         *   for declarations, selector and `{` for rules, or last parameter
         *   and `{` for at-rules.
         * * `important`: the content of the important statement,
         *   if it is not just `!important`.
         *
         * PostCSS cleans declaration from comments and extra spaces,
         * but it stores origin content in raws properties.
         * As such, if you dont change a declarations value,
         * PostCSS will use the raw value with comments.
         *
         * @example
         * const root = postcss.parse('a {\n  color:black\n}')
         * root.first.first.raws //=> { before: '\n  ', between: ':' }
         */
              },
            ])

            return Declaration
          })(_node2.default)

          exports.default = Declaration
          module.exports = exports['default']
        },
        { './node': 540, './warn-once': 551 },
      ],
      537: [
        function(require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', {
            value: true,
          })

          var _createClass = (function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i]
                descriptor.enumerable = descriptor.enumerable || false
                descriptor.configurable = true
                if ('value' in descriptor) descriptor.writable = true
                Object.defineProperty(target, descriptor.key, descriptor)
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps)
              if (staticProps) defineProperties(Constructor, staticProps)
              return Constructor
            }
          })() // break cyclical dependency deadlock  #87

          require('./root')

          var _cssSyntaxError = require('./css-syntax-error')

          var _cssSyntaxError2 = _interopRequireDefault(_cssSyntaxError)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function')
            }
          }

          // import PreviousMap    from './previous-map';

          var sequence = 0

          /**
 * @typedef  {object} filePosition
 * @property {string} file   - path to file
 * @property {number} line   - source line in file
 * @property {number} column - source column in file
 */

          /**
 * Represents the source CSS.
 *
 * @example
 * const root  = postcss.parse(css, { from: file });
 * const input = root.source.input;
 */

          var Input = (function() {
            /**
     * @param {string} css    - input CSS source
     * @param {object} [opts] - {@link Processor#process} options
     */
            function Input(css) {
              var opts = arguments.length > 1 && arguments[1] !== undefined
                ? arguments[1]
                : {}

              _classCallCheck(this, Input)

              /**
         * @member {string} - input CSS source
         *
         * @example
         * const input = postcss.parse('a{}', { from: file }).input;
         * input.css //=> "a{}";
         */
              this.css = css.toString()

              if (this.css[0] === '\uFEFF' || this.css[0] === '\uFFFE') {
                this.css = this.css.slice(1)
              }

              if (opts.from) {
                if (/^\w+:\/\//.test(opts.from)) {
                  /**
                 * @member {string} - The absolute path to the CSS source file
                 *                    defined with the `from` option.
                 *
                 * @example
                 * const root = postcss.parse(css, { from: 'a.css' });
                 * root.source.input.file //=> '/home/ai/a.css'
                 */
                  this.file = opts.from
                } else {
                  this.file = path.resolve(opts.from)
                }
              }

              /*
                let map = new PreviousMap(this.css, opts);
                if ( map.text ) {
                    /!**
                     * @member {PreviousMap} - The input source map passed from
                     *                         a compilation step before PostCSS
                     *                         (for example, from Sass compiler).
                     *
                     * @example
                     * root.source.input.map.consumer().sources //=> ['a.sass']
                     *!/
                    this.map = map;
                    let file = map.consumer().file;
                    if ( !this.file && file ) this.file = this.mapResolve(file);
                }
        */

              if (!this.file) {
                sequence += 1
                /**
             * @member {string} - The unique ID of the CSS source. It will be
             *                    created if `from` option is not provided
             *                    (because PostCSS does not know the file path).
             *
             * @example
             * const root = postcss.parse(css);
             * root.source.input.file //=> undefined
             * root.source.input.id   //=> "<input css 1>"
             */
                this.id = '<input css ' + sequence + '>'
              }
              if (this.map) this.map.file = this.from
            }

            _createClass(Input, [
              {
                key: 'error',
                value: function error(message, line, column) {
                  var opts = arguments.length > 3 && arguments[3] !== undefined
                    ? arguments[3]
                    : {}

                  var result = void 0
                  var origin = this.origin(line, column)
                  if (origin) {
                    result = new _cssSyntaxError2.default(
                      message,
                      origin.line,
                      origin.column,
                      origin.source,
                      origin.file,
                      opts.plugin
                    )
                  } else {
                    result = new _cssSyntaxError2.default(
                      message,
                      line,
                      column,
                      this.css,
                      this.file,
                      opts.plugin
                    )
                  }

                  result.input = {
                    line: line,
                    column: column,
                    source: this.css,
                  }
                  if (this.file) result.input.file = this.file

                  return result
                },

                /**
         * Reads the input source map and returns a symbol position
         * in the input source (e.g., in a Sass file that was compiled
         * to CSS before being passed to PostCSS).
         *
         * @param {number} line   - line in input CSS
         * @param {number} column - column in input CSS
         *
         * @return {filePosition} position in input source
         *
         * @example
         * root.source.input.origin(1, 1) //=> { file: 'a.css', line: 3, column: 1 }
         */
              },
              {
                key: 'origin',
                value: function origin(line, column) {
                  if (!this.map) return false
                  var consumer = this.map.consumer()

                  var from = consumer.originalPositionFor({
                    line: line,
                    column: column,
                  })
                  if (!from.source) return false

                  var result = {
                    file: this.mapResolve(from.source),
                    line: from.line,
                    column: from.column,
                  }

                  var source = consumer.sourceContentFor(from.source)
                  if (source) result.source = source

                  return result
                },
              },
              {
                key: 'mapResolve',
                value: function mapResolve(file) {
                  if (/^\w+:\/\//.test(file)) {
                    return file
                  } else {
                    return path.resolve(
                      this.map.consumer().sourceRoot || '.',
                      file
                    )
                  }
                },

                /**
         * The CSS source identifier. Contains {@link Input#file} if the user
         * set the `from` option, or {@link Input#id} if they did not.
         * @type {string}
         *
         * @example
         * const root = postcss.parse(css, { from: 'a.css' });
         * root.source.input.from //=> "/home/ai/a.css"
         *
         * const root = postcss.parse(css);
         * root.source.input.from //=> "<input css 1>"
         */
              },
              {
                key: 'from',
                get: function get() {
                  return this.file || this.id
                },
              },
            ])

            return Input
          })()

          exports.default = Input
          module.exports = exports['default']
        },
        { './css-syntax-error': 535, './root': 545 },
      ],
      538: [
        function(require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', {
            value: true,
          })

          var _createClass = (function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i]
                descriptor.enumerable = descriptor.enumerable || false
                descriptor.configurable = true
                if ('value' in descriptor) descriptor.writable = true
                Object.defineProperty(target, descriptor.key, descriptor)
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps)
              if (staticProps) defineProperties(Constructor, staticProps)
              return Constructor
            }
          })()

          var _typeof = typeof Symbol === 'function' &&
            typeof Symbol.iterator === 'symbol'
            ? function(obj) {
                return typeof obj
              }
            : function(obj) {
                return obj &&
                  typeof Symbol === 'function' &&
                  obj.constructor === Symbol &&
                  obj !== Symbol.prototype
                  ? 'symbol'
                  : typeof obj
              }

          var _stringify2 = require('./stringify')

          var _stringify3 = _interopRequireDefault(_stringify2)

          var _warnOnce = require('./warn-once')

          var _warnOnce2 = _interopRequireDefault(_warnOnce)

          var _result = require('./result')

          var _result2 = _interopRequireDefault(_result)

          var _parse = require('./parse')

          var _parse2 = _interopRequireDefault(_parse)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function')
            }
          }

          function isPromise(obj) {
            return (
              (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) ===
                'object' && typeof obj.then === 'function'
            )
          }

          /**
 * @callback onFulfilled
 * @param {Result} result
 */

          /**
 * @callback onRejected
 * @param {Error} error
 */

          /**
 * A Promise proxy for the result of PostCSS transformations.
 *
 * A `LazyResult` instance is returned by {@link Processor#process}.
 *
 * @example
 * const lazy = postcss([cssnext]).process(css);
 */

          var LazyResult = (function() {
            function LazyResult(processor, css, opts) {
              _classCallCheck(this, LazyResult)

              this.stringified = false
              this.processed = false

              var root = void 0
              if (
                (typeof css === 'undefined' ? 'undefined' : _typeof(css)) ===
                  'object' &&
                css.type === 'root'
              ) {
                root = css
              } else if (
                css instanceof LazyResult ||
                css instanceof _result2.default
              ) {
                root = css.root
                if (css.map) {
                  if (typeof opts.map === 'undefined') opts.map = {}
                  if (!opts.map.inline) opts.map.inline = false
                  opts.map.prev = css.map
                }
              } else {
                var parser = _parse2.default
                if (opts.syntax) parser = opts.syntax.parse
                if (opts.parser) parser = opts.parser
                if (parser.parse) parser = parser.parse

                try {
                  root = parser(css, opts)
                } catch (error) {
                  this.error = error
                }
              }

              this.result = new _result2.default(processor, root, opts)
            }

            /**
     * Returns a {@link Processor} instance, which will be used
     * for CSS transformations.
     * @type {Processor}
     */

            _createClass(LazyResult, [
              {
                key: 'warnings',

                /**
         * Processes input CSS through synchronous plugins
         * and calls {@link Result#warnings()}.
         *
         * @return {Warning[]} warnings from plugins
         */
                value: function warnings() {
                  return this.sync().warnings()
                },

                /**
         * Alias for the {@link LazyResult#css} property.
         *
         * @example
         * lazy + '' === lazy.css;
         *
         * @return {string} output CSS
         */
              },
              {
                key: 'toString',
                value: function toString() {
                  return this.css
                },

                /**
         * Processes input CSS through synchronous and asynchronous plugins
         * and calls `onFulfilled` with a Result instance. If a plugin throws
         * an error, the `onRejected` callback will be executed.
         *
         * It implements standard Promise API.
         *
         * @param {onFulfilled} onFulfilled - callback will be executed
         *                                    when all plugins will finish work
         * @param {onRejected}  onRejected  - callback will be execited on any error
         *
         * @return {Promise} Promise API to make queue
         *
         * @example
         * postcss([cssnext]).process(css).then(result => {
         *   console.log(result.css);
         * });
         */
              },
              {
                key: 'then',
                value: function then(onFulfilled, onRejected) {
                  return this.async().then(onFulfilled, onRejected)
                },

                /**
         * Processes input CSS through synchronous and asynchronous plugins
         * and calls onRejected for each error thrown in any plugin.
         *
         * It implements standard Promise API.
         *
         * @param {onRejected} onRejected - callback will be execited on any error
         *
         * @return {Promise} Promise API to make queue
         *
         * @example
         * postcss([cssnext]).process(css).then(result => {
         *   console.log(result.css);
         * }).catch(error => {
         *   console.error(error);
         * });
         */
              },
              {
                key: 'catch',
                value: function _catch(onRejected) {
                  return this.async().catch(onRejected)
                },
              },
              {
                key: 'handleError',
                value: function handleError(error, plugin) {
                  try {
                    this.error = error
                    if (error.name === 'CssSyntaxError' && !error.plugin) {
                      error.plugin = plugin.postcssPlugin
                      error.setMessage()
                    } else if (plugin.postcssVersion) {
                      var pluginName = plugin.postcssPlugin
                      var pluginVer = plugin.postcssVersion
                      var runtimeVer = this.result.processor.version
                      var a = pluginVer.split('.')
                      var b = runtimeVer.split('.')

                      if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) {
                        ;(0, _warnOnce2.default)(
                          'Your current PostCSS version ' +
                            'is ' +
                            runtimeVer +
                            ', but ' +
                            pluginName +
                            ' ' +
                            'uses ' +
                            pluginVer +
                            '. Perhaps this is ' +
                            'the source of the error below.'
                        )
                      }
                    }
                  } catch (err) {
                    if (console && console.error) console.error(err)
                  }
                },
              },
              {
                key: 'asyncTick',
                value: function asyncTick(resolve, reject) {
                  var _this = this

                  if (this.plugin >= this.processor.plugins.length) {
                    this.processed = true
                    return resolve()
                  }

                  try {
                    var plugin = this.processor.plugins[this.plugin]
                    var promise = this.run(plugin)
                    this.plugin += 1

                    if (isPromise(promise)) {
                      promise
                        .then(function() {
                          _this.asyncTick(resolve, reject)
                        })
                        .catch(function(error) {
                          _this.handleError(error, plugin)
                          _this.processed = true
                          reject(error)
                        })
                    } else {
                      this.asyncTick(resolve, reject)
                    }
                  } catch (error) {
                    this.processed = true
                    reject(error)
                  }
                },
              },
              {
                key: 'async',
                value: function async() {
                  var _this2 = this

                  if (this.processed) {
                    return new Promise(function(resolve, reject) {
                      if (_this2.error) {
                        reject(_this2.error)
                      } else {
                        resolve(_this2.stringify())
                      }
                    })
                  }
                  if (this.processing) {
                    return this.processing
                  }

                  this.processing = new Promise(function(resolve, reject) {
                    if (_this2.error) return reject(_this2.error)
                    _this2.plugin = 0
                    _this2.asyncTick(resolve, reject)
                  }).then(function() {
                    _this2.processed = true
                    return _this2.stringify()
                  })

                  return this.processing
                },
              },
              {
                key: 'sync',
                value: function sync() {
                  var _this3 = this

                  if (this.processed) return this.result
                  this.processed = true

                  if (this.processing) {
                    throw new Error(
                      'Use process(css).then(cb) to work with async plugins'
                    )
                  }

                  if (this.error) throw this.error

                  this.result.processor.plugins.forEach(function(plugin) {
                    var promise = _this3.run(plugin)
                    if (isPromise(promise)) {
                      throw new Error(
                        'Use process(css).then(cb) to work with async plugins'
                      )
                    }
                  })

                  return this.result
                },
              },
              {
                key: 'run',
                value: function run(plugin) {
                  this.result.lastPlugin = plugin

                  try {
                    return plugin(this.result.root, this.result)
                  } catch (error) {
                    this.handleError(error, plugin)
                    throw error
                  }
                },
              },
              {
                key: 'stringify',
                value: function stringify() {
                  if (this.stringified) return this.result
                  this.stringified = true

                  this.sync()

                  var opts = this.result.opts
                  var str = _stringify3.default
                  if (opts.syntax) str = opts.syntax.stringify
                  if (opts.stringifier) str = opts.stringifier
                  if (str.stringify) str = str.stringify

                  var result = ''
                  str(this.root, function(i) {
                    result += i
                  })
                  this.result.css = result

                  return this.result
                },
              },
              {
                key: 'processor',
                get: function get() {
                  return this.result.processor
                },

                /**
         * Options from the {@link Processor#process} call.
         * @type {processOptions}
         */
              },
              {
                key: 'opts',
                get: function get() {
                  return this.result.opts
                },

                /**
         * Processes input CSS through synchronous plugins, converts `Root`
         * to a CSS string and returns {@link Result#css}.
         *
         * This property will only work with synchronous plugins.
         * If the processor contains any asynchronous plugins
         * it will throw an error. This is why this method is only
         * for debug purpose, you should always use {@link LazyResult#then}.
         *
         * @type {string}
         * @see Result#css
         */
              },
              {
                key: 'css',
                get: function get() {
                  return this.stringify().css
                },

                /**
         * An alias for the `css` property. Use it with syntaxes
         * that generate non-CSS output.
         *
         * This property will only work with synchronous plugins.
         * If the processor contains any asynchronous plugins
         * it will throw an error. This is why this method is only
         * for debug purpose, you should always use {@link LazyResult#then}.
         *
         * @type {string}
         * @see Result#content
         */
              },
              {
                key: 'content',
                get: function get() {
                  return this.stringify().content
                },

                /**
         * Processes input CSS through synchronous plugins
         * and returns {@link Result#map}.
         *
         * This property will only work with synchronous plugins.
         * If the processor contains any asynchronous plugins
         * it will throw an error. This is why this method is only
         * for debug purpose, you should always use {@link LazyResult#then}.
         *
         * @type {SourceMapGenerator}
         * @see Result#map
         */
              },
              {
                key: 'map',
                get: function get() {
                  return this.stringify().map
                },

                /**
         * Processes input CSS through synchronous plugins
         * and returns {@link Result#root}.
         *
         * This property will only work with synchronous plugins. If the processor
         * contains any asynchronous plugins it will throw an error.
         *
         * This is why this method is only for debug purpose,
         * you should always use {@link LazyResult#then}.
         *
         * @type {Root}
         * @see Result#root
         */
              },
              {
                key: 'root',
                get: function get() {
                  return this.sync().root
                },

                /**
         * Processes input CSS through synchronous plugins
         * and returns {@link Result#messages}.
         *
         * This property will only work with synchronous plugins. If the processor
         * contains any asynchronous plugins it will throw an error.
         *
         * This is why this method is only for debug purpose,
         * you should always use {@link LazyResult#then}.
         *
         * @type {Message[]}
         * @see Result#messages
         */
              },
              {
                key: 'messages',
                get: function get() {
                  return this.sync().messages
                },
              },
            ])

            return LazyResult
          })()

          exports.default = LazyResult
          module.exports = exports['default']
        },
        {
          './parse': 541,
          './result': 544,
          './stringify': 548,
          './warn-once': 551,
        },
      ],
      539: [
        function(require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', {
            value: true,
          })
          /**
 * Contains helpers for safely splitting lists of CSS values,
 * preserving parentheses and quotes.
 *
 * @example
 * const list = postcss.list;
 *
 * @namespace list
 */
          var list = {
            split: function split(string, separators, last) {
              var array = []
              var current = ''
              var split = false

              var func = 0
              var quote = false
              var escape = false

              for (var i = 0; i < string.length; i++) {
                var letter = string[i]

                if (quote) {
                  if (escape) {
                    escape = false
                  } else if (letter === '\\') {
                    escape = true
                  } else if (letter === quote) {
                    quote = false
                  }
                } else if (letter === '"' || letter === "'") {
                  quote = letter
                } else if (letter === '(') {
                  func += 1
                } else if (letter === ')') {
                  if (func > 0) func -= 1
                } else if (func === 0) {
                  if (separators.indexOf(letter) !== -1) split = true
                }

                if (split) {
                  if (current !== '') array.push(current.trim())
                  current = ''
                  split = false
                } else {
                  current += letter
                }
              }

              if (last || current !== '') array.push(current.trim())
              return array
            },

            /**
     * Safely splits space-separated values (such as those for `background`,
     * `border-radius`, and other shorthand properties).
     *
     * @param {string} string - space-separated values
     *
     * @return {string[]} splitted values
     *
     * @example
     * postcss.list.space('1px calc(10% + 1px)') //=> ['1px', 'calc(10% + 1px)']
     */
            space: function space(string) {
              var spaces = [' ', '\n', '\t']
              return list.split(string, spaces)
            },

            /**
     * Safely splits comma-separated values (such as those for `transition-*`
     * and `background` properties).
     *
     * @param {string} string - comma-separated values
     *
     * @return {string[]} splitted values
     *
     * @example
     * postcss.list.comma('black, linear-gradient(white, black)')
     * //=> ['black', 'linear-gradient(white, black)']
     */
            comma: function comma(string) {
              var comma = ','
              return list.split(string, [comma], true)
            },
          }

          exports.default = list
          module.exports = exports['default']
        },
        {},
      ],
      540: [
        function(require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', {
            value: true,
          })

          var _createClass = (function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i]
                descriptor.enumerable = descriptor.enumerable || false
                descriptor.configurable = true
                if ('value' in descriptor) descriptor.writable = true
                Object.defineProperty(target, descriptor.key, descriptor)
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps)
              if (staticProps) defineProperties(Constructor, staticProps)
              return Constructor
            }
          })()

          var _typeof = typeof Symbol === 'function' &&
            typeof Symbol.iterator === 'symbol'
            ? function(obj) {
                return typeof obj
              }
            : function(obj) {
                return obj &&
                  typeof Symbol === 'function' &&
                  obj.constructor === Symbol &&
                  obj !== Symbol.prototype
                  ? 'symbol'
                  : typeof obj
              }

          var _cssSyntaxError = require('./css-syntax-error')

          var _cssSyntaxError2 = _interopRequireDefault(_cssSyntaxError)

          var _stringifier = require('./stringifier')

          var _stringifier2 = _interopRequireDefault(_stringifier)

          var _stringify = require('./stringify')

          var _stringify2 = _interopRequireDefault(_stringify)

          var _warnOnce = require('./warn-once')

          var _warnOnce2 = _interopRequireDefault(_warnOnce)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function')
            }
          }

          /**
 * @typedef {object} position
 * @property {number} line   - source line in file
 * @property {number} column - source column in file
 */

          /**
 * @typedef {object} source
 * @property {Input} input    - {@link Input} with input file
 * @property {position} start - The starting position of the nodes source
 * @property {position} end   - The ending position of the nodes source
 */

          var cloneNode = function cloneNode(obj, parent) {
            var cloned = new obj.constructor()

            for (var i in obj) {
              if (!obj.hasOwnProperty(i)) continue
              var value = obj[i]
              var type = typeof value === 'undefined'
                ? 'undefined'
                : _typeof(value)

              if (i === 'parent' && type === 'object') {
                if (parent) cloned[i] = parent
              } else if (i === 'source') {
                cloned[i] = value
              } else if (value instanceof Array) {
                cloned[i] = value.map(function(j) {
                  return cloneNode(j, cloned)
                })
              } else if (
                i !== 'before' &&
                i !== 'after' &&
                i !== 'between' &&
                i !== 'semicolon'
              ) {
                if (type === 'object' && value !== null)
                  value = cloneNode(value)
                cloned[i] = value
              }
            }

            return cloned
          }

          /**
 * All node classes inherit the following common methods.
 *
 * @abstract
 */

          var Node = (function() {
            /**
     * @param {object} [defaults] - value for node properties
     */
            function Node() {
              var defaults = arguments.length > 0 && arguments[0] !== undefined
                ? arguments[0]
                : {}

              _classCallCheck(this, Node)

              this.raws = {}
              for (var name in defaults) {
                this[name] = defaults[name]
              }
            }

            /**
     * Returns a CssSyntaxError instance containing the original position
     * of the node in the source, showing line and column numbers and also
     * a small excerpt to facilitate debugging.
     *
     * If present, an input source map will be used to get the original position
     * of the source, even from a previous compilation step
     * (e.g., from Sass compilation).
     *
     * This method produces very useful error messages.
     *
     * @param {string} message     - error description
     * @param {object} [opts]      - options
     * @param {string} opts.plugin - plugin name that created this error.
     *                               PostCSS will set it automatically.
     * @param {string} opts.word   - a word inside a nodes string that should
     *                               be highlighted as the source of the error
     * @param {number} opts.index  - an index inside a nodes string that should
     *                               be highlighted as the source of the error
     *
     * @return {CssSyntaxError} error object to throw it
     *
     * @example
     * if ( !variables[name] ) {
     *   throw decl.error('Unknown variable ' + name, { word: name });
     *   // CssSyntaxError: postcss-vars:a.sass:4:3: Unknown variable $black
     *   //   color: $black
     *   // a
     *   //          ^
     *   //   background: white
     * }
     */

            _createClass(Node, [
              {
                key: 'error',
                value: function error(message) {
                  var opts = arguments.length > 1 && arguments[1] !== undefined
                    ? arguments[1]
                    : {}

                  if (this.source) {
                    var pos = this.positionBy(opts)
                    return this.source.input.error(
                      message,
                      pos.line,
                      pos.column,
                      opts
                    )
                  } else {
                    return new _cssSyntaxError2.default(message)
                  }
                },

                /**
         * This method is provided as a convenience wrapper for {@link Result#warn}.
         *
         * @param {Result} result      - the {@link Result} instance
         *                               that will receive the warning
         * @param {string} text        - warning message
         * @param {object} [opts]      - options
         * @param {string} opts.plugin - plugin name that created this warning.
         *                               PostCSS will set it automatically.
         * @param {string} opts.word   - a word inside a nodes string that should
         *                               be highlighted as the source of the warning
         * @param {number} opts.index  - an index inside a nodes string that should
         *                               be highlighted as the source of the warning
         *
         * @return {Warning} created warning object
         *
         * @example
         * const plugin = postcss.plugin('postcss-deprecated', () => {
         *   return (root, result) => {
         *     root.walkDecls('bad', decl => {
         *       decl.warn(result, 'Deprecated property bad');
         *     });
         *   };
         * });
         */
              },
              {
                key: 'warn',
                value: function warn(result, text, opts) {
                  var data = { node: this }
                  for (var i in opts) {
                    data[i] = opts[i]
                  }
                  return result.warn(text, data)
                },

                /**
         * Removes the node from its parent and cleans the parent properties
         * from the node and its children.
         *
         * @example
         * if ( decl.prop.match(/^-webkit-/) ) {
         *   decl.remove();
         * }
         *
         * @return {Node} node to make calls chain
         */
              },
              {
                key: 'remove',
                value: function remove() {
                  if (this.parent) {
                    this.parent.removeChild(this)
                  }
                  this.parent = undefined
                  return this
                },

                /**
         * Returns a CSS string representing the node.
         *
         * @param {stringifier|syntax} [stringifier] - a syntax to use
         *                                             in string generation
         *
         * @return {string} CSS string of this node
         *
         * @example
         * postcss.rule({ selector: 'a' }).toString() //=> "a {}"
         */
              },
              {
                key: 'toString',
                value: function toString() {
                  var stringifier = arguments.length > 0 &&
                    arguments[0] !== undefined
                    ? arguments[0]
                    : _stringify2.default

                  if (stringifier.stringify) stringifier = stringifier.stringify
                  var result = ''
                  stringifier(this, function(i) {
                    result += i
                  })
                  return result
                },

                /**
         * Returns a clone of the node.
         *
         * The resulting cloned node and its (cloned) children will have
         * a clean parent and code style properties.
         *
         * @param {object} [overrides] - new properties to override in the clone.
         *
         * @example
         * const cloned = decl.clone({ prop: '-moz-' + decl.prop });
         * cloned.raws.before  //=> undefined
         * cloned.parent       //=> undefined
         * cloned.toString()   //=> -moz-transform: scale(0)
         *
         * @return {Node} clone of the node
         */
              },
              {
                key: 'clone',
                value: function clone() {
                  var overrides = arguments.length > 0 &&
                    arguments[0] !== undefined
                    ? arguments[0]
                    : {}

                  var cloned = cloneNode(this)
                  for (var name in overrides) {
                    cloned[name] = overrides[name]
                  }
                  return cloned
                },

                /**
         * Shortcut to clone the node and insert the resulting cloned node
         * before the current node.
         *
         * @param {object} [overrides] - new properties to override in the clone.
         *
         * @example
         * decl.cloneBefore({ prop: '-moz-' + decl.prop });
         *
         * @return {Node} - new node
         */
              },
              {
                key: 'cloneBefore',
                value: function cloneBefore() {
                  var overrides = arguments.length > 0 &&
                    arguments[0] !== undefined
                    ? arguments[0]
                    : {}

                  var cloned = this.clone(overrides)
                  this.parent.insertBefore(this, cloned)
                  return cloned
                },

                /**
         * Shortcut to clone the node and insert the resulting cloned node
         * after the current node.
         *
         * @param {object} [overrides] - new properties to override in the clone.
         *
         * @return {Node} - new node
         */
              },
              {
                key: 'cloneAfter',
                value: function cloneAfter() {
                  var overrides = arguments.length > 0 &&
                    arguments[0] !== undefined
                    ? arguments[0]
                    : {}

                  var cloned = this.clone(overrides)
                  this.parent.insertAfter(this, cloned)
                  return cloned
                },

                /**
         * Inserts node(s) before the current node and removes the current node.
         *
         * @param {...Node} nodes - node(s) to replace current one
         *
         * @example
         * if ( atrule.name == 'mixin' ) {
         *   atrule.replaceWith(mixinRules[atrule.params]);
         * }
         *
         * @return {Node} current node to methods chain
         */
              },
              {
                key: 'replaceWith',
                value: function replaceWith() {
                  var _this = this

                  if (this.parent) {
                    for (
                      var _len = arguments.length,
                        nodes = Array(_len),
                        _key = 0;
                      _key < _len;
                      _key++
                    ) {
                      nodes[_key] = arguments[_key]
                    }

                    nodes.forEach(function(node) {
                      _this.parent.insertBefore(_this, node)
                    })

                    this.remove()
                  }

                  return this
                },

                /**
         * Removes the node from its current parent and inserts it
         * at the end of `newParent`.
         *
         * This will clean the `before` and `after` code {@link Node#raws} data
         * from the node and replace them with the indentation style of `newParent`.
         * It will also clean the `between` property
         * if `newParent` is in another {@link Root}.
         *
         * @param {Container} newParent - container node where the current node
         *                                will be moved
         *
         * @example
         * atrule.moveTo(atrule.root());
         *
         * @return {Node} current node to methods chain
         */
              },
              {
                key: 'moveTo',
                value: function moveTo(newParent) {
                  this.cleanRaws(this.root() === newParent.root())
                  this.remove()
                  newParent.append(this)
                  return this
                },

                /**
         * Removes the node from its current parent and inserts it into
         * a new parent before `otherNode`.
         *
         * This will also clean the nodes code style properties just as it would
         * in {@link Node#moveTo}.
         *
         * @param {Node} otherNode - node that will be before current node
         *
         * @return {Node} current node to methods chain
         */
              },
              {
                key: 'moveBefore',
                value: function moveBefore(otherNode) {
                  this.cleanRaws(this.root() === otherNode.root())
                  this.remove()
                  otherNode.parent.insertBefore(otherNode, this)
                  return this
                },

                /**
         * Removes the node from its current parent and inserts it into
         * a new parent after `otherNode`.
         *
         * This will also clean the nodes code style properties just as it would
         * in {@link Node#moveTo}.
         *
         * @param {Node} otherNode - node that will be after current node
         *
         * @return {Node} current node to methods chain
         */
              },
              {
                key: 'moveAfter',
                value: function moveAfter(otherNode) {
                  this.cleanRaws(this.root() === otherNode.root())
                  this.remove()
                  otherNode.parent.insertAfter(otherNode, this)
                  return this
                },

                /**
         * Returns the next child of the nodes parent.
         * Returns `undefined` if the current node is the last child.
         *
         * @return {Node|undefined} next node
         *
         * @example
         * if ( comment.text === 'delete next' ) {
         *   const next = comment.next();
         *   if ( next ) {
         *     next.remove();
         *   }
         * }
         */
              },
              {
                key: 'next',
                value: function next() {
                  var index = this.parent.index(this)
                  return this.parent.nodes[index + 1]
                },

                /**
         * Returns the previous child of the nodes parent.
         * Returns `undefined` if the current node is the first child.
         *
         * @return {Node|undefined} previous node
         *
         * @example
         * const annotation = decl.prev();
         * if ( annotation.type == 'comment' ) {
         *  readAnnotation(annotation.text);
         * }
         */
              },
              {
                key: 'prev',
                value: function prev() {
                  var index = this.parent.index(this)
                  return this.parent.nodes[index - 1]
                },
              },
              {
                key: 'toJSON',
                value: function toJSON() {
                  var fixed = {}

                  for (var name in this) {
                    if (!this.hasOwnProperty(name)) continue
                    if (name === 'parent') continue
                    var value = this[name]

                    if (value instanceof Array) {
                      fixed[name] = value.map(function(i) {
                        if (
                          (typeof i === 'undefined'
                            ? 'undefined'
                            : _typeof(i)) === 'object' &&
                          i.toJSON
                        ) {
                          return i.toJSON()
                        } else {
                          return i
                        }
                      })
                    } else if (
                      (typeof value === 'undefined'
                        ? 'undefined'
                        : _typeof(value)) === 'object' &&
                      value.toJSON
                    ) {
                      fixed[name] = value.toJSON()
                    } else {
                      fixed[name] = value
                    }
                  }

                  return fixed
                },

                /**
         * Returns a {@link Node#raws} value. If the node is missing
         * the code style property (because the node was manually built or cloned),
         * PostCSS will try to autodetect the code style property by looking
         * at other nodes in the tree.
         *
         * @param {string} prop          - name of code style property
         * @param {string} [defaultType] - name of default value, it can be missed
         *                                 if the value is the same as prop
         *
         * @example
         * const root = postcss.parse('a { background: white }');
         * root.nodes[0].append({ prop: 'color', value: 'black' });
         * root.nodes[0].nodes[1].raws.before   //=> undefined
         * root.nodes[0].nodes[1].raw('before') //=> ' '
         *
         * @return {string} code style value
         */
              },
              {
                key: 'raw',
                value: function raw(prop, defaultType) {
                  var str = new _stringifier2.default()
                  return str.raw(this, prop, defaultType)
                },

                /**
         * Finds the Root instance of the nodes tree.
         *
         * @example
         * root.nodes[0].nodes[0].root() === root
         *
         * @return {Root} root parent
         */
              },
              {
                key: 'root',
                value: function root() {
                  var result = this
                  while (result.parent) {
                    result = result.parent
                  }
                  return result
                },
              },
              {
                key: 'cleanRaws',
                value: function cleanRaws(keepBetween) {
                  delete this.raws.before
                  delete this.raws.after
                  if (!keepBetween) delete this.raws.between
                },
              },
              {
                key: 'positionInside',
                value: function positionInside(index) {
                  var string = this.toString()
                  var column = this.source.start.column
                  var line = this.source.start.line

                  for (var i = 0; i < index; i++) {
                    if (string[i] === '\n') {
                      column = 1
                      line += 1
                    } else {
                      column += 1
                    }
                  }

                  return { line: line, column: column }
                },
              },
              {
                key: 'positionBy',
                value: function positionBy(opts) {
                  var pos = this.source.start
                  if (opts.index) {
                    pos = this.positionInside(opts.index)
                  } else if (opts.word) {
                    var index = this.toString().indexOf(opts.word)
                    if (index !== -1) pos = this.positionInside(index)
                  }
                  return pos
                },
              },
              {
                key: 'removeSelf',
                value: function removeSelf() {
                  ;(0, _warnOnce2.default)(
                    'Node#removeSelf is deprecated. Use Node#remove.'
                  )
                  return this.remove()
                },
              },
              {
                key: 'replace',
                value: function replace(nodes) {
                  ;(0, _warnOnce2.default)(
                    'Node#replace is deprecated. Use Node#replaceWith'
                  )
                  return this.replaceWith(nodes)
                },
              },
              {
                key: 'style',
                value: function style(own, detect) {
                  ;(0, _warnOnce2.default)(
                    'Node#style() is deprecated. Use Node#raw()'
                  )
                  return this.raw(own, detect)
                },
              },
              {
                key: 'cleanStyles',
                value: function cleanStyles(keepBetween) {
                  ;(0, _warnOnce2.default)(
                    'Node#cleanStyles() is deprecated. Use Node#cleanRaws()'
                  )
                  return this.cleanRaws(keepBetween)
                },
              },
              {
                key: 'before',
                get: function get() {
                  ;(0, _warnOnce2.default)(
                    'Node#before is deprecated. Use Node#raws.before'
                  )
                  return this.raws.before
                },
                set: function set(val) {
                  ;(0, _warnOnce2.default)(
                    'Node#before is deprecated. Use Node#raws.before'
                  )
                  this.raws.before = val
                },
              },
              {
                key: 'between',
                get: function get() {
                  ;(0, _warnOnce2.default)(
                    'Node#between is deprecated. Use Node#raws.between'
                  )
                  return this.raws.between
                },
                set: function set(val) {
                  ;(0, _warnOnce2.default)(
                    'Node#between is deprecated. Use Node#raws.between'
                  )
                  this.raws.between = val
                },

                /**
         * @memberof Node#
         * @member {string} type - String representing the nodes type.
         *                         Possible values are `root`, `atrule`, `rule`,
         *                         `decl`, or `comment`.
         *
         * @example
         * postcss.decl({ prop: 'color', value: 'black' }).type //=> 'decl'
         */

                /**
         * @memberof Node#
         * @member {Container} parent - the nodes parent node.
         *
         * @example
         * root.nodes[0].parent == root;
         */

                /**
         * @memberof Node#
         * @member {source} source - the input source of the node
         *
         * The property is used in source map generation.
         *
         * If you create a node manually (e.g., with `postcss.decl()`),
         * that node will not have a `source` property and will be absent
         * from the source map. For this reason, the plugin developer should
         * consider cloning nodes to create new ones (in which case the new nodes
         * source will reference the original, cloned node) or setting
         * the `source` property manually.
         *
         * ```js
         * // Bad
         * const prefixed = postcss.decl({
         *   prop: '-moz-' + decl.prop,
         *   value: decl.value
         * });
         *
         * // Good
         * const prefixed = decl.clone({ prop: '-moz-' + decl.prop });
         * ```
         *
         * ```js
         * if ( atrule.name == 'add-link' ) {
         *   const rule = postcss.rule({ selector: 'a', source: atrule.source });
         *   atrule.parent.insertBefore(atrule, rule);
         * }
         * ```
         *
         * @example
         * decl.source.input.from //=> '/home/ai/a.sass'
         * decl.source.start      //=> { line: 10, column: 2 }
         * decl.source.end        //=> { line: 10, column: 12 }
         */

                /**
         * @memberof Node#
         * @member {object} raws - Information to generate byte-to-byte equal
         *                         node string as it was in the origin input.
         *
         * Every parser saves its own properties,
         * but the default CSS parser uses:
         *
         * * `before`: the space symbols before the node. It also stores `*`
         *   and `_` symbols before the declaration (IE hack).
         * * `after`: the space symbols after the last child of the node
         *   to the end of the node.
         * * `between`: the symbols between the property and value
         *   for declarations, selector and `{` for rules, or last parameter
         *   and `{` for at-rules.
         * * `semicolon`: contains true if the last child has
         *   an (optional) semicolon.
         * * `afterName`: the space between the at-rule name and its parameters.
         * * `left`: the space symbols between `/*` and the comments text.
         * * `right`: the space symbols between the comments text
         *   and <code>*&#47;</code>.
         * * `important`: the content of the important statement,
         *   if it is not just `!important`.
         *
         * PostCSS cleans selectors, declaration values and at-rule parameters
         * from comments and extra spaces, but it stores origin content in raws
         * properties. As such, if you dont change a declarations value,
         * PostCSS will use the raw value with comments.
         *
         * @example
         * const root = postcss.parse('a {\n  color:black\n}')
         * root.first.first.raws //=> { before: '\n  ', between: ':' }
         */
              },
            ])

            return Node
          })()

          exports.default = Node
          module.exports = exports['default']
        },
        {
          './css-syntax-error': 535,
          './stringifier': 547,
          './stringify': 548,
          './warn-once': 551,
        },
      ],
      541: [
        function(require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', {
            value: true,
          })
          exports.default = parse

          var _parser = require('./parser')

          var _parser2 = _interopRequireDefault(_parser)

          var _input = require('./input')

          var _input2 = _interopRequireDefault(_input)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          function parse(css, opts) {
            if (opts && opts.safe) {
              throw new Error(
                'Option safe was removed. ' +
                  'Use parser: require("postcss-safe-parser")'
              )
            }

            var input = new _input2.default(css, opts)

            var parser = new _parser2.default(input)
            try {
              parser.tokenize()
              parser.loop()
            } catch (e) {
              if (e.name === 'CssSyntaxError' && opts && opts.from) {
                if (/\.scss$/i.test(opts.from)) {
                  e.message +=
                    '\nYou tried to parse SCSS with ' +
                    'the standard CSS parser; ' +
                    'try again with the postcss-scss parser'
                } else if (/\.less$/i.test(opts.from)) {
                  e.message +=
                    '\nYou tried to parse Less with ' +
                    'the standard CSS parser; ' +
                    'try again with the postcss-less parser'
                }
              }
              throw e
            }

            return parser.root
          }
          module.exports = exports['default']
        },
        { './input': 537, './parser': 542 },
      ],
      542: [
        function(require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', {
            value: true,
          })

          var _createClass = (function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i]
                descriptor.enumerable = descriptor.enumerable || false
                descriptor.configurable = true
                if ('value' in descriptor) descriptor.writable = true
                Object.defineProperty(target, descriptor.key, descriptor)
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps)
              if (staticProps) defineProperties(Constructor, staticProps)
              return Constructor
            }
          })()

          var _declaration = require('./declaration')

          var _declaration2 = _interopRequireDefault(_declaration)

          var _tokenize = require('./tokenize')

          var _tokenize2 = _interopRequireDefault(_tokenize)

          var _comment = require('./comment')

          var _comment2 = _interopRequireDefault(_comment)

          var _atRule = require('./at-rule')

          var _atRule2 = _interopRequireDefault(_atRule)

          var _root = require('./root')

          var _root2 = _interopRequireDefault(_root)

          var _rule = require('./rule')

          var _rule2 = _interopRequireDefault(_rule)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function')
            }
          }

          var Parser = (function() {
            function Parser(input) {
              _classCallCheck(this, Parser)

              this.input = input

              this.pos = 0
              this.root = new _root2.default()
              this.current = this.root
              this.spaces = ''
              this.semicolon = false

              this.root.source = { input: input, start: { line: 1, column: 1 } }
            }

            _createClass(Parser, [
              {
                key: 'tokenize',
                value: function tokenize() {
                  this.tokens = (0, _tokenize2.default)(this.input)
                },
              },
              {
                key: 'loop',
                value: function loop() {
                  var token = void 0
                  while (this.pos < this.tokens.length) {
                    token = this.tokens[this.pos]

                    switch (token[0]) {
                      case 'space':
                      case ';':
                        this.spaces += token[1]
                        break

                      case '}':
                        this.end(token)
                        break

                      case 'comment':
                        this.comment(token)
                        break

                      case 'at-word':
                        this.atrule(token)
                        break

                      case '{':
                        this.emptyRule(token)
                        break

                      default:
                        this.other()
                        break
                    }

                    this.pos += 1
                  }
                  this.endFile()
                },
              },
              {
                key: 'comment',
                value: function comment(token) {
                  var node = new _comment2.default()
                  this.init(node, token[2], token[3])
                  node.source.end = { line: token[4], column: token[5] }

                  var text = token[1].slice(2, -2)
                  if (/^\s*$/.test(text)) {
                    node.text = ''
                    node.raws.left = text
                    node.raws.right = ''
                  } else {
                    var match = text.match(/^(\s*)([^]*[^\s])(\s*)$/)
                    node.text = match[2]
                    node.raws.left = match[1]
                    node.raws.right = match[3]
                  }
                },
              },
              {
                key: 'emptyRule',
                value: function emptyRule(token) {
                  var node = new _rule2.default()
                  this.init(node, token[2], token[3])
                  node.selector = ''
                  node.raws.between = ''
                  this.current = node
                },
              },
              {
                key: 'other',
                value: function other() {
                  var token = void 0
                  var end = false
                  var type = null
                  var colon = false
                  var bracket = null
                  var brackets = []

                  var start = this.pos
                  while (this.pos < this.tokens.length) {
                    token = this.tokens[this.pos]
                    type = token[0]

                    if (type === '(' || type === '[') {
                      if (!bracket) bracket = token
                      brackets.push(type === '(' ? ')' : ']')
                    } else if (brackets.length === 0) {
                      if (type === ';') {
                        if (colon) {
                          this.decl(this.tokens.slice(start, this.pos + 1))
                          return
                        } else {
                          break
                        }
                      } else if (type === '{') {
                        this.rule(this.tokens.slice(start, this.pos + 1))
                        return
                      } else if (type === '}') {
                        this.pos -= 1
                        end = true
                        break
                      } else if (type === ':') {
                        colon = true
                      }
                    } else if (type === brackets[brackets.length - 1]) {
                      brackets.pop()
                      if (brackets.length === 0) bracket = null
                    }

                    this.pos += 1
                  }
                  if (this.pos === this.tokens.length) {
                    this.pos -= 1
                    end = true
                  }

                  if (brackets.length > 0) this.unclosedBracket(bracket)

                  if (end && colon) {
                    while (this.pos > start) {
                      token = this.tokens[this.pos][0]
                      if (token !== 'space' && token !== 'comment') break
                      this.pos -= 1
                    }
                    this.decl(this.tokens.slice(start, this.pos + 1))
                    return
                  }

                  this.unknownWord(start)
                },
              },
              {
                key: 'rule',
                value: function rule(tokens) {
                  tokens.pop()

                  var node = new _rule2.default()
                  this.init(node, tokens[0][2], tokens[0][3])

                  node.raws.between = this.spacesFromEnd(tokens)
                  this.raw(node, 'selector', tokens)
                  this.current = node
                },
              },
              {
                key: 'decl',
                value: function decl(tokens) {
                  var node = new _declaration2.default()
                  this.init(node)

                  var last = tokens[tokens.length - 1]
                  if (last[0] === ';') {
                    this.semicolon = true
                    tokens.pop()
                  }
                  if (last[4]) {
                    node.source.end = { line: last[4], column: last[5] }
                  } else {
                    node.source.end = { line: last[2], column: last[3] }
                  }

                  while (tokens[0][0] !== 'word') {
                    node.raws.before += tokens.shift()[1]
                  }
                  node.source.start = {
                    line: tokens[0][2],
                    column: tokens[0][3],
                  }

                  node.prop = ''
                  while (tokens.length) {
                    var type = tokens[0][0]
                    if (
                      type === ':' ||
                      type === 'space' ||
                      type === 'comment'
                    ) {
                      break
                    }
                    node.prop += tokens.shift()[1]
                  }

                  node.raws.between = ''

                  var token = void 0
                  while (tokens.length) {
                    token = tokens.shift()

                    if (token[0] === ':') {
                      node.raws.between += token[1]
                      break
                    } else {
                      node.raws.between += token[1]
                    }
                  }

                  if (node.prop[0] === '_' || node.prop[0] === '*') {
                    node.raws.before += node.prop[0]
                    node.prop = node.prop.slice(1)
                  }
                  node.raws.between += this.spacesFromStart(tokens)
                  this.precheckMissedSemicolon(tokens)

                  for (var i = tokens.length - 1; i > 0; i--) {
                    token = tokens[i]
                    if (token[1] === '!important') {
                      node.important = true
                      var string = this.stringFrom(tokens, i)
                      string = this.spacesFromEnd(tokens) + string
                      if (string !== ' !important') node.raws.important = string
                      break
                    } else if (token[1] === 'important') {
                      var cache = tokens.slice(0)
                      var str = ''
                      for (var j = i; j > 0; j--) {
                        var _type = cache[j][0]
                        if (
                          str.trim().indexOf('!') === 0 &&
                          _type !== 'space'
                        ) {
                          break
                        }
                        str = cache.pop()[1] + str
                      }
                      if (str.trim().indexOf('!') === 0) {
                        node.important = true
                        node.raws.important = str
                        tokens = cache
                      }
                    }

                    if (token[0] !== 'space' && token[0] !== 'comment') {
                      break
                    }
                  }

                  this.raw(node, 'value', tokens)

                  if (node.value.indexOf(':') !== -1)
                    this.checkMissedSemicolon(tokens)
                },
              },
              {
                key: 'atrule',
                value: function atrule(token) {
                  var node = new _atRule2.default()
                  node.name = token[1].slice(1)
                  if (node.name === '') {
                    this.unnamedAtrule(node, token)
                  }
                  this.init(node, token[2], token[3])

                  var last = false
                  var open = false
                  var params = []

                  this.pos += 1
                  while (this.pos < this.tokens.length) {
                    token = this.tokens[this.pos]

                    if (token[0] === ';') {
                      node.source.end = { line: token[2], column: token[3] }
                      this.semicolon = true
                      break
                    } else if (token[0] === '{') {
                      open = true
                      break
                    } else if (token[0] === '}') {
                      this.end(token)
                      break
                    } else {
                      params.push(token)
                    }

                    this.pos += 1
                  }
                  if (this.pos === this.tokens.length) {
                    last = true
                  }

                  node.raws.between = this.spacesFromEnd(params)
                  if (params.length) {
                    node.raws.afterName = this.spacesFromStart(params)
                    this.raw(node, 'params', params)
                    if (last) {
                      token = params[params.length - 1]
                      node.source.end = { line: token[4], column: token[5] }
                      this.spaces = node.raws.between
                      node.raws.between = ''
                    }
                  } else {
                    node.raws.afterName = ''
                    node.params = ''
                  }

                  if (open) {
                    node.nodes = []
                    this.current = node
                  }
                },
              },
              {
                key: 'end',
                value: function end(token) {
                  if (this.current.nodes && this.current.nodes.length) {
                    this.current.raws.semicolon = this.semicolon
                  }
                  this.semicolon = false

                  this.current.raws.after =
                    (this.current.raws.after || '') + this.spaces
                  this.spaces = ''

                  if (this.current.parent) {
                    this.current.source.end = {
                      line: token[2],
                      column: token[3],
                    }
                    this.current = this.current.parent
                  } else {
                    this.unexpectedClose(token)
                  }
                },
              },
              {
                key: 'endFile',
                value: function endFile() {
                  if (this.current.parent) this.unclosedBlock()
                  if (this.current.nodes && this.current.nodes.length) {
                    this.current.raws.semicolon = this.semicolon
                  }
                  this.current.raws.after =
                    (this.current.raws.after || '') + this.spaces
                },

                // Helpers
              },
              {
                key: 'init',
                value: function init(node, line, column) {
                  this.current.push(node)

                  node.source = {
                    start: { line: line, column: column },
                    input: this.input,
                  }
                  node.raws.before = this.spaces
                  this.spaces = ''
                  if (node.type !== 'comment') this.semicolon = false
                },
              },
              {
                key: 'raw',
                value: function raw(node, prop, tokens) {
                  var token = void 0,
                    type = void 0
                  var length = tokens.length
                  var value = ''
                  var clean = true
                  for (var i = 0; i < length; i += 1) {
                    token = tokens[i]
                    type = token[0]
                    if (
                      type === 'comment' ||
                      (type === 'space' && i === length - 1)
                    ) {
                      clean = false
                    } else {
                      value += token[1]
                    }
                  }
                  if (!clean) {
                    var raw = tokens.reduce(function(all, i) {
                      return all + i[1]
                    }, '')
                    node.raws[prop] = { value: value, raw: raw }
                  }
                  node[prop] = value
                },
              },
              {
                key: 'spacesFromEnd',
                value: function spacesFromEnd(tokens) {
                  var lastTokenType = void 0
                  var spaces = ''
                  while (tokens.length) {
                    lastTokenType = tokens[tokens.length - 1][0]
                    if (
                      lastTokenType !== 'space' &&
                      lastTokenType !== 'comment'
                    )
                      break
                    spaces = tokens.pop()[1] + spaces
                  }
                  return spaces
                },
              },
              {
                key: 'spacesFromStart',
                value: function spacesFromStart(tokens) {
                  var next = void 0
                  var spaces = ''
                  while (tokens.length) {
                    next = tokens[0][0]
                    if (next !== 'space' && next !== 'comment') break
                    spaces += tokens.shift()[1]
                  }
                  return spaces
                },
              },
              {
                key: 'stringFrom',
                value: function stringFrom(tokens, from) {
                  var result = ''
                  for (var i = from; i < tokens.length; i++) {
                    result += tokens[i][1]
                  }
                  tokens.splice(from, tokens.length - from)
                  return result
                },
              },
              {
                key: 'colon',
                value: function colon(tokens) {
                  var brackets = 0
                  var token = void 0,
                    type = void 0,
                    prev = void 0
                  for (var i = 0; i < tokens.length; i++) {
                    token = tokens[i]
                    type = token[0]

                    if (type === '(') {
                      brackets += 1
                    } else if (type === ')') {
                      brackets -= 1
                    } else if (brackets === 0 && type === ':') {
                      if (!prev) {
                        this.doubleColon(token)
                      } else if (prev[0] === 'word' && prev[1] === 'progid') {
                        continue
                      } else {
                        return i
                      }
                    }

                    prev = token
                  }
                  return false
                },

                // Errors
              },
              {
                key: 'unclosedBracket',
                value: function unclosedBracket(bracket) {
                  throw this.input.error(
                    'Unclosed bracket',
                    bracket[2],
                    bracket[3]
                  )
                },
              },
              {
                key: 'unknownWord',
                value: function unknownWord(start) {
                  var token = this.tokens[start]
                  throw this.input.error('Unknown word', token[2], token[3])
                },
              },
              {
                key: 'unexpectedClose',
                value: function unexpectedClose(token) {
                  throw this.input.error('Unexpected }', token[2], token[3])
                },
              },
              {
                key: 'unclosedBlock',
                value: function unclosedBlock() {
                  var pos = this.current.source.start
                  throw this.input.error('Unclosed block', pos.line, pos.column)
                },
              },
              {
                key: 'doubleColon',
                value: function doubleColon(token) {
                  throw this.input.error('Double colon', token[2], token[3])
                },
              },
              {
                key: 'unnamedAtrule',
                value: function unnamedAtrule(node, token) {
                  throw this.input.error(
                    'At-rule without name',
                    token[2],
                    token[3]
                  )
                },
              },
              {
                key: 'precheckMissedSemicolon',
                value: function precheckMissedSemicolon(tokens) {
                  // Hook for Safe Parser
                  tokens
                },
              },
              {
                key: 'checkMissedSemicolon',
                value: function checkMissedSemicolon(tokens) {
                  var colon = this.colon(tokens)
                  if (colon === false) return

                  var founded = 0
                  var token = void 0
                  for (var j = colon - 1; j >= 0; j--) {
                    token = tokens[j]
                    if (token[0] !== 'space') {
                      founded += 1
                      if (founded === 2) break
                    }
                  }
                  throw this.input.error('Missed semicolon', token[2], token[3])
                },
              },
            ])

            return Parser
          })()

          exports.default = Parser
          module.exports = exports['default']
        },
        {
          './at-rule': 532,
          './comment': 533,
          './declaration': 536,
          './root': 545,
          './rule': 546,
          './tokenize': 550,
        },
      ],
      543: [
        function(require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', {
            value: true,
          })

          var _typeof = typeof Symbol === 'function' &&
            typeof Symbol.iterator === 'symbol'
            ? function(obj) {
                return typeof obj
              }
            : function(obj) {
                return obj &&
                  typeof Symbol === 'function' &&
                  obj.constructor === Symbol &&
                  obj !== Symbol.prototype
                  ? 'symbol'
                  : typeof obj
              }

          var _createClass = (function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i]
                descriptor.enumerable = descriptor.enumerable || false
                descriptor.configurable = true
                if ('value' in descriptor) descriptor.writable = true
                Object.defineProperty(target, descriptor.key, descriptor)
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps)
              if (staticProps) defineProperties(Constructor, staticProps)
              return Constructor
            }
          })()

          var _lazyResult = require('./lazy-result')

          var _lazyResult2 = _interopRequireDefault(_lazyResult)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function')
            }
          }

          /**
 * @callback builder
 * @param {string} part          - part of generated CSS connected to this node
 * @param {Node}   node          - AST node
 * @param {"start"|"end"} [type] - nodes part type
 */

          /**
 * @callback parser
 *
 * @param {string|toString} css   - string with input CSS or any object
 *                                  with toString() method, like a Buffer
 * @param {processOptions} [opts] - options with only `from` and `map` keys
 *
 * @return {Root} PostCSS AST
 */

          /**
 * @callback stringifier
 *
 * @param {Node} node       - start node for stringifing. Usually {@link Root}.
 * @param {builder} builder - function to concatenate CSS from nodes parts
 *                            or generate string and source map
 *
 * @return {void}
 */

          /**
 * @typedef {object} syntax
 * @property {parser} parse          - function to generate AST by string
 * @property {stringifier} stringify - function to generate string by AST
 */

          /**
 * @typedef {object} toString
 * @property {function} toString
 */

          /**
 * @callback pluginFunction
 * @param {Root} root     - parsed input CSS
 * @param {Result} result - result to set warnings or check other plugins
 */

          /**
 * @typedef {object} Plugin
 * @property {function} postcss - PostCSS plugin function
 */

          /**
 * @typedef {object} processOptions
 * @property {string} from             - the path of the CSS source file.
 *                                       You should always set `from`,
 *                                       because it is used in source map
 *                                       generation and syntax error messages.
 * @property {string} to               - the path where youll put the output
 *                                       CSS file. You should always set `to`
 *                                       to generate correct source maps.
 * @property {parser} parser           - function to generate AST by string
 * @property {stringifier} stringifier - class to generate string by AST
 * @property {syntax} syntax           - object with `parse` and `stringify`
 * @property {object} map              - source map options
 * @property {boolean} map.inline                    - does source map should
 *                                                     be embedded in the output
 *                                                     CSS as a base64-encoded
 *                                                     comment
 * @property {string|object|false|function} map.prev - source map content
 *                                                     from a previous
 *                                                     processing step
 *                                                     (for example, Sass).
 *                                                     PostCSS will try to find
 *                                                     previous map
 *                                                     automatically, so you
 *                                                     could disable it by
 *                                                     `false` value.
 * @property {boolean} map.sourcesContent            - does PostCSS should set
 *                                                     the origin content to map
 * @property {string|false} map.annotation           - does PostCSS should set
 *                                                     annotation comment to map
 * @property {string} map.from                       - override `from` in maps
 *                                                     `sources`
 */

          /**
 * Contains plugins to process CSS. Create one `Processor` instance,
 * initialize its plugins, and then use that instance on numerous CSS files.
 *
 * @example
 * const processor = postcss([autoprefixer, precss]);
 * processor.process(css1).then(result => console.log(result.css));
 * processor.process(css2).then(result => console.log(result.css));
 */
          var Processor = (function() {
            /**
   * @param {Array.<Plugin|pluginFunction>|Processor} plugins - PostCSS
   *        plugins. See {@link Processor#use} for plugin format.
   */
            function Processor() {
              var plugins = arguments.length > 0 && arguments[0] !== undefined
                ? arguments[0]
                : []

              _classCallCheck(this, Processor)

              /**
     * @member {string} - Current PostCSS version.
     *
     * @example
     * if ( result.processor.version.split('.')[0] !== '5' ) {
     *   throw new Error('This plugin works only with PostCSS 5');
     * }
     */
              this.version = '5.2.0'
              /**
     * @member {pluginFunction[]} - Plugins added to this processor.
     *
     * @example
     * const processor = postcss([autoprefixer, precss]);
     * processor.plugins.length //=> 2
     */
              this.plugins = this.normalize(plugins)
            }

            /**
   * Adds a plugin to be used as a CSS processor.
   *
   * PostCSS plugin can be in 4 formats:
   * * A plugin created by {@link postcss.plugin} method.
   * * A function. PostCSS will pass the function a @{link Root}
   *   as the first argument and current {@link Result} instance
   *   as the second.
   * * An object with a `postcss` method. PostCSS will use that method
   *   as described in #2.
   * * Another {@link Processor} instance. PostCSS will copy plugins
   *   from that instance into this one.
   *
   * Plugins can also be added by passing them as arguments when creating
   * a `postcss` instance (see [`postcss(plugins)`]).
   *
   * Asynchronous plugins should return a `Promise` instance.
   *
   * @param {Plugin|pluginFunction|Processor} plugin - PostCSS plugin
   *                                                   or {@link Processor}
   *                                                   with plugins
   *
   * @example
   * const processor = postcss()
   *   .use(autoprefixer)
   *   .use(precss);
   *
   * @return {Processes} current processor to make methods chain
   */

            _createClass(Processor, [
              {
                key: 'use',
                value: function use(plugin) {
                  this.plugins = this.plugins.concat(this.normalize([plugin]))
                  return this
                },

                /**
     * Parses source CSS and returns a {@link LazyResult} Promise proxy.
     * Because some plugins can be asynchronous it doesnt make
     * any transformations. Transformations will be applied
     * in the {@link LazyResult} methods.
     *
     * @param {string|toString|Result} css - String with input CSS or
     *                                       any object with a `toString()`
     *                                       method, like a Buffer.
     *                                       Optionally, send a {@link Result}
     *                                       instance and the processor will
     *                                       take the {@link Root} from it.
     * @param {processOptions} [opts]      - options
     *
     * @return {LazyResult} Promise proxy
     *
     * @example
     * processor.process(css, { from: 'a.css', to: 'a.out.css' })
     *   .then(result => {
     *      console.log(result.css);
     *   });
     */
              },
              {
                key: 'process',
                value: function process(css) {
                  var opts = arguments.length > 1 && arguments[1] !== undefined
                    ? arguments[1]
                    : {}

                  return new _lazyResult2.default(this, css, opts)
                },
              },
              {
                key: 'normalize',
                value: function normalize(plugins) {
                  var normalized = []
                  plugins.forEach(function(i) {
                    if (i.postcss) i = i.postcss

                    if (
                      (typeof i === 'undefined' ? 'undefined' : _typeof(i)) ===
                        'object' &&
                      Array.isArray(i.plugins)
                    ) {
                      normalized = normalized.concat(i.plugins)
                    } else if (typeof i === 'function') {
                      normalized.push(i)
                    } else {
                      throw new Error(i + ' is not a PostCSS plugin')
                    }
                  })
                  return normalized
                },
              },
            ])

            return Processor
          })()

          exports.default = Processor
          module.exports = exports['default']
        },
        { './lazy-result': 538 },
      ],
      544: [
        function(require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', {
            value: true,
          })

          var _createClass = (function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i]
                descriptor.enumerable = descriptor.enumerable || false
                descriptor.configurable = true
                if ('value' in descriptor) descriptor.writable = true
                Object.defineProperty(target, descriptor.key, descriptor)
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps)
              if (staticProps) defineProperties(Constructor, staticProps)
              return Constructor
            }
          })()

          var _warning = require('./warning')

          var _warning2 = _interopRequireDefault(_warning)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function')
            }
          }

          /**
 * @typedef  {object} Message
 * @property {string} type   - message type
 * @property {string} plugin - source PostCSS plugin name
 */

          /**
 * Provides the result of the PostCSS transformations.
 *
 * A Result instance is returned by {@link LazyResult#then}
 * or {@link Root#toResult} methods.
 *
 * @example
 * postcss([cssnext]).process(css).then(function (result) {
 *    console.log(result.css);
 * });
 *
 * @example
 * var result2 = postcss.parse(css).toResult();
 */
          var Result = (function() {
            /**
   * @param {Processor} processor - processor used for this transformation.
   * @param {Root}      root      - Root node after all transformations.
   * @param {processOptions} opts - options from the {@link Processor#process}
   *                                or {@link Root#toResult}
   */
            function Result(processor, root, opts) {
              _classCallCheck(this, Result)

              /**
     * @member {Processor} - The Processor instance used
     *                       for this transformation.
     *
     * @example
     * for ( let plugin of result.processor.plugins) {
     *   if ( plugin.postcssPlugin === 'postcss-bad' ) {
     *     throw 'postcss-good is incompatible with postcss-bad';
     *   }
     * });
     */
              this.processor = processor
              /**
     * @member {Message[]} - Contains messages from plugins
     *                       (e.g., warnings or custom messages).
     *                       Each message should have type
     *                       and plugin properties.
     *
     * @example
     * postcss.plugin('postcss-min-browser', () => {
     *   return (root, result) => {
     *     var browsers = detectMinBrowsersByCanIUse(root);
     *     result.messages.push({
     *       type:    'min-browser',
     *       plugin:  'postcss-min-browser',
     *       browsers: browsers
     *     });
     *   };
     * });
     */
              this.messages = []
              /**
     * @member {Root} - Root node after all transformations.
     *
     * @example
     * root.toResult().root == root;
     */
              this.root = root
              /**
     * @member {processOptions} - Options from the {@link Processor#process}
     *                            or {@link Root#toResult} call
     *                            that produced this Result instance.
     *
     * @example
     * root.toResult(opts).opts == opts;
     */
              this.opts = opts
              /**
     * @member {string} - A CSS string representing of {@link Result#root}.
     *
     * @example
     * postcss.parse('a{}').toResult().css //=> "a{}"
     */
              this.css = undefined
              /**
     * @member {SourceMapGenerator} - An instance of `SourceMapGenerator`
     *                                class from the `source-map` library,
     *                                representing changes
     *                                to the {@link Result#root} instance.
     *
     * @example
     * result.map.toJSON() //=> { version: 3, file: 'a.css',  }
     *
     * @example
     * if ( result.map ) {
     *   fs.writeFileSync(result.opts.to + '.map', result.map.toString());
     * }
     */
              this.map = undefined
            }

            /**
   * Returns for @{link Result#css} content.
   *
   * @example
   * result + '' === result.css
   *
   * @return {string} string representing of {@link Result#root}
   */

            _createClass(Result, [
              {
                key: 'toString',
                value: function toString() {
                  return this.css
                },

                /**
     * Creates an instance of {@link Warning} and adds it
     * to {@link Result#messages}.
     *
     * @param {string} text        - warning message
     * @param {Object} [opts]      - warning options
     * @param {Node}   opts.node   - CSS node that caused the warning
     * @param {string} opts.word   - word in CSS source that caused the warning
     * @param {number} opts.index  - index in CSS node string that caused
     *                               the warning
     * @param {string} opts.plugin - name of the plugin that created
     *                               this warning. {@link Result#warn} fills
     *                               this property automatically.
     *
     * @return {Warning} created warning
     */
              },
              {
                key: 'warn',
                value: function warn(text) {
                  var opts = arguments.length > 1 && arguments[1] !== undefined
                    ? arguments[1]
                    : {}

                  if (!opts.plugin) {
                    if (this.lastPlugin && this.lastPlugin.postcssPlugin) {
                      opts.plugin = this.lastPlugin.postcssPlugin
                    }
                  }

                  var warning = new _warning2.default(text, opts)
                  this.messages.push(warning)

                  return warning
                },

                /**
     * Returns warnings from plugins. Filters {@link Warning} instances
     * from {@link Result#messages}.
     *
     * @example
     * result.warnings().forEach(warn => {
     *   console.warn(warn.toString());
     * });
     *
     * @return {Warning[]} warnings from plugins
     */
              },
              {
                key: 'warnings',
                value: function warnings() {
                  return this.messages.filter(function(i) {
                    return i.type === 'warning'
                  })
                },

                /**
     * An alias for the {@link Result#css} property.
     * Use it with syntaxes that generate non-CSS output.
     * @type {string}
     *
     * @example
     * result.css === result.content;
     */
              },
              {
                key: 'content',
                get: function get() {
                  return this.css
                },
              },
            ])

            return Result
          })()

          exports.default = Result
          module.exports = exports['default']
        },
        { './warning': 552 },
      ],
      545: [
        function(require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', {
            value: true,
          })

          var _createClass = (function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i]
                descriptor.enumerable = descriptor.enumerable || false
                descriptor.configurable = true
                if ('value' in descriptor) descriptor.writable = true
                Object.defineProperty(target, descriptor.key, descriptor)
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps)
              if (staticProps) defineProperties(Constructor, staticProps)
              return Constructor
            }
          })()

          var _get = function get(object, property, receiver) {
            if (object === null) object = Function.prototype
            var desc = Object.getOwnPropertyDescriptor(object, property)
            if (desc === undefined) {
              var parent = Object.getPrototypeOf(object)
              if (parent === null) {
                return undefined
              } else {
                return get(parent, property, receiver)
              }
            } else if ('value' in desc) {
              return desc.value
            } else {
              var getter = desc.get
              if (getter === undefined) {
                return undefined
              }
              return getter.call(receiver)
            }
          }

          require('./rule')

          var _container = require('./container')

          var _container2 = _interopRequireDefault(_container)

          var _lazyResult = require('./lazy-result')

          var _lazyResult2 = _interopRequireDefault(_lazyResult)

          var _processor = require('./processor')

          var _processor2 = _interopRequireDefault(_processor)

          var _warnOnce = require('./warn-once')

          var _warnOnce2 = _interopRequireDefault(_warnOnce)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function')
            }
          }

          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError(
                "this hasn't been initialised - super() hasn't been called"
              )
            }
            return call &&
              (typeof call === 'object' || typeof call === 'function')
              ? call
              : self
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== 'function' && superClass !== null) {
              throw new TypeError(
                'Super expression must either be null or a function, not ' +
                  typeof superClass
              )
            }
            subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true,
                },
              }
            )
            if (superClass)
              Object.setPrototypeOf
                ? Object.setPrototypeOf(subClass, superClass)
                : (subClass.__proto__ = superClass)
          } // break cyclical dependency deadlock  #87

          /**
 * Represents a CSS file and contains all its parsed nodes.
 *
 * @extends Container
 *
 * @example
 * const root = postcss.parse('a{color:black} b{z-index:2}');
 * root.type         //=> 'root'
 * root.nodes.length //=> 2
 */
          var Root = (function(_Container) {
            _inherits(Root, _Container)

            function Root(defaults) {
              _classCallCheck(this, Root)

              var _this = _possibleConstructorReturn(
                this,
                (Root.__proto__ || Object.getPrototypeOf(Root))
                  .call(this, defaults)
              )

              _this.type = 'root'
              if (!_this.nodes) _this.nodes = []
              return _this
            }

            _createClass(Root, [
              {
                key: 'removeChild',
                value: function removeChild(child) {
                  child = this.index(child)

                  if (child === 0 && this.nodes.length > 1) {
                    this.nodes[1].raws.before = this.nodes[child].raws.before
                  }

                  return _get(
                    Root.prototype.__proto__ ||
                      Object.getPrototypeOf(Root.prototype),
                    'removeChild',
                    this
                  ).call(this, child)
                },
              },
              {
                key: 'normalize',
                value: function normalize(child, sample, type) {
                  var nodes = _get(
                    Root.prototype.__proto__ ||
                      Object.getPrototypeOf(Root.prototype),
                    'normalize',
                    this
                  ).call(this, child)

                  if (sample) {
                    if (type === 'prepend') {
                      if (this.nodes.length > 1) {
                        sample.raws.before = this.nodes[1].raws.before
                      } else {
                        delete sample.raws.before
                      }
                    } else if (this.first !== sample) {
                      nodes.forEach(function(node) {
                        node.raws.before = sample.raws.before
                      })
                    }
                  }

                  return nodes
                },

                /**
         * Returns a {@link Result} instance representing the roots CSS.
         *
         * @param {processOptions} [opts] - options with only `to` and `map` keys
         *
         * @return {Result} result with current roots CSS
         *
         * @example
         * const root1 = postcss.parse(css1, { from: 'a.css' });
         * const root2 = postcss.parse(css2, { from: 'b.css' });
         * root1.append(root2);
         * const result = root1.toResult({ to: 'all.css', map: true });
         */
              },
              {
                key: 'toResult',
                value: function toResult() {
                  var opts = arguments.length > 0 && arguments[0] !== undefined
                    ? arguments[0]
                    : {}

                  var lazy = new _lazyResult2.default(
                    new _processor2.default(),
                    this,
                    opts
                  )
                  return lazy.stringify()
                },
              },
              {
                key: 'remove',
                value: function remove(child) {
                  ;(0, _warnOnce2.default)(
                    'Root#remove is deprecated. Use Root#removeChild'
                  )
                  this.removeChild(child)
                },
              },
              {
                key: 'prevMap',
                value: function prevMap() {
                  ;(0, _warnOnce2.default)(
                    'Root#prevMap is deprecated. Use Root#source.input.map'
                  )
                  return this.source.input.map
                },

                /**
         * @memberof Root#
         * @member {object} raws - Information to generate byte-to-byte equal
         *                         node string as it was in the origin input.
         *
         * Every parser saves its own properties,
         * but the default CSS parser uses:
         *
         * * `after`: the space symbols after the last child to the end of file.
         * * `semicolon`: is the last child has an (optional) semicolon.
         *
         * @example
         * postcss.parse('a {}\n').raws //=> { after: '\n' }
         * postcss.parse('a {}').raws   //=> { after: '' }
         */
              },
            ])

            return Root
          })(_container2.default)

          exports.default = Root
          module.exports = exports['default']
        },
        {
          './container': 534,
          './lazy-result': 538,
          './processor': 543,
          './rule': 546,
          './warn-once': 551,
        },
      ],
      546: [
        function(require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', {
            value: true,
          })

          var _createClass = (function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i]
                descriptor.enumerable = descriptor.enumerable || false
                descriptor.configurable = true
                if ('value' in descriptor) descriptor.writable = true
                Object.defineProperty(target, descriptor.key, descriptor)
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps)
              if (staticProps) defineProperties(Constructor, staticProps)
              return Constructor
            }
          })()

          require('./at-rule')

          var _container = require('./container')

          var _container2 = _interopRequireDefault(_container)

          var _warnOnce = require('./warn-once')

          var _warnOnce2 = _interopRequireDefault(_warnOnce)

          var _list = require('./list')

          var _list2 = _interopRequireDefault(_list)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function')
            }
          }

          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError(
                "this hasn't been initialised - super() hasn't been called"
              )
            }
            return call &&
              (typeof call === 'object' || typeof call === 'function')
              ? call
              : self
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== 'function' && superClass !== null) {
              throw new TypeError(
                'Super expression must either be null or a function, not ' +
                  typeof superClass
              )
            }
            subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true,
                },
              }
            )
            if (superClass)
              Object.setPrototypeOf
                ? Object.setPrototypeOf(subClass, superClass)
                : (subClass.__proto__ = superClass)
          } // break cyclical dependency deadlock  #87

          /**
 * Represents a CSS rule: a selector followed by a declaration block.
 *
 * @extends Container
 *
 * @example
 * const root = postcss.parse('a{}');
 * const rule = root.first;
 * rule.type       //=> 'rule'
 * rule.toString() //=> 'a{}'
 */
          var Rule = (function(_Container) {
            _inherits(Rule, _Container)

            function Rule(defaults) {
              _classCallCheck(this, Rule)

              var _this = _possibleConstructorReturn(
                this,
                (Rule.__proto__ || Object.getPrototypeOf(Rule))
                  .call(this, defaults)
              )

              _this.type = 'rule'
              if (!_this.nodes) _this.nodes = []
              return _this
            }

            /**
     * An array containing the rules individual selectors.
     * Groups of selectors are split at commas.
     *
     * @type {string[]}
     *
     * @example
     * const root = postcss.parse('a, b { }');
     * const rule = root.first;
     *
     * rule.selector  //=> 'a, b'
     * rule.selectors //=> ['a', 'b']
     *
     * rule.selectors = ['a', 'strong'];
     * rule.selector //=> 'a, strong'
     */

            _createClass(Rule, [
              {
                key: 'selectors',
                get: function get() {
                  return _list2.default.comma(this.selector)
                },
                set: function set(values) {
                  var match = this.selector ? this.selector.match(/,\s*/) : null
                  var sep = match
                    ? match[0]
                    : ',' + this.raw('between', 'beforeOpen')
                  this.selector = values.join(sep)
                },
              },
              {
                key: '_selector',
                get: function get() {
                  ;(0, _warnOnce2.default)(
                    'Rule#_selector is deprecated. Use Rule#raws.selector'
                  )
                  return this.raws.selector
                },
                set: function set(val) {
                  ;(0, _warnOnce2.default)(
                    'Rule#_selector is deprecated. Use Rule#raws.selector'
                  )
                  this.raws.selector = val
                },

                /**
         * @memberof Rule#
         * @member {string} selector - the rules full selector represented
         *                             as a string
         *
         * @example
         * const root = postcss.parse('a, b { }');
         * const rule = root.first;
         * rule.selector //=> 'a, b'
         */

                /**
         * @memberof Rule#
         * @member {object} raws - Information to generate byte-to-byte equal
         *                         node string as it was in the origin input.
         *
         * Every parser saves its own properties,
         * but the default CSS parser uses:
         *
         * * `before`: the space symbols before the node. It also stores `*`
         *   and `_` symbols before the declaration (IE hack).
         * * `after`: the space symbols after the last child of the node
         *   to the end of the node.
         * * `between`: the symbols between the property and value
         *   for declarations, selector and `{` for rules, or last parameter
         *   and `{` for at-rules.
         * * `semicolon`: contains true if the last child has
         *   an (optional) semicolon.
         *
         * PostCSS cleans selectors from comments and extra spaces,
         * but it stores origin content in raws properties.
         * As such, if you dont change a declarations value,
         * PostCSS will use the raw value with comments.
         *
         * @example
         * const root = postcss.parse('a {\n  color:black\n}')
         * root.first.first.raws //=> { before: '', between: ' ', after: '\n' }
         */
              },
            ])

            return Rule
          })(_container2.default)

          exports.default = Rule
          module.exports = exports['default']
        },
        {
          './at-rule': 532,
          './container': 534,
          './list': 539,
          './warn-once': 551,
        },
      ],
      547: [
        function(require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', {
            value: true,
          })

          var _createClass = (function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i]
                descriptor.enumerable = descriptor.enumerable || false
                descriptor.configurable = true
                if ('value' in descriptor) descriptor.writable = true
                Object.defineProperty(target, descriptor.key, descriptor)
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps)
              if (staticProps) defineProperties(Constructor, staticProps)
              return Constructor
            }
          })()

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function')
            }
          }

          /* eslint-disable valid-jsdoc */

          var defaultRaw = {
            colon: ': ',
            indent: '    ',
            beforeDecl: '\n',
            beforeRule: '\n',
            beforeOpen: ' ',
            beforeClose: '\n',
            beforeComment: '\n',
            after: '\n',
            emptyBody: '',
            commentLeft: ' ',
            commentRight: ' ',
          }

          function capitalize(str) {
            return str[0].toUpperCase() + str.slice(1)
          }

          var Stringifier = (function() {
            function Stringifier(builder) {
              _classCallCheck(this, Stringifier)

              this.builder = builder
            }

            _createClass(Stringifier, [
              {
                key: 'stringify',
                value: function stringify(node, semicolon) {
                  this[node.type](node, semicolon)
                },
              },
              {
                key: 'root',
                value: function root(node) {
                  this.body(node)
                  if (node.raws.after) this.builder(node.raws.after)
                },
              },
              {
                key: 'comment',
                value: function comment(node) {
                  var left = this.raw(node, 'left', 'commentLeft')
                  var right = this.raw(node, 'right', 'commentRight')
                  this.builder('/*' + left + node.text + right + '*/', node)
                },
              },
              {
                key: 'decl',
                value: function decl(node, semicolon) {
                  var between = this.raw(node, 'between', 'colon')
                  var string =
                    node.prop + between + this.rawValue(node, 'value')

                  if (node.important) {
                    string += node.raws.important || ' !important'
                  }

                  if (semicolon) string += ';'
                  this.builder(string, node)
                },
              },
              {
                key: 'rule',
                value: function rule(node) {
                  this.block(node, this.rawValue(node, 'selector'))
                },
              },
              {
                key: 'atrule',
                value: function atrule(node, semicolon) {
                  var name = '@' + node.name
                  var params = node.params ? this.rawValue(node, 'params') : ''

                  if (typeof node.raws.afterName !== 'undefined') {
                    name += node.raws.afterName
                  } else if (params) {
                    name += ' '
                  }

                  if (node.nodes) {
                    this.block(node, name + params)
                  } else {
                    var end = (node.raws.between || '') + (semicolon ? ';' : '')
                    this.builder(name + params + end, node)
                  }
                },
              },
              {
                key: 'body',
                value: function body(node) {
                  var last = node.nodes.length - 1
                  while (last > 0) {
                    if (node.nodes[last].type !== 'comment') break
                    last -= 1
                  }

                  var semicolon = this.raw(node, 'semicolon')
                  for (var i = 0; i < node.nodes.length; i++) {
                    var child = node.nodes[i]
                    var before = this.raw(child, 'before')
                    if (before) this.builder(before)
                    this.stringify(child, last !== i || semicolon)
                  }
                },
              },
              {
                key: 'block',
                value: function block(node, start) {
                  var between = this.raw(node, 'between', 'beforeOpen')
                  this.builder(start + between + '{', node, 'start')

                  var after = void 0
                  if (node.nodes && node.nodes.length) {
                    this.body(node)
                    after = this.raw(node, 'after')
                  } else {
                    after = this.raw(node, 'after', 'emptyBody')
                  }

                  if (after) this.builder(after)
                  this.builder('}', node, 'end')
                },
              },
              {
                key: 'raw',
                value: function raw(node, own, detect) {
                  var value = void 0
                  if (!detect) detect = own

                  // Already had
                  if (own) {
                    value = node.raws[own]
                    if (typeof value !== 'undefined') return value
                  }

                  var parent = node.parent

                  // Hack for first rule in CSS
                  if (detect === 'before') {
                    if (
                      !parent ||
                      (parent.type === 'root' && parent.first === node)
                    ) {
                      return ''
                    }
                  }

                  // Floating child without parent
                  if (!parent) return defaultRaw[detect]

                  // Detect style by other nodes
                  var root = node.root()
                  if (!root.rawCache) root.rawCache = {}
                  if (typeof root.rawCache[detect] !== 'undefined') {
                    return root.rawCache[detect]
                  }

                  if (detect === 'before' || detect === 'after') {
                    return this.beforeAfter(node, detect)
                  } else {
                    var method = 'raw' + capitalize(detect)
                    if (this[method]) {
                      value = this[method](root, node)
                    } else {
                      root.walk(function(i) {
                        value = i.raws[own]
                        if (typeof value !== 'undefined') return false
                      })
                    }
                  }

                  if (typeof value === 'undefined') value = defaultRaw[detect]

                  root.rawCache[detect] = value
                  return value
                },
              },
              {
                key: 'rawSemicolon',
                value: function rawSemicolon(root) {
                  var value = void 0
                  root.walk(function(i) {
                    if (i.nodes && i.nodes.length && i.last.type === 'decl') {
                      value = i.raws.semicolon
                      if (typeof value !== 'undefined') return false
                    }
                  })
                  return value
                },
              },
              {
                key: 'rawEmptyBody',
                value: function rawEmptyBody(root) {
                  var value = void 0
                  root.walk(function(i) {
                    if (i.nodes && i.nodes.length === 0) {
                      value = i.raws.after
                      if (typeof value !== 'undefined') return false
                    }
                  })
                  return value
                },
              },
              {
                key: 'rawIndent',
                value: function rawIndent(root) {
                  if (root.raws.indent) return root.raws.indent
                  var value = void 0
                  root.walk(function(i) {
                    var p = i.parent
                    if (p && p !== root && p.parent && p.parent === root) {
                      if (typeof i.raws.before !== 'undefined') {
                        var parts = i.raws.before.split('\n')
                        value = parts[parts.length - 1]
                        value = value.replace(/[^\s]/g, '')
                        return false
                      }
                    }
                  })
                  return value
                },
              },
              {
                key: 'rawBeforeComment',
                value: function rawBeforeComment(root, node) {
                  var value = void 0
                  root.walkComments(function(i) {
                    if (typeof i.raws.before !== 'undefined') {
                      value = i.raws.before
                      if (value.indexOf('\n') !== -1) {
                        value = value.replace(/[^\n]+$/, '')
                      }
                      return false
                    }
                  })
                  if (typeof value === 'undefined') {
                    value = this.raw(node, null, 'beforeDecl')
                  }
                  return value
                },
              },
              {
                key: 'rawBeforeDecl',
                value: function rawBeforeDecl(root, node) {
                  var value = void 0
                  root.walkDecls(function(i) {
                    if (typeof i.raws.before !== 'undefined') {
                      value = i.raws.before
                      if (value.indexOf('\n') !== -1) {
                        value = value.replace(/[^\n]+$/, '')
                      }
                      return false
                    }
                  })
                  if (typeof value === 'undefined') {
                    value = this.raw(node, null, 'beforeRule')
                  }
                  return value
                },
              },
              {
                key: 'rawBeforeRule',
                value: function rawBeforeRule(root) {
                  var value = void 0
                  root.walk(function(i) {
                    if (i.nodes && (i.parent !== root || root.first !== i)) {
                      if (typeof i.raws.before !== 'undefined') {
                        value = i.raws.before
                        if (value.indexOf('\n') !== -1) {
                          value = value.replace(/[^\n]+$/, '')
                        }
                        return false
                      }
                    }
                  })
                  return value
                },
              },
              {
                key: 'rawBeforeClose',
                value: function rawBeforeClose(root) {
                  var value = void 0
                  root.walk(function(i) {
                    if (i.nodes && i.nodes.length > 0) {
                      if (typeof i.raws.after !== 'undefined') {
                        value = i.raws.after
                        if (value.indexOf('\n') !== -1) {
                          value = value.replace(/[^\n]+$/, '')
                        }
                        return false
                      }
                    }
                  })
                  return value
                },
              },
              {
                key: 'rawBeforeOpen',
                value: function rawBeforeOpen(root) {
                  var value = void 0
                  root.walk(function(i) {
                    if (i.type !== 'decl') {
                      value = i.raws.between
                      if (typeof value !== 'undefined') return false
                    }
                  })
                  return value
                },
              },
              {
                key: 'rawColon',
                value: function rawColon(root) {
                  var value = void 0
                  root.walkDecls(function(i) {
                    if (typeof i.raws.between !== 'undefined') {
                      value = i.raws.between.replace(/[^\s:]/g, '')
                      return false
                    }
                  })
                  return value
                },
              },
              {
                key: 'beforeAfter',
                value: function beforeAfter(node, detect) {
                  var value = void 0
                  if (node.type === 'decl') {
                    value = this.raw(node, null, 'beforeDecl')
                  } else if (node.type === 'comment') {
                    value = this.raw(node, null, 'beforeComment')
                  } else if (detect === 'before') {
                    value = this.raw(node, null, 'beforeRule')
                  } else {
                    value = this.raw(node, null, 'beforeClose')
                  }

                  var buf = node.parent
                  var depth = 0
                  while (buf && buf.type !== 'root') {
                    depth += 1
                    buf = buf.parent
                  }

                  if (value.indexOf('\n') !== -1) {
                    var indent = this.raw(node, null, 'indent')
                    if (indent.length) {
                      for (var step = 0; step < depth; step++) {
                        value += indent
                      }
                    }
                  }

                  return value
                },
              },
              {
                key: 'rawValue',
                value: function rawValue(node, prop) {
                  var value = node[prop]
                  var raw = node.raws[prop]
                  if (raw && raw.value === value) {
                    return raw.raw
                  } else {
                    return value
                  }
                },
              },
            ])

            return Stringifier
          })()

          exports.default = Stringifier
          module.exports = exports['default']
        },
        {},
      ],
      548: [
        function(require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', {
            value: true,
          })
          exports.default = stringify

          var _stringifier = require('./stringifier')

          var _stringifier2 = _interopRequireDefault(_stringifier)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          function stringify(node, builder) {
            var str = new _stringifier2.default(builder)
            str.stringify(node)
          }
          module.exports = exports['default']
        },
        { './stringifier': 547 },
      ],
      549: [
        function(require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', {
            value: true,
          })

          var _tokenize = require('./tokenize')

          var _tokenize2 = _interopRequireDefault(_tokenize)

          var _input = require('./input')

          var _input2 = _interopRequireDefault(_input)

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj }
          }

          var HIGHLIGHT_THEME = {
            brackets: [36, 39], // cyan
            string: [31, 39], // red
            'at-word': [31, 39], // red
            comment: [90, 39], // gray
            '{': [32, 39], // green
            '}': [32, 39], // green
            ':': [1, 22], // bold
            ';': [1, 22], // bold
            '(': [1, 22], // bold
            ')': [1, 22], // bold
          }

          function code(color) {
            return '\x1B[' + color + 'm'
          }

          function terminalHighlight(css) {
            var tokens = (0, _tokenize2.default)(new _input2.default(css), {
              ignoreErrors: true,
            })
            var result = []
            tokens.forEach(function(token) {
              var color = HIGHLIGHT_THEME[token[0]]
              if (color) {
                result.push(
                  token[1]
                    .split(/\r?\n/)
                    .map(function(i) {
                      return code(color[0]) + i + code(color[1])
                    })
                    .join('\n')
                )
              } else {
                result.push(token[1])
              }
            })
            return result.join('')
          }

          exports.default = terminalHighlight
          module.exports = exports['default']
        },
        { './input': 537, './tokenize': 550 },
      ],
      550: [
        function(require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', {
            value: true,
          })
          exports.default = tokenize
          var SINGLE_QUOTE = "'".charCodeAt(0)
          var DOUBLE_QUOTE = '"'.charCodeAt(0)
          var BACKSLASH = '\\'.charCodeAt(0)
          var SLASH = '/'.charCodeAt(0)
          var NEWLINE = '\n'.charCodeAt(0)
          var SPACE = ' '.charCodeAt(0)
          var FEED = '\f'.charCodeAt(0)
          var TAB = '\t'.charCodeAt(0)
          var CR = '\r'.charCodeAt(0)
          var OPEN_SQUARE = '['.charCodeAt(0)
          var CLOSE_SQUARE = ']'.charCodeAt(0)
          var OPEN_PARENTHESES = '('.charCodeAt(0)
          var CLOSE_PARENTHESES = ')'.charCodeAt(0)
          var OPEN_CURLY = '{'.charCodeAt(0)
          var CLOSE_CURLY = '}'.charCodeAt(0)
          var SEMICOLON = ';'.charCodeAt(0)
          var ASTERISK = '*'.charCodeAt(0)
          var COLON = ':'.charCodeAt(0)
          var AT = '@'.charCodeAt(0)

          var RE_AT_END = /[ \n\t\r\f\{\(\)'"\\;/\[\]#]/g
          var RE_WORD_END = /[ \n\t\r\f\(\)\{\}:;@!'"\\\]\[#]|\/(?=\*)/g
          var RE_BAD_BRACKET = /.[\\\/\("'\n]/

          function tokenize(input) {
            var options = arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : {}

            var tokens = []
            var css = input.css.valueOf()

            var ignore = options.ignoreErrors

            var code = void 0,
              next = void 0,
              quote = void 0,
              lines = void 0,
              last = void 0,
              content = void 0,
              escape = void 0,
              nextLine = void 0,
              nextOffset = void 0,
              escaped = void 0,
              escapePos = void 0,
              prev = void 0,
              n = void 0

            var length = css.length
            var offset = -1
            var line = 1
            var pos = 0

            function unclosed(what) {
              throw input.error('Unclosed ' + what, line, pos - offset)
            }

            while (pos < length) {
              code = css.charCodeAt(pos)

              if (
                code === NEWLINE ||
                code === FEED ||
                (code === CR && css.charCodeAt(pos + 1) !== NEWLINE)
              ) {
                offset = pos
                line += 1
              }

              switch (code) {
                case NEWLINE:
                case SPACE:
                case TAB:
                case CR:
                case FEED:
                  next = pos
                  do {
                    next += 1
                    code = css.charCodeAt(next)
                    if (code === NEWLINE) {
                      offset = next
                      line += 1
                    }
                  } while (
                    code === SPACE ||
                    code === NEWLINE ||
                    code === TAB ||
                    code === CR ||
                    code === FEED
                  )

                  tokens.push(['space', css.slice(pos, next)])
                  pos = next - 1
                  break

                case OPEN_SQUARE:
                  tokens.push(['[', '[', line, pos - offset])
                  break

                case CLOSE_SQUARE:
                  tokens.push([']', ']', line, pos - offset])
                  break

                case OPEN_CURLY:
                  tokens.push(['{', '{', line, pos - offset])
                  break

                case CLOSE_CURLY:
                  tokens.push(['}', '}', line, pos - offset])
                  break

                case COLON:
                  tokens.push([':', ':', line, pos - offset])
                  break

                case SEMICOLON:
                  tokens.push([';', ';', line, pos - offset])
                  break

                case OPEN_PARENTHESES:
                  prev = tokens.length ? tokens[tokens.length - 1][1] : ''
                  n = css.charCodeAt(pos + 1)
                  if (
                    prev === 'url' &&
                    n !== SINGLE_QUOTE &&
                    n !== DOUBLE_QUOTE &&
                    n !== SPACE &&
                    n !== NEWLINE &&
                    n !== TAB &&
                    n !== FEED &&
                    n !== CR
                  ) {
                    next = pos
                    do {
                      escaped = false
                      next = css.indexOf(')', next + 1)
                      if (next === -1) {
                        if (ignore) {
                          next = pos
                          break
                        } else {
                          unclosed('bracket')
                        }
                      }
                      escapePos = next
                      while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                        escapePos -= 1
                        escaped = !escaped
                      }
                    } while (escaped)

                    tokens.push([
                      'brackets',
                      css.slice(pos, next + 1),
                      line,
                      pos - offset,
                      line,
                      next - offset,
                    ])
                    pos = next
                  } else {
                    next = css.indexOf(')', pos + 1)
                    content = css.slice(pos, next + 1)

                    if (next === -1 || RE_BAD_BRACKET.test(content)) {
                      tokens.push(['(', '(', line, pos - offset])
                    } else {
                      tokens.push([
                        'brackets',
                        content,
                        line,
                        pos - offset,
                        line,
                        next - offset,
                      ])
                      pos = next
                    }
                  }

                  break

                case CLOSE_PARENTHESES:
                  tokens.push([')', ')', line, pos - offset])
                  break

                case SINGLE_QUOTE:
                case DOUBLE_QUOTE:
                  quote = code === SINGLE_QUOTE ? "'" : '"'
                  next = pos
                  do {
                    escaped = false
                    next = css.indexOf(quote, next + 1)
                    if (next === -1) {
                      if (ignore) {
                        next = pos + 1
                        break
                      } else {
                        unclosed('quote')
                      }
                    }
                    escapePos = next
                    while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                      escapePos -= 1
                      escaped = !escaped
                    }
                  } while (escaped)

                  content = css.slice(pos, next + 1)
                  lines = content.split('\n')
                  last = lines.length - 1

                  if (last > 0) {
                    nextLine = line + last
                    nextOffset = next - lines[last].length
                  } else {
                    nextLine = line
                    nextOffset = offset
                  }

                  tokens.push([
                    'string',
                    css.slice(pos, next + 1),
                    line,
                    pos - offset,
                    nextLine,
                    next - nextOffset,
                  ])

                  offset = nextOffset
                  line = nextLine
                  pos = next
                  break

                case AT:
                  RE_AT_END.lastIndex = pos + 1
                  RE_AT_END.test(css)
                  if (RE_AT_END.lastIndex === 0) {
                    next = css.length - 1
                  } else {
                    next = RE_AT_END.lastIndex - 2
                  }
                  tokens.push([
                    'at-word',
                    css.slice(pos, next + 1),
                    line,
                    pos - offset,
                    line,
                    next - offset,
                  ])
                  pos = next
                  break

                case BACKSLASH:
                  next = pos
                  escape = true
                  while (css.charCodeAt(next + 1) === BACKSLASH) {
                    next += 1
                    escape = !escape
                  }
                  code = css.charCodeAt(next + 1)
                  if (
                    escape &&
                    code !== SLASH &&
                    code !== SPACE &&
                    code !== NEWLINE &&
                    code !== TAB &&
                    code !== CR &&
                    code !== FEED
                  ) {
                    next += 1
                  }
                  tokens.push([
                    'word',
                    css.slice(pos, next + 1),
                    line,
                    pos - offset,
                    line,
                    next - offset,
                  ])
                  pos = next
                  break

                default:
                  if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {
                    next = css.indexOf('*/', pos + 2) + 1
                    if (next === 0) {
                      if (ignore) {
                        next = css.length
                      } else {
                        unclosed('comment')
                      }
                    }

                    content = css.slice(pos, next + 1)
                    lines = content.split('\n')
                    last = lines.length - 1

                    if (last > 0) {
                      nextLine = line + last
                      nextOffset = next - lines[last].length
                    } else {
                      nextLine = line
                      nextOffset = offset
                    }

                    tokens.push([
                      'comment',
                      content,
                      line,
                      pos - offset,
                      nextLine,
                      next - nextOffset,
                    ])

                    offset = nextOffset
                    line = nextLine
                    pos = next
                  } else {
                    RE_WORD_END.lastIndex = pos + 1
                    RE_WORD_END.test(css)
                    if (RE_WORD_END.lastIndex === 0) {
                      next = css.length - 1
                    } else {
                      next = RE_WORD_END.lastIndex - 2
                    }

                    tokens.push([
                      'word',
                      css.slice(pos, next + 1),
                      line,
                      pos - offset,
                      line,
                      next - offset,
                    ])
                    pos = next
                  }

                  break
              }

              pos++
            }

            return tokens
          }
          module.exports = exports['default']
        },
        {},
      ],
      551: [
        function(require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', {
            value: true,
          })
          exports.default = warnOnce
          var printed = {}

          function warnOnce(message) {
            if (printed[message]) return
            printed[message] = true

            if (typeof console !== 'undefined' && console.warn)
              console.warn(message)
          }
          module.exports = exports['default']
        },
        {},
      ],
      552: [
        function(require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', {
            value: true,
          })

          var _createClass = (function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i]
                descriptor.enumerable = descriptor.enumerable || false
                descriptor.configurable = true
                if ('value' in descriptor) descriptor.writable = true
                Object.defineProperty(target, descriptor.key, descriptor)
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps)
              if (staticProps) defineProperties(Constructor, staticProps)
              return Constructor
            }
          })()

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function')
            }
          }

          /**
 * Represents a plugins warning. It can be created using {@link Node#warn}.
 *
 * @example
 * if ( decl.important ) {
 *     decl.warn(result, 'Avoid !important', { word: '!important' });
 * }
 */
          var Warning = (function() {
            /**
   * @param {string} text        - warning message
   * @param {Object} [opts]      - warning options
   * @param {Node}   opts.node   - CSS node that caused the warning
   * @param {string} opts.word   - word in CSS source that caused the warning
   * @param {number} opts.index  - index in CSS node string that caused
   *                               the warning
   * @param {string} opts.plugin - name of the plugin that created
   *                               this warning. {@link Result#warn} fills
   *                               this property automatically.
   */
            function Warning(text) {
              var opts = arguments.length > 1 && arguments[1] !== undefined
                ? arguments[1]
                : {}

              _classCallCheck(this, Warning)

              /**
     * @member {string} - Type to filter warnings from
     *                    {@link Result#messages}. Always equal
     *                    to `"warning"`.
     *
     * @example
     * const nonWarning = result.messages.filter(i => i.type !== 'warning')
     */
              this.type = 'warning'
              /**
     * @member {string} - The warning message.
     *
     * @example
     * warning.text //=> 'Try to avoid !important'
     */
              this.text = text

              if (opts.node && opts.node.source) {
                var pos = opts.node.positionBy(opts)
                /**
       * @member {number} - Line in the input file
       *                    with this warnings source
       *
       * @example
       * warning.line //=> 5
       */
                this.line = pos.line
                /**
       * @member {number} - Column in the input file
       *                    with this warnings source.
       *
       * @example
       * warning.column //=> 6
       */
                this.column = pos.column
              }

              for (var opt in opts) {
                this[opt] = opts[opt]
              }
            }

            /**
   * Returns a warning position and message.
   *
   * @example
   * warning.toString() //=> 'postcss-lint:a.css:10:14: Avoid !important'
   *
   * @return {string} warning position and message
   */

            _createClass(Warning, [
              {
                key: 'toString',
                value: function toString() {
                  if (this.node) {
                    return this.node.error(this.text, {
                      plugin: this.plugin,
                      index: this.index,
                      word: this.word,
                    }).message
                  } else if (this.plugin) {
                    return this.plugin + ': ' + this.text
                  } else {
                    return this.text
                  }
                },

                /**
     * @memberof Warning#
     * @member {string} plugin - The name of the plugin that created
     *                           it will fill this property automatically.
     *                           this warning. When you call {@link Node#warn}
     *
     * @example
     * warning.plugin //=> 'postcss-important'
     */

                /**
     * @memberof Warning#
     * @member {Node} node - Contains the CSS node that caused the warning.
     *
     * @example
     * warning.node.toString() //=> 'color: white !important'
     */
              },
            ])

            return Warning
          })()

          exports.default = Warning
          module.exports = exports['default']
        },
        {},
      ],
      553: [
        function(require, module, exports) {
          'use strict'
          module.exports = false
        },
        {},
      ],
      554: [
        function(require, module, exports) {
          var ranges = require('./ranges')

          var channelWithDecimalPointPercentageTpl =
            '\\s*(?:\\.\\d+|_NUMBERS_(?:\\.\\d+)?)%\\s*',
            channelWithDecimalPointTpl = channelWithDecimalPointPercentageTpl.replace(
              '%',
              ''
            ),
            // Channels
            percentageChannel = new RegExp(
              channelWithDecimalPointPercentageTpl.replace(
                '_NUMBERS_',
                ranges['100'].source
              )
            ),
            eightBitChannel = new RegExp(
              channelWithDecimalPointTpl.replace(
                '_NUMBERS_',
                ranges['255'].source
              )
            ),
            hueChannel = new RegExp(
              channelWithDecimalPointTpl.replace(
                '_NUMBERS_',
                ranges['360'].source
              )
            ),
            alphaChannel = new RegExp(
              channelWithDecimalPointTpl.replace(
                '_NUMBERS_',
                ranges['1'].source
              )
            )

          module.exports = {
            eightBit: eightBitChannel,
            hue: hueChannel,
            percentage: percentageChannel,
            alpha: alphaChannel,
          }
        },
        { './ranges': 556 },
      ],
      555: [
        function(require, module, exports) {
          var colorNames = require('css-color-names')
          var channels = require('./channels')

          // Space templates
          var opaqueSpaceTpl = '_space_\\(_1_,_2_,_3_\\)'
          var alphaSpaceTpl = '_space_a\\(_1_,_2_,_3_,_a_\\)'.replace(
            '_a_',
            channels.alpha.source
          )

          var spaces = {
            hex: /#(?:[0-9a-f]{6}|[0-9a-f]{3})(?![0-9a-f])/gi,

            rgb: new RegExp(
              opaqueSpaceTpl
                .replace('_space_', 'rgb')
                .replace(/_[1-3]_/g, channels.eightBit.source),
              'gi'
            ),
            rgba: new RegExp(
              alphaSpaceTpl
                .replace('_space_', 'rgb')
                .replace(/_[1-3]_/g, channels.eightBit.source),
              'gi'
            ),

            hsv: new RegExp(
              opaqueSpaceTpl
                .replace('_space_', 'hsv')
                .replace('_1_', channels.hue.source)
                .replace('_2_', channels.percentage.source)
                .replace('_3_', channels.percentage.source),
              'gi'
            ),
            hsva: new RegExp(
              alphaSpaceTpl
                .replace('_space_', 'hsv')
                .replace('_1_', channels.hue.source)
                .replace('_2_', channels.percentage.source)
                .replace('_3_', channels.percentage.source),
              'gi'
            ),

            hsl: new RegExp(
              opaqueSpaceTpl
                .replace('_space_', 'hsl')
                .replace('_1_', channels.hue.source)
                .replace('_2_', channels.percentage.source)
                .replace('_3_', channels.percentage.source),
              'gi'
            ),
            hsla: new RegExp(
              alphaSpaceTpl
                .replace('_space_', 'hsl')
                .replace('_1_', channels.hue.source)
                .replace('_2_', channels.percentage.source)
                .replace('_3_', channels.percentage.source),
              'gi'
            ),

            names: new RegExp(
              '\\b(?:' + Object.keys(colorNames).join('|') + ')\\b',
              'gi'
            ),
          }

          spaces.all = new RegExp(
            Object.keys(spaces)
              .map(function(space) {
                return spaces[space].source
              })
              .join('|'),
            'gi'
          )

          module.exports = spaces
        },
        { './channels': 554, 'css-color-names': 239 },
      ],
      556: [
        function(require, module, exports) {
          module.exports = {
            '1': /1|0/,
            '100': /100|(?:[1-9]?\d)/,
            '255': /255|(?:25[0-4]|2[0-4]\d|1\d\d|[1-9]?\d)/,
            '360': /360|(?:3[0-5]\d|[1-2]\d\d|[1-9]?\d)/,
          }
        },
        {},
      ],
      557: [
        function(require, module, exports) {
          var space = require('to-space-case')

          /**
 * Export.
 */

          module.exports = toCamelCase

          /**
 * Convert a `string` to camel case.
 *
 * @param {String} string
 * @return {String}
 */

          function toCamelCase(string) {
            return space(string).replace(/\s(\w)/g, function(matches, letter) {
              return letter.toUpperCase()
            })
          }
        },
        { 'to-space-case': 562 },
      ],
      558: [
        function(require, module, exports) {
          'use strict'
          module.exports = function toFastProperties(obj) {
            function f() {}
            f.prototype = obj
            new f()
            return
            eval(obj)
          }
        },
        {},
      ],
      559: [
        function(require, module, exports) {
          /**
 * Export.
 */

          module.exports = toNoCase

          /**
 * Test whether a string is camel-case.
 */

          var hasSpace = /\s/
          var hasSeparator = /(_|-|\.|:)/
          var hasCamel = /([a-z][A-Z]|[A-Z][a-z])/

          /**
 * Remove any starting case from a `string`, like camel or snake, but keep
 * spaces and punctuation that may be important otherwise.
 *
 * @param {String} string
 * @return {String}
 */

          function toNoCase(string) {
            if (hasSpace.test(string)) return string.toLowerCase()
            if (hasSeparator.test(string))
              return (unseparate(string) || string).toLowerCase()
            if (hasCamel.test(string)) return uncamelize(string).toLowerCase()
            return string.toLowerCase()
          }

          /**
 * Separator splitter.
 */

          var separatorSplitter = /[\W_]+(.|$)/g

          /**
 * Un-separate a `string`.
 *
 * @param {String} string
 * @return {String}
 */

          function unseparate(string) {
            return string.replace(separatorSplitter, function(m, next) {
              return next ? ' ' + next : ''
            })
          }

          /**
 * Camelcase splitter.
 */

          var camelSplitter = /(.)([A-Z]+)/g

          /**
 * Un-camelcase a `string`.
 *
 * @param {String} string
 * @return {String}
 */

          function uncamelize(string) {
            return string.replace(camelSplitter, function(m, previous, uppers) {
              return previous + ' ' + uppers.toLowerCase().split('').join(' ')
            })
          }
        },
        {},
      ],
      560: [
        function(require, module, exports) {
          var space = require('to-space-case')

          /**
 * Export.
 */

          module.exports = toPascalCase

          /**
 * Convert a `string` to pascal case.
 *
 * @param {String} string
 * @return {String}
 */

          function toPascalCase(string) {
            return space(string).replace(/(?:^|\s)(\w)/g, function(
              matches,
              letter
            ) {
              return letter.toUpperCase()
            })
          }
        },
        { 'to-space-case': 562 },
      ],
      561: [
        function(require, module, exports) {
          var toSpace = require('to-space-case')

          /**
 * Export.
 */

          module.exports = toSlugCase

          /**
 * Convert a `string` to slug case.
 *
 * @param {String} string
 * @return {String}
 */

          function toSlugCase(string) {
            return toSpace(string).replace(/\s/g, '-')
          }
        },
        { 'to-space-case': 562 },
      ],
      562: [
        function(require, module, exports) {
          var clean = require('to-no-case')

          /**
 * Export.
 */

          module.exports = toSpaceCase

          /**
 * Convert a `string` to space case.
 *
 * @param {String} string
 * @return {String}
 */

          function toSpaceCase(string) {
            return clean(string)
              .replace(/[\W_]+(.|$)/g, function(matches, match) {
                return match ? ' ' + match : ''
              })
              .trim()
          }
        },
        { 'to-no-case': 559 },
      ],
      563: [
        function(require, module, exports) {
          var fs = require('fs'),
            cons = require('constants')

          module.exports = touch
          touch.touchSync = touch.sync = function(f, options) {
            return touch(f, options)
          }

          touch.ftouch = ftouch
          touch.ftouchSync = ftouch.sync = function(fd, options) {
            return ftouch(fd, options)
          }

          function validOpts(options) {
            options = Object.create(options || {})

            // {mtime: true}, {ctime: true}
            // If set to something else, then treat as epoch ms value
            var now = new Date(options.time || Date.now())
            if (!options.atime && !options.mtime) {
              options.atime = options.mtime = now
            } else {
              if (true === options.atime) {
                options.atime = now
              }
              if (true === options.mtime) {
                options.mtime = now
              }
            }

            var oflags = 0
            if (!options.force) {
              oflags = oflags | cons.O_RDWR
            }

            if (!options.nocreate) {
              oflags = oflags | cons.O_CREAT
            }

            options.oflags = oflags
            return options
          }

          function optionsRef(then, arg, options, cb) {
            if (!options.ref) return then(arg, options, cb)

            return cb
              ? fs.stat(options.ref, optionsRefcb(then, arg, options, cb))
              : optionsRefcb(then, arg, options)(null, fs.statSync(options.ref))
          }

          function optionsRefcb(then, arg, options, cb) {
            return function(er, s) {
              if (er) {
                er.path = er.file = options.ref
                return cb(er)
              }
              options.atime = options.atime && s.atime.getTime()
              options.mtime = options.mtime && s.mtime.getTime()

              // so we don't keep doing this.
              options.ref = null

              return then(arg, options, cb)
            }
          }

          function touch(f, options, cb) {
            if (typeof options === 'function') (cb = options), (options = null)
            options = validOpts(options)
            return optionsRef(touch_, f, validOpts(options), cb)
          }

          function touch_(f, options, cb) {
            return openThenF(f, options, cb)
          }

          function openThenF(f, options, cb) {
            options.closeAfter = true
            return cb
              ? fs.open(f, options.oflags, openThenFcb(options, cb))
              : openThenFcb(options)(null, fs.openSync(f, options.oflags))
          }

          function openThenFcb(options, cb) {
            return function(er, fd) {
              if (er) {
                if (fd && options.closeAfter) fs.close(fd, function() {})
                return cb(er)
              }
              return ftouch(fd, options, cb)
            }
          }

          function ftouch(fd, options, cb) {
            if (typeof options === 'function') (cb = options), (options = null)
            return optionsRef(ftouch_, fd, validOpts(options), cb)
          }

          function ftouch_(fd, options, cb) {
            // still not set.  leave as what the file already has.
            return fstatThenFutimes(fd, options, cb)
          }

          function fstatThenFutimes(fd, options, cb) {
            if (options.atime && options.mtime)
              return thenFutimes(fd, options, cb)

            return cb
              ? fs.fstat(fd, fstatThenFutimescb(fd, options, cb))
              : fstatThenFutimescb(fd, options)(null, fs.fstatSync(fd))
          }

          function fstatThenFutimescb(fd, options, cb) {
            return function(er, s) {
              if (er) {
                if (options.closeAfter) fs.close(fd, function() {})
                return cb(er)
              }
              options.atime = options.atime || s.atime.getTime()
              options.mtime = options.mtime || s.mtime.getTime()
              return thenFutimes(fd, options, cb)
            }
          }

          function thenFutimes(fd, options, cb) {
            if (typeof options.atime === 'object') {
              options.atime = options.atime.getTime()
            }
            if (typeof options.mtime === 'object') {
              options.mtime = options.mtime.getTime()
            }

            var a = parseInt(options.atime / 1000, 10),
              m = parseInt(options.mtime / 1000, 10)
            return cb
              ? fs.futimes(fd, a, m, thenFutimescb(fd, options, cb))
              : thenFutimescb(fd, options)(null, fs.futimesSync(fd, a, m))
          }

          function thenFutimescb(fd, options, cb) {
            return function(er, res) {
              if (er) {
                if (options.closeAfter) fs.close(fd, function() {})
                return cb(er)
              }
              return finish(fd, options, res, cb)
            }
          }

          function finish(fd, options, res, cb) {
            return options.closeAfter
              ? finishClose(fd, options, res, cb)
              : cb ? cb(null, res) : res
          }

          function finishClose(fd, options, res, cb) {
            return cb
              ? fs.close(fd, finishClosecb(res, options, cb))
              : finishClosecb(res, options)(null, fs.closeSync(fd))
          }

          function finishClosecb(res, options, cb) {
            return function(er) {
              if (er) return cb(er)
              options.closeAfter = null
              return finish(null, options, res, cb)
            }
          }
        },
        { constants: 131, fs: 118 },
      ],
      564: [
        function(require, module, exports) {
          'use strict'
          module.exports = function(str) {
            var tail = str.length

            while (/[\s\uFEFF\u00A0]/.test(str[tail - 1])) {
              tail--
            }

            return str.slice(0, tail)
          }
        },
        {},
      ],
      565: [
        function(require, module, exports) {
          exports.isatty = function() {
            return false
          }

          function ReadStream() {
            throw new Error('tty.ReadStream is not implemented')
          }
          exports.ReadStream = ReadStream

          function WriteStream() {
            throw new Error('tty.ReadStream is not implemented')
          }
          exports.WriteStream = WriteStream
        },
        {},
      ],
      566: [
        function(require, module, exports) {
          if (typeof Object.create === 'function') {
            // implementation from standard node.js 'util' module
            module.exports = function inherits(ctor, superCtor) {
              ctor.super_ = superCtor
              ctor.prototype = Object.create(superCtor.prototype, {
                constructor: {
                  value: ctor,
                  enumerable: false,
                  writable: true,
                  configurable: true,
                },
              })
            }
          } else {
            // old school shim for old browsers
            module.exports = function inherits(ctor, superCtor) {
              ctor.super_ = superCtor
              var TempCtor = function() {}
              TempCtor.prototype = superCtor.prototype
              ctor.prototype = new TempCtor()
              ctor.prototype.constructor = ctor
            }
          }
        },
        {},
      ],
      567: [
        function(require, module, exports) {
          module.exports = function isBuffer(arg) {
            return (
              arg &&
              typeof arg === 'object' &&
              typeof arg.copy === 'function' &&
              typeof arg.fill === 'function' &&
              typeof arg.readUInt8 === 'function'
            )
          }
        },
        {},
      ],
      568: [
        function(require, module, exports) {
          ;(function(process, global) {
            // Copyright Joyent, Inc. and other Node contributors.
            //
            // Permission is hereby granted, free of charge, to any person obtaining a
            // copy of this software and associated documentation files (the
            // "Software"), to deal in the Software without restriction, including
            // without limitation the rights to use, copy, modify, merge, publish,
            // distribute, sublicense, and/or sell copies of the Software, and to permit
            // persons to whom the Software is furnished to do so, subject to the
            // following conditions:
            //
            // The above copyright notice and this permission notice shall be included
            // in all copies or substantial portions of the Software.
            //
            // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
            // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
            // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
            // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
            // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
            // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
            // USE OR OTHER DEALINGS IN THE SOFTWARE.

            var formatRegExp = /%[sdj%]/g
            exports.format = function(f) {
              if (!isString(f)) {
                var objects = []
                for (var i = 0; i < arguments.length; i++) {
                  objects.push(inspect(arguments[i]))
                }
                return objects.join(' ')
              }

              var i = 1
              var args = arguments
              var len = args.length
              var str = String(f).replace(formatRegExp, function(x) {
                if (x === '%%') return '%'
                if (i >= len) return x
                switch (x) {
                  case '%s':
                    return String(args[i++])
                  case '%d':
                    return Number(args[i++])
                  case '%j':
                    try {
                      return JSON.stringify(args[i++])
                    } catch (_) {
                      return '[Circular]'
                    }
                  default:
                    return x
                }
              })
              for (var x = args[i]; i < len; x = args[++i]) {
                if (isNull(x) || !isObject(x)) {
                  str += ' ' + x
                } else {
                  str += ' ' + inspect(x)
                }
              }
              return str
            }

            // Mark that a method should not be used.
            // Returns a modified function which warns once by default.
            // If --no-deprecation is set, then it is a no-op.
            exports.deprecate = function(fn, msg) {
              // Allow for deprecating things in the process of starting up.
              if (isUndefined(global.process)) {
                return function() {
                  return exports.deprecate(fn, msg).apply(this, arguments)
                }
              }

              if (process.noDeprecation === true) {
                return fn
              }

              var warned = false
              function deprecated() {
                if (!warned) {
                  if (process.throwDeprecation) {
                    throw new Error(msg)
                  } else if (process.traceDeprecation) {
                    console.trace(msg)
                  } else {
                    console.error(msg)
                  }
                  warned = true
                }
                return fn.apply(this, arguments)
              }

              return deprecated
            }

            var debugs = {}
            var debugEnviron
            exports.debuglog = function(set) {
              if (isUndefined(debugEnviron))
                debugEnviron = process.env.NODE_DEBUG || ''
              set = set.toUpperCase()
              if (!debugs[set]) {
                if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
                  var pid = process.pid
                  debugs[set] = function() {
                    var msg = exports.format.apply(exports, arguments)
                    console.error('%s %d: %s', set, pid, msg)
                  }
                } else {
                  debugs[set] = function() {}
                }
              }
              return debugs[set]
            }

            /**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
            /* legacy: obj, showHidden, depth, colors*/
            function inspect(obj, opts) {
              // default options
              var ctx = {
                seen: [],
                stylize: stylizeNoColor,
              }
              // legacy...
              if (arguments.length >= 3) ctx.depth = arguments[2]
              if (arguments.length >= 4) ctx.colors = arguments[3]
              if (isBoolean(opts)) {
                // legacy...
                ctx.showHidden = opts
              } else if (opts) {
                // got an "options" object
                exports._extend(ctx, opts)
              }
              // set default options
              if (isUndefined(ctx.showHidden)) ctx.showHidden = false
              if (isUndefined(ctx.depth)) ctx.depth = 2
              if (isUndefined(ctx.colors)) ctx.colors = false
              if (isUndefined(ctx.customInspect)) ctx.customInspect = true
              if (ctx.colors) ctx.stylize = stylizeWithColor
              return formatValue(ctx, obj, ctx.depth)
            }
            exports.inspect = inspect

            // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
            inspect.colors = {
              bold: [1, 22],
              italic: [3, 23],
              underline: [4, 24],
              inverse: [7, 27],
              white: [37, 39],
              grey: [90, 39],
              black: [30, 39],
              blue: [34, 39],
              cyan: [36, 39],
              green: [32, 39],
              magenta: [35, 39],
              red: [31, 39],
              yellow: [33, 39],
            }

            // Don't use 'blue' not visible on cmd.exe
            inspect.styles = {
              special: 'cyan',
              number: 'yellow',
              boolean: 'yellow',
              undefined: 'grey',
              null: 'bold',
              string: 'green',
              date: 'magenta',
              // "name": intentionally not styling
              regexp: 'red',
            }

            function stylizeWithColor(str, styleType) {
              var style = inspect.styles[styleType]

              if (style) {
                return (
                  '\u001b[' +
                  inspect.colors[style][0] +
                  'm' +
                  str +
                  '\u001b[' +
                  inspect.colors[style][1] +
                  'm'
                )
              } else {
                return str
              }
            }

            function stylizeNoColor(str, styleType) {
              return str
            }

            function arrayToHash(array) {
              var hash = {}

              array.forEach(function(val, idx) {
                hash[val] = true
              })

              return hash
            }

            function formatValue(ctx, value, recurseTimes) {
              // Provide a hook for user-specified inspect functions.
              // Check that value is an object with an inspect function on it
              if (
                ctx.customInspect &&
                value &&
                isFunction(value.inspect) &&
                // Filter out the util module, it's inspect function is special
                value.inspect !== exports.inspect &&
                // Also filter out any prototype objects using the circular check.
                !(value.constructor && value.constructor.prototype === value)
              ) {
                var ret = value.inspect(recurseTimes, ctx)
                if (!isString(ret)) {
                  ret = formatValue(ctx, ret, recurseTimes)
                }
                return ret
              }

              // Primitive types cannot have properties
              var primitive = formatPrimitive(ctx, value)
              if (primitive) {
                return primitive
              }

              // Look up the keys of the object.
              var keys = Object.keys(value)
              var visibleKeys = arrayToHash(keys)

              if (ctx.showHidden) {
                keys = Object.getOwnPropertyNames(value)
              }

              // IE doesn't make error fields non-enumerable
              // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
              if (
                isError(value) &&
                (keys.indexOf('message') >= 0 ||
                  keys.indexOf('description') >= 0)
              ) {
                return formatError(value)
              }

              // Some type of object without properties can be shortcutted.
              if (keys.length === 0) {
                if (isFunction(value)) {
                  var name = value.name ? ': ' + value.name : ''
                  return ctx.stylize('[Function' + name + ']', 'special')
                }
                if (isRegExp(value)) {
                  return ctx.stylize(
                    RegExp.prototype.toString.call(value),
                    'regexp'
                  )
                }
                if (isDate(value)) {
                  return ctx.stylize(
                    Date.prototype.toString.call(value),
                    'date'
                  )
                }
                if (isError(value)) {
                  return formatError(value)
                }
              }

              var base = '',
                array = false,
                braces = ['{', '}']

              // Make Array say that they are Array
              if (isArray(value)) {
                array = true
                braces = ['[', ']']
              }

              // Make functions say that they are functions
              if (isFunction(value)) {
                var n = value.name ? ': ' + value.name : ''
                base = ' [Function' + n + ']'
              }

              // Make RegExps say that they are RegExps
              if (isRegExp(value)) {
                base = ' ' + RegExp.prototype.toString.call(value)
              }

              // Make dates with properties first say the date
              if (isDate(value)) {
                base = ' ' + Date.prototype.toUTCString.call(value)
              }

              // Make error with message first say the error
              if (isError(value)) {
                base = ' ' + formatError(value)
              }

              if (keys.length === 0 && (!array || value.length == 0)) {
                return braces[0] + base + braces[1]
              }

              if (recurseTimes < 0) {
                if (isRegExp(value)) {
                  return ctx.stylize(
                    RegExp.prototype.toString.call(value),
                    'regexp'
                  )
                } else {
                  return ctx.stylize('[Object]', 'special')
                }
              }

              ctx.seen.push(value)

              var output
              if (array) {
                output = formatArray(
                  ctx,
                  value,
                  recurseTimes,
                  visibleKeys,
                  keys
                )
              } else {
                output = keys.map(function(key) {
                  return formatProperty(
                    ctx,
                    value,
                    recurseTimes,
                    visibleKeys,
                    key,
                    array
                  )
                })
              }

              ctx.seen.pop()

              return reduceToSingleString(output, base, braces)
            }

            function formatPrimitive(ctx, value) {
              if (isUndefined(value))
                return ctx.stylize('undefined', 'undefined')
              if (isString(value)) {
                var simple =
                  "'" +
                  JSON.stringify(value)
                    .replace(/^"|"$/g, '')
                    .replace(/'/g, "\\'")
                    .replace(/\\"/g, '"') +
                  "'"
                return ctx.stylize(simple, 'string')
              }
              if (isNumber(value)) return ctx.stylize('' + value, 'number')
              if (isBoolean(value)) return ctx.stylize('' + value, 'boolean')
              // For some reason typeof null is "object", so special case here.
              if (isNull(value)) return ctx.stylize('null', 'null')
            }

            function formatError(value) {
              return '[' + Error.prototype.toString.call(value) + ']'
            }

            function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
              var output = []
              for (var i = 0, l = value.length; i < l; ++i) {
                if (hasOwnProperty(value, String(i))) {
                  output.push(
                    formatProperty(
                      ctx,
                      value,
                      recurseTimes,
                      visibleKeys,
                      String(i),
                      true
                    )
                  )
                } else {
                  output.push('')
                }
              }
              keys.forEach(function(key) {
                if (!key.match(/^\d+$/)) {
                  output.push(
                    formatProperty(
                      ctx,
                      value,
                      recurseTimes,
                      visibleKeys,
                      key,
                      true
                    )
                  )
                }
              })
              return output
            }

            function formatProperty(
              ctx,
              value,
              recurseTimes,
              visibleKeys,
              key,
              array
            ) {
              var name, str, desc
              desc = Object.getOwnPropertyDescriptor(value, key) || {
                value: value[key],
              }
              if (desc.get) {
                if (desc.set) {
                  str = ctx.stylize('[Getter/Setter]', 'special')
                } else {
                  str = ctx.stylize('[Getter]', 'special')
                }
              } else {
                if (desc.set) {
                  str = ctx.stylize('[Setter]', 'special')
                }
              }
              if (!hasOwnProperty(visibleKeys, key)) {
                name = '[' + key + ']'
              }
              if (!str) {
                if (ctx.seen.indexOf(desc.value) < 0) {
                  if (isNull(recurseTimes)) {
                    str = formatValue(ctx, desc.value, null)
                  } else {
                    str = formatValue(ctx, desc.value, recurseTimes - 1)
                  }
                  if (str.indexOf('\n') > -1) {
                    if (array) {
                      str = str
                        .split('\n')
                        .map(function(line) {
                          return '  ' + line
                        })
                        .join('\n')
                        .substr(2)
                    } else {
                      str =
                        '\n' +
                        str
                          .split('\n')
                          .map(function(line) {
                            return '   ' + line
                          })
                          .join('\n')
                    }
                  }
                } else {
                  str = ctx.stylize('[Circular]', 'special')
                }
              }
              if (isUndefined(name)) {
                if (array && key.match(/^\d+$/)) {
                  return str
                }
                name = JSON.stringify('' + key)
                if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                  name = name.substr(1, name.length - 2)
                  name = ctx.stylize(name, 'name')
                } else {
                  name = name
                    .replace(/'/g, "\\'")
                    .replace(/\\"/g, '"')
                    .replace(/(^"|"$)/g, "'")
                  name = ctx.stylize(name, 'string')
                }
              }

              return name + ': ' + str
            }

            function reduceToSingleString(output, base, braces) {
              var numLinesEst = 0
              var length = output.reduce(function(prev, cur) {
                numLinesEst++
                if (cur.indexOf('\n') >= 0) numLinesEst++
                return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1
              }, 0)

              if (length > 60) {
                return (
                  braces[0] +
                  (base === '' ? '' : base + '\n ') +
                  ' ' +
                  output.join(',\n  ') +
                  ' ' +
                  braces[1]
                )
              }

              return (
                braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1]
              )
            }

            // NOTE: These type checking functions intentionally don't use `instanceof`
            // because it is fragile and can be easily faked with `Object.create()`.
            function isArray(ar) {
              return Array.isArray(ar)
            }
            exports.isArray = isArray

            function isBoolean(arg) {
              return typeof arg === 'boolean'
            }
            exports.isBoolean = isBoolean

            function isNull(arg) {
              return arg === null
            }
            exports.isNull = isNull

            function isNullOrUndefined(arg) {
              return arg == null
            }
            exports.isNullOrUndefined = isNullOrUndefined

            function isNumber(arg) {
              return typeof arg === 'number'
            }
            exports.isNumber = isNumber

            function isString(arg) {
              return typeof arg === 'string'
            }
            exports.isString = isString

            function isSymbol(arg) {
              return typeof arg === 'symbol'
            }
            exports.isSymbol = isSymbol

            function isUndefined(arg) {
              return arg === void 0
            }
            exports.isUndefined = isUndefined

            function isRegExp(re) {
              return isObject(re) && objectToString(re) === '[object RegExp]'
            }
            exports.isRegExp = isRegExp

            function isObject(arg) {
              return typeof arg === 'object' && arg !== null
            }
            exports.isObject = isObject

            function isDate(d) {
              return isObject(d) && objectToString(d) === '[object Date]'
            }
            exports.isDate = isDate

            function isError(e) {
              return (
                isObject(e) &&
                (objectToString(e) === '[object Error]' || e instanceof Error)
              )
            }
            exports.isError = isError

            function isFunction(arg) {
              return typeof arg === 'function'
            }
            exports.isFunction = isFunction

            function isPrimitive(arg) {
              return (
                arg === null ||
                typeof arg === 'boolean' ||
                typeof arg === 'number' ||
                typeof arg === 'string' ||
                typeof arg === 'symbol' || // ES6 symbol
                typeof arg === 'undefined'
              )
            }
            exports.isPrimitive = isPrimitive

            exports.isBuffer = require('./support/isBuffer')

            function objectToString(o) {
              return Object.prototype.toString.call(o)
            }

            function pad(n) {
              return n < 10 ? '0' + n.toString(10) : n.toString(10)
            }

            var months = [
              'Jan',
              'Feb',
              'Mar',
              'Apr',
              'May',
              'Jun',
              'Jul',
              'Aug',
              'Sep',
              'Oct',
              'Nov',
              'Dec',
            ]

            // 26 Feb 16:19:34
            function timestamp() {
              var d = new Date()
              var time = [
                pad(d.getHours()),
                pad(d.getMinutes()),
                pad(d.getSeconds()),
              ].join(':')
              return [d.getDate(), months[d.getMonth()], time].join(' ')
            }

            // log is just a thin wrapper to console.log that prepends a timestamp
            exports.log = function() {
              console.log(
                '%s - %s',
                timestamp(),
                exports.format.apply(exports, arguments)
              )
            }

            /**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
            exports.inherits = require('inherits')

            exports._extend = function(origin, add) {
              // Don't do anything if add isn't an object
              if (!add || !isObject(add)) return origin

              var keys = Object.keys(add)
              var i = keys.length
              while (i--) {
                origin[keys[i]] = add[keys[i]]
              }
              return origin
            }

            function hasOwnProperty(obj, prop) {
              return Object.prototype.hasOwnProperty.call(obj, prop)
            }
          }.call(
            this,
            require('_process'),
            typeof global !== 'undefined'
              ? global
              : typeof self !== 'undefined'
                ? self
                : typeof window !== 'undefined' ? window : {}
          ))
        },
        { './support/isBuffer': 567, _process: 507, inherits: 566 },
      ],
      569: [
        function(require, module, exports) {
          ;(function(global, factory) {
            typeof exports === 'object' && typeof module !== 'undefined'
              ? factory(exports)
              : typeof define === 'function' && define.amd
                ? define(['exports'], factory)
                : factory((global.vlq = global.vlq || {}))
          })(this, function(exports) {
            'use strict'
            var charToInteger = {}
            var integerToChar = {}

            'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
              .split('')
              .forEach(function(char, i) {
                charToInteger[char] = i
                integerToChar[i] = char
              })

            function decode(string) {
              var result = []
              var shift = 0
              var value = 0

              for (var i = 0; i < string.length; i += 1) {
                var integer = charToInteger[string[i]]

                if (integer === undefined) {
                  throw new Error('Invalid character (' + string[i] + ')')
                }

                var hasContinuationBit = integer & 32

                integer &= 31
                value += integer << shift

                if (hasContinuationBit) {
                  shift += 5
                } else {
                  var shouldNegate = value & 1
                  value >>= 1

                  result.push(shouldNegate ? -value : value)

                  // reset
                  value = shift = 0
                }
              }

              return result
            }

            function encode(value) {
              var result

              if (typeof value === 'number') {
                result = encodeInteger(value)
              } else {
                result = ''
                for (var i = 0; i < value.length; i += 1) {
                  result += encodeInteger(value[i])
                }
              }

              return result
            }

            function encodeInteger(num) {
              var result = ''

              if (num < 0) {
                num = (-num << 1) | 1
              } else {
                num <<= 1
              }

              do {
                var clamped = num & 31
                num >>= 5

                if (num > 0) {
                  clamped |= 32
                }

                result += integerToChar[clamped]
              } while (num > 0)

              return result
            }

            exports.decode = decode
            exports.encode = encode

            Object.defineProperty(exports, '__esModule', { value: true })
          })
        },
        {},
      ],
    },
    {},
    [1]
  )(1)
})
